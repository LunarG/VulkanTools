
/* Copyright (c) 2015-2023 Valve Corporation
 * Copyright (c) 2015-2023 LunarG, Inc.
 * Copyright (c) 2015-2017, 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author: Lenny Komow <lenny@lunarg.com>
 * Author: Joey Bzdek <joey@lunarg.com>
 * Author: Shannon McPherson <shannon@lunarg.com>
 * Author: Charles Giessen <charles@lunarg.com>
 */

/*
 * This file is generated from the Khronos Vulkan XML API Registry.
 */

#pragma once

#include "api_dump.h"
#include "api_dump_video_html.h"

void dump_html_pNext_trampoline(const void* object, const ApiDumpSettings& settings, int indents);


void dump_html_VkClearColorValue(const VkClearColorValue& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkClearValue(const VkClearValue& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkPerformanceCounterResultKHR(const VkPerformanceCounterResultKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkDeviceOrHostAddressConstAMDX(const VkDeviceOrHostAddressConstAMDX& object, const ApiDumpSettings& settings, int indents);
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkDeviceOrHostAddressKHR(const VkDeviceOrHostAddressKHR& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkDeviceOrHostAddressConstKHR(const VkDeviceOrHostAddressConstKHR& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkAccelerationStructureGeometryDataKHR(const VkAccelerationStructureGeometryDataKHR& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkPerformanceValueDataINTEL(const VkPerformanceValueDataINTEL& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkPipelineExecutableStatisticValueKHR(const VkPipelineExecutableStatisticValueKHR& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkDescriptorDataEXT(const VkDescriptorDataEXT& object, const ApiDumpSettings& settings, int indents);
void dump_html_VkAccelerationStructureMotionInstanceDataNV(const VkAccelerationStructureMotionInstanceDataNV& object, const ApiDumpSettings& settings, int indents);

//=========================== Type Implementations ==========================//

void dump_html_uint64_t(uint64_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    settings.stream() << "</div></summary>";
}
void dump_html_size_t(size_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    settings.stream() << "</div></summary>";
}
void dump_html_char(char object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    settings.stream() << "</div></summary>";
}
void dump_html_float(float object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    settings.stream() << "</div></summary>";
}
void dump_html_int64_t(int64_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    settings.stream() << "</div></summary>";
}
void dump_html_double(double object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    settings.stream() << "</div></summary>";
}

//========================= Basetype Implementations ========================//

void dump_html_VkBool32(VkBool32 object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
void dump_html_VkDeviceAddress(VkDeviceAddress object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
void dump_html_VkDeviceSize(VkDeviceSize object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
void dump_html_VkFlags(VkFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
void dump_html_VkSampleMask(VkSampleMask object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
void dump_html_VkFlags64(VkFlags64 object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_MTLDevice_id(MTLDevice_id object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_MTLCommandQueue_id(MTLCommandQueue_id object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_MTLBuffer_id(MTLBuffer_id object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_MTLTexture_id(MTLTexture_id object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_IOSurfaceRef(IOSurfaceRef object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_MTLSharedEvent_id(MTLSharedEvent_id object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_VkRemoteAddressNV(VkRemoteAddressNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}


#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_ANativeWindow(const ANativeWindow* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_AHardwareBuffer(const AHardwareBuffer* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif
#endif // VK_USE_PLATFORM_ANDROID_KHR


#if defined(VK_USE_PLATFORM_METAL_EXT)
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_CAMetalLayer(CAMetalLayer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif
#endif // VK_USE_PLATFORM_METAL_EXT

//======================= System Type Implementations =======================//

#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_DWORD(const DWORD object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_Display(const Display* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_GGP)
void dump_html_GgpFrameToken(const GgpFrameToken object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_GGP
#if defined(VK_USE_PLATFORM_GGP)
void dump_html_GgpStreamDescriptor(const GgpStreamDescriptor object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_GGP
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_HANDLE(const HANDLE object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_HINSTANCE(const HINSTANCE object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_HMONITOR(const HMONITOR object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_HWND(const HWND object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
void dump_html_IDirectFB(const IDirectFB object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
void dump_html_IDirectFBSurface(const IDirectFBSurface object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_LPCWSTR(const LPCWSTR object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_SECURITY_ATTRIBUTES(const SECURITY_ATTRIBUTES* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_VisualID(const VisualID object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_Window(const Window object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html__screen_buffer(const _screen_buffer* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html__screen_context(const _screen_context* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html__screen_window(const _screen_window* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
void dump_html_wl_display(const wl_display* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
void dump_html_wl_surface(const wl_surface* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_xcb_connection_t(const xcb_connection_t* object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    OutputAddress(settings, object);
    settings.stream() << "</div>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_xcb_visualid_t(const xcb_visualid_t object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_xcb_window_t(const xcb_window_t object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_zx_handle_t(const zx_handle_t object, const ApiDumpSettings& settings, int indents)
{
    if (settings.showAddress())
        settings.stream() << "<div class='val'>" << object << "</div></summary>";
    else
        settings.stream() << "<div class='val'>address</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA

//========================== Handle Implementations =========================//

void dump_html_VkBuffer(const VkBuffer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkImage(const VkImage object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkInstance(const VkInstance object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkPhysicalDevice(const VkPhysicalDevice object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDevice(const VkDevice object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkQueue(const VkQueue object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkSemaphore(const VkSemaphore object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkCommandBuffer(const VkCommandBuffer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkFence(const VkFence object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDeviceMemory(const VkDeviceMemory object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkEvent(const VkEvent object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkQueryPool(const VkQueryPool object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkBufferView(const VkBufferView object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageView(const VkImageView object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkShaderModule(const VkShaderModule object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineCache(const VkPipelineCache object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineLayout(const VkPipelineLayout object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipeline(const VkPipeline object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkRenderPass(const VkRenderPass object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorSetLayout(const VkDescriptorSetLayout object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkSampler(const VkSampler object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorSet(const VkDescriptorSet object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorPool(const VkDescriptorPool object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkFramebuffer(const VkFramebuffer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkCommandPool(const VkCommandPool object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkSamplerYcbcrConversion(const VkSamplerYcbcrConversion object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorUpdateTemplate(const VkDescriptorUpdateTemplate object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkPrivateDataSlot(const VkPrivateDataSlot object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkSurfaceKHR(const VkSurfaceKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkSwapchainKHR(const VkSwapchainKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDisplayKHR(const VkDisplayKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDisplayModeKHR(const VkDisplayModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDebugReportCallbackEXT(const VkDebugReportCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoSessionKHR(const VkVideoSessionKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoSessionParametersKHR(const VkVideoSessionParametersKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkCuModuleNVX(const VkCuModuleNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkCuFunctionNVX(const VkCuFunctionNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDebugUtilsMessengerEXT(const VkDebugUtilsMessengerEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkAccelerationStructureKHR(const VkAccelerationStructureKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkDeferredOperationKHR(const VkDeferredOperationKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkValidationCacheEXT(const VkValidationCacheEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkAccelerationStructureNV(const VkAccelerationStructureNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkPerformanceConfigurationINTEL(const VkPerformanceConfigurationINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkIndirectCommandsLayoutNV(const VkIndirectCommandsLayoutNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkCudaModuleNV(const VkCudaModuleNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkCudaFunctionNV(const VkCudaFunctionNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferCollectionFUCHSIA(const VkBufferCollectionFUCHSIA object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
void dump_html_VkMicromapEXT(const VkMicromapEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkOpticalFlowSessionNV(const VkOpticalFlowSessionNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}
void dump_html_VkShaderEXT(const VkShaderEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    settings.stream() << "</div></summary>";
}

//=========================== Enum Implementations ==========================//

void dump_html_VkResult(VkResult object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SUCCESS (";
        break;
    case 1:
        settings.stream() << "VK_NOT_READY (";
        break;
    case 2:
        settings.stream() << "VK_TIMEOUT (";
        break;
    case 3:
        settings.stream() << "VK_EVENT_SET (";
        break;
    case 4:
        settings.stream() << "VK_EVENT_RESET (";
        break;
    case 5:
        settings.stream() << "VK_INCOMPLETE (";
        break;
    case -1:
        settings.stream() << "VK_ERROR_OUT_OF_HOST_MEMORY (";
        break;
    case -2:
        settings.stream() << "VK_ERROR_OUT_OF_DEVICE_MEMORY (";
        break;
    case -3:
        settings.stream() << "VK_ERROR_INITIALIZATION_FAILED (";
        break;
    case -4:
        settings.stream() << "VK_ERROR_DEVICE_LOST (";
        break;
    case -5:
        settings.stream() << "VK_ERROR_MEMORY_MAP_FAILED (";
        break;
    case -6:
        settings.stream() << "VK_ERROR_LAYER_NOT_PRESENT (";
        break;
    case -7:
        settings.stream() << "VK_ERROR_EXTENSION_NOT_PRESENT (";
        break;
    case -8:
        settings.stream() << "VK_ERROR_FEATURE_NOT_PRESENT (";
        break;
    case -9:
        settings.stream() << "VK_ERROR_INCOMPATIBLE_DRIVER (";
        break;
    case -10:
        settings.stream() << "VK_ERROR_TOO_MANY_OBJECTS (";
        break;
    case -11:
        settings.stream() << "VK_ERROR_FORMAT_NOT_SUPPORTED (";
        break;
    case -12:
        settings.stream() << "VK_ERROR_FRAGMENTED_POOL (";
        break;
    case -13:
        settings.stream() << "VK_ERROR_UNKNOWN (";
        break;
    case -1000069000:
        settings.stream() << "VK_ERROR_OUT_OF_POOL_MEMORY (";
        break;
    case -1000072003:
        settings.stream() << "VK_ERROR_INVALID_EXTERNAL_HANDLE (";
        break;
    case -1000161000:
        settings.stream() << "VK_ERROR_FRAGMENTATION (";
        break;
    case -1000257000:
        settings.stream() << "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS (";
        break;
    case 1000297000:
        settings.stream() << "VK_PIPELINE_COMPILE_REQUIRED (";
        break;
    case -1000000000:
        settings.stream() << "VK_ERROR_SURFACE_LOST_KHR (";
        break;
    case -1000000001:
        settings.stream() << "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR (";
        break;
    case 1000001003:
        settings.stream() << "VK_SUBOPTIMAL_KHR (";
        break;
    case -1000001004:
        settings.stream() << "VK_ERROR_OUT_OF_DATE_KHR (";
        break;
    case -1000003001:
        settings.stream() << "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR (";
        break;
    case -1000011001:
        settings.stream() << "VK_ERROR_VALIDATION_FAILED_EXT (";
        break;
    case -1000012000:
        settings.stream() << "VK_ERROR_INVALID_SHADER_NV (";
        break;
    case -1000023000:
        settings.stream() << "VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR (";
        break;
    case -1000023001:
        settings.stream() << "VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR (";
        break;
    case -1000023002:
        settings.stream() << "VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR (";
        break;
    case -1000023003:
        settings.stream() << "VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR (";
        break;
    case -1000023004:
        settings.stream() << "VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR (";
        break;
    case -1000023005:
        settings.stream() << "VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR (";
        break;
    case -1000158000:
        settings.stream() << "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT (";
        break;
    case -1000174001:
        settings.stream() << "VK_ERROR_NOT_PERMITTED_KHR (";
        break;
    case -1000255000:
        settings.stream() << "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT (";
        break;
    case 1000268000:
        settings.stream() << "VK_THREAD_IDLE_KHR (";
        break;
    case 1000268001:
        settings.stream() << "VK_THREAD_DONE_KHR (";
        break;
    case 1000268002:
        settings.stream() << "VK_OPERATION_DEFERRED_KHR (";
        break;
    case 1000268003:
        settings.stream() << "VK_OPERATION_NOT_DEFERRED_KHR (";
        break;
    case -1000299000:
        settings.stream() << "VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR (";
        break;
    case -1000338000:
        settings.stream() << "VK_ERROR_COMPRESSION_EXHAUSTED_EXT (";
        break;
    case 1000482000:
        settings.stream() << "VK_INCOMPATIBLE_SHADER_BINARY_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkStructureType(VkStructureType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_STRUCTURE_TYPE_APPLICATION_INFO (";
        break;
    case 1:
        settings.stream() << "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO (";
        break;
    case 2:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO (";
        break;
    case 3:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO (";
        break;
    case 4:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBMIT_INFO (";
        break;
    case 5:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (";
        break;
    case 6:
        settings.stream() << "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE (";
        break;
    case 7:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO (";
        break;
    case 8:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (";
        break;
    case 9:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (";
        break;
    case 10:
        settings.stream() << "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO (";
        break;
    case 11:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO (";
        break;
    case 12:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (";
        break;
    case 13:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO (";
        break;
    case 14:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO (";
        break;
    case 15:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (";
        break;
    case 16:
        settings.stream() << "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO (";
        break;
    case 17:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO (";
        break;
    case 18:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO (";
        break;
    case 19:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO (";
        break;
    case 20:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO (";
        break;
    case 21:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO (";
        break;
    case 22:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO (";
        break;
    case 23:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO (";
        break;
    case 24:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO (";
        break;
    case 25:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO (";
        break;
    case 26:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO (";
        break;
    case 27:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO (";
        break;
    case 28:
        settings.stream() << "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO (";
        break;
    case 29:
        settings.stream() << "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO (";
        break;
    case 30:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO (";
        break;
    case 31:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO (";
        break;
    case 32:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO (";
        break;
    case 33:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO (";
        break;
    case 34:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO (";
        break;
    case 35:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET (";
        break;
    case 36:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET (";
        break;
    case 37:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (";
        break;
    case 38:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO (";
        break;
    case 39:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO (";
        break;
    case 40:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (";
        break;
    case 41:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO (";
        break;
    case 42:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (";
        break;
    case 43:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (";
        break;
    case 44:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER (";
        break;
    case 45:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER (";
        break;
    case 46:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_BARRIER (";
        break;
    case 47:
        settings.stream() << "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO (";
        break;
    case 48:
        settings.stream() << "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO (";
        break;
    case 1000094000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES (";
        break;
    case 1000157000:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO (";
        break;
    case 1000157001:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO (";
        break;
    case 1000083000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES (";
        break;
    case 1000127000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS (";
        break;
    case 1000127001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO (";
        break;
    case 1000060000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO (";
        break;
    case 1000060003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO (";
        break;
    case 1000060004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO (";
        break;
    case 1000060005:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO (";
        break;
    case 1000060006:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO (";
        break;
    case 1000060013:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO (";
        break;
    case 1000060014:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO (";
        break;
    case 1000070000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES (";
        break;
    case 1000070001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO (";
        break;
    case 1000146000:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 (";
        break;
    case 1000146001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 (";
        break;
    case 1000146002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 (";
        break;
    case 1000146003:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 (";
        break;
    case 1000146004:
        settings.stream() << "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 (";
        break;
    case 1000059000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 (";
        break;
    case 1000059001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (";
        break;
    case 1000059002:
        settings.stream() << "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (";
        break;
    case 1000059003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 (";
        break;
    case 1000059004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 (";
        break;
    case 1000059005:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 (";
        break;
    case 1000059006:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 (";
        break;
    case 1000059007:
        settings.stream() << "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 (";
        break;
    case 1000059008:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 (";
        break;
    case 1000117000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES (";
        break;
    case 1000117001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO (";
        break;
    case 1000117002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO (";
        break;
    case 1000117003:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO (";
        break;
    case 1000053000:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO (";
        break;
    case 1000053001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES (";
        break;
    case 1000053002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES (";
        break;
    case 1000120000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES (";
        break;
    case 1000145000:
        settings.stream() << "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO (";
        break;
    case 1000145001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES (";
        break;
    case 1000145002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES (";
        break;
    case 1000145003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 (";
        break;
    case 1000156000:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO (";
        break;
    case 1000156001:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO (";
        break;
    case 1000156002:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO (";
        break;
    case 1000156003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO (";
        break;
    case 1000156004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES (";
        break;
    case 1000156005:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES (";
        break;
    case 1000085000:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO (";
        break;
    case 1000071000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO (";
        break;
    case 1000071001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES (";
        break;
    case 1000071002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO (";
        break;
    case 1000071003:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES (";
        break;
    case 1000071004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES (";
        break;
    case 1000072000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO (";
        break;
    case 1000072001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO (";
        break;
    case 1000072002:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO (";
        break;
    case 1000112000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO (";
        break;
    case 1000112001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES (";
        break;
    case 1000113000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO (";
        break;
    case 1000077000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO (";
        break;
    case 1000076000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO (";
        break;
    case 1000076001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES (";
        break;
    case 1000168000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES (";
        break;
    case 1000168001:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT (";
        break;
    case 1000063000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES (";
        break;
    case 49:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES (";
        break;
    case 50:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES (";
        break;
    case 51:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES (";
        break;
    case 52:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES (";
        break;
    case 1000147000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO (";
        break;
    case 1000109000:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 (";
        break;
    case 1000109001:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 (";
        break;
    case 1000109002:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 (";
        break;
    case 1000109003:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 (";
        break;
    case 1000109004:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 (";
        break;
    case 1000109005:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO (";
        break;
    case 1000109006:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_END_INFO (";
        break;
    case 1000177000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES (";
        break;
    case 1000196000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES (";
        break;
    case 1000180000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES (";
        break;
    case 1000082000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES (";
        break;
    case 1000197000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES (";
        break;
    case 1000161000:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO (";
        break;
    case 1000161001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES (";
        break;
    case 1000161002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES (";
        break;
    case 1000161003:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO (";
        break;
    case 1000161004:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT (";
        break;
    case 1000199000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES (";
        break;
    case 1000199001:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE (";
        break;
    case 1000221000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES (";
        break;
    case 1000246000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO (";
        break;
    case 1000130000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES (";
        break;
    case 1000130001:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO (";
        break;
    case 1000211000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES (";
        break;
    case 1000108000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES (";
        break;
    case 1000108001:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO (";
        break;
    case 1000108002:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO (";
        break;
    case 1000108003:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO (";
        break;
    case 1000253000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES (";
        break;
    case 1000175000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES (";
        break;
    case 1000241000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES (";
        break;
    case 1000241001:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT (";
        break;
    case 1000241002:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT (";
        break;
    case 1000261000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES (";
        break;
    case 1000207000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES (";
        break;
    case 1000207001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES (";
        break;
    case 1000207002:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO (";
        break;
    case 1000207003:
        settings.stream() << "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO (";
        break;
    case 1000207004:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO (";
        break;
    case 1000207005:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO (";
        break;
    case 1000257000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES (";
        break;
    case 1000244001:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO (";
        break;
    case 1000257002:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO (";
        break;
    case 1000257003:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO (";
        break;
    case 1000257004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO (";
        break;
    case 53:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES (";
        break;
    case 54:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES (";
        break;
    case 1000192000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO (";
        break;
    case 1000215000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES (";
        break;
    case 1000245000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES (";
        break;
    case 1000276000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES (";
        break;
    case 1000295000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES (";
        break;
    case 1000295001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO (";
        break;
    case 1000295002:
        settings.stream() << "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO (";
        break;
    case 1000297000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES (";
        break;
    case 1000314000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 (";
        break;
    case 1000314001:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 (";
        break;
    case 1000314002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 (";
        break;
    case 1000314003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEPENDENCY_INFO (";
        break;
    case 1000314004:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBMIT_INFO_2 (";
        break;
    case 1000314005:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO (";
        break;
    case 1000314006:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO (";
        break;
    case 1000314007:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES (";
        break;
    case 1000325000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES (";
        break;
    case 1000335000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES (";
        break;
    case 1000337000:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 (";
        break;
    case 1000337001:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 (";
        break;
    case 1000337002:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 (";
        break;
    case 1000337003:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 (";
        break;
    case 1000337004:
        settings.stream() << "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 (";
        break;
    case 1000337005:
        settings.stream() << "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 (";
        break;
    case 1000337006:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_COPY_2 (";
        break;
    case 1000337007:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_COPY_2 (";
        break;
    case 1000337008:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_BLIT_2 (";
        break;
    case 1000337009:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 (";
        break;
    case 1000337010:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 (";
        break;
    case 1000225000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES (";
        break;
    case 1000225001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO (";
        break;
    case 1000225002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES (";
        break;
    case 1000138000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES (";
        break;
    case 1000138001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES (";
        break;
    case 1000138002:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK (";
        break;
    case 1000138003:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO (";
        break;
    case 1000066000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES (";
        break;
    case 1000044000:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_INFO (";
        break;
    case 1000044001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO (";
        break;
    case 1000044002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO (";
        break;
    case 1000044003:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES (";
        break;
    case 1000044004:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO (";
        break;
    case 1000280000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES (";
        break;
    case 1000280001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES (";
        break;
    case 1000281001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES (";
        break;
    case 1000360000:
        settings.stream() << "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (";
        break;
    case 1000413000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES (";
        break;
    case 1000413001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES (";
        break;
    case 1000413002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS (";
        break;
    case 1000413003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS (";
        break;
    case 1000001000:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR (";
        break;
    case 1000001001:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (";
        break;
    case 1000060007:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR (";
        break;
    case 1000060008:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR (";
        break;
    case 1000060009:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR (";
        break;
    case 1000060010:
        settings.stream() << "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR (";
        break;
    case 1000060011:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR (";
        break;
    case 1000060012:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR (";
        break;
    case 1000002000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR (";
        break;
    case 1000002001:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000003000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR (";
        break;
    case 1000004000:
        settings.stream() << "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000005000:
        settings.stream() << "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000006000:
        settings.stream() << "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000008000:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000009000:
        settings.stream() << "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000010000:
        settings.stream() << "VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID (";
        break;
    case 1000010001:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID (";
        break;
    case 1000010002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID (";
        break;
    case 1000011000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT (";
        break;
    case 1000018000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD (";
        break;
    case 1000022000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT (";
        break;
    case 1000022001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT (";
        break;
    case 1000022002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT (";
        break;
    case 1000023000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR (";
        break;
    case 1000023001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR (";
        break;
    case 1000023002:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR (";
        break;
    case 1000023003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR (";
        break;
    case 1000023004:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR (";
        break;
    case 1000023005:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR (";
        break;
    case 1000023006:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR (";
        break;
    case 1000023007:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR (";
        break;
    case 1000023008:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR (";
        break;
    case 1000023009:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR (";
        break;
    case 1000023010:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR (";
        break;
    case 1000023011:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR (";
        break;
    case 1000023012:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR (";
        break;
    case 1000023013:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR (";
        break;
    case 1000023014:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR (";
        break;
    case 1000023015:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR (";
        break;
    case 1000023016:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR (";
        break;
    case 1000024000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR (";
        break;
    case 1000024001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR (";
        break;
    case 1000024002:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR (";
        break;
    case 1000026000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV (";
        break;
    case 1000026001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV (";
        break;
    case 1000026002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV (";
        break;
    case 1000028000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT (";
        break;
    case 1000028001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT (";
        break;
    case 1000028002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT (";
        break;
    case 1000029000:
        settings.stream() << "VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX (";
        break;
    case 1000029001:
        settings.stream() << "VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX (";
        break;
    case 1000029002:
        settings.stream() << "VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX (";
        break;
    case 1000030000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX (";
        break;
    case 1000030001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX (";
        break;
    case 1000038000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR (";
        break;
    case 1000038001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR (";
        break;
    case 1000038002:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR (";
        break;
    case 1000038003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR (";
        break;
    case 1000038004:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR (";
        break;
    case 1000038005:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR (";
        break;
    case 1000038006:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR (";
        break;
    case 1000038007:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR (";
        break;
    case 1000038008:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR (";
        break;
    case 1000038009:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR (";
        break;
    case 1000038010:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR (";
        break;
    case 1000038011:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR (";
        break;
    case 1000038012:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR (";
        break;
    case 1000038013:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR (";
        break;
    case 1000039000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR (";
        break;
    case 1000039001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR (";
        break;
    case 1000039002:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR (";
        break;
    case 1000039003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR (";
        break;
    case 1000039004:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR (";
        break;
    case 1000039005:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR (";
        break;
    case 1000039006:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR (";
        break;
    case 1000039007:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR (";
        break;
    case 1000039009:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR (";
        break;
    case 1000039010:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR (";
        break;
    case 1000039011:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR (";
        break;
    case 1000039012:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR (";
        break;
    case 1000039013:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR (";
        break;
    case 1000039014:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR (";
        break;
    case 1000040000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR (";
        break;
    case 1000040001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR (";
        break;
    case 1000040003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR (";
        break;
    case 1000040004:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR (";
        break;
    case 1000040005:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR (";
        break;
    case 1000040006:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR (";
        break;
    case 1000041000:
        settings.stream() << "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD (";
        break;
    case 1000044006:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR (";
        break;
    case 1000044007:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT (";
        break;
    case 1000044008:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD (";
        break;
    case 1000044009:
        settings.stream() << "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX (";
        break;
    case 1000049000:
        settings.stream() << "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP (";
        break;
    case 1000050000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV (";
        break;
    case 1000051000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV (";
        break;
    case 1000056000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV (";
        break;
    case 1000056001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV (";
        break;
    case 1000057000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV (";
        break;
    case 1000057001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV (";
        break;
    case 1000058000:
        settings.stream() << "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV (";
        break;
    case 1000061000:
        settings.stream() << "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT (";
        break;
    case 1000062000:
        settings.stream() << "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN (";
        break;
    case 1000067000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT (";
        break;
    case 1000067001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT (";
        break;
    case 1000068000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT (";
        break;
    case 1000068001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT (";
        break;
    case 1000068002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT (";
        break;
    case 1000073000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000073001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000073002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR (";
        break;
    case 1000073003:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000074000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR (";
        break;
    case 1000074001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR (";
        break;
    case 1000074002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR (";
        break;
    case 1000075000:
        settings.stream() << "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR (";
        break;
    case 1000078000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000078001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000078002:
        settings.stream() << "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR (";
        break;
    case 1000078003:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000079000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR (";
        break;
    case 1000079001:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR (";
        break;
    case 1000080000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR (";
        break;
    case 1000081000:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT (";
        break;
    case 1000081001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT (";
        break;
    case 1000081002:
        settings.stream() << "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT (";
        break;
    case 1000084000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR (";
        break;
    case 1000087000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV (";
        break;
    case 1000090000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT (";
        break;
    case 1000091000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT (";
        break;
    case 1000091001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT (";
        break;
    case 1000091002:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT (";
        break;
    case 1000091003:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT (";
        break;
    case 1000092000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE (";
        break;
    case 1000097000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX (";
        break;
    case 1000098000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV (";
        break;
    case 1000099000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT (";
        break;
    case 1000099001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT (";
        break;
    case 1000101000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT (";
        break;
    case 1000101001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT (";
        break;
    case 1000102000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT (";
        break;
    case 1000102001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT (";
        break;
    case 1000105000:
        settings.stream() << "VK_STRUCTURE_TYPE_HDR_METADATA_EXT (";
        break;
    case 1000110000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG (";
        break;
    case 1000111000:
        settings.stream() << "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR (";
        break;
    case 1000114000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000114001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000114002:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000115000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR (";
        break;
    case 1000115001:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR (";
        break;
    case 1000116000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR (";
        break;
    case 1000116001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR (";
        break;
    case 1000116002:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR (";
        break;
    case 1000116003:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR (";
        break;
    case 1000116004:
        settings.stream() << "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR (";
        break;
    case 1000116005:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR (";
        break;
    case 1000116006:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR (";
        break;
    case 1000119000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR (";
        break;
    case 1000119001:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR (";
        break;
    case 1000119002:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR (";
        break;
    case 1000121000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR (";
        break;
    case 1000121001:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR (";
        break;
    case 1000121002:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR (";
        break;
    case 1000121003:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR (";
        break;
    case 1000121004:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR (";
        break;
    case 1000122000:
        settings.stream() << "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK (";
        break;
    case 1000123000:
        settings.stream() << "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK (";
        break;
    case 1000128000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT (";
        break;
    case 1000128001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT (";
        break;
    case 1000128002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT (";
        break;
    case 1000128003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT (";
        break;
    case 1000128004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT (";
        break;
    case 1000129000:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID (";
        break;
    case 1000129001:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID (";
        break;
    case 1000129002:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID (";
        break;
    case 1000129003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID (";
        break;
    case 1000129004:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID (";
        break;
    case 1000129005:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID (";
        break;
    case 1000129006:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID (";
        break;
    case 1000134000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX (";
        break;
    case 1000134001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX (";
        break;
    case 1000134002:
        settings.stream() << "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX (";
        break;
    case 1000134003:
        settings.stream() << "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX (";
        break;
    case 1000134004:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX (";
        break;
    case 1000143000:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT (";
        break;
    case 1000143001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT (";
        break;
    case 1000143002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT (";
        break;
    case 1000143003:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT (";
        break;
    case 1000143004:
        settings.stream() << "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT (";
        break;
    case 1000148000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT (";
        break;
    case 1000148001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT (";
        break;
    case 1000148002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT (";
        break;
    case 1000149000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV (";
        break;
    case 1000150007:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR (";
        break;
    case 1000150000:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR (";
        break;
    case 1000150002:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR (";
        break;
    case 1000150003:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR (";
        break;
    case 1000150004:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR (";
        break;
    case 1000150005:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR (";
        break;
    case 1000150006:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR (";
        break;
    case 1000150009:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR (";
        break;
    case 1000150010:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR (";
        break;
    case 1000150011:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR (";
        break;
    case 1000150012:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR (";
        break;
    case 1000150013:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR (";
        break;
    case 1000150014:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR (";
        break;
    case 1000150017:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR (";
        break;
    case 1000150020:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR (";
        break;
    case 1000347000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR (";
        break;
    case 1000347001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR (";
        break;
    case 1000150015:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR (";
        break;
    case 1000150016:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR (";
        break;
    case 1000150018:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR (";
        break;
    case 1000348013:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR (";
        break;
    case 1000152000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV (";
        break;
    case 1000154000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV (";
        break;
    case 1000154001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV (";
        break;
    case 1000158000:
        settings.stream() << "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT (";
        break;
    case 1000158002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT (";
        break;
    case 1000158003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT (";
        break;
    case 1000158004:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT (";
        break;
    case 1000158005:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT (";
        break;
    case 1000158006:
        settings.stream() << "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT (";
        break;
    case 1000160000:
        settings.stream() << "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT (";
        break;
    case 1000160001:
        settings.stream() << "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT (";
        break;
    case 1000163000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR (";
        break;
    case 1000163001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR (";
        break;
    case 1000164000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV (";
        break;
    case 1000164001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV (";
        break;
    case 1000164002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV (";
        break;
    case 1000164005:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV (";
        break;
    case 1000165000:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV (";
        break;
    case 1000165001:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV (";
        break;
    case 1000165003:
        settings.stream() << "VK_STRUCTURE_TYPE_GEOMETRY_NV (";
        break;
    case 1000165004:
        settings.stream() << "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV (";
        break;
    case 1000165005:
        settings.stream() << "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV (";
        break;
    case 1000165006:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV (";
        break;
    case 1000165007:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV (";
        break;
    case 1000165008:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV (";
        break;
    case 1000165009:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV (";
        break;
    case 1000165011:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV (";
        break;
    case 1000165012:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV (";
        break;
    case 1000166000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV (";
        break;
    case 1000166001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV (";
        break;
    case 1000170000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT (";
        break;
    case 1000170001:
        settings.stream() << "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT (";
        break;
    case 1000178000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT (";
        break;
    case 1000178001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT (";
        break;
    case 1000178002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT (";
        break;
    case 1000181000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR (";
        break;
    case 1000183000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD (";
        break;
    case 1000185000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD (";
        break;
    case 1000187000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR (";
        break;
    case 1000187001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR (";
        break;
    case 1000187002:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR (";
        break;
    case 1000187003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR (";
        break;
    case 1000187004:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR (";
        break;
    case 1000187005:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR (";
        break;
    case 1000174000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR (";
        break;
    case 1000388000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR (";
        break;
    case 1000388001:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR (";
        break;
    case 1000189000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD (";
        break;
    case 1000190000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT (";
        break;
    case 1000191000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP (";
        break;
    case 1000201000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV (";
        break;
    case 1000202000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV (";
        break;
    case 1000202001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV (";
        break;
    case 1000204000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV (";
        break;
    case 1000205000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV (";
        break;
    case 1000205002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV (";
        break;
    case 1000206000:
        settings.stream() << "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV (";
        break;
    case 1000206001:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV (";
        break;
    case 1000209000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL (";
        break;
    case 1000210000:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL (";
        break;
    case 1000210001:
        settings.stream() << "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL (";
        break;
    case 1000210002:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL (";
        break;
    case 1000210003:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL (";
        break;
    case 1000210004:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL (";
        break;
    case 1000210005:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL (";
        break;
    case 1000212000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT (";
        break;
    case 1000213000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD (";
        break;
    case 1000213001:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD (";
        break;
    case 1000214000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA (";
        break;
    case 1000217000:
        settings.stream() << "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT (";
        break;
    case 1000218000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT (";
        break;
    case 1000218001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT (";
        break;
    case 1000218002:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT (";
        break;
    case 1000226000:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR (";
        break;
    case 1000226001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR (";
        break;
    case 1000226002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR (";
        break;
    case 1000226003:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR (";
        break;
    case 1000226004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR (";
        break;
    case 1000227000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD (";
        break;
    case 1000229000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD (";
        break;
    case 1000232000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR (";
        break;
    case 1000232001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR (";
        break;
    case 1000232002:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR (";
        break;
    case 1000234000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT (";
        break;
    case 1000235000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR (";
        break;
    case 1000237000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT (";
        break;
    case 1000238000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT (";
        break;
    case 1000238001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT (";
        break;
    case 1000239000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR (";
        break;
    case 1000240000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV (";
        break;
    case 1000244000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT (";
        break;
    case 1000244002:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT (";
        break;
    case 1000247000:
        settings.stream() << "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT (";
        break;
    case 1000248000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR (";
        break;
    case 1000249000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV (";
        break;
    case 1000249001:
        settings.stream() << "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV (";
        break;
    case 1000249002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV (";
        break;
    case 1000250000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV (";
        break;
    case 1000250001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV (";
        break;
    case 1000250002:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV (";
        break;
    case 1000251000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT (";
        break;
    case 1000252000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT (";
        break;
    case 1000254000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT (";
        break;
    case 1000254001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT (";
        break;
    case 1000254002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT (";
        break;
    case 1000255000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT (";
        break;
    case 1000255002:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT (";
        break;
    case 1000255001:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT (";
        break;
    case 1000256000:
        settings.stream() << "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT (";
        break;
    case 1000260000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT (";
        break;
    case 1000267000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT (";
        break;
    case 1000269000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR (";
        break;
    case 1000269001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR (";
        break;
    case 1000269002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR (";
        break;
    case 1000269003:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR (";
        break;
    case 1000269004:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR (";
        break;
    case 1000269005:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR (";
        break;
    case 1000270000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT (";
        break;
    case 1000270001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT (";
        break;
    case 1000270002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT (";
        break;
    case 1000270003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT (";
        break;
    case 1000270004:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT (";
        break;
    case 1000270005:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT (";
        break;
    case 1000270006:
        settings.stream() << "VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT (";
        break;
    case 1000270007:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT (";
        break;
    case 1000270008:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT (";
        break;
    case 1000270009:
        settings.stream() << "VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT (";
        break;
    case 1000271000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR (";
        break;
    case 1000271001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR (";
        break;
    case 1000272000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT (";
        break;
    case 1000272001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT (";
        break;
    case 1000272002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT (";
        break;
    case 1000273000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT (";
        break;
    case 1000274000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT (";
        break;
    case 1000274001:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT (";
        break;
    case 1000274002:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT (";
        break;
    case 1000275000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT (";
        break;
    case 1000275001:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT (";
        break;
    case 1000275002:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT (";
        break;
    case 1000275003:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT (";
        break;
    case 1000275004:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT (";
        break;
    case 1000275005:
        settings.stream() << "VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT (";
        break;
    case 1000277000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV (";
        break;
    case 1000277001:
        settings.stream() << "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV (";
        break;
    case 1000277002:
        settings.stream() << "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV (";
        break;
    case 1000277003:
        settings.stream() << "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV (";
        break;
    case 1000277004:
        settings.stream() << "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV (";
        break;
    case 1000277005:
        settings.stream() << "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV (";
        break;
    case 1000277006:
        settings.stream() << "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV (";
        break;
    case 1000277007:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV (";
        break;
    case 1000278000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV (";
        break;
    case 1000278001:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV (";
        break;
    case 1000281000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT (";
        break;
    case 1000282000:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM (";
        break;
    case 1000282001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM (";
        break;
    case 1000283000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT (";
        break;
    case 1000283001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT (";
        break;
    case 1000283002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT (";
        break;
    case 1000284000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT (";
        break;
    case 1000284001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT (";
        break;
    case 1000284002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT (";
        break;
    case 1000286000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT (";
        break;
    case 1000286001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT (";
        break;
    case 1000287000:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT (";
        break;
    case 1000287001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT (";
        break;
    case 1000287002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT (";
        break;
    case 1000290000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR (";
        break;
    case 1000292000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV (";
        break;
    case 1000292001:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV (";
        break;
    case 1000292002:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV (";
        break;
    case 1000294000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_ID_KHR (";
        break;
    case 1000294001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR (";
        break;
    case 1000299000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR (";
        break;
    case 1000299001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR (";
        break;
    case 1000299002:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR (";
        break;
    case 1000299003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR (";
        break;
    case 1000299004:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR (";
        break;
    case 1000299005:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR (";
        break;
    case 1000299006:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR (";
        break;
    case 1000299007:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR (";
        break;
    case 1000299008:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR (";
        break;
    case 1000299009:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR (";
        break;
    case 1000299010:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR (";
        break;
    case 1000300000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV (";
        break;
    case 1000300001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV (";
        break;
    case 1000307000:
        settings.stream() << "VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV (";
        break;
    case 1000307001:
        settings.stream() << "VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV (";
        break;
    case 1000307002:
        settings.stream() << "VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV (";
        break;
    case 1000307003:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV (";
        break;
    case 1000307004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV (";
        break;
    case 1000308000:
        settings.stream() << "VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR (";
        break;
    case 1000310000:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV (";
        break;
    case 1000311000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT (";
        break;
    case 1000311001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT (";
        break;
    case 1000311002:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT (";
        break;
    case 1000311003:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT (";
        break;
    case 1000311004:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT (";
        break;
    case 1000311005:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT (";
        break;
    case 1000311006:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT (";
        break;
    case 1000311007:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT (";
        break;
    case 1000311008:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT (";
        break;
    case 1000311009:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT (";
        break;
    case 1000311010:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT (";
        break;
    case 1000311011:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT (";
        break;
    case 1000314008:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV (";
        break;
    case 1000314009:
        settings.stream() << "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV (";
        break;
    case 1000316000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT (";
        break;
    case 1000316001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT (";
        break;
    case 1000316002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT (";
        break;
    case 1000316003:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT (";
        break;
    case 1000316004:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT (";
        break;
    case 1000316005:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT (";
        break;
    case 1000316006:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT (";
        break;
    case 1000316007:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT (";
        break;
    case 1000316008:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT (";
        break;
    case 1000316010:
        settings.stream() << "VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT (";
        break;
    case 1000316011:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT (";
        break;
    case 1000316012:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT (";
        break;
    case 1000316009:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT (";
        break;
    case 1000320000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT (";
        break;
    case 1000320001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT (";
        break;
    case 1000320002:
        settings.stream() << "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT (";
        break;
    case 1000321000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD (";
        break;
    case 1000203000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR (";
        break;
    case 1000322000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR (";
        break;
    case 1000323000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR (";
        break;
    case 1000326000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV (";
        break;
    case 1000326001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV (";
        break;
    case 1000326002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV (";
        break;
    case 1000327000:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV (";
        break;
    case 1000327001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV (";
        break;
    case 1000327002:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV (";
        break;
    case 1000328000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT (";
        break;
    case 1000328001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT (";
        break;
    case 1000330000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT (";
        break;
    case 1000332000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT (";
        break;
    case 1000332001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT (";
        break;
    case 1000333000:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM (";
        break;
    case 1000336000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR (";
        break;
    case 1000338000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT (";
        break;
    case 1000338001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT (";
        break;
    case 1000338004:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT (";
        break;
    case 1000339000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT (";
        break;
    case 1000340000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT (";
        break;
    case 1000341000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT (";
        break;
    case 1000341001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT (";
        break;
    case 1000341002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT (";
        break;
    case 1000344000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT (";
        break;
    case 1000346000:
        settings.stream() << "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT (";
        break;
    case 1000352000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT (";
        break;
    case 1000352001:
        settings.stream() << "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT (";
        break;
    case 1000352002:
        settings.stream() << "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT (";
        break;
    case 1000353000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT (";
        break;
    case 1000354000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT (";
        break;
    case 1000354001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT (";
        break;
    case 1000355000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT (";
        break;
    case 1000355001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT (";
        break;
    case 1000356000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT (";
        break;
    case 1000364000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA (";
        break;
    case 1000364001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA (";
        break;
    case 1000364002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA (";
        break;
    case 1000365000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA (";
        break;
    case 1000365001:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA (";
        break;
    case 1000366000:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA (";
        break;
    case 1000366001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA (";
        break;
    case 1000366002:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA (";
        break;
    case 1000366003:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA (";
        break;
    case 1000366004:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA (";
        break;
    case 1000366005:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA (";
        break;
    case 1000366006:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA (";
        break;
    case 1000366007:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA (";
        break;
    case 1000366008:
        settings.stream() << "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA (";
        break;
    case 1000366009:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA (";
        break;
    case 1000369000:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI (";
        break;
    case 1000369001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI (";
        break;
    case 1000369002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI (";
        break;
    case 1000370000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI (";
        break;
    case 1000371000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV (";
        break;
    case 1000371001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV (";
        break;
    case 1000372000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT (";
        break;
    case 1000372001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT (";
        break;
    case 1000373000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV (";
        break;
    case 1000373001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV (";
        break;
    case 1000373002:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV (";
        break;
    case 1000373003:
        settings.stream() << "VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV (";
        break;
    case 1000373004:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV (";
        break;
    case 1000373005:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV (";
        break;
    case 1000373006:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV (";
        break;
    case 1000373007:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV (";
        break;
    case 1000374000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV (";
        break;
    case 1000374001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV (";
        break;
    case 1000374002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV (";
        break;
    case 1000374003:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV (";
        break;
    case 1000374004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV (";
        break;
    case 1000375000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT (";
        break;
    case 1000375001:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT (";
        break;
    case 1000376000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT (";
        break;
    case 1000376001:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT (";
        break;
    case 1000376002:
        settings.stream() << "VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT (";
        break;
    case 1000377000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT (";
        break;
    case 1000378000:
        settings.stream() << "VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX (";
        break;
    case 1000381000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT (";
        break;
    case 1000381001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT (";
        break;
    case 1000382000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT (";
        break;
    case 1000386000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR (";
        break;
    case 1000391000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT (";
        break;
    case 1000391001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT (";
        break;
    case 1000392000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT (";
        break;
    case 1000392001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT (";
        break;
    case 1000393000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT (";
        break;
    case 1000395000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT (";
        break;
    case 1000395001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT (";
        break;
    case 1000396000:
        settings.stream() << "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT (";
        break;
    case 1000396001:
        settings.stream() << "VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT (";
        break;
    case 1000396002:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT (";
        break;
    case 1000396003:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT (";
        break;
    case 1000396004:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT (";
        break;
    case 1000396005:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT (";
        break;
    case 1000396006:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT (";
        break;
    case 1000396007:
        settings.stream() << "VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT (";
        break;
    case 1000396008:
        settings.stream() << "VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT (";
        break;
    case 1000396009:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT (";
        break;
    case 1000397000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV (";
        break;
    case 1000397001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV (";
        break;
    case 1000397002:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV (";
        break;
    case 1000404000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI (";
        break;
    case 1000404001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI (";
        break;
    case 1000404002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI (";
        break;
    case 1000411000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT (";
        break;
    case 1000411001:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT (";
        break;
    case 1000412000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT (";
        break;
    case 1000415000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM (";
        break;
    case 1000416000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR (";
        break;
    case 1000417000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM (";
        break;
    case 1000417001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM (";
        break;
    case 1000417002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM (";
        break;
    case 1000418000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT (";
        break;
    case 1000418001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT (";
        break;
    case 1000420000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE (";
        break;
    case 1000420001:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE (";
        break;
    case 1000420002:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE (";
        break;
    case 1000421000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT (";
        break;
    case 1000422000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT (";
        break;
    case 1000424000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM (";
        break;
    case 1000424001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM (";
        break;
    case 1000424002:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM (";
        break;
    case 1000424003:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM (";
        break;
    case 1000424004:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM (";
        break;
    case 1000425000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM (";
        break;
    case 1000425001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM (";
        break;
    case 1000425002:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM (";
        break;
    case 1000426000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV (";
        break;
    case 1000426001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV (";
        break;
    case 1000427000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV (";
        break;
    case 1000427001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV (";
        break;
    case 1000428000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV (";
        break;
    case 1000428001:
        settings.stream() << "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV (";
        break;
    case 1000428002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV (";
        break;
    case 1000430000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV (";
        break;
    case 1000434000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR (";
        break;
    case 1000435000:
        settings.stream() << "VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT (";
        break;
    case 1000437000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT (";
        break;
    case 1000440000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM (";
        break;
    case 1000440001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM (";
        break;
    case 1000440002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM (";
        break;
    case 1000451000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT (";
        break;
    case 1000451001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT (";
        break;
    case 1000453000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT (";
        break;
    case 1000455000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT (";
        break;
    case 1000455001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT (";
        break;
    case 1000458000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT (";
        break;
    case 1000458001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT (";
        break;
    case 1000458002:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT (";
        break;
    case 1000458003:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT (";
        break;
    case 1000459000:
        settings.stream() << "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG (";
        break;
    case 1000459001:
        settings.stream() << "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG (";
        break;
    case 1000462000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT (";
        break;
    case 1000462001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT (";
        break;
    case 1000462002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT (";
        break;
    case 1000462003:
        settings.stream() << "VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT (";
        break;
    case 1000342000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT (";
        break;
    case 1000464000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV (";
        break;
    case 1000464001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV (";
        break;
    case 1000464002:
        settings.stream() << "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV (";
        break;
    case 1000464003:
        settings.stream() << "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV (";
        break;
    case 1000464004:
        settings.stream() << "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV (";
        break;
    case 1000464005:
        settings.stream() << "VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV (";
        break;
    case 1000464010:
        settings.stream() << "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV (";
        break;
    case 1000465000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT (";
        break;
    case 1000466000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT (";
        break;
    case 1000468000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID (";
        break;
    case 1000468001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID (";
        break;
    case 1000468002:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID (";
        break;
    case 1000470000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR (";
        break;
    case 1000470001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR (";
        break;
    case 1000470003:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR (";
        break;
    case 1000470004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR (";
        break;
    case 1000338002:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR (";
        break;
    case 1000338003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR (";
        break;
    case 1000470005:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR (";
        break;
    case 1000470006:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR (";
        break;
    case 1000481000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR (";
        break;
    case 1000482000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT (";
        break;
    case 1000482001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT (";
        break;
    case 1000482002:
        settings.stream() << "VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT (";
        break;
    case 1000484000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM (";
        break;
    case 1000484001:
        settings.stream() << "VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM (";
        break;
    case 1000485000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC (";
        break;
    case 1000485001:
        settings.stream() << "VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC (";
        break;
    case 1000488000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM (";
        break;
    case 1000489000:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV (";
        break;
    case 1000489001:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV (";
        break;
    case 1000489002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV (";
        break;
    case 1000490000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV (";
        break;
    case 1000490001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV (";
        break;
    case 1000492000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV (";
        break;
    case 1000492001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV (";
        break;
    case 1000351000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT (";
        break;
    case 1000351002:
        settings.stream() << "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT (";
        break;
    case 1000496000:
        settings.stream() << "VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT (";
        break;
    case 1000497000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM (";
        break;
    case 1000497001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM (";
        break;
    case 1000498000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT (";
        break;
    case 1000499000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT (";
        break;
    case 1000505000:
        settings.stream() << "VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV (";
        break;
    case 1000505001:
        settings.stream() << "VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV (";
        break;
    case 1000505002:
        settings.stream() << "VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV (";
        break;
    case 1000505003:
        settings.stream() << "VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV (";
        break;
    case 1000505004:
        settings.stream() << "VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV (";
        break;
    case 1000505005:
        settings.stream() << "VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV (";
        break;
    case 1000505006:
        settings.stream() << "VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV (";
        break;
    case 1000505007:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV (";
        break;
    case 1000505008:
        settings.stream() << "VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV (";
        break;
    case 1000506000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR (";
        break;
    case 1000506001:
        settings.stream() << "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR (";
        break;
    case 1000506002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR (";
        break;
    case 1000510000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM (";
        break;
    case 1000510001:
        settings.stream() << "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM (";
        break;
    case 1000512000:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR (";
        break;
    case 1000512001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR (";
        break;
    case 1000512003:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR (";
        break;
    case 1000512004:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR (";
        break;
    case 1000512005:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR (";
        break;
    case 1000515000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR (";
        break;
    case 1000515001:
        settings.stream() << "VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR (";
        break;
    case 1000516000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV (";
        break;
    case 1000518000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM (";
        break;
    case 1000518001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM (";
        break;
    case 1000518002:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM (";
        break;
    case 1000519000:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM (";
        break;
    case 1000519001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM (";
        break;
    case 1000519002:
        settings.stream() << "VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM (";
        break;
    case 1000520000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM (";
        break;
    case 1000520001:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM (";
        break;
    case 1000521000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM (";
        break;
    case 1000524000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT (";
        break;
    case 1000525000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR (";
        break;
    case 1000190001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR (";
        break;
    case 1000190002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR (";
        break;
    case 1000528000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR (";
        break;
    case 1000529000:
        settings.stream() << "VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX (";
        break;
    case 1000529001:
        settings.stream() << "VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX (";
        break;
    case 1000529002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX (";
        break;
    case 1000529003:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX (";
        break;
    case 1000529004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX (";
        break;
    case 1000530000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT (";
        break;
    case 1000265000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR (";
        break;
    case 1000259000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR (";
        break;
    case 1000259001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR (";
        break;
    case 1000259002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR (";
        break;
    case 1000184000:
        settings.stream() << "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR (";
        break;
    case 1000544000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR (";
        break;
    case 1000545000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR (";
        break;
    case 1000545001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR (";
        break;
    case 1000545002:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR (";
        break;
    case 1000545003:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR (";
        break;
    case 1000545004:
        settings.stream() << "VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR (";
        break;
    case 1000545005:
        settings.stream() << "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR (";
        break;
    case 1000545006:
        settings.stream() << "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR (";
        break;
    case 1000545007:
        settings.stream() << "VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT (";
        break;
    case 1000545008:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT (";
        break;
    case 1000546000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV (";
        break;
    case 1000555000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV (";
        break;
    case 1000563000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV (";
        break;
    case 1000568000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPipelineCacheHeaderVersion(VkPipelineCacheHeaderVersion object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_PIPELINE_CACHE_HEADER_VERSION_ONE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkImageLayout(VkImageLayout object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_LAYOUT_UNDEFINED (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_LAYOUT_GENERAL (";
        break;
    case 2:
        settings.stream() << "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL (";
        break;
    case 3:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL (";
        break;
    case 4:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL (";
        break;
    case 5:
        settings.stream() << "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL (";
        break;
    case 6:
        settings.stream() << "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL (";
        break;
    case 7:
        settings.stream() << "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL (";
        break;
    case 8:
        settings.stream() << "VK_IMAGE_LAYOUT_PREINITIALIZED (";
        break;
    case 1000117000:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL (";
        break;
    case 1000117001:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL (";
        break;
    case 1000241000:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL (";
        break;
    case 1000241001:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL (";
        break;
    case 1000241002:
        settings.stream() << "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL (";
        break;
    case 1000241003:
        settings.stream() << "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL (";
        break;
    case 1000314000:
        settings.stream() << "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL (";
        break;
    case 1000314001:
        settings.stream() << "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL (";
        break;
    case 1000001002:
        settings.stream() << "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR (";
        break;
    case 1000024000:
        settings.stream() << "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR (";
        break;
    case 1000024001:
        settings.stream() << "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR (";
        break;
    case 1000024002:
        settings.stream() << "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR (";
        break;
    case 1000111000:
        settings.stream() << "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR (";
        break;
    case 1000218000:
        settings.stream() << "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT (";
        break;
    case 1000164003:
        settings.stream() << "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR (";
        break;
    case 1000232000:
        settings.stream() << "VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR (";
        break;
    case 1000299000:
        settings.stream() << "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR (";
        break;
    case 1000299001:
        settings.stream() << "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR (";
        break;
    case 1000299002:
        settings.stream() << "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR (";
        break;
    case 1000339000:
        settings.stream() << "VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkObjectType(VkObjectType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_OBJECT_TYPE_UNKNOWN (";
        break;
    case 1:
        settings.stream() << "VK_OBJECT_TYPE_INSTANCE (";
        break;
    case 2:
        settings.stream() << "VK_OBJECT_TYPE_PHYSICAL_DEVICE (";
        break;
    case 3:
        settings.stream() << "VK_OBJECT_TYPE_DEVICE (";
        break;
    case 4:
        settings.stream() << "VK_OBJECT_TYPE_QUEUE (";
        break;
    case 5:
        settings.stream() << "VK_OBJECT_TYPE_SEMAPHORE (";
        break;
    case 6:
        settings.stream() << "VK_OBJECT_TYPE_COMMAND_BUFFER (";
        break;
    case 7:
        settings.stream() << "VK_OBJECT_TYPE_FENCE (";
        break;
    case 8:
        settings.stream() << "VK_OBJECT_TYPE_DEVICE_MEMORY (";
        break;
    case 9:
        settings.stream() << "VK_OBJECT_TYPE_BUFFER (";
        break;
    case 10:
        settings.stream() << "VK_OBJECT_TYPE_IMAGE (";
        break;
    case 11:
        settings.stream() << "VK_OBJECT_TYPE_EVENT (";
        break;
    case 12:
        settings.stream() << "VK_OBJECT_TYPE_QUERY_POOL (";
        break;
    case 13:
        settings.stream() << "VK_OBJECT_TYPE_BUFFER_VIEW (";
        break;
    case 14:
        settings.stream() << "VK_OBJECT_TYPE_IMAGE_VIEW (";
        break;
    case 15:
        settings.stream() << "VK_OBJECT_TYPE_SHADER_MODULE (";
        break;
    case 16:
        settings.stream() << "VK_OBJECT_TYPE_PIPELINE_CACHE (";
        break;
    case 17:
        settings.stream() << "VK_OBJECT_TYPE_PIPELINE_LAYOUT (";
        break;
    case 18:
        settings.stream() << "VK_OBJECT_TYPE_RENDER_PASS (";
        break;
    case 19:
        settings.stream() << "VK_OBJECT_TYPE_PIPELINE (";
        break;
    case 20:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT (";
        break;
    case 21:
        settings.stream() << "VK_OBJECT_TYPE_SAMPLER (";
        break;
    case 22:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_POOL (";
        break;
    case 23:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_SET (";
        break;
    case 24:
        settings.stream() << "VK_OBJECT_TYPE_FRAMEBUFFER (";
        break;
    case 25:
        settings.stream() << "VK_OBJECT_TYPE_COMMAND_POOL (";
        break;
    case 1000156000:
        settings.stream() << "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION (";
        break;
    case 1000085000:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE (";
        break;
    case 1000295000:
        settings.stream() << "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT (";
        break;
    case 1000000000:
        settings.stream() << "VK_OBJECT_TYPE_SURFACE_KHR (";
        break;
    case 1000001000:
        settings.stream() << "VK_OBJECT_TYPE_SWAPCHAIN_KHR (";
        break;
    case 1000002000:
        settings.stream() << "VK_OBJECT_TYPE_DISPLAY_KHR (";
        break;
    case 1000002001:
        settings.stream() << "VK_OBJECT_TYPE_DISPLAY_MODE_KHR (";
        break;
    case 1000011000:
        settings.stream() << "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT (";
        break;
    case 1000023000:
        settings.stream() << "VK_OBJECT_TYPE_VIDEO_SESSION_KHR (";
        break;
    case 1000023001:
        settings.stream() << "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR (";
        break;
    case 1000029000:
        settings.stream() << "VK_OBJECT_TYPE_CU_MODULE_NVX (";
        break;
    case 1000029001:
        settings.stream() << "VK_OBJECT_TYPE_CU_FUNCTION_NVX (";
        break;
    case 1000128000:
        settings.stream() << "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT (";
        break;
    case 1000150000:
        settings.stream() << "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR (";
        break;
    case 1000160000:
        settings.stream() << "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT (";
        break;
    case 1000165000:
        settings.stream() << "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV (";
        break;
    case 1000210000:
        settings.stream() << "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL (";
        break;
    case 1000268000:
        settings.stream() << "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR (";
        break;
    case 1000277000:
        settings.stream() << "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV (";
        break;
    case 1000307000:
        settings.stream() << "VK_OBJECT_TYPE_CUDA_MODULE_NV (";
        break;
    case 1000307001:
        settings.stream() << "VK_OBJECT_TYPE_CUDA_FUNCTION_NV (";
        break;
    case 1000366000:
        settings.stream() << "VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA (";
        break;
    case 1000396000:
        settings.stream() << "VK_OBJECT_TYPE_MICROMAP_EXT (";
        break;
    case 1000464000:
        settings.stream() << "VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV (";
        break;
    case 1000482000:
        settings.stream() << "VK_OBJECT_TYPE_SHADER_EXT (";
        break;
    case 1000489000:
        settings.stream() << "VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkVendorId(VkVendorId object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0x10001:
        settings.stream() << "VK_VENDOR_ID_VIV (";
        break;
    case 0x10002:
        settings.stream() << "VK_VENDOR_ID_VSI (";
        break;
    case 0x10003:
        settings.stream() << "VK_VENDOR_ID_KAZAN (";
        break;
    case 0x10004:
        settings.stream() << "VK_VENDOR_ID_CODEPLAY (";
        break;
    case 0x10005:
        settings.stream() << "VK_VENDOR_ID_MESA (";
        break;
    case 0x10006:
        settings.stream() << "VK_VENDOR_ID_POCL (";
        break;
    case 0x10007:
        settings.stream() << "VK_VENDOR_ID_MOBILEYE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSystemAllocationScope(VkSystemAllocationScope object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND (";
        break;
    case 1:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT (";
        break;
    case 2:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_CACHE (";
        break;
    case 3:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE (";
        break;
    case 4:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkInternalAllocationType(VkInternalAllocationType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkFormat(VkFormat object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FORMAT_UNDEFINED (";
        break;
    case 1:
        settings.stream() << "VK_FORMAT_R4G4_UNORM_PACK8 (";
        break;
    case 2:
        settings.stream() << "VK_FORMAT_R4G4B4A4_UNORM_PACK16 (";
        break;
    case 3:
        settings.stream() << "VK_FORMAT_B4G4R4A4_UNORM_PACK16 (";
        break;
    case 4:
        settings.stream() << "VK_FORMAT_R5G6B5_UNORM_PACK16 (";
        break;
    case 5:
        settings.stream() << "VK_FORMAT_B5G6R5_UNORM_PACK16 (";
        break;
    case 6:
        settings.stream() << "VK_FORMAT_R5G5B5A1_UNORM_PACK16 (";
        break;
    case 7:
        settings.stream() << "VK_FORMAT_B5G5R5A1_UNORM_PACK16 (";
        break;
    case 8:
        settings.stream() << "VK_FORMAT_A1R5G5B5_UNORM_PACK16 (";
        break;
    case 9:
        settings.stream() << "VK_FORMAT_R8_UNORM (";
        break;
    case 10:
        settings.stream() << "VK_FORMAT_R8_SNORM (";
        break;
    case 11:
        settings.stream() << "VK_FORMAT_R8_USCALED (";
        break;
    case 12:
        settings.stream() << "VK_FORMAT_R8_SSCALED (";
        break;
    case 13:
        settings.stream() << "VK_FORMAT_R8_UINT (";
        break;
    case 14:
        settings.stream() << "VK_FORMAT_R8_SINT (";
        break;
    case 15:
        settings.stream() << "VK_FORMAT_R8_SRGB (";
        break;
    case 16:
        settings.stream() << "VK_FORMAT_R8G8_UNORM (";
        break;
    case 17:
        settings.stream() << "VK_FORMAT_R8G8_SNORM (";
        break;
    case 18:
        settings.stream() << "VK_FORMAT_R8G8_USCALED (";
        break;
    case 19:
        settings.stream() << "VK_FORMAT_R8G8_SSCALED (";
        break;
    case 20:
        settings.stream() << "VK_FORMAT_R8G8_UINT (";
        break;
    case 21:
        settings.stream() << "VK_FORMAT_R8G8_SINT (";
        break;
    case 22:
        settings.stream() << "VK_FORMAT_R8G8_SRGB (";
        break;
    case 23:
        settings.stream() << "VK_FORMAT_R8G8B8_UNORM (";
        break;
    case 24:
        settings.stream() << "VK_FORMAT_R8G8B8_SNORM (";
        break;
    case 25:
        settings.stream() << "VK_FORMAT_R8G8B8_USCALED (";
        break;
    case 26:
        settings.stream() << "VK_FORMAT_R8G8B8_SSCALED (";
        break;
    case 27:
        settings.stream() << "VK_FORMAT_R8G8B8_UINT (";
        break;
    case 28:
        settings.stream() << "VK_FORMAT_R8G8B8_SINT (";
        break;
    case 29:
        settings.stream() << "VK_FORMAT_R8G8B8_SRGB (";
        break;
    case 30:
        settings.stream() << "VK_FORMAT_B8G8R8_UNORM (";
        break;
    case 31:
        settings.stream() << "VK_FORMAT_B8G8R8_SNORM (";
        break;
    case 32:
        settings.stream() << "VK_FORMAT_B8G8R8_USCALED (";
        break;
    case 33:
        settings.stream() << "VK_FORMAT_B8G8R8_SSCALED (";
        break;
    case 34:
        settings.stream() << "VK_FORMAT_B8G8R8_UINT (";
        break;
    case 35:
        settings.stream() << "VK_FORMAT_B8G8R8_SINT (";
        break;
    case 36:
        settings.stream() << "VK_FORMAT_B8G8R8_SRGB (";
        break;
    case 37:
        settings.stream() << "VK_FORMAT_R8G8B8A8_UNORM (";
        break;
    case 38:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SNORM (";
        break;
    case 39:
        settings.stream() << "VK_FORMAT_R8G8B8A8_USCALED (";
        break;
    case 40:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SSCALED (";
        break;
    case 41:
        settings.stream() << "VK_FORMAT_R8G8B8A8_UINT (";
        break;
    case 42:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SINT (";
        break;
    case 43:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SRGB (";
        break;
    case 44:
        settings.stream() << "VK_FORMAT_B8G8R8A8_UNORM (";
        break;
    case 45:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SNORM (";
        break;
    case 46:
        settings.stream() << "VK_FORMAT_B8G8R8A8_USCALED (";
        break;
    case 47:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SSCALED (";
        break;
    case 48:
        settings.stream() << "VK_FORMAT_B8G8R8A8_UINT (";
        break;
    case 49:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SINT (";
        break;
    case 50:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SRGB (";
        break;
    case 51:
        settings.stream() << "VK_FORMAT_A8B8G8R8_UNORM_PACK32 (";
        break;
    case 52:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SNORM_PACK32 (";
        break;
    case 53:
        settings.stream() << "VK_FORMAT_A8B8G8R8_USCALED_PACK32 (";
        break;
    case 54:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SSCALED_PACK32 (";
        break;
    case 55:
        settings.stream() << "VK_FORMAT_A8B8G8R8_UINT_PACK32 (";
        break;
    case 56:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SINT_PACK32 (";
        break;
    case 57:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SRGB_PACK32 (";
        break;
    case 58:
        settings.stream() << "VK_FORMAT_A2R10G10B10_UNORM_PACK32 (";
        break;
    case 59:
        settings.stream() << "VK_FORMAT_A2R10G10B10_SNORM_PACK32 (";
        break;
    case 60:
        settings.stream() << "VK_FORMAT_A2R10G10B10_USCALED_PACK32 (";
        break;
    case 61:
        settings.stream() << "VK_FORMAT_A2R10G10B10_SSCALED_PACK32 (";
        break;
    case 62:
        settings.stream() << "VK_FORMAT_A2R10G10B10_UINT_PACK32 (";
        break;
    case 63:
        settings.stream() << "VK_FORMAT_A2R10G10B10_SINT_PACK32 (";
        break;
    case 64:
        settings.stream() << "VK_FORMAT_A2B10G10R10_UNORM_PACK32 (";
        break;
    case 65:
        settings.stream() << "VK_FORMAT_A2B10G10R10_SNORM_PACK32 (";
        break;
    case 66:
        settings.stream() << "VK_FORMAT_A2B10G10R10_USCALED_PACK32 (";
        break;
    case 67:
        settings.stream() << "VK_FORMAT_A2B10G10R10_SSCALED_PACK32 (";
        break;
    case 68:
        settings.stream() << "VK_FORMAT_A2B10G10R10_UINT_PACK32 (";
        break;
    case 69:
        settings.stream() << "VK_FORMAT_A2B10G10R10_SINT_PACK32 (";
        break;
    case 70:
        settings.stream() << "VK_FORMAT_R16_UNORM (";
        break;
    case 71:
        settings.stream() << "VK_FORMAT_R16_SNORM (";
        break;
    case 72:
        settings.stream() << "VK_FORMAT_R16_USCALED (";
        break;
    case 73:
        settings.stream() << "VK_FORMAT_R16_SSCALED (";
        break;
    case 74:
        settings.stream() << "VK_FORMAT_R16_UINT (";
        break;
    case 75:
        settings.stream() << "VK_FORMAT_R16_SINT (";
        break;
    case 76:
        settings.stream() << "VK_FORMAT_R16_SFLOAT (";
        break;
    case 77:
        settings.stream() << "VK_FORMAT_R16G16_UNORM (";
        break;
    case 78:
        settings.stream() << "VK_FORMAT_R16G16_SNORM (";
        break;
    case 79:
        settings.stream() << "VK_FORMAT_R16G16_USCALED (";
        break;
    case 80:
        settings.stream() << "VK_FORMAT_R16G16_SSCALED (";
        break;
    case 81:
        settings.stream() << "VK_FORMAT_R16G16_UINT (";
        break;
    case 82:
        settings.stream() << "VK_FORMAT_R16G16_SINT (";
        break;
    case 83:
        settings.stream() << "VK_FORMAT_R16G16_SFLOAT (";
        break;
    case 84:
        settings.stream() << "VK_FORMAT_R16G16B16_UNORM (";
        break;
    case 85:
        settings.stream() << "VK_FORMAT_R16G16B16_SNORM (";
        break;
    case 86:
        settings.stream() << "VK_FORMAT_R16G16B16_USCALED (";
        break;
    case 87:
        settings.stream() << "VK_FORMAT_R16G16B16_SSCALED (";
        break;
    case 88:
        settings.stream() << "VK_FORMAT_R16G16B16_UINT (";
        break;
    case 89:
        settings.stream() << "VK_FORMAT_R16G16B16_SINT (";
        break;
    case 90:
        settings.stream() << "VK_FORMAT_R16G16B16_SFLOAT (";
        break;
    case 91:
        settings.stream() << "VK_FORMAT_R16G16B16A16_UNORM (";
        break;
    case 92:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SNORM (";
        break;
    case 93:
        settings.stream() << "VK_FORMAT_R16G16B16A16_USCALED (";
        break;
    case 94:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SSCALED (";
        break;
    case 95:
        settings.stream() << "VK_FORMAT_R16G16B16A16_UINT (";
        break;
    case 96:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SINT (";
        break;
    case 97:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SFLOAT (";
        break;
    case 98:
        settings.stream() << "VK_FORMAT_R32_UINT (";
        break;
    case 99:
        settings.stream() << "VK_FORMAT_R32_SINT (";
        break;
    case 100:
        settings.stream() << "VK_FORMAT_R32_SFLOAT (";
        break;
    case 101:
        settings.stream() << "VK_FORMAT_R32G32_UINT (";
        break;
    case 102:
        settings.stream() << "VK_FORMAT_R32G32_SINT (";
        break;
    case 103:
        settings.stream() << "VK_FORMAT_R32G32_SFLOAT (";
        break;
    case 104:
        settings.stream() << "VK_FORMAT_R32G32B32_UINT (";
        break;
    case 105:
        settings.stream() << "VK_FORMAT_R32G32B32_SINT (";
        break;
    case 106:
        settings.stream() << "VK_FORMAT_R32G32B32_SFLOAT (";
        break;
    case 107:
        settings.stream() << "VK_FORMAT_R32G32B32A32_UINT (";
        break;
    case 108:
        settings.stream() << "VK_FORMAT_R32G32B32A32_SINT (";
        break;
    case 109:
        settings.stream() << "VK_FORMAT_R32G32B32A32_SFLOAT (";
        break;
    case 110:
        settings.stream() << "VK_FORMAT_R64_UINT (";
        break;
    case 111:
        settings.stream() << "VK_FORMAT_R64_SINT (";
        break;
    case 112:
        settings.stream() << "VK_FORMAT_R64_SFLOAT (";
        break;
    case 113:
        settings.stream() << "VK_FORMAT_R64G64_UINT (";
        break;
    case 114:
        settings.stream() << "VK_FORMAT_R64G64_SINT (";
        break;
    case 115:
        settings.stream() << "VK_FORMAT_R64G64_SFLOAT (";
        break;
    case 116:
        settings.stream() << "VK_FORMAT_R64G64B64_UINT (";
        break;
    case 117:
        settings.stream() << "VK_FORMAT_R64G64B64_SINT (";
        break;
    case 118:
        settings.stream() << "VK_FORMAT_R64G64B64_SFLOAT (";
        break;
    case 119:
        settings.stream() << "VK_FORMAT_R64G64B64A64_UINT (";
        break;
    case 120:
        settings.stream() << "VK_FORMAT_R64G64B64A64_SINT (";
        break;
    case 121:
        settings.stream() << "VK_FORMAT_R64G64B64A64_SFLOAT (";
        break;
    case 122:
        settings.stream() << "VK_FORMAT_B10G11R11_UFLOAT_PACK32 (";
        break;
    case 123:
        settings.stream() << "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 (";
        break;
    case 124:
        settings.stream() << "VK_FORMAT_D16_UNORM (";
        break;
    case 125:
        settings.stream() << "VK_FORMAT_X8_D24_UNORM_PACK32 (";
        break;
    case 126:
        settings.stream() << "VK_FORMAT_D32_SFLOAT (";
        break;
    case 127:
        settings.stream() << "VK_FORMAT_S8_UINT (";
        break;
    case 128:
        settings.stream() << "VK_FORMAT_D16_UNORM_S8_UINT (";
        break;
    case 129:
        settings.stream() << "VK_FORMAT_D24_UNORM_S8_UINT (";
        break;
    case 130:
        settings.stream() << "VK_FORMAT_D32_SFLOAT_S8_UINT (";
        break;
    case 131:
        settings.stream() << "VK_FORMAT_BC1_RGB_UNORM_BLOCK (";
        break;
    case 132:
        settings.stream() << "VK_FORMAT_BC1_RGB_SRGB_BLOCK (";
        break;
    case 133:
        settings.stream() << "VK_FORMAT_BC1_RGBA_UNORM_BLOCK (";
        break;
    case 134:
        settings.stream() << "VK_FORMAT_BC1_RGBA_SRGB_BLOCK (";
        break;
    case 135:
        settings.stream() << "VK_FORMAT_BC2_UNORM_BLOCK (";
        break;
    case 136:
        settings.stream() << "VK_FORMAT_BC2_SRGB_BLOCK (";
        break;
    case 137:
        settings.stream() << "VK_FORMAT_BC3_UNORM_BLOCK (";
        break;
    case 138:
        settings.stream() << "VK_FORMAT_BC3_SRGB_BLOCK (";
        break;
    case 139:
        settings.stream() << "VK_FORMAT_BC4_UNORM_BLOCK (";
        break;
    case 140:
        settings.stream() << "VK_FORMAT_BC4_SNORM_BLOCK (";
        break;
    case 141:
        settings.stream() << "VK_FORMAT_BC5_UNORM_BLOCK (";
        break;
    case 142:
        settings.stream() << "VK_FORMAT_BC5_SNORM_BLOCK (";
        break;
    case 143:
        settings.stream() << "VK_FORMAT_BC6H_UFLOAT_BLOCK (";
        break;
    case 144:
        settings.stream() << "VK_FORMAT_BC6H_SFLOAT_BLOCK (";
        break;
    case 145:
        settings.stream() << "VK_FORMAT_BC7_UNORM_BLOCK (";
        break;
    case 146:
        settings.stream() << "VK_FORMAT_BC7_SRGB_BLOCK (";
        break;
    case 147:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK (";
        break;
    case 148:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK (";
        break;
    case 149:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK (";
        break;
    case 150:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK (";
        break;
    case 151:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK (";
        break;
    case 152:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK (";
        break;
    case 153:
        settings.stream() << "VK_FORMAT_EAC_R11_UNORM_BLOCK (";
        break;
    case 154:
        settings.stream() << "VK_FORMAT_EAC_R11_SNORM_BLOCK (";
        break;
    case 155:
        settings.stream() << "VK_FORMAT_EAC_R11G11_UNORM_BLOCK (";
        break;
    case 156:
        settings.stream() << "VK_FORMAT_EAC_R11G11_SNORM_BLOCK (";
        break;
    case 157:
        settings.stream() << "VK_FORMAT_ASTC_4x4_UNORM_BLOCK (";
        break;
    case 158:
        settings.stream() << "VK_FORMAT_ASTC_4x4_SRGB_BLOCK (";
        break;
    case 159:
        settings.stream() << "VK_FORMAT_ASTC_5x4_UNORM_BLOCK (";
        break;
    case 160:
        settings.stream() << "VK_FORMAT_ASTC_5x4_SRGB_BLOCK (";
        break;
    case 161:
        settings.stream() << "VK_FORMAT_ASTC_5x5_UNORM_BLOCK (";
        break;
    case 162:
        settings.stream() << "VK_FORMAT_ASTC_5x5_SRGB_BLOCK (";
        break;
    case 163:
        settings.stream() << "VK_FORMAT_ASTC_6x5_UNORM_BLOCK (";
        break;
    case 164:
        settings.stream() << "VK_FORMAT_ASTC_6x5_SRGB_BLOCK (";
        break;
    case 165:
        settings.stream() << "VK_FORMAT_ASTC_6x6_UNORM_BLOCK (";
        break;
    case 166:
        settings.stream() << "VK_FORMAT_ASTC_6x6_SRGB_BLOCK (";
        break;
    case 167:
        settings.stream() << "VK_FORMAT_ASTC_8x5_UNORM_BLOCK (";
        break;
    case 168:
        settings.stream() << "VK_FORMAT_ASTC_8x5_SRGB_BLOCK (";
        break;
    case 169:
        settings.stream() << "VK_FORMAT_ASTC_8x6_UNORM_BLOCK (";
        break;
    case 170:
        settings.stream() << "VK_FORMAT_ASTC_8x6_SRGB_BLOCK (";
        break;
    case 171:
        settings.stream() << "VK_FORMAT_ASTC_8x8_UNORM_BLOCK (";
        break;
    case 172:
        settings.stream() << "VK_FORMAT_ASTC_8x8_SRGB_BLOCK (";
        break;
    case 173:
        settings.stream() << "VK_FORMAT_ASTC_10x5_UNORM_BLOCK (";
        break;
    case 174:
        settings.stream() << "VK_FORMAT_ASTC_10x5_SRGB_BLOCK (";
        break;
    case 175:
        settings.stream() << "VK_FORMAT_ASTC_10x6_UNORM_BLOCK (";
        break;
    case 176:
        settings.stream() << "VK_FORMAT_ASTC_10x6_SRGB_BLOCK (";
        break;
    case 177:
        settings.stream() << "VK_FORMAT_ASTC_10x8_UNORM_BLOCK (";
        break;
    case 178:
        settings.stream() << "VK_FORMAT_ASTC_10x8_SRGB_BLOCK (";
        break;
    case 179:
        settings.stream() << "VK_FORMAT_ASTC_10x10_UNORM_BLOCK (";
        break;
    case 180:
        settings.stream() << "VK_FORMAT_ASTC_10x10_SRGB_BLOCK (";
        break;
    case 181:
        settings.stream() << "VK_FORMAT_ASTC_12x10_UNORM_BLOCK (";
        break;
    case 182:
        settings.stream() << "VK_FORMAT_ASTC_12x10_SRGB_BLOCK (";
        break;
    case 183:
        settings.stream() << "VK_FORMAT_ASTC_12x12_UNORM_BLOCK (";
        break;
    case 184:
        settings.stream() << "VK_FORMAT_ASTC_12x12_SRGB_BLOCK (";
        break;
    case 1000156000:
        settings.stream() << "VK_FORMAT_G8B8G8R8_422_UNORM (";
        break;
    case 1000156001:
        settings.stream() << "VK_FORMAT_B8G8R8G8_422_UNORM (";
        break;
    case 1000156002:
        settings.stream() << "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM (";
        break;
    case 1000156003:
        settings.stream() << "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM (";
        break;
    case 1000156004:
        settings.stream() << "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM (";
        break;
    case 1000156005:
        settings.stream() << "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM (";
        break;
    case 1000156006:
        settings.stream() << "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM (";
        break;
    case 1000156007:
        settings.stream() << "VK_FORMAT_R10X6_UNORM_PACK16 (";
        break;
    case 1000156008:
        settings.stream() << "VK_FORMAT_R10X6G10X6_UNORM_2PACK16 (";
        break;
    case 1000156009:
        settings.stream() << "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 (";
        break;
    case 1000156010:
        settings.stream() << "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 (";
        break;
    case 1000156011:
        settings.stream() << "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 (";
        break;
    case 1000156012:
        settings.stream() << "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156013:
        settings.stream() << "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156014:
        settings.stream() << "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156015:
        settings.stream() << "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156016:
        settings.stream() << "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 (";
        break;
    case 1000156017:
        settings.stream() << "VK_FORMAT_R12X4_UNORM_PACK16 (";
        break;
    case 1000156018:
        settings.stream() << "VK_FORMAT_R12X4G12X4_UNORM_2PACK16 (";
        break;
    case 1000156019:
        settings.stream() << "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 (";
        break;
    case 1000156020:
        settings.stream() << "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 (";
        break;
    case 1000156021:
        settings.stream() << "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 (";
        break;
    case 1000156022:
        settings.stream() << "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156023:
        settings.stream() << "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156024:
        settings.stream() << "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156025:
        settings.stream() << "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156026:
        settings.stream() << "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 (";
        break;
    case 1000156027:
        settings.stream() << "VK_FORMAT_G16B16G16R16_422_UNORM (";
        break;
    case 1000156028:
        settings.stream() << "VK_FORMAT_B16G16R16G16_422_UNORM (";
        break;
    case 1000156029:
        settings.stream() << "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM (";
        break;
    case 1000156030:
        settings.stream() << "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM (";
        break;
    case 1000156031:
        settings.stream() << "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM (";
        break;
    case 1000156032:
        settings.stream() << "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM (";
        break;
    case 1000156033:
        settings.stream() << "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM (";
        break;
    case 1000330000:
        settings.stream() << "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM (";
        break;
    case 1000330001:
        settings.stream() << "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 (";
        break;
    case 1000330002:
        settings.stream() << "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 (";
        break;
    case 1000330003:
        settings.stream() << "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM (";
        break;
    case 1000340000:
        settings.stream() << "VK_FORMAT_A4R4G4B4_UNORM_PACK16 (";
        break;
    case 1000340001:
        settings.stream() << "VK_FORMAT_A4B4G4R4_UNORM_PACK16 (";
        break;
    case 1000066000:
        settings.stream() << "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK (";
        break;
    case 1000066001:
        settings.stream() << "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK (";
        break;
    case 1000066002:
        settings.stream() << "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK (";
        break;
    case 1000066003:
        settings.stream() << "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK (";
        break;
    case 1000066004:
        settings.stream() << "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK (";
        break;
    case 1000066005:
        settings.stream() << "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK (";
        break;
    case 1000066006:
        settings.stream() << "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK (";
        break;
    case 1000066007:
        settings.stream() << "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK (";
        break;
    case 1000066008:
        settings.stream() << "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK (";
        break;
    case 1000066009:
        settings.stream() << "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK (";
        break;
    case 1000066010:
        settings.stream() << "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK (";
        break;
    case 1000066011:
        settings.stream() << "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK (";
        break;
    case 1000066012:
        settings.stream() << "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK (";
        break;
    case 1000066013:
        settings.stream() << "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK (";
        break;
    case 1000054000:
        settings.stream() << "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054001:
        settings.stream() << "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054002:
        settings.stream() << "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054003:
        settings.stream() << "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054004:
        settings.stream() << "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000054005:
        settings.stream() << "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000054006:
        settings.stream() << "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000054007:
        settings.stream() << "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000288000:
        settings.stream() << "VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT (";
        break;
    case 1000288001:
        settings.stream() << "VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT (";
        break;
    case 1000288002:
        settings.stream() << "VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288003:
        settings.stream() << "VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT (";
        break;
    case 1000288004:
        settings.stream() << "VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT (";
        break;
    case 1000288005:
        settings.stream() << "VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288006:
        settings.stream() << "VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT (";
        break;
    case 1000288007:
        settings.stream() << "VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT (";
        break;
    case 1000288008:
        settings.stream() << "VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288009:
        settings.stream() << "VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT (";
        break;
    case 1000288010:
        settings.stream() << "VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT (";
        break;
    case 1000288011:
        settings.stream() << "VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288012:
        settings.stream() << "VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT (";
        break;
    case 1000288013:
        settings.stream() << "VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT (";
        break;
    case 1000288014:
        settings.stream() << "VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288015:
        settings.stream() << "VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT (";
        break;
    case 1000288016:
        settings.stream() << "VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT (";
        break;
    case 1000288017:
        settings.stream() << "VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288018:
        settings.stream() << "VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT (";
        break;
    case 1000288019:
        settings.stream() << "VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT (";
        break;
    case 1000288020:
        settings.stream() << "VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288021:
        settings.stream() << "VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT (";
        break;
    case 1000288022:
        settings.stream() << "VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT (";
        break;
    case 1000288023:
        settings.stream() << "VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288024:
        settings.stream() << "VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT (";
        break;
    case 1000288025:
        settings.stream() << "VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT (";
        break;
    case 1000288026:
        settings.stream() << "VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000288027:
        settings.stream() << "VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT (";
        break;
    case 1000288028:
        settings.stream() << "VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT (";
        break;
    case 1000288029:
        settings.stream() << "VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT (";
        break;
    case 1000464000:
        settings.stream() << "VK_FORMAT_R16G16_SFIXED5_NV (";
        break;
    case 1000470000:
        settings.stream() << "VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR (";
        break;
    case 1000470001:
        settings.stream() << "VK_FORMAT_A8_UNORM_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkImageTiling(VkImageTiling object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_TILING_OPTIMAL (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_TILING_LINEAR (";
        break;
    case 1000158000:
        settings.stream() << "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkImageType(VkImageType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_TYPE_1D (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_TYPE_2D (";
        break;
    case 2:
        settings.stream() << "VK_IMAGE_TYPE_3D (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPhysicalDeviceType(VkPhysicalDeviceType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_OTHER (";
        break;
    case 1:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (";
        break;
    case 2:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU (";
        break;
    case 3:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU (";
        break;
    case 4:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_CPU (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkQueryType(VkQueryType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_QUERY_TYPE_OCCLUSION (";
        break;
    case 1:
        settings.stream() << "VK_QUERY_TYPE_PIPELINE_STATISTICS (";
        break;
    case 2:
        settings.stream() << "VK_QUERY_TYPE_TIMESTAMP (";
        break;
    case 1000023000:
        settings.stream() << "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR (";
        break;
    case 1000028004:
        settings.stream() << "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT (";
        break;
    case 1000116000:
        settings.stream() << "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR (";
        break;
    case 1000150000:
        settings.stream() << "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR (";
        break;
    case 1000150001:
        settings.stream() << "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR (";
        break;
    case 1000165000:
        settings.stream() << "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV (";
        break;
    case 1000210000:
        settings.stream() << "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL (";
        break;
    case 1000299000:
        settings.stream() << "VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR (";
        break;
    case 1000328000:
        settings.stream() << "VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT (";
        break;
    case 1000382000:
        settings.stream() << "VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT (";
        break;
    case 1000386000:
        settings.stream() << "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR (";
        break;
    case 1000386001:
        settings.stream() << "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR (";
        break;
    case 1000396000:
        settings.stream() << "VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT (";
        break;
    case 1000396001:
        settings.stream() << "VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSharingMode(VkSharingMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHARING_MODE_EXCLUSIVE (";
        break;
    case 1:
        settings.stream() << "VK_SHARING_MODE_CONCURRENT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkComponentSwizzle(VkComponentSwizzle object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMPONENT_SWIZZLE_IDENTITY (";
        break;
    case 1:
        settings.stream() << "VK_COMPONENT_SWIZZLE_ZERO (";
        break;
    case 2:
        settings.stream() << "VK_COMPONENT_SWIZZLE_ONE (";
        break;
    case 3:
        settings.stream() << "VK_COMPONENT_SWIZZLE_R (";
        break;
    case 4:
        settings.stream() << "VK_COMPONENT_SWIZZLE_G (";
        break;
    case 5:
        settings.stream() << "VK_COMPONENT_SWIZZLE_B (";
        break;
    case 6:
        settings.stream() << "VK_COMPONENT_SWIZZLE_A (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkImageViewType(VkImageViewType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_1D (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_2D (";
        break;
    case 2:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_3D (";
        break;
    case 3:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_CUBE (";
        break;
    case 4:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_1D_ARRAY (";
        break;
    case 5:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_2D_ARRAY (";
        break;
    case 6:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBlendFactor(VkBlendFactor object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLEND_FACTOR_ZERO (";
        break;
    case 1:
        settings.stream() << "VK_BLEND_FACTOR_ONE (";
        break;
    case 2:
        settings.stream() << "VK_BLEND_FACTOR_SRC_COLOR (";
        break;
    case 3:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR (";
        break;
    case 4:
        settings.stream() << "VK_BLEND_FACTOR_DST_COLOR (";
        break;
    case 5:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR (";
        break;
    case 6:
        settings.stream() << "VK_BLEND_FACTOR_SRC_ALPHA (";
        break;
    case 7:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA (";
        break;
    case 8:
        settings.stream() << "VK_BLEND_FACTOR_DST_ALPHA (";
        break;
    case 9:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA (";
        break;
    case 10:
        settings.stream() << "VK_BLEND_FACTOR_CONSTANT_COLOR (";
        break;
    case 11:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR (";
        break;
    case 12:
        settings.stream() << "VK_BLEND_FACTOR_CONSTANT_ALPHA (";
        break;
    case 13:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA (";
        break;
    case 14:
        settings.stream() << "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE (";
        break;
    case 15:
        settings.stream() << "VK_BLEND_FACTOR_SRC1_COLOR (";
        break;
    case 16:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR (";
        break;
    case 17:
        settings.stream() << "VK_BLEND_FACTOR_SRC1_ALPHA (";
        break;
    case 18:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBlendOp(VkBlendOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLEND_OP_ADD (";
        break;
    case 1:
        settings.stream() << "VK_BLEND_OP_SUBTRACT (";
        break;
    case 2:
        settings.stream() << "VK_BLEND_OP_REVERSE_SUBTRACT (";
        break;
    case 3:
        settings.stream() << "VK_BLEND_OP_MIN (";
        break;
    case 4:
        settings.stream() << "VK_BLEND_OP_MAX (";
        break;
    case 1000148000:
        settings.stream() << "VK_BLEND_OP_ZERO_EXT (";
        break;
    case 1000148001:
        settings.stream() << "VK_BLEND_OP_SRC_EXT (";
        break;
    case 1000148002:
        settings.stream() << "VK_BLEND_OP_DST_EXT (";
        break;
    case 1000148003:
        settings.stream() << "VK_BLEND_OP_SRC_OVER_EXT (";
        break;
    case 1000148004:
        settings.stream() << "VK_BLEND_OP_DST_OVER_EXT (";
        break;
    case 1000148005:
        settings.stream() << "VK_BLEND_OP_SRC_IN_EXT (";
        break;
    case 1000148006:
        settings.stream() << "VK_BLEND_OP_DST_IN_EXT (";
        break;
    case 1000148007:
        settings.stream() << "VK_BLEND_OP_SRC_OUT_EXT (";
        break;
    case 1000148008:
        settings.stream() << "VK_BLEND_OP_DST_OUT_EXT (";
        break;
    case 1000148009:
        settings.stream() << "VK_BLEND_OP_SRC_ATOP_EXT (";
        break;
    case 1000148010:
        settings.stream() << "VK_BLEND_OP_DST_ATOP_EXT (";
        break;
    case 1000148011:
        settings.stream() << "VK_BLEND_OP_XOR_EXT (";
        break;
    case 1000148012:
        settings.stream() << "VK_BLEND_OP_MULTIPLY_EXT (";
        break;
    case 1000148013:
        settings.stream() << "VK_BLEND_OP_SCREEN_EXT (";
        break;
    case 1000148014:
        settings.stream() << "VK_BLEND_OP_OVERLAY_EXT (";
        break;
    case 1000148015:
        settings.stream() << "VK_BLEND_OP_DARKEN_EXT (";
        break;
    case 1000148016:
        settings.stream() << "VK_BLEND_OP_LIGHTEN_EXT (";
        break;
    case 1000148017:
        settings.stream() << "VK_BLEND_OP_COLORDODGE_EXT (";
        break;
    case 1000148018:
        settings.stream() << "VK_BLEND_OP_COLORBURN_EXT (";
        break;
    case 1000148019:
        settings.stream() << "VK_BLEND_OP_HARDLIGHT_EXT (";
        break;
    case 1000148020:
        settings.stream() << "VK_BLEND_OP_SOFTLIGHT_EXT (";
        break;
    case 1000148021:
        settings.stream() << "VK_BLEND_OP_DIFFERENCE_EXT (";
        break;
    case 1000148022:
        settings.stream() << "VK_BLEND_OP_EXCLUSION_EXT (";
        break;
    case 1000148023:
        settings.stream() << "VK_BLEND_OP_INVERT_EXT (";
        break;
    case 1000148024:
        settings.stream() << "VK_BLEND_OP_INVERT_RGB_EXT (";
        break;
    case 1000148025:
        settings.stream() << "VK_BLEND_OP_LINEARDODGE_EXT (";
        break;
    case 1000148026:
        settings.stream() << "VK_BLEND_OP_LINEARBURN_EXT (";
        break;
    case 1000148027:
        settings.stream() << "VK_BLEND_OP_VIVIDLIGHT_EXT (";
        break;
    case 1000148028:
        settings.stream() << "VK_BLEND_OP_LINEARLIGHT_EXT (";
        break;
    case 1000148029:
        settings.stream() << "VK_BLEND_OP_PINLIGHT_EXT (";
        break;
    case 1000148030:
        settings.stream() << "VK_BLEND_OP_HARDMIX_EXT (";
        break;
    case 1000148031:
        settings.stream() << "VK_BLEND_OP_HSL_HUE_EXT (";
        break;
    case 1000148032:
        settings.stream() << "VK_BLEND_OP_HSL_SATURATION_EXT (";
        break;
    case 1000148033:
        settings.stream() << "VK_BLEND_OP_HSL_COLOR_EXT (";
        break;
    case 1000148034:
        settings.stream() << "VK_BLEND_OP_HSL_LUMINOSITY_EXT (";
        break;
    case 1000148035:
        settings.stream() << "VK_BLEND_OP_PLUS_EXT (";
        break;
    case 1000148036:
        settings.stream() << "VK_BLEND_OP_PLUS_CLAMPED_EXT (";
        break;
    case 1000148037:
        settings.stream() << "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT (";
        break;
    case 1000148038:
        settings.stream() << "VK_BLEND_OP_PLUS_DARKER_EXT (";
        break;
    case 1000148039:
        settings.stream() << "VK_BLEND_OP_MINUS_EXT (";
        break;
    case 1000148040:
        settings.stream() << "VK_BLEND_OP_MINUS_CLAMPED_EXT (";
        break;
    case 1000148041:
        settings.stream() << "VK_BLEND_OP_CONTRAST_EXT (";
        break;
    case 1000148042:
        settings.stream() << "VK_BLEND_OP_INVERT_OVG_EXT (";
        break;
    case 1000148043:
        settings.stream() << "VK_BLEND_OP_RED_EXT (";
        break;
    case 1000148044:
        settings.stream() << "VK_BLEND_OP_GREEN_EXT (";
        break;
    case 1000148045:
        settings.stream() << "VK_BLEND_OP_BLUE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCompareOp(VkCompareOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMPARE_OP_NEVER (";
        break;
    case 1:
        settings.stream() << "VK_COMPARE_OP_LESS (";
        break;
    case 2:
        settings.stream() << "VK_COMPARE_OP_EQUAL (";
        break;
    case 3:
        settings.stream() << "VK_COMPARE_OP_LESS_OR_EQUAL (";
        break;
    case 4:
        settings.stream() << "VK_COMPARE_OP_GREATER (";
        break;
    case 5:
        settings.stream() << "VK_COMPARE_OP_NOT_EQUAL (";
        break;
    case 6:
        settings.stream() << "VK_COMPARE_OP_GREATER_OR_EQUAL (";
        break;
    case 7:
        settings.stream() << "VK_COMPARE_OP_ALWAYS (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDynamicState(VkDynamicState object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT (";
        break;
    case 1:
        settings.stream() << "VK_DYNAMIC_STATE_SCISSOR (";
        break;
    case 2:
        settings.stream() << "VK_DYNAMIC_STATE_LINE_WIDTH (";
        break;
    case 3:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_BIAS (";
        break;
    case 4:
        settings.stream() << "VK_DYNAMIC_STATE_BLEND_CONSTANTS (";
        break;
    case 5:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_BOUNDS (";
        break;
    case 6:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK (";
        break;
    case 7:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK (";
        break;
    case 8:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_REFERENCE (";
        break;
    case 1000267000:
        settings.stream() << "VK_DYNAMIC_STATE_CULL_MODE (";
        break;
    case 1000267001:
        settings.stream() << "VK_DYNAMIC_STATE_FRONT_FACE (";
        break;
    case 1000267002:
        settings.stream() << "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY (";
        break;
    case 1000267003:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT (";
        break;
    case 1000267004:
        settings.stream() << "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT (";
        break;
    case 1000267005:
        settings.stream() << "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE (";
        break;
    case 1000267006:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE (";
        break;
    case 1000267007:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE (";
        break;
    case 1000267008:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP (";
        break;
    case 1000267009:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE (";
        break;
    case 1000267010:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE (";
        break;
    case 1000267011:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_OP (";
        break;
    case 1000377001:
        settings.stream() << "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE (";
        break;
    case 1000377002:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE (";
        break;
    case 1000377004:
        settings.stream() << "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE (";
        break;
    case 1000087000:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV (";
        break;
    case 1000099000:
        settings.stream() << "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT (";
        break;
    case 1000099001:
        settings.stream() << "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT (";
        break;
    case 1000099002:
        settings.stream() << "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT (";
        break;
    case 1000143000:
        settings.stream() << "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT (";
        break;
    case 1000347000:
        settings.stream() << "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR (";
        break;
    case 1000164004:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV (";
        break;
    case 1000164006:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV (";
        break;
    case 1000205000:
        settings.stream() << "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV (";
        break;
    case 1000205001:
        settings.stream() << "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV (";
        break;
    case 1000226000:
        settings.stream() << "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR (";
        break;
    case 1000352000:
        settings.stream() << "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT (";
        break;
    case 1000377000:
        settings.stream() << "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT (";
        break;
    case 1000377003:
        settings.stream() << "VK_DYNAMIC_STATE_LOGIC_OP_EXT (";
        break;
    case 1000381000:
        settings.stream() << "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT (";
        break;
    case 1000455003:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT (";
        break;
    case 1000455004:
        settings.stream() << "VK_DYNAMIC_STATE_POLYGON_MODE_EXT (";
        break;
    case 1000455005:
        settings.stream() << "VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT (";
        break;
    case 1000455006:
        settings.stream() << "VK_DYNAMIC_STATE_SAMPLE_MASK_EXT (";
        break;
    case 1000455007:
        settings.stream() << "VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT (";
        break;
    case 1000455008:
        settings.stream() << "VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT (";
        break;
    case 1000455009:
        settings.stream() << "VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT (";
        break;
    case 1000455010:
        settings.stream() << "VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT (";
        break;
    case 1000455011:
        settings.stream() << "VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT (";
        break;
    case 1000455012:
        settings.stream() << "VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT (";
        break;
    case 1000455002:
        settings.stream() << "VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT (";
        break;
    case 1000455013:
        settings.stream() << "VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT (";
        break;
    case 1000455014:
        settings.stream() << "VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT (";
        break;
    case 1000455015:
        settings.stream() << "VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT (";
        break;
    case 1000455016:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT (";
        break;
    case 1000455017:
        settings.stream() << "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT (";
        break;
    case 1000455018:
        settings.stream() << "VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT (";
        break;
    case 1000455019:
        settings.stream() << "VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT (";
        break;
    case 1000455020:
        settings.stream() << "VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT (";
        break;
    case 1000455021:
        settings.stream() << "VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT (";
        break;
    case 1000455022:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT (";
        break;
    case 1000455023:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV (";
        break;
    case 1000455024:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV (";
        break;
    case 1000455025:
        settings.stream() << "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV (";
        break;
    case 1000455026:
        settings.stream() << "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV (";
        break;
    case 1000455027:
        settings.stream() << "VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV (";
        break;
    case 1000455028:
        settings.stream() << "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV (";
        break;
    case 1000455029:
        settings.stream() << "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV (";
        break;
    case 1000455030:
        settings.stream() << "VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV (";
        break;
    case 1000455031:
        settings.stream() << "VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV (";
        break;
    case 1000455032:
        settings.stream() << "VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV (";
        break;
    case 1000524000:
        settings.stream() << "VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT (";
        break;
    case 1000259000:
        settings.stream() << "VK_DYNAMIC_STATE_LINE_STIPPLE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkFrontFace(VkFrontFace object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FRONT_FACE_COUNTER_CLOCKWISE (";
        break;
    case 1:
        settings.stream() << "VK_FRONT_FACE_CLOCKWISE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkVertexInputRate(VkVertexInputRate object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VERTEX_INPUT_RATE_VERTEX (";
        break;
    case 1:
        settings.stream() << "VK_VERTEX_INPUT_RATE_INSTANCE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPrimitiveTopology(VkPrimitiveTopology object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_POINT_LIST (";
        break;
    case 1:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_LIST (";
        break;
    case 2:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP (";
        break;
    case 3:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST (";
        break;
    case 4:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP (";
        break;
    case 5:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN (";
        break;
    case 6:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY (";
        break;
    case 7:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY (";
        break;
    case 8:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY (";
        break;
    case 9:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY (";
        break;
    case 10:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPolygonMode(VkPolygonMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_POLYGON_MODE_FILL (";
        break;
    case 1:
        settings.stream() << "VK_POLYGON_MODE_LINE (";
        break;
    case 2:
        settings.stream() << "VK_POLYGON_MODE_POINT (";
        break;
    case 1000153000:
        settings.stream() << "VK_POLYGON_MODE_FILL_RECTANGLE_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkStencilOp(VkStencilOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_STENCIL_OP_KEEP (";
        break;
    case 1:
        settings.stream() << "VK_STENCIL_OP_ZERO (";
        break;
    case 2:
        settings.stream() << "VK_STENCIL_OP_REPLACE (";
        break;
    case 3:
        settings.stream() << "VK_STENCIL_OP_INCREMENT_AND_CLAMP (";
        break;
    case 4:
        settings.stream() << "VK_STENCIL_OP_DECREMENT_AND_CLAMP (";
        break;
    case 5:
        settings.stream() << "VK_STENCIL_OP_INVERT (";
        break;
    case 6:
        settings.stream() << "VK_STENCIL_OP_INCREMENT_AND_WRAP (";
        break;
    case 7:
        settings.stream() << "VK_STENCIL_OP_DECREMENT_AND_WRAP (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkLogicOp(VkLogicOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LOGIC_OP_CLEAR (";
        break;
    case 1:
        settings.stream() << "VK_LOGIC_OP_AND (";
        break;
    case 2:
        settings.stream() << "VK_LOGIC_OP_AND_REVERSE (";
        break;
    case 3:
        settings.stream() << "VK_LOGIC_OP_COPY (";
        break;
    case 4:
        settings.stream() << "VK_LOGIC_OP_AND_INVERTED (";
        break;
    case 5:
        settings.stream() << "VK_LOGIC_OP_NO_OP (";
        break;
    case 6:
        settings.stream() << "VK_LOGIC_OP_XOR (";
        break;
    case 7:
        settings.stream() << "VK_LOGIC_OP_OR (";
        break;
    case 8:
        settings.stream() << "VK_LOGIC_OP_NOR (";
        break;
    case 9:
        settings.stream() << "VK_LOGIC_OP_EQUIVALENT (";
        break;
    case 10:
        settings.stream() << "VK_LOGIC_OP_INVERT (";
        break;
    case 11:
        settings.stream() << "VK_LOGIC_OP_OR_REVERSE (";
        break;
    case 12:
        settings.stream() << "VK_LOGIC_OP_COPY_INVERTED (";
        break;
    case 13:
        settings.stream() << "VK_LOGIC_OP_OR_INVERTED (";
        break;
    case 14:
        settings.stream() << "VK_LOGIC_OP_NAND (";
        break;
    case 15:
        settings.stream() << "VK_LOGIC_OP_SET (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBorderColor(VkBorderColor object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK (";
        break;
    case 1:
        settings.stream() << "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK (";
        break;
    case 2:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK (";
        break;
    case 3:
        settings.stream() << "VK_BORDER_COLOR_INT_OPAQUE_BLACK (";
        break;
    case 4:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE (";
        break;
    case 5:
        settings.stream() << "VK_BORDER_COLOR_INT_OPAQUE_WHITE (";
        break;
    case 1000287003:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT (";
        break;
    case 1000287004:
        settings.stream() << "VK_BORDER_COLOR_INT_CUSTOM_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkFilter(VkFilter object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FILTER_NEAREST (";
        break;
    case 1:
        settings.stream() << "VK_FILTER_LINEAR (";
        break;
    case 1000015000:
        settings.stream() << "VK_FILTER_CUBIC_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSamplerAddressMode(VkSamplerAddressMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_REPEAT (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT (";
        break;
    case 2:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE (";
        break;
    case 3:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER (";
        break;
    case 4:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSamplerMipmapMode(VkSamplerMipmapMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_MIPMAP_MODE_NEAREST (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_MIPMAP_MODE_LINEAR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDescriptorType(VkDescriptorType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DESCRIPTOR_TYPE_SAMPLER (";
        break;
    case 1:
        settings.stream() << "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER (";
        break;
    case 2:
        settings.stream() << "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE (";
        break;
    case 3:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE (";
        break;
    case 4:
        settings.stream() << "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER (";
        break;
    case 5:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER (";
        break;
    case 6:
        settings.stream() << "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER (";
        break;
    case 7:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER (";
        break;
    case 8:
        settings.stream() << "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC (";
        break;
    case 9:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC (";
        break;
    case 10:
        settings.stream() << "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT (";
        break;
    case 1000138000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK (";
        break;
    case 1000150000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR (";
        break;
    case 1000165000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV (";
        break;
    case 1000440000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM (";
        break;
    case 1000440001:
        settings.stream() << "VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM (";
        break;
    case 1000351000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_MUTABLE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAttachmentLoadOp(VkAttachmentLoadOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_LOAD (";
        break;
    case 1:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_CLEAR (";
        break;
    case 2:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_DONT_CARE (";
        break;
    case 1000400000:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_NONE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAttachmentStoreOp(VkAttachmentStoreOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ATTACHMENT_STORE_OP_STORE (";
        break;
    case 1:
        settings.stream() << "VK_ATTACHMENT_STORE_OP_DONT_CARE (";
        break;
    case 1000301000:
        settings.stream() << "VK_ATTACHMENT_STORE_OP_NONE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPipelineBindPoint(VkPipelineBindPoint object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PIPELINE_BIND_POINT_GRAPHICS (";
        break;
    case 1:
        settings.stream() << "VK_PIPELINE_BIND_POINT_COMPUTE (";
        break;
    case 1000134000:
        settings.stream() << "VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX (";
        break;
    case 1000165000:
        settings.stream() << "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR (";
        break;
    case 1000369003:
        settings.stream() << "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCommandBufferLevel(VkCommandBufferLevel object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMMAND_BUFFER_LEVEL_PRIMARY (";
        break;
    case 1:
        settings.stream() << "VK_COMMAND_BUFFER_LEVEL_SECONDARY (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkIndexType(VkIndexType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_INDEX_TYPE_UINT16 (";
        break;
    case 1:
        settings.stream() << "VK_INDEX_TYPE_UINT32 (";
        break;
    case 1000165000:
        settings.stream() << "VK_INDEX_TYPE_NONE_KHR (";
        break;
    case 1000265000:
        settings.stream() << "VK_INDEX_TYPE_UINT8_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSubpassContents(VkSubpassContents object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SUBPASS_CONTENTS_INLINE (";
        break;
    case 1:
        settings.stream() << "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS (";
        break;
    case 1000451000:
        settings.stream() << "VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPointClippingBehavior(VkPointClippingBehavior object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES (";
        break;
    case 1:
        settings.stream() << "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkTessellationDomainOrigin(VkTessellationDomainOrigin object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT (";
        break;
    case 1:
        settings.stream() << "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSamplerYcbcrModelConversion(VkSamplerYcbcrModelConversion object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY (";
        break;
    case 2:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 (";
        break;
    case 3:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 (";
        break;
    case 4:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSamplerYcbcrRange(VkSamplerYcbcrRange object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_YCBCR_RANGE_ITU_FULL (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkChromaLocation(VkChromaLocation object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_CHROMA_LOCATION_COSITED_EVEN (";
        break;
    case 1:
        settings.stream() << "VK_CHROMA_LOCATION_MIDPOINT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDescriptorUpdateTemplateType(VkDescriptorUpdateTemplateType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET (";
        break;
    case 1:
        settings.stream() << "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDriverId(VkDriverId object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_DRIVER_ID_AMD_PROPRIETARY (";
        break;
    case 2:
        settings.stream() << "VK_DRIVER_ID_AMD_OPEN_SOURCE (";
        break;
    case 3:
        settings.stream() << "VK_DRIVER_ID_MESA_RADV (";
        break;
    case 4:
        settings.stream() << "VK_DRIVER_ID_NVIDIA_PROPRIETARY (";
        break;
    case 5:
        settings.stream() << "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS (";
        break;
    case 6:
        settings.stream() << "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA (";
        break;
    case 7:
        settings.stream() << "VK_DRIVER_ID_IMAGINATION_PROPRIETARY (";
        break;
    case 8:
        settings.stream() << "VK_DRIVER_ID_QUALCOMM_PROPRIETARY (";
        break;
    case 9:
        settings.stream() << "VK_DRIVER_ID_ARM_PROPRIETARY (";
        break;
    case 10:
        settings.stream() << "VK_DRIVER_ID_GOOGLE_SWIFTSHADER (";
        break;
    case 11:
        settings.stream() << "VK_DRIVER_ID_GGP_PROPRIETARY (";
        break;
    case 12:
        settings.stream() << "VK_DRIVER_ID_BROADCOM_PROPRIETARY (";
        break;
    case 13:
        settings.stream() << "VK_DRIVER_ID_MESA_LLVMPIPE (";
        break;
    case 14:
        settings.stream() << "VK_DRIVER_ID_MOLTENVK (";
        break;
    case 15:
        settings.stream() << "VK_DRIVER_ID_COREAVI_PROPRIETARY (";
        break;
    case 16:
        settings.stream() << "VK_DRIVER_ID_JUICE_PROPRIETARY (";
        break;
    case 17:
        settings.stream() << "VK_DRIVER_ID_VERISILICON_PROPRIETARY (";
        break;
    case 18:
        settings.stream() << "VK_DRIVER_ID_MESA_TURNIP (";
        break;
    case 19:
        settings.stream() << "VK_DRIVER_ID_MESA_V3DV (";
        break;
    case 20:
        settings.stream() << "VK_DRIVER_ID_MESA_PANVK (";
        break;
    case 21:
        settings.stream() << "VK_DRIVER_ID_SAMSUNG_PROPRIETARY (";
        break;
    case 22:
        settings.stream() << "VK_DRIVER_ID_MESA_VENUS (";
        break;
    case 23:
        settings.stream() << "VK_DRIVER_ID_MESA_DOZEN (";
        break;
    case 24:
        settings.stream() << "VK_DRIVER_ID_MESA_NVK (";
        break;
    case 25:
        settings.stream() << "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA (";
        break;
    case 26:
        settings.stream() << "VK_DRIVER_ID_MESA_AGXV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkShaderFloatControlsIndependence(VkShaderFloatControlsIndependence object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY (";
        break;
    case 1:
        settings.stream() << "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL (";
        break;
    case 2:
        settings.stream() << "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSamplerReductionMode(VkSamplerReductionMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_MIN (";
        break;
    case 2:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_MAX (";
        break;
    case 1000521000:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkSemaphoreType(VkSemaphoreType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SEMAPHORE_TYPE_BINARY (";
        break;
    case 1:
        settings.stream() << "VK_SEMAPHORE_TYPE_TIMELINE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPresentModeKHR(VkPresentModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PRESENT_MODE_IMMEDIATE_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PRESENT_MODE_MAILBOX_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PRESENT_MODE_FIFO_KHR (";
        break;
    case 3:
        settings.stream() << "VK_PRESENT_MODE_FIFO_RELAXED_KHR (";
        break;
    case 1000111000:
        settings.stream() << "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR (";
        break;
    case 1000111001:
        settings.stream() << "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkColorSpaceKHR(VkColorSpaceKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (";
        break;
    case 1000104001:
        settings.stream() << "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT (";
        break;
    case 1000104002:
        settings.stream() << "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT (";
        break;
    case 1000104003:
        settings.stream() << "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT (";
        break;
    case 1000104004:
        settings.stream() << "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT (";
        break;
    case 1000104005:
        settings.stream() << "VK_COLOR_SPACE_BT709_LINEAR_EXT (";
        break;
    case 1000104006:
        settings.stream() << "VK_COLOR_SPACE_BT709_NONLINEAR_EXT (";
        break;
    case 1000104007:
        settings.stream() << "VK_COLOR_SPACE_BT2020_LINEAR_EXT (";
        break;
    case 1000104008:
        settings.stream() << "VK_COLOR_SPACE_HDR10_ST2084_EXT (";
        break;
    case 1000104009:
        settings.stream() << "VK_COLOR_SPACE_DOLBYVISION_EXT (";
        break;
    case 1000104010:
        settings.stream() << "VK_COLOR_SPACE_HDR10_HLG_EXT (";
        break;
    case 1000104011:
        settings.stream() << "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT (";
        break;
    case 1000104012:
        settings.stream() << "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT (";
        break;
    case 1000104013:
        settings.stream() << "VK_COLOR_SPACE_PASS_THROUGH_EXT (";
        break;
    case 1000104014:
        settings.stream() << "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT (";
        break;
    case 1000213000:
        settings.stream() << "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDebugReportObjectTypeEXT(VkDebugReportObjectTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT (";
        break;
    case 3:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT (";
        break;
    case 4:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT (";
        break;
    case 5:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT (";
        break;
    case 6:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT (";
        break;
    case 7:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT (";
        break;
    case 8:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT (";
        break;
    case 9:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT (";
        break;
    case 10:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT (";
        break;
    case 11:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT (";
        break;
    case 12:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT (";
        break;
    case 13:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT (";
        break;
    case 14:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT (";
        break;
    case 15:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT (";
        break;
    case 16:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT (";
        break;
    case 17:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT (";
        break;
    case 18:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT (";
        break;
    case 19:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT (";
        break;
    case 20:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT (";
        break;
    case 21:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT (";
        break;
    case 22:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT (";
        break;
    case 23:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT (";
        break;
    case 24:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT (";
        break;
    case 25:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT (";
        break;
    case 26:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT (";
        break;
    case 27:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT (";
        break;
    case 28:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT (";
        break;
    case 29:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT (";
        break;
    case 30:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT (";
        break;
    case 33:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT (";
        break;
    case 1000156000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT (";
        break;
    case 1000085000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT (";
        break;
    case 1000029000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT (";
        break;
    case 1000029001:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT (";
        break;
    case 1000150000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT (";
        break;
    case 1000165000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT (";
        break;
    case 1000307000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT (";
        break;
    case 1000307001:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT (";
        break;
    case 1000366000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkRasterizationOrderAMD(VkRasterizationOrderAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_RASTERIZATION_ORDER_STRICT_AMD (";
        break;
    case 1:
        settings.stream() << "VK_RASTERIZATION_ORDER_RELAXED_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkQueryResultStatusKHR(VkQueryResultStatusKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case -1:
        settings.stream() << "VK_QUERY_RESULT_STATUS_ERROR_KHR (";
        break;
    case 0:
        settings.stream() << "VK_QUERY_RESULT_STATUS_NOT_READY_KHR (";
        break;
    case 1:
        settings.stream() << "VK_QUERY_RESULT_STATUS_COMPLETE_KHR (";
        break;
    case -1000299000:
        settings.stream() << "VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkShaderInfoTypeAMD(VkShaderInfoTypeAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADER_INFO_TYPE_STATISTICS_AMD (";
        break;
    case 1:
        settings.stream() << "VK_SHADER_INFO_TYPE_BINARY_AMD (";
        break;
    case 2:
        settings.stream() << "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkValidationCheckEXT(VkValidationCheckEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VALIDATION_CHECK_ALL_EXT (";
        break;
    case 1:
        settings.stream() << "VK_VALIDATION_CHECK_SHADERS_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPipelineRobustnessBufferBehaviorEXT(VkPipelineRobustnessBufferBehaviorEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT (";
        break;
    case 1:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT (";
        break;
    case 2:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT (";
        break;
    case 3:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPipelineRobustnessImageBehaviorEXT(VkPipelineRobustnessImageBehaviorEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT (";
        break;
    case 1:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT (";
        break;
    case 2:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT (";
        break;
    case 3:
        settings.stream() << "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDisplayPowerStateEXT(VkDisplayPowerStateEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DISPLAY_POWER_STATE_OFF_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DISPLAY_POWER_STATE_SUSPEND_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DISPLAY_POWER_STATE_ON_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDeviceEventTypeEXT(VkDeviceEventTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDisplayEventTypeEXT(VkDisplayEventTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkViewportCoordinateSwizzleNV(VkViewportCoordinateSwizzleNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV (";
        break;
    case 1:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV (";
        break;
    case 2:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV (";
        break;
    case 3:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV (";
        break;
    case 4:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV (";
        break;
    case 5:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV (";
        break;
    case 6:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV (";
        break;
    case 7:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDiscardRectangleModeEXT(VkDiscardRectangleModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkConservativeRasterizationModeEXT(VkConservativeRasterizationModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceCounterUnitKHR(VkPerformanceCounterUnitKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR (";
        break;
    case 3:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR (";
        break;
    case 4:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR (";
        break;
    case 5:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR (";
        break;
    case 6:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR (";
        break;
    case 7:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR (";
        break;
    case 8:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR (";
        break;
    case 9:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR (";
        break;
    case 10:
        settings.stream() << "VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceCounterScopeKHR(VkPerformanceCounterScopeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceCounterStorageKHR(VkPerformanceCounterStorageKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR (";
        break;
    case 3:
        settings.stream() << "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR (";
        break;
    case 4:
        settings.stream() << "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR (";
        break;
    case 5:
        settings.stream() << "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBlendOverlapEXT(VkBlendOverlapEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLEND_OVERLAP_UNCORRELATED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_BLEND_OVERLAP_DISJOINT_EXT (";
        break;
    case 2:
        settings.stream() << "VK_BLEND_OVERLAP_CONJOINT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAccelerationStructureTypeKHR(VkAccelerationStructureTypeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR (";
        break;
    case 2:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBuildAccelerationStructureModeKHR(VkBuildAccelerationStructureModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR (";
        break;
    case 1:
        settings.stream() << "VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkGeometryTypeKHR(VkGeometryTypeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_GEOMETRY_TYPE_TRIANGLES_KHR (";
        break;
    case 1:
        settings.stream() << "VK_GEOMETRY_TYPE_AABBS_KHR (";
        break;
    case 2:
        settings.stream() << "VK_GEOMETRY_TYPE_INSTANCES_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAccelerationStructureBuildTypeKHR(VkAccelerationStructureBuildTypeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR (";
        break;
    case 2:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCopyAccelerationStructureModeKHR(VkCopyAccelerationStructureModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR (";
        break;
    case 1:
        settings.stream() << "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR (";
        break;
    case 2:
        settings.stream() << "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR (";
        break;
    case 3:
        settings.stream() << "VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAccelerationStructureCompatibilityKHR(VkAccelerationStructureCompatibilityKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCoverageModulationModeNV(VkCoverageModulationModeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_NONE_NV (";
        break;
    case 1:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_RGB_NV (";
        break;
    case 2:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_ALPHA_NV (";
        break;
    case 3:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_RGBA_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkValidationCacheHeaderVersionEXT(VkValidationCacheHeaderVersionEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkShadingRatePaletteEntryNV(VkShadingRatePaletteEntryNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV (";
        break;
    case 1:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 2:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 3:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 4:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 5:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV (";
        break;
    case 6:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV (";
        break;
    case 7:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV (";
        break;
    case 8:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV (";
        break;
    case 9:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV (";
        break;
    case 10:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV (";
        break;
    case 11:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCoarseSampleOrderTypeNV(VkCoarseSampleOrderTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV (";
        break;
    case 1:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV (";
        break;
    case 2:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV (";
        break;
    case 3:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkRayTracingShaderGroupTypeKHR(VkRayTracingShaderGroupTypeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR (";
        break;
    case 1:
        settings.stream() << "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR (";
        break;
    case 2:
        settings.stream() << "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAccelerationStructureMemoryRequirementsTypeNV(VkAccelerationStructureMemoryRequirementsTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV (";
        break;
    case 2:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkQueueGlobalPriorityKHR(VkQueueGlobalPriorityKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 128:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR (";
        break;
    case 256:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR (";
        break;
    case 512:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR (";
        break;
    case 1024:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkTimeDomainKHR(VkTimeDomainKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_TIME_DOMAIN_DEVICE_KHR (";
        break;
    case 1:
        settings.stream() << "VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR (";
        break;
    case 2:
        settings.stream() << "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR (";
        break;
    case 3:
        settings.stream() << "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkMemoryOverallocationBehaviorAMD(VkMemoryOverallocationBehaviorAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD (";
        break;
    case 1:
        settings.stream() << "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD (";
        break;
    case 2:
        settings.stream() << "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceConfigurationTypeINTEL(VkPerformanceConfigurationTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkQueryPoolSamplingModeINTEL(VkQueryPoolSamplingModeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceOverrideTypeINTEL(VkPerformanceOverrideTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceParameterTypeINTEL(VkPerformanceParameterTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPerformanceValueTypeINTEL(VkPerformanceValueTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL (";
        break;
    case 2:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL (";
        break;
    case 3:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL (";
        break;
    case 4:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkFragmentShadingRateCombinerOpKHR(VkFragmentShadingRateCombinerOpKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR (";
        break;
    case 1:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR (";
        break;
    case 2:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR (";
        break;
    case 3:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR (";
        break;
    case 4:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkValidationFeatureEnableEXT(VkValidationFeatureEnableEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT (";
        break;
    case 2:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT (";
        break;
    case 3:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT (";
        break;
    case 4:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkValidationFeatureDisableEXT(VkValidationFeatureDisableEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT (";
        break;
    case 1:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT (";
        break;
    case 2:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT (";
        break;
    case 3:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT (";
        break;
    case 4:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT (";
        break;
    case 5:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT (";
        break;
    case 6:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT (";
        break;
    case 7:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkComponentTypeKHR(VkComponentTypeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMPONENT_TYPE_FLOAT16_KHR (";
        break;
    case 1:
        settings.stream() << "VK_COMPONENT_TYPE_FLOAT32_KHR (";
        break;
    case 2:
        settings.stream() << "VK_COMPONENT_TYPE_FLOAT64_KHR (";
        break;
    case 3:
        settings.stream() << "VK_COMPONENT_TYPE_SINT8_KHR (";
        break;
    case 4:
        settings.stream() << "VK_COMPONENT_TYPE_SINT16_KHR (";
        break;
    case 5:
        settings.stream() << "VK_COMPONENT_TYPE_SINT32_KHR (";
        break;
    case 6:
        settings.stream() << "VK_COMPONENT_TYPE_SINT64_KHR (";
        break;
    case 7:
        settings.stream() << "VK_COMPONENT_TYPE_UINT8_KHR (";
        break;
    case 8:
        settings.stream() << "VK_COMPONENT_TYPE_UINT16_KHR (";
        break;
    case 9:
        settings.stream() << "VK_COMPONENT_TYPE_UINT32_KHR (";
        break;
    case 10:
        settings.stream() << "VK_COMPONENT_TYPE_UINT64_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkScopeKHR(VkScopeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_SCOPE_DEVICE_KHR (";
        break;
    case 2:
        settings.stream() << "VK_SCOPE_WORKGROUP_KHR (";
        break;
    case 3:
        settings.stream() << "VK_SCOPE_SUBGROUP_KHR (";
        break;
    case 5:
        settings.stream() << "VK_SCOPE_QUEUE_FAMILY_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCoverageReductionModeNV(VkCoverageReductionModeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COVERAGE_REDUCTION_MODE_MERGE_NV (";
        break;
    case 1:
        settings.stream() << "VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkProvokingVertexModeEXT(VkProvokingVertexModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT (";
        break;
    case 1:
        settings.stream() << "VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkFullScreenExclusiveEXT(VkFullScreenExclusiveEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT (";
        break;
    case 1:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT (";
        break;
    case 2:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT (";
        break;
    case 3:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkLineRasterizationModeKHR(VkLineRasterizationModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR (";
        break;
    case 1:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR (";
        break;
    case 2:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR (";
        break;
    case 3:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkPipelineExecutableStatisticFormatKHR(VkPipelineExecutableStatisticFormatKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR (";
        break;
    case 3:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkIndirectCommandsTokenTypeNV(VkIndirectCommandsTokenTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV (";
        break;
    case 1:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV (";
        break;
    case 2:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV (";
        break;
    case 3:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV (";
        break;
    case 4:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV (";
        break;
    case 5:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV (";
        break;
    case 6:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV (";
        break;
    case 7:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV (";
        break;
    case 1000328000:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV (";
        break;
    case 1000428003:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV (";
        break;
    case 1000428004:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDepthBiasRepresentationEXT(VkDepthBiasRepresentationEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDeviceMemoryReportEventTypeEXT(VkDeviceMemoryReportEventTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT (";
        break;
    case 3:
        settings.stream() << "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT (";
        break;
    case 4:
        settings.stream() << "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkVideoEncodeTuningModeKHR(VkVideoEncodeTuningModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR (";
        break;
    case 1:
        settings.stream() << "VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR (";
        break;
    case 2:
        settings.stream() << "VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR (";
        break;
    case 3:
        settings.stream() << "VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR (";
        break;
    case 4:
        settings.stream() << "VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkFragmentShadingRateTypeNV(VkFragmentShadingRateTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV (";
        break;
    case 1:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkFragmentShadingRateNV(VkFragmentShadingRateNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV (";
        break;
    case 1:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV (";
        break;
    case 4:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV (";
        break;
    case 5:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV (";
        break;
    case 6:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV (";
        break;
    case 9:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV (";
        break;
    case 10:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV (";
        break;
    case 11:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 12:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 13:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 14:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 15:
        settings.stream() << "VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkAccelerationStructureMotionInstanceTypeNV(VkAccelerationStructureMotionInstanceTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV (";
        break;
    case 2:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDeviceFaultAddressTypeEXT(VkDeviceFaultAddressTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT (";
        break;
    case 3:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT (";
        break;
    case 4:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT (";
        break;
    case 5:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT (";
        break;
    case 6:
        settings.stream() << "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDeviceFaultVendorBinaryHeaderVersionEXT(VkDeviceFaultVendorBinaryHeaderVersionEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkShaderGroupShaderKHR(VkShaderGroupShaderKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADER_GROUP_SHADER_GENERAL_KHR (";
        break;
    case 1:
        settings.stream() << "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR (";
        break;
    case 2:
        settings.stream() << "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR (";
        break;
    case 3:
        settings.stream() << "VK_SHADER_GROUP_SHADER_INTERSECTION_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDeviceAddressBindingTypeEXT(VkDeviceAddressBindingTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkMicromapTypeEXT(VkMicromapTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT (";
        break;
    case 1000397000:
        settings.stream() << "VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBuildMicromapModeEXT(VkBuildMicromapModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BUILD_MICROMAP_MODE_BUILD_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCopyMicromapModeEXT(VkCopyMicromapModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COPY_MICROMAP_MODE_CLONE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_COPY_MICROMAP_MODE_SERIALIZE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT (";
        break;
    case 3:
        settings.stream() << "VK_COPY_MICROMAP_MODE_COMPACT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkOpacityMicromapFormatEXT(VkOpacityMicromapFormatEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkOpacityMicromapSpecialIndexEXT(VkOpacityMicromapSpecialIndexEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case -1:
        settings.stream() << "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT (";
        break;
    case -2:
        settings.stream() << "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT (";
        break;
    case -3:
        settings.stream() << "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT (";
        break;
    case -4:
        settings.stream() << "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkDisplacementMicromapFormatNV(VkDisplacementMicromapFormatNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV (";
        break;
    case 2:
        settings.stream() << "VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV (";
        break;
    case 3:
        settings.stream() << "VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkSubpassMergeStatusEXT(VkSubpassMergeStatusEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_MERGED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT (";
        break;
    case 2:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT (";
        break;
    case 3:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT (";
        break;
    case 4:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT (";
        break;
    case 5:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT (";
        break;
    case 6:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT (";
        break;
    case 7:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT (";
        break;
    case 8:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT (";
        break;
    case 9:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT (";
        break;
    case 10:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT (";
        break;
    case 11:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT (";
        break;
    case 12:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT (";
        break;
    case 13:
        settings.stream() << "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkDirectDriverLoadingModeLUNARG(VkDirectDriverLoadingModeLUNARG object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG (";
        break;
    case 1:
        settings.stream() << "VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkOpticalFlowPerformanceLevelNV(VkOpticalFlowPerformanceLevelNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV (";
        break;
    case 1:
        settings.stream() << "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV (";
        break;
    case 2:
        settings.stream() << "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV (";
        break;
    case 3:
        settings.stream() << "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkOpticalFlowSessionBindingPointNV(VkOpticalFlowSessionBindingPointNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV (";
        break;
    case 1:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV (";
        break;
    case 2:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV (";
        break;
    case 3:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV (";
        break;
    case 4:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV (";
        break;
    case 5:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV (";
        break;
    case 6:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV (";
        break;
    case 7:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV (";
        break;
    case 8:
        settings.stream() << "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkShaderCodeTypeEXT(VkShaderCodeTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADER_CODE_TYPE_BINARY_EXT (";
        break;
    case 1:
        settings.stream() << "VK_SHADER_CODE_TYPE_SPIRV_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkRayTracingInvocationReorderModeNV(VkRayTracingInvocationReorderModeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV (";
        break;
    case 1:
        settings.stream() << "VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkLayerSettingTypeEXT(VkLayerSettingTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LAYER_SETTING_TYPE_BOOL32_EXT (";
        break;
    case 1:
        settings.stream() << "VK_LAYER_SETTING_TYPE_INT32_EXT (";
        break;
    case 2:
        settings.stream() << "VK_LAYER_SETTING_TYPE_INT64_EXT (";
        break;
    case 3:
        settings.stream() << "VK_LAYER_SETTING_TYPE_UINT32_EXT (";
        break;
    case 4:
        settings.stream() << "VK_LAYER_SETTING_TYPE_UINT64_EXT (";
        break;
    case 5:
        settings.stream() << "VK_LAYER_SETTING_TYPE_FLOAT32_EXT (";
        break;
    case 6:
        settings.stream() << "VK_LAYER_SETTING_TYPE_FLOAT64_EXT (";
        break;
    case 7:
        settings.stream() << "VK_LAYER_SETTING_TYPE_STRING_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkLatencyMarkerNV(VkLatencyMarkerNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LATENCY_MARKER_SIMULATION_START_NV (";
        break;
    case 1:
        settings.stream() << "VK_LATENCY_MARKER_SIMULATION_END_NV (";
        break;
    case 2:
        settings.stream() << "VK_LATENCY_MARKER_RENDERSUBMIT_START_NV (";
        break;
    case 3:
        settings.stream() << "VK_LATENCY_MARKER_RENDERSUBMIT_END_NV (";
        break;
    case 4:
        settings.stream() << "VK_LATENCY_MARKER_PRESENT_START_NV (";
        break;
    case 5:
        settings.stream() << "VK_LATENCY_MARKER_PRESENT_END_NV (";
        break;
    case 6:
        settings.stream() << "VK_LATENCY_MARKER_INPUT_SAMPLE_NV (";
        break;
    case 7:
        settings.stream() << "VK_LATENCY_MARKER_TRIGGER_FLASH_NV (";
        break;
    case 8:
        settings.stream() << "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV (";
        break;
    case 9:
        settings.stream() << "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV (";
        break;
    case 10:
        settings.stream() << "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV (";
        break;
    case 11:
        settings.stream() << "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkOutOfBandQueueTypeNV(VkOutOfBandQueueTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV (";
        break;
    case 1:
        settings.stream() << "VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkBlockMatchWindowCompareModeQCOM(VkBlockMatchWindowCompareModeQCOM object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM (";
        break;
    case 1:
        settings.stream() << "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkCubicFilterWeightsQCOM(VkCubicFilterWeightsQCOM object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM (";
        break;
    case 1:
        settings.stream() << "VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM (";
        break;
    case 2:
        settings.stream() << "VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM (";
        break;
    case 3:
        settings.stream() << "VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}
void dump_html_VkLayeredDriverUnderlyingApiMSFT(VkLayeredDriverUnderlyingApiMSFT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT (";
        break;
    case 1:
        settings.stream() << "VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    settings.stream() << object << ")</div></summary>";
}

//========================= Bitmask Implementations =========================//

void dump_html_VkAccessFlagBits(VkAccessFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_INDEX_READ_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_UNIFORM_READ_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_SHADER_READ_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_SHADER_WRITE_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_TRANSFER_READ_BIT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_TRANSFER_WRITE_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_HOST_READ_BIT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_HOST_WRITE_BIT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_MEMORY_READ_BIT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_MEMORY_WRITE_BIT"; is_first = false;
    }
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_NONE"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageAspectFlagBits(VkImageAspectFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_COLOR_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_DEPTH_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_STENCIL_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_METADATA_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_PLANE_0_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_PLANE_1_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_PLANE_2_BIT"; is_first = false;
    }
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_NONE"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkFormatFeatureFlagBits(VkFormatFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_BLIT_SRC_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_BLIT_DST_BIT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_TRANSFER_DST_BIT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_DISJOINT_BIT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageCreateFlagBits(VkImageCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_ALIAS_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_PROTECTED_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_DISJOINT_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_RESERVED_19_BIT_EXT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSampleCountFlagBits(VkSampleCountFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_1_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_2_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_4_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_8_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_16_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_32_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLE_COUNT_64_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageUsageFlagBits(VkImageUsageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_TRANSFER_DST_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_SAMPLED_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_STORAGE_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_RESERVED_24_BIT_COREAVI"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_RESERVED_23_BIT_EXT"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_RESERVED_25_BIT_KHR"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_USAGE_RESERVED_26_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkInstanceCreateFlagBits(VkInstanceCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMemoryHeapFlagBits(VkMemoryHeapFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMemoryPropertyFlagBits(VkMemoryPropertyFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_PROTECTED_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkQueueFlagBits(VkQueueFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_GRAPHICS_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_COMPUTE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_TRANSFER_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_SPARSE_BINDING_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_PROTECTED_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_VIDEO_DECODE_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_RESERVED_9_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_VIDEO_ENCODE_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_RESERVED_7_BIT_QCOM"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_RESERVED_11_BIT_ARM"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_OPTICAL_FLOW_BIT_NV"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUEUE_RESERVED_10_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDeviceQueueCreateFlagBits(VkDeviceQueueCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineStageFlagBits(VkPipelineStageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_TRANSFER_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_HOST_BIT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"; is_first = false;
    }
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_NONE"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMemoryMapFlagBits(VkMemoryMapFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_MAP_PLACED_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSparseMemoryBindFlagBits(VkSparseMemoryBindFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SPARSE_MEMORY_BIND_METADATA_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSparseImageFormatFlagBits(VkSparseImageFormatFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkFenceCreateFlagBits(VkFenceCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FENCE_CREATE_SIGNALED_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkEventCreateFlagBits(VkEventCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EVENT_CREATE_DEVICE_ONLY_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkQueryPipelineStatisticFlagBits(VkQueryPipelineStatisticFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkQueryResultFlagBits(VkQueryResultFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_RESULT_64_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_RESULT_WAIT_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_RESULT_PARTIAL_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkBufferCreateFlagBits(VkBufferCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_PROTECTED_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkBufferUsageFlagBits(VkBufferUsageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_TRANSFER_DST_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_RESERVED_28_BIT_KHR"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_RESERVED_29_BIT_KHR"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_RESERVED_30_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_RESERVED_27_BIT_QCOM"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageViewCreateFlagBits(VkImageViewCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineCacheCreateFlagBits(VkPipelineCacheCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkColorComponentFlagBits(VkColorComponentFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COLOR_COMPONENT_R_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COLOR_COMPONENT_G_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COLOR_COMPONENT_B_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COLOR_COMPONENT_A_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineCreateFlagBits(VkPipelineCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_DERIVATIVE_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineShaderStageCreateFlagBits(VkPipelineShaderStageCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkShaderStageFlagBits(VkShaderStageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_VERTEX_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_GEOMETRY_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_FRAGMENT_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_COMPUTE_BIT"; is_first = false;
    }
    if(object == 0x0000001F) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_ALL_GRAPHICS"; is_first = false;
    }
    if(object == 0x7FFFFFFF) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_ALL"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_RAYGEN_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_ANY_HIT_BIT_KHR"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_MISS_BIT_KHR"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_INTERSECTION_BIT_KHR"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_CALLABLE_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_TASK_BIT_EXT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_MESH_BIT_EXT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkCullModeFlagBits(VkCullModeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_CULL_MODE_NONE"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_CULL_MODE_FRONT_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_CULL_MODE_BACK_BIT"; is_first = false;
    }
    if(object == 0x00000003) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_CULL_MODE_FRONT_AND_BACK"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineDepthStencilStateCreateFlagBits(VkPipelineDepthStencilStateCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineColorBlendStateCreateFlagBits(VkPipelineColorBlendStateCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineLayoutCreateFlagBits(VkPipelineLayoutCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSamplerCreateFlagBits(VkSamplerCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorPoolCreateFlagBits(VkDescriptorPoolCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorSetLayoutCreateFlagBits(VkDescriptorSetLayoutCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkAttachmentDescriptionFlagBits(VkAttachmentDescriptionFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDependencyFlagBits(VkDependencyFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEPENDENCY_BY_REGION_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEPENDENCY_DEVICE_GROUP_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEPENDENCY_VIEW_LOCAL_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkFramebufferCreateFlagBits(VkFramebufferCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkRenderPassCreateFlagBits(VkRenderPassCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSubpassDescriptionFlagBits(VkSubpassDescriptionFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkCommandPoolCreateFlagBits(VkCommandPoolCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_POOL_CREATE_PROTECTED_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkCommandPoolResetFlagBits(VkCommandPoolResetFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkCommandBufferUsageFlagBits(VkCommandBufferUsageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkQueryControlFlagBits(VkQueryControlFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_QUERY_CONTROL_PRECISE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkCommandBufferResetFlagBits(VkCommandBufferResetFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkStencilFaceFlagBits(VkStencilFaceFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_STENCIL_FACE_FRONT_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_STENCIL_FACE_BACK_BIT"; is_first = false;
    }
    if(object == 0x00000003) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_STENCIL_FACE_FRONT_AND_BACK"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSubgroupFeatureFlagBits(VkSubgroupFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_BASIC_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_VOTE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_BALLOT_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_SHUFFLE_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_CLUSTERED_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_QUAD_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPeerMemoryFeatureFlagBits(VkPeerMemoryFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMemoryAllocateFlagBits(VkMemoryAllocateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalMemoryHandleTypeFlagBits(VkExternalMemoryHandleTypeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalMemoryFeatureFlagBits(VkExternalMemoryFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalFenceHandleTypeFlagBits(VkExternalFenceHandleTypeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalFenceFeatureFlagBits(VkExternalFenceFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkFenceImportFlagBits(VkFenceImportFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FENCE_IMPORT_TEMPORARY_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSemaphoreImportFlagBits(VkSemaphoreImportFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalSemaphoreHandleTypeFlagBits(VkExternalSemaphoreHandleTypeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalSemaphoreFeatureFlagBits(VkExternalSemaphoreFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkResolveModeFlagBits(VkResolveModeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RESOLVE_MODE_NONE"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RESOLVE_MODE_AVERAGE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RESOLVE_MODE_MIN_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RESOLVE_MODE_MAX_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDescriptorBindingFlagBits(VkDescriptorBindingFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSemaphoreWaitFlagBits(VkSemaphoreWaitFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SEMAPHORE_WAIT_ANY_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineCreationFeedbackFlagBits(VkPipelineCreationFeedbackFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkToolPurposeFlagBits(VkToolPurposeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_VALIDATION_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_PROFILING_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_TRACING_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineStageFlagBits2(VkPipelineStageFlagBits2 object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_NONE"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_HOST_BIT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"; is_first = false;
    }
    if(object & 4294967296) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_COPY_BIT"; is_first = false;
    }
    if(object & 8589934592) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_RESOLVE_BIT"; is_first = false;
    }
    if(object & 17179869184) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_BLIT_BIT"; is_first = false;
    }
    if(object & 34359738368) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_CLEAR_BIT"; is_first = false;
    }
    if(object & 68719476736) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"; is_first = false;
    }
    if(object & 137438953472) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"; is_first = false;
    }
    if(object & 274877906944) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"; is_first = false;
    }
    if(object & 549755813888) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"; is_first = false;
    }
    if(object & 1099511627776) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"; is_first = false;
    }
    if(object & 2199023255552) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"; is_first = false;
    }
    if(object & 8796093022208) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"; is_first = false;
    }
    if(object & 17592186044416) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_RESERVED_44_BIT_NV"; is_first = false;
    }
    if(object & 4398046511104) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_RESERVED_42_BIT_EXT"; is_first = false;
    }
    if(object & 35184372088832) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_STAGE_2_RESERVED_45_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkAccessFlagBits2(VkAccessFlagBits2 object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_NONE"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_INDEX_READ_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_UNIFORM_READ_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_SHADER_READ_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_SHADER_WRITE_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_TRANSFER_READ_BIT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_TRANSFER_WRITE_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_HOST_READ_BIT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_HOST_WRITE_BIT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_MEMORY_READ_BIT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_MEMORY_WRITE_BIT"; is_first = false;
    }
    if(object & 4294967296) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"; is_first = false;
    }
    if(object & 8589934592) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_SHADER_STORAGE_READ_BIT"; is_first = false;
    }
    if(object & 17179869184) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"; is_first = false;
    }
    if(object & 34359738368) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR"; is_first = false;
    }
    if(object & 68719476736) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR"; is_first = false;
    }
    if(object & 70368744177664) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_46_BIT_INTEL"; is_first = false;
    }
    if(object & 137438953472) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR"; is_first = false;
    }
    if(object & 274877906944) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR"; is_first = false;
    }
    if(object & 2251799813685248) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_51_BIT_QCOM"; is_first = false;
    }
    if(object & 4503599627370496) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_52_BIT_QCOM"; is_first = false;
    }
    if(object & 9007199254740992) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_53_BIT_QCOM"; is_first = false;
    }
    if(object & 18014398509481984) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_54_BIT_QCOM"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"; is_first = false;
    }
    if(object & 2199023255552) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT"; is_first = false;
    }
    if(object & 549755813888) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI"; is_first = false;
    }
    if(object & 1099511627776) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR"; is_first = false;
    }
    if(object & 17592186044416) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_MICROMAP_READ_BIT_EXT"; is_first = false;
    }
    if(object & 35184372088832) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT"; is_first = false;
    }
    if(object & 562949953421312) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_49_BIT_ARM"; is_first = false;
    }
    if(object & 1125899906842624) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_50_BIT_ARM"; is_first = false;
    }
    if(object & 4398046511104) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV"; is_first = false;
    }
    if(object & 8796093022208) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV"; is_first = false;
    }
    if(object & 140737488355328) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_47_BIT_EXT"; is_first = false;
    }
    if(object & 281474976710656) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_48_BIT_EXT"; is_first = false;
    }
    if(object & 36028797018963968) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_55_BIT_NV"; is_first = false;
    }
    if(object & 72057594037927936) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCESS_2_RESERVED_56_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSubmitFlagBits(VkSubmitFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SUBMIT_PROTECTED_BIT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkRenderingFlagBits(VkRenderingFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDERING_SUSPENDING_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDERING_RESUMING_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDERING_CONTENTS_INLINE_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkFormatFeatureFlagBits2(VkFormatFeatureFlagBits2 object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_BLIT_DST_BIT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_DISJOINT_BIT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"; is_first = false;
    }
    if(object & 2147483648) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"; is_first = false;
    }
    if(object & 4294967296) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"; is_first = false;
    }
    if(object & 8589934592) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 17592186044416) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_44_BIT_EXT"; is_first = false;
    }
    if(object & 35184372088832) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_45_BIT_EXT"; is_first = false;
    }
    if(object & 70368744177664) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR"; is_first = false;
    }
    if(object & 2251799813685248) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_51_BIT_EXT"; is_first = false;
    }
    if(object & 274877906944) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV"; is_first = false;
    }
    if(object & 17179869184) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM"; is_first = false;
    }
    if(object & 34359738368) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM"; is_first = false;
    }
    if(object & 68719476736) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM"; is_first = false;
    }
    if(object & 137438953472) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM"; is_first = false;
    }
    if(object & 140737488355328) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM"; is_first = false;
    }
    if(object & 549755813888) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_39_BIT_EXT"; is_first = false;
    }
    if(object & 1099511627776) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV"; is_first = false;
    }
    if(object & 2199023255552) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV"; is_first = false;
    }
    if(object & 4398046511104) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV"; is_first = false;
    }
    if(object & 281474976710656) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_48_BIT_EXT"; is_first = false;
    }
    if(object & 562949953421312) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_49_BIT_KHR"; is_first = false;
    }
    if(object & 1125899906842624) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FORMAT_FEATURE_2_RESERVED_50_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSurfaceTransformFlagBitsKHR(VkSurfaceTransformFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkCompositeAlphaFlagBitsKHR(VkCompositeAlphaFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSwapchainCreateFlagBitsKHR(VkSwapchainCreateFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDeviceGroupPresentModeFlagBitsKHR(VkDeviceGroupPresentModeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDisplayPlaneAlphaFlagBitsKHR(VkDisplayPlaneAlphaFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDebugReportFlagBitsEXT(VkDebugReportFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_REPORT_WARNING_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_REPORT_ERROR_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_REPORT_DEBUG_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoCodecOperationFlagBitsKHR(VkVideoCodecOperationFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODEC_OPERATION_NONE_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoChromaSubsamplingFlagBitsKHR(VkVideoChromaSubsamplingFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoComponentBitDepthFlagBitsKHR(VkVideoComponentBitDepthFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoCapabilityFlagBitsKHR(VkVideoCapabilityFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoSessionCreateFlagBitsKHR(VkVideoSessionCreateFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_SESSION_CREATE_RESERVED_3_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_SESSION_CREATE_RESERVED_4_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoCodingControlFlagBitsKHR(VkVideoCodingControlFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoDecodeCapabilityFlagBitsKHR(VkVideoDecodeCapabilityFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoDecodeUsageFlagBitsKHR(VkVideoDecodeUsageFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_USAGE_DEFAULT_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH264CapabilityFlagBitsKHR(VkVideoEncodeH264CapabilityFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH264StdFlagBitsKHR(VkVideoEncodeH264StdFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH264RateControlFlagBitsKHR(VkVideoEncodeH264RateControlFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH265CapabilityFlagBitsKHR(VkVideoEncodeH265CapabilityFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH265StdFlagBitsKHR(VkVideoEncodeH265StdFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH265CtbSizeFlagBitsKHR(VkVideoEncodeH265CtbSizeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR(VkVideoEncodeH265TransformBlockSizeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeH265RateControlFlagBitsKHR(VkVideoEncodeH265RateControlFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoDecodeH264PictureLayoutFlagBitsKHR(VkVideoDecodeH264PictureLayoutFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalMemoryHandleTypeFlagBitsNV(VkExternalMemoryHandleTypeFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkExternalMemoryFeatureFlagBitsNV(VkExternalMemoryFeatureFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkConditionalRenderingFlagBitsEXT(VkConditionalRenderingFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkSurfaceCounterFlagBitsEXT(VkSurfaceCounterFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SURFACE_COUNTER_VBLANK_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPerformanceCounterDescriptionFlagBitsKHR(VkPerformanceCounterDescriptionFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkAcquireProfilingLockFlagBitsKHR(VkAcquireProfilingLockFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDebugUtilsMessageSeverityFlagBitsEXT(VkDebugUtilsMessageSeverityFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDebugUtilsMessageTypeFlagBitsEXT(VkDebugUtilsMessageTypeFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkBuildAccelerationStructureFlagBitsKHR(VkBuildAccelerationStructureFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkGeometryFlagBitsKHR(VkGeometryFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_OPAQUE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkGeometryInstanceFlagBitsKHR(VkGeometryInstanceFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkAccelerationStructureCreateFlagBitsKHR(VkAccelerationStructureCreateFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineCompilerControlFlagBitsAMD(VkPipelineCompilerControlFlagBitsAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkShaderCorePropertiesFlagBitsAMD(VkShaderCorePropertiesFlagBitsAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkHostImageCopyFlagBitsEXT(VkHostImageCopyFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_HOST_IMAGE_COPY_MEMCPY_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMemoryUnmapFlagBitsKHR(VkMemoryUnmapFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_UNMAP_RESERVE_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPresentScalingFlagBitsEXT(VkPresentScalingFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PRESENT_SCALING_STRETCH_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPresentGravityFlagBitsEXT(VkPresentGravityFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PRESENT_GRAVITY_MIN_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PRESENT_GRAVITY_MAX_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PRESENT_GRAVITY_CENTERED_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkIndirectStateFlagBitsNV(VkIndirectStateFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkIndirectCommandsLayoutUsageFlagBitsNV(VkIndirectCommandsLayoutUsageFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeFlagBitsKHR(VkVideoEncodeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_RESERVED_0_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_RESERVED_1_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeCapabilityFlagBitsKHR(VkVideoEncodeCapabilityFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CAPABILITY_RESERVED_2_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CAPABILITY_RESERVED_3_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeRateControlModeFlagBitsKHR(VkVideoEncodeRateControlModeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeFeedbackFlagBitsKHR(VkVideoEncodeFeedbackFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeUsageFlagBitsKHR(VkVideoEncodeUsageFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkVideoEncodeContentFlagBitsKHR(VkVideoEncodeContentFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDeviceDiagnosticsConfigFlagBitsNV(VkDeviceDiagnosticsConfigFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalObjectTypeFlagBitsEXT(VkExportMetalObjectTypeFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_VkGraphicsPipelineLibraryFlagBitsEXT(VkGraphicsPipelineLibraryFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageCompressionFlagBitsEXT(VkImageCompressionFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_DEFAULT_EXT"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_DISABLED_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkImageCompressionFixedRateFlagBitsEXT(VkImageCompressionFixedRateFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkDeviceAddressBindingFlagBitsEXT(VkDeviceAddressBindingFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImageConstraintsInfoFlagBitsFUCHSIA(VkImageConstraintsInfoFlagBitsFUCHSIA object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
void dump_html_VkFrameBoundaryFlagBitsEXT(VkFrameBoundaryFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkBuildMicromapFlagBitsEXT(VkBuildMicromapFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMicromapCreateFlagBitsEXT(VkMicromapCreateFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPhysicalDeviceSchedulingControlsFlagBitsARM(VkPhysicalDeviceSchedulingControlsFlagBitsARM object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkMemoryDecompressionMethodFlagBitsNV(VkMemoryDecompressionMethodFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkOpticalFlowGridSizeFlagBitsNV(VkOpticalFlowGridSizeFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkOpticalFlowUsageFlagBitsNV(VkOpticalFlowUsageFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object == 0) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV"; is_first = false;
    }
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_USAGE_COST_BIT_NV"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkOpticalFlowSessionCreateFlagBitsNV(VkOpticalFlowSessionCreateFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkOpticalFlowExecuteFlagBitsNV(VkOpticalFlowExecuteFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkPipelineCreateFlagBits2KHR(VkPipelineCreateFlagBits2KHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR"; is_first = false;
    }
    if(object & 8589934592) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RESERVED_33_BIT_KHR"; is_first = false;
    }
    if(object & 17179869184) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"; is_first = false;
    }
    if(object & 262144) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 4294967296) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RESERVED_32_BIT_KHR"; is_first = false;
    }
    if(object & 2147483648) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RESERVED_31_BIT_KHR"; is_first = false;
    }
    if(object & 34359738368) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_PIPELINE_CREATE_2_RESERVED_35_BIT_KHR"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkBufferUsageFlagBits2KHR(VkBufferUsageFlagBits2KHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 256) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR"; is_first = false;
    }
    if(object & 33554432) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX"; is_first = false;
    }
    if(object & 268435456) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_RESERVED_28_BIT_KHR"; is_first = false;
    }
    if(object & 536870912) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_RESERVED_29_BIT_KHR"; is_first = false;
    }
    if(object & 1073741824) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_RESERVED_30_BIT_KHR"; is_first = false;
    }
    if(object & 134217728) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_RESERVED_27_BIT_QCOM"; is_first = false;
    }
    if(object & 512) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT"; is_first = false;
    }
    if(object & 1024) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"; is_first = false;
    }
    if(object & 2048) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 4096) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 8192) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 16384) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR"; is_first = false;
    }
    if(object & 32768) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR"; is_first = false;
    }
    if(object & 65536) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR"; is_first = false;
    }
    if(object & 131072) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR"; is_first = false;
    }
    if(object & 524288) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"; is_first = false;
    }
    if(object & 1048576) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"; is_first = false;
    }
    if(object & 2097152) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 4194304) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 67108864) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"; is_first = false;
    }
    if(object & 8388608) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"; is_first = false;
    }
    if(object & 16777216) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}
void dump_html_VkShaderCreateFlagBitsEXT(VkShaderCreateFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(object & 1) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_LINK_STAGE_BIT_EXT"; is_first = false;
    }
    if(object & 2) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"; is_first = false;
    }
    if(object & 4) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"; is_first = false;
    }
    if(object & 8) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT"; is_first = false;
    }
    if(object & 16) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT"; is_first = false;
    }
    if(object & 32) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT"; is_first = false;
    }
    if(object & 64) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"; is_first = false;
    }
    if(object & 128) {
        settings.stream() << (is_first ? " (" : " | ") << "VK_SHADER_CREATE_EXTENSION_573_BIT_EXT"; is_first = false;
    }
    if(!is_first)
        settings.stream() << ")";
    settings.stream() << "</div></summary>";
}

//=========================== Flag Implementations ==========================//

void dump_html_VkAccessFlags(VkAccessFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkAccessFlagBits((VkAccessFlagBits) object, settings, indents);
}
void dump_html_VkImageAspectFlags(VkImageAspectFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageAspectFlagBits((VkImageAspectFlagBits) object, settings, indents);
}
void dump_html_VkFormatFeatureFlags(VkFormatFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkFormatFeatureFlagBits((VkFormatFeatureFlagBits) object, settings, indents);
}
void dump_html_VkImageCreateFlags(VkImageCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageCreateFlagBits((VkImageCreateFlagBits) object, settings, indents);
}
void dump_html_VkSampleCountFlags(VkSampleCountFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSampleCountFlagBits((VkSampleCountFlagBits) object, settings, indents);
}
void dump_html_VkImageUsageFlags(VkImageUsageFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageUsageFlagBits((VkImageUsageFlagBits) object, settings, indents);
}
void dump_html_VkInstanceCreateFlags(VkInstanceCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkInstanceCreateFlagBits((VkInstanceCreateFlagBits) object, settings, indents);
}
void dump_html_VkMemoryHeapFlags(VkMemoryHeapFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMemoryHeapFlagBits((VkMemoryHeapFlagBits) object, settings, indents);
}
void dump_html_VkMemoryPropertyFlags(VkMemoryPropertyFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMemoryPropertyFlagBits((VkMemoryPropertyFlagBits) object, settings, indents);
}
void dump_html_VkQueueFlags(VkQueueFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkQueueFlagBits((VkQueueFlagBits) object, settings, indents);
}
void dump_html_VkDeviceQueueCreateFlags(VkDeviceQueueCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDeviceQueueCreateFlagBits((VkDeviceQueueCreateFlagBits) object, settings, indents);
}
void dump_html_VkPipelineStageFlags(VkPipelineStageFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineStageFlagBits((VkPipelineStageFlagBits) object, settings, indents);
}
void dump_html_VkMemoryMapFlags(VkMemoryMapFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMemoryMapFlagBits((VkMemoryMapFlagBits) object, settings, indents);
}
void dump_html_VkSparseMemoryBindFlags(VkSparseMemoryBindFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSparseMemoryBindFlagBits((VkSparseMemoryBindFlagBits) object, settings, indents);
}
void dump_html_VkSparseImageFormatFlags(VkSparseImageFormatFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSparseImageFormatFlagBits((VkSparseImageFormatFlagBits) object, settings, indents);
}
void dump_html_VkFenceCreateFlags(VkFenceCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkFenceCreateFlagBits((VkFenceCreateFlagBits) object, settings, indents);
}
void dump_html_VkEventCreateFlags(VkEventCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkEventCreateFlagBits((VkEventCreateFlagBits) object, settings, indents);
}
void dump_html_VkQueryPipelineStatisticFlags(VkQueryPipelineStatisticFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkQueryPipelineStatisticFlagBits((VkQueryPipelineStatisticFlagBits) object, settings, indents);
}
void dump_html_VkQueryResultFlags(VkQueryResultFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkQueryResultFlagBits((VkQueryResultFlagBits) object, settings, indents);
}
void dump_html_VkBufferCreateFlags(VkBufferCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkBufferCreateFlagBits((VkBufferCreateFlagBits) object, settings, indents);
}
void dump_html_VkBufferUsageFlags(VkBufferUsageFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkBufferUsageFlagBits((VkBufferUsageFlagBits) object, settings, indents);
}
void dump_html_VkImageViewCreateFlags(VkImageViewCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageViewCreateFlagBits((VkImageViewCreateFlagBits) object, settings, indents);
}
void dump_html_VkPipelineCacheCreateFlags(VkPipelineCacheCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineCacheCreateFlagBits((VkPipelineCacheCreateFlagBits) object, settings, indents);
}
void dump_html_VkColorComponentFlags(VkColorComponentFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkColorComponentFlagBits((VkColorComponentFlagBits) object, settings, indents);
}
void dump_html_VkPipelineCreateFlags(VkPipelineCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineCreateFlagBits((VkPipelineCreateFlagBits) object, settings, indents);
}
void dump_html_VkPipelineShaderStageCreateFlags(VkPipelineShaderStageCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineShaderStageCreateFlagBits((VkPipelineShaderStageCreateFlagBits) object, settings, indents);
}
void dump_html_VkCullModeFlags(VkCullModeFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkCullModeFlagBits((VkCullModeFlagBits) object, settings, indents);
}
void dump_html_VkPipelineDepthStencilStateCreateFlags(VkPipelineDepthStencilStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineDepthStencilStateCreateFlagBits((VkPipelineDepthStencilStateCreateFlagBits) object, settings, indents);
}
void dump_html_VkPipelineColorBlendStateCreateFlags(VkPipelineColorBlendStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineColorBlendStateCreateFlagBits((VkPipelineColorBlendStateCreateFlagBits) object, settings, indents);
}
void dump_html_VkPipelineLayoutCreateFlags(VkPipelineLayoutCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineLayoutCreateFlagBits((VkPipelineLayoutCreateFlagBits) object, settings, indents);
}
void dump_html_VkShaderStageFlags(VkShaderStageFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkShaderStageFlagBits((VkShaderStageFlagBits) object, settings, indents);
}
void dump_html_VkSamplerCreateFlags(VkSamplerCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSamplerCreateFlagBits((VkSamplerCreateFlagBits) object, settings, indents);
}
void dump_html_VkDescriptorPoolCreateFlags(VkDescriptorPoolCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDescriptorPoolCreateFlagBits((VkDescriptorPoolCreateFlagBits) object, settings, indents);
}
void dump_html_VkDescriptorSetLayoutCreateFlags(VkDescriptorSetLayoutCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDescriptorSetLayoutCreateFlagBits((VkDescriptorSetLayoutCreateFlagBits) object, settings, indents);
}
void dump_html_VkAttachmentDescriptionFlags(VkAttachmentDescriptionFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkAttachmentDescriptionFlagBits((VkAttachmentDescriptionFlagBits) object, settings, indents);
}
void dump_html_VkDependencyFlags(VkDependencyFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDependencyFlagBits((VkDependencyFlagBits) object, settings, indents);
}
void dump_html_VkFramebufferCreateFlags(VkFramebufferCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkFramebufferCreateFlagBits((VkFramebufferCreateFlagBits) object, settings, indents);
}
void dump_html_VkRenderPassCreateFlags(VkRenderPassCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkRenderPassCreateFlagBits((VkRenderPassCreateFlagBits) object, settings, indents);
}
void dump_html_VkSubpassDescriptionFlags(VkSubpassDescriptionFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSubpassDescriptionFlagBits((VkSubpassDescriptionFlagBits) object, settings, indents);
}
void dump_html_VkCommandPoolCreateFlags(VkCommandPoolCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkCommandPoolCreateFlagBits((VkCommandPoolCreateFlagBits) object, settings, indents);
}
void dump_html_VkCommandPoolResetFlags(VkCommandPoolResetFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkCommandPoolResetFlagBits((VkCommandPoolResetFlagBits) object, settings, indents);
}
void dump_html_VkCommandBufferUsageFlags(VkCommandBufferUsageFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkCommandBufferUsageFlagBits((VkCommandBufferUsageFlagBits) object, settings, indents);
}
void dump_html_VkQueryControlFlags(VkQueryControlFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkQueryControlFlagBits((VkQueryControlFlagBits) object, settings, indents);
}
void dump_html_VkCommandBufferResetFlags(VkCommandBufferResetFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkCommandBufferResetFlagBits((VkCommandBufferResetFlagBits) object, settings, indents);
}
void dump_html_VkStencilFaceFlags(VkStencilFaceFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkStencilFaceFlagBits((VkStencilFaceFlagBits) object, settings, indents);
}
void dump_html_VkSubgroupFeatureFlags(VkSubgroupFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSubgroupFeatureFlagBits((VkSubgroupFeatureFlagBits) object, settings, indents);
}
void dump_html_VkPeerMemoryFeatureFlags(VkPeerMemoryFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPeerMemoryFeatureFlagBits((VkPeerMemoryFeatureFlagBits) object, settings, indents);
}
void dump_html_VkMemoryAllocateFlags(VkMemoryAllocateFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMemoryAllocateFlagBits((VkMemoryAllocateFlagBits) object, settings, indents);
}
void dump_html_VkExternalMemoryHandleTypeFlags(VkExternalMemoryHandleTypeFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalMemoryHandleTypeFlagBits((VkExternalMemoryHandleTypeFlagBits) object, settings, indents);
}
void dump_html_VkExternalMemoryFeatureFlags(VkExternalMemoryFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalMemoryFeatureFlagBits((VkExternalMemoryFeatureFlagBits) object, settings, indents);
}
void dump_html_VkExternalFenceHandleTypeFlags(VkExternalFenceHandleTypeFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalFenceHandleTypeFlagBits((VkExternalFenceHandleTypeFlagBits) object, settings, indents);
}
void dump_html_VkExternalFenceFeatureFlags(VkExternalFenceFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalFenceFeatureFlagBits((VkExternalFenceFeatureFlagBits) object, settings, indents);
}
void dump_html_VkFenceImportFlags(VkFenceImportFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkFenceImportFlagBits((VkFenceImportFlagBits) object, settings, indents);
}
void dump_html_VkSemaphoreImportFlags(VkSemaphoreImportFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSemaphoreImportFlagBits((VkSemaphoreImportFlagBits) object, settings, indents);
}
void dump_html_VkExternalSemaphoreHandleTypeFlags(VkExternalSemaphoreHandleTypeFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalSemaphoreHandleTypeFlagBits((VkExternalSemaphoreHandleTypeFlagBits) object, settings, indents);
}
void dump_html_VkExternalSemaphoreFeatureFlags(VkExternalSemaphoreFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalSemaphoreFeatureFlagBits((VkExternalSemaphoreFeatureFlagBits) object, settings, indents);
}
void dump_html_VkResolveModeFlags(VkResolveModeFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkResolveModeFlagBits((VkResolveModeFlagBits) object, settings, indents);
}
void dump_html_VkDescriptorBindingFlags(VkDescriptorBindingFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDescriptorBindingFlagBits((VkDescriptorBindingFlagBits) object, settings, indents);
}
void dump_html_VkSemaphoreWaitFlags(VkSemaphoreWaitFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSemaphoreWaitFlagBits((VkSemaphoreWaitFlagBits) object, settings, indents);
}
void dump_html_VkPipelineCreationFeedbackFlags(VkPipelineCreationFeedbackFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineCreationFeedbackFlagBits((VkPipelineCreationFeedbackFlagBits) object, settings, indents);
}
void dump_html_VkToolPurposeFlags(VkToolPurposeFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkToolPurposeFlagBits((VkToolPurposeFlagBits) object, settings, indents);
}
void dump_html_VkPipelineStageFlags2(VkPipelineStageFlags2 object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineStageFlagBits2((VkPipelineStageFlagBits2) object, settings, indents);
}
void dump_html_VkAccessFlags2(VkAccessFlags2 object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkAccessFlagBits2((VkAccessFlagBits2) object, settings, indents);
}
void dump_html_VkSubmitFlags(VkSubmitFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSubmitFlagBits((VkSubmitFlagBits) object, settings, indents);
}
void dump_html_VkRenderingFlags(VkRenderingFlags object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkRenderingFlagBits((VkRenderingFlagBits) object, settings, indents);
}
void dump_html_VkFormatFeatureFlags2(VkFormatFeatureFlags2 object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkFormatFeatureFlagBits2((VkFormatFeatureFlagBits2) object, settings, indents);
}
void dump_html_VkCompositeAlphaFlagsKHR(VkCompositeAlphaFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkCompositeAlphaFlagBitsKHR((VkCompositeAlphaFlagBitsKHR) object, settings, indents);
}
void dump_html_VkSurfaceTransformFlagsKHR(VkSurfaceTransformFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSurfaceTransformFlagBitsKHR((VkSurfaceTransformFlagBitsKHR) object, settings, indents);
}
void dump_html_VkSwapchainCreateFlagsKHR(VkSwapchainCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSwapchainCreateFlagBitsKHR((VkSwapchainCreateFlagBitsKHR) object, settings, indents);
}
void dump_html_VkDeviceGroupPresentModeFlagsKHR(VkDeviceGroupPresentModeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDeviceGroupPresentModeFlagBitsKHR((VkDeviceGroupPresentModeFlagBitsKHR) object, settings, indents);
}
void dump_html_VkDisplayPlaneAlphaFlagsKHR(VkDisplayPlaneAlphaFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDisplayPlaneAlphaFlagBitsKHR((VkDisplayPlaneAlphaFlagBitsKHR) object, settings, indents);
}
void dump_html_VkDebugReportFlagsEXT(VkDebugReportFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDebugReportFlagBitsEXT((VkDebugReportFlagBitsEXT) object, settings, indents);
}
void dump_html_VkVideoCodecOperationFlagsKHR(VkVideoCodecOperationFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoCodecOperationFlagBitsKHR((VkVideoCodecOperationFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoChromaSubsamplingFlagsKHR(VkVideoChromaSubsamplingFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoChromaSubsamplingFlagBitsKHR((VkVideoChromaSubsamplingFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoComponentBitDepthFlagsKHR(VkVideoComponentBitDepthFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoComponentBitDepthFlagBitsKHR((VkVideoComponentBitDepthFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoCapabilityFlagsKHR(VkVideoCapabilityFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoCapabilityFlagBitsKHR((VkVideoCapabilityFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoSessionCreateFlagsKHR(VkVideoSessionCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoSessionCreateFlagBitsKHR((VkVideoSessionCreateFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoCodingControlFlagsKHR(VkVideoCodingControlFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoCodingControlFlagBitsKHR((VkVideoCodingControlFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoDecodeCapabilityFlagsKHR(VkVideoDecodeCapabilityFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoDecodeCapabilityFlagBitsKHR((VkVideoDecodeCapabilityFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoDecodeUsageFlagsKHR(VkVideoDecodeUsageFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoDecodeUsageFlagBitsKHR((VkVideoDecodeUsageFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH264CapabilityFlagsKHR(VkVideoEncodeH264CapabilityFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH264CapabilityFlagBitsKHR((VkVideoEncodeH264CapabilityFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH264StdFlagsKHR(VkVideoEncodeH264StdFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH264StdFlagBitsKHR((VkVideoEncodeH264StdFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH264RateControlFlagsKHR(VkVideoEncodeH264RateControlFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH264RateControlFlagBitsKHR((VkVideoEncodeH264RateControlFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH265CapabilityFlagsKHR(VkVideoEncodeH265CapabilityFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH265CapabilityFlagBitsKHR((VkVideoEncodeH265CapabilityFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH265StdFlagsKHR(VkVideoEncodeH265StdFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH265StdFlagBitsKHR((VkVideoEncodeH265StdFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH265CtbSizeFlagsKHR(VkVideoEncodeH265CtbSizeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH265CtbSizeFlagBitsKHR((VkVideoEncodeH265CtbSizeFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH265TransformBlockSizeFlagsKHR(VkVideoEncodeH265TransformBlockSizeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH265TransformBlockSizeFlagBitsKHR((VkVideoEncodeH265TransformBlockSizeFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeH265RateControlFlagsKHR(VkVideoEncodeH265RateControlFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeH265RateControlFlagBitsKHR((VkVideoEncodeH265RateControlFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoDecodeH264PictureLayoutFlagsKHR(VkVideoDecodeH264PictureLayoutFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoDecodeH264PictureLayoutFlagBitsKHR((VkVideoDecodeH264PictureLayoutFlagBitsKHR) object, settings, indents);
}
void dump_html_VkExternalMemoryHandleTypeFlagsNV(VkExternalMemoryHandleTypeFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalMemoryHandleTypeFlagBitsNV((VkExternalMemoryHandleTypeFlagBitsNV) object, settings, indents);
}
void dump_html_VkExternalMemoryFeatureFlagsNV(VkExternalMemoryFeatureFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExternalMemoryFeatureFlagBitsNV((VkExternalMemoryFeatureFlagBitsNV) object, settings, indents);
}
void dump_html_VkConditionalRenderingFlagsEXT(VkConditionalRenderingFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkConditionalRenderingFlagBitsEXT((VkConditionalRenderingFlagBitsEXT) object, settings, indents);
}
void dump_html_VkSurfaceCounterFlagsEXT(VkSurfaceCounterFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkSurfaceCounterFlagBitsEXT((VkSurfaceCounterFlagBitsEXT) object, settings, indents);
}
void dump_html_VkPerformanceCounterDescriptionFlagsKHR(VkPerformanceCounterDescriptionFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPerformanceCounterDescriptionFlagBitsKHR((VkPerformanceCounterDescriptionFlagBitsKHR) object, settings, indents);
}
void dump_html_VkAcquireProfilingLockFlagsKHR(VkAcquireProfilingLockFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkAcquireProfilingLockFlagBitsKHR((VkAcquireProfilingLockFlagBitsKHR) object, settings, indents);
}
void dump_html_VkDebugUtilsMessageTypeFlagsEXT(VkDebugUtilsMessageTypeFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDebugUtilsMessageTypeFlagBitsEXT((VkDebugUtilsMessageTypeFlagBitsEXT) object, settings, indents);
}
void dump_html_VkDebugUtilsMessageSeverityFlagsEXT(VkDebugUtilsMessageSeverityFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDebugUtilsMessageSeverityFlagBitsEXT((VkDebugUtilsMessageSeverityFlagBitsEXT) object, settings, indents);
}
void dump_html_VkBuildAccelerationStructureFlagsKHR(VkBuildAccelerationStructureFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkBuildAccelerationStructureFlagBitsKHR((VkBuildAccelerationStructureFlagBitsKHR) object, settings, indents);
}
void dump_html_VkGeometryFlagsKHR(VkGeometryFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkGeometryFlagBitsKHR((VkGeometryFlagBitsKHR) object, settings, indents);
}
void dump_html_VkGeometryInstanceFlagsKHR(VkGeometryInstanceFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkGeometryInstanceFlagBitsKHR((VkGeometryInstanceFlagBitsKHR) object, settings, indents);
}
void dump_html_VkAccelerationStructureCreateFlagsKHR(VkAccelerationStructureCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkAccelerationStructureCreateFlagBitsKHR((VkAccelerationStructureCreateFlagBitsKHR) object, settings, indents);
}
void dump_html_VkPipelineCompilerControlFlagsAMD(VkPipelineCompilerControlFlagsAMD object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineCompilerControlFlagBitsAMD((VkPipelineCompilerControlFlagBitsAMD) object, settings, indents);
}
void dump_html_VkShaderCorePropertiesFlagsAMD(VkShaderCorePropertiesFlagsAMD object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkShaderCorePropertiesFlagBitsAMD((VkShaderCorePropertiesFlagBitsAMD) object, settings, indents);
}
void dump_html_VkHostImageCopyFlagsEXT(VkHostImageCopyFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkHostImageCopyFlagBitsEXT((VkHostImageCopyFlagBitsEXT) object, settings, indents);
}
void dump_html_VkMemoryUnmapFlagsKHR(VkMemoryUnmapFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMemoryUnmapFlagBitsKHR((VkMemoryUnmapFlagBitsKHR) object, settings, indents);
}
void dump_html_VkPresentScalingFlagsEXT(VkPresentScalingFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPresentScalingFlagBitsEXT((VkPresentScalingFlagBitsEXT) object, settings, indents);
}
void dump_html_VkPresentGravityFlagsEXT(VkPresentGravityFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPresentGravityFlagBitsEXT((VkPresentGravityFlagBitsEXT) object, settings, indents);
}
void dump_html_VkIndirectStateFlagsNV(VkIndirectStateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkIndirectStateFlagBitsNV((VkIndirectStateFlagBitsNV) object, settings, indents);
}
void dump_html_VkIndirectCommandsLayoutUsageFlagsNV(VkIndirectCommandsLayoutUsageFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkIndirectCommandsLayoutUsageFlagBitsNV((VkIndirectCommandsLayoutUsageFlagBitsNV) object, settings, indents);
}
void dump_html_VkVideoEncodeFlagsKHR(VkVideoEncodeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeFlagBitsKHR((VkVideoEncodeFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeCapabilityFlagsKHR(VkVideoEncodeCapabilityFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeCapabilityFlagBitsKHR((VkVideoEncodeCapabilityFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeRateControlModeFlagsKHR(VkVideoEncodeRateControlModeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeRateControlModeFlagBitsKHR((VkVideoEncodeRateControlModeFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeFeedbackFlagsKHR(VkVideoEncodeFeedbackFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeFeedbackFlagBitsKHR((VkVideoEncodeFeedbackFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeUsageFlagsKHR(VkVideoEncodeUsageFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeUsageFlagBitsKHR((VkVideoEncodeUsageFlagBitsKHR) object, settings, indents);
}
void dump_html_VkVideoEncodeContentFlagsKHR(VkVideoEncodeContentFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkVideoEncodeContentFlagBitsKHR((VkVideoEncodeContentFlagBitsKHR) object, settings, indents);
}
void dump_html_VkDeviceDiagnosticsConfigFlagsNV(VkDeviceDiagnosticsConfigFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDeviceDiagnosticsConfigFlagBitsNV((VkDeviceDiagnosticsConfigFlagBitsNV) object, settings, indents);
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalObjectTypeFlagsEXT(VkExportMetalObjectTypeFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkExportMetalObjectTypeFlagBitsEXT((VkExportMetalObjectTypeFlagBitsEXT) object, settings, indents);
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_VkGraphicsPipelineLibraryFlagsEXT(VkGraphicsPipelineLibraryFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkGraphicsPipelineLibraryFlagBitsEXT((VkGraphicsPipelineLibraryFlagBitsEXT) object, settings, indents);
}
void dump_html_VkImageCompressionFlagsEXT(VkImageCompressionFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageCompressionFlagBitsEXT((VkImageCompressionFlagBitsEXT) object, settings, indents);
}
void dump_html_VkImageCompressionFixedRateFlagsEXT(VkImageCompressionFixedRateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageCompressionFixedRateFlagBitsEXT((VkImageCompressionFixedRateFlagBitsEXT) object, settings, indents);
}
void dump_html_VkDeviceAddressBindingFlagsEXT(VkDeviceAddressBindingFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkDeviceAddressBindingFlagBitsEXT((VkDeviceAddressBindingFlagBitsEXT) object, settings, indents);
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImageConstraintsInfoFlagsFUCHSIA(VkImageConstraintsInfoFlagsFUCHSIA object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkImageConstraintsInfoFlagBitsFUCHSIA((VkImageConstraintsInfoFlagBitsFUCHSIA) object, settings, indents);
}
#endif // VK_USE_PLATFORM_FUCHSIA
void dump_html_VkFrameBoundaryFlagsEXT(VkFrameBoundaryFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkFrameBoundaryFlagBitsEXT((VkFrameBoundaryFlagBitsEXT) object, settings, indents);
}
void dump_html_VkBuildMicromapFlagsEXT(VkBuildMicromapFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkBuildMicromapFlagBitsEXT((VkBuildMicromapFlagBitsEXT) object, settings, indents);
}
void dump_html_VkMicromapCreateFlagsEXT(VkMicromapCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMicromapCreateFlagBitsEXT((VkMicromapCreateFlagBitsEXT) object, settings, indents);
}
void dump_html_VkPhysicalDeviceSchedulingControlsFlagsARM(VkPhysicalDeviceSchedulingControlsFlagsARM object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPhysicalDeviceSchedulingControlsFlagBitsARM((VkPhysicalDeviceSchedulingControlsFlagBitsARM) object, settings, indents);
}
void dump_html_VkMemoryDecompressionMethodFlagsNV(VkMemoryDecompressionMethodFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkMemoryDecompressionMethodFlagBitsNV((VkMemoryDecompressionMethodFlagBitsNV) object, settings, indents);
}
void dump_html_VkOpticalFlowGridSizeFlagsNV(VkOpticalFlowGridSizeFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkOpticalFlowGridSizeFlagBitsNV((VkOpticalFlowGridSizeFlagBitsNV) object, settings, indents);
}
void dump_html_VkOpticalFlowUsageFlagsNV(VkOpticalFlowUsageFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkOpticalFlowUsageFlagBitsNV((VkOpticalFlowUsageFlagBitsNV) object, settings, indents);
}
void dump_html_VkOpticalFlowSessionCreateFlagsNV(VkOpticalFlowSessionCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkOpticalFlowSessionCreateFlagBitsNV((VkOpticalFlowSessionCreateFlagBitsNV) object, settings, indents);
}
void dump_html_VkOpticalFlowExecuteFlagsNV(VkOpticalFlowExecuteFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkOpticalFlowExecuteFlagBitsNV((VkOpticalFlowExecuteFlagBitsNV) object, settings, indents);
}
void dump_html_VkPipelineCreateFlags2KHR(VkPipelineCreateFlags2KHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkPipelineCreateFlagBits2KHR((VkPipelineCreateFlagBits2KHR) object, settings, indents);
}
void dump_html_VkBufferUsageFlags2KHR(VkBufferUsageFlags2KHR object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkBufferUsageFlagBits2KHR((VkBufferUsageFlagBits2KHR) object, settings, indents);
}
void dump_html_VkShaderCreateFlagsEXT(VkShaderCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    dump_html_VkShaderCreateFlagBitsEXT((VkShaderCreateFlagBitsEXT) object, settings, indents);
}


void dump_html_VkDeviceCreateFlags(VkDeviceCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkSemaphoreCreateFlags(VkSemaphoreCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkQueryPoolCreateFlags(VkQueryPoolCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkBufferViewCreateFlags(VkBufferViewCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkShaderModuleCreateFlags(VkShaderModuleCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineVertexInputStateCreateFlags(VkPipelineVertexInputStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineInputAssemblyStateCreateFlags(VkPipelineInputAssemblyStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineTessellationStateCreateFlags(VkPipelineTessellationStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineViewportStateCreateFlags(VkPipelineViewportStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineRasterizationStateCreateFlags(VkPipelineRasterizationStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineMultisampleStateCreateFlags(VkPipelineMultisampleStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineDynamicStateCreateFlags(VkPipelineDynamicStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkDescriptorPoolResetFlags(VkDescriptorPoolResetFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkCommandPoolTrimFlags(VkCommandPoolTrimFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkDescriptorUpdateTemplateCreateFlags(VkDescriptorUpdateTemplateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPrivateDataSlotCreateFlags(VkPrivateDataSlotCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkDisplayModeCreateFlagsKHR(VkDisplayModeCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkDisplaySurfaceCreateFlagsKHR(VkDisplaySurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_VkXlibSurfaceCreateFlagsKHR(VkXlibSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_VkXcbSurfaceCreateFlagsKHR(VkXcbSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
void dump_html_VkWaylandSurfaceCreateFlagsKHR(VkWaylandSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidSurfaceCreateFlagsKHR(VkAndroidSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkWin32SurfaceCreateFlagsKHR(VkWin32SurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkVideoSessionParametersCreateFlagsKHR(VkVideoSessionParametersCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkVideoBeginCodingFlagsKHR(VkVideoBeginCodingFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkVideoEndCodingFlagsKHR(VkVideoEndCodingFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkVideoDecodeFlagsKHR(VkVideoDecodeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineRasterizationStateStreamCreateFlagsEXT(VkPipelineRasterizationStateStreamCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_GGP)
void dump_html_VkStreamDescriptorSurfaceCreateFlagsGGP(VkStreamDescriptorSurfaceCreateFlagsGGP object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_GGP
#if defined(VK_USE_PLATFORM_VI_NN)
void dump_html_VkViSurfaceCreateFlagsNN(VkViSurfaceCreateFlagsNN object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_VI_NN
void dump_html_VkPipelineViewportSwizzleStateCreateFlagsNV(VkPipelineViewportSwizzleStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineDiscardRectangleStateCreateFlagsEXT(VkPipelineDiscardRectangleStateCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineRasterizationConservativeStateCreateFlagsEXT(VkPipelineRasterizationConservativeStateCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(VkPipelineRasterizationDepthClipStateCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
void dump_html_VkIOSSurfaceCreateFlagsMVK(VkIOSSurfaceCreateFlagsMVK object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_IOS_MVK
#if defined(VK_USE_PLATFORM_MACOS_MVK)
void dump_html_VkMacOSSurfaceCreateFlagsMVK(VkMacOSSurfaceCreateFlagsMVK object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_MACOS_MVK
void dump_html_VkDebugUtilsMessengerCallbackDataFlagsEXT(VkDebugUtilsMessengerCallbackDataFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkDebugUtilsMessengerCreateFlagsEXT(VkDebugUtilsMessengerCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineCoverageToColorStateCreateFlagsNV(VkPipelineCoverageToColorStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkPipelineCoverageModulationStateCreateFlagsNV(VkPipelineCoverageModulationStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkValidationCacheCreateFlagsEXT(VkValidationCacheCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImagePipeSurfaceCreateFlagsFUCHSIA(VkImagePipeSurfaceCreateFlagsFUCHSIA object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkMetalSurfaceCreateFlagsEXT(VkMetalSurfaceCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_VkPipelineCoverageReductionStateCreateFlagsNV(VkPipelineCoverageReductionStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkHeadlessSurfaceCreateFlagsEXT(VkHeadlessSurfaceCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkDeviceMemoryReportFlagsEXT(VkDeviceMemoryReportFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkVideoEncodeRateControlFlagsKHR(VkVideoEncodeRateControlFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkAccelerationStructureMotionInfoFlagsNV(VkAccelerationStructureMotionInfoFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
void dump_html_VkAccelerationStructureMotionInstanceFlagsNV(VkAccelerationStructureMotionInstanceFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
void dump_html_VkDirectFBSurfaceCreateFlagsEXT(VkDirectFBSurfaceCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImageFormatConstraintsFlagsFUCHSIA(VkImageFormatConstraintsFlagsFUCHSIA object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkScreenSurfaceCreateFlagsQNX(VkScreenSurfaceCreateFlagsQNX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
void dump_html_VkDirectDriverLoadingFlagsLUNARG(VkDirectDriverLoadingFlagsLUNARG object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}

//======================= Func Pointer Implementations ======================//

void dump_html_PFN_vkAllocationFunction(PFN_vkAllocationFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkFreeFunction(PFN_vkFreeFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkInternalAllocationNotification(PFN_vkInternalAllocationNotification object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkInternalFreeNotification(PFN_vkInternalFreeNotification object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkReallocationFunction(PFN_vkReallocationFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkVoidFunction(PFN_vkVoidFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkDebugReportCallbackEXT(PFN_vkDebugReportCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkDebugUtilsMessengerCallbackEXT(PFN_vkDebugUtilsMessengerCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkDeviceMemoryReportCallbackEXT(PFN_vkDeviceMemoryReportCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}
void dump_html_PFN_vkGetInstanceProcAddrLUNARG(PFN_vkGetInstanceProcAddrLUNARG object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    settings.stream() << "</div></summary>";
}

//========================== Struct Implementations =========================//

void dump_html_VkExtent2D(const VkExtent2D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
}
void dump_html_VkExtent3D(const VkExtent3D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.depth, settings, "uint32_t", "depth", indents + 1, dump_html_uint32_t);
}
void dump_html_VkOffset2D(const VkOffset2D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.x, settings, "int32_t", "x", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.y, settings, "int32_t", "y", indents + 1, dump_html_int32_t);
}
void dump_html_VkOffset3D(const VkOffset3D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.x, settings, "int32_t", "x", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.y, settings, "int32_t", "y", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.z, settings, "int32_t", "z", indents + 1, dump_html_int32_t);
}
void dump_html_VkRect2D(const VkRect2D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkOffset2D>(object.offset, settings, "VkOffset2D", "offset", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.extent, settings, "VkExtent2D", "extent", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkBaseInStructure(const VkBaseInStructure& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    dump_html_pointer<const VkBaseInStructure>(object.pNext, settings, "const struct VkBaseInStructure*", "pNext", indents + 1, dump_html_VkBaseInStructure);
}
void dump_html_VkBaseOutStructure(const VkBaseOutStructure& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    dump_html_pointer<const VkBaseOutStructure>(object.pNext, settings, "struct VkBaseOutStructure*", "pNext", indents + 1, dump_html_VkBaseOutStructure);
}
void dump_html_VkBufferMemoryBarrier(const VkBufferMemoryBarrier& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const uint32_t>(object.srcQueueFamilyIndex, settings, "uint32_t", "srcQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstQueueFamilyIndex, settings, "uint32_t", "dstQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkDispatchIndirectCommand(const VkDispatchIndirectCommand& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.x, settings, "uint32_t", "x", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.y, settings, "uint32_t", "y", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.z, settings, "uint32_t", "z", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDrawIndexedIndirectCommand(const VkDrawIndexedIndirectCommand& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.indexCount, settings, "uint32_t", "indexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceCount, settings, "uint32_t", "instanceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstIndex, settings, "uint32_t", "firstIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const int32_t>(object.vertexOffset, settings, "int32_t", "vertexOffset", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.firstInstance, settings, "uint32_t", "firstInstance", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDrawIndirectCommand(const VkDrawIndirectCommand& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.vertexCount, settings, "uint32_t", "vertexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceCount, settings, "uint32_t", "instanceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstVertex, settings, "uint32_t", "firstVertex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstInstance, settings, "uint32_t", "firstInstance", indents + 1, dump_html_uint32_t);
}
void dump_html_VkImageSubresourceRange(const VkImageSubresourceRange& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.baseMipLevel, settings, "uint32_t", "baseMipLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.levelCount, settings, "uint32_t", "levelCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkImageMemoryBarrier(const VkImageMemoryBarrier& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkImageLayout>(object.oldLayout, settings, "VkImageLayout", "oldLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.newLayout, settings, "VkImageLayout", "newLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.srcQueueFamilyIndex, settings, "uint32_t", "srcQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstQueueFamilyIndex, settings, "uint32_t", "dstQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageSubresourceRange>(object.subresourceRange, settings, "VkImageSubresourceRange", "subresourceRange", indents + 1, dump_html_VkImageSubresourceRange);
}
void dump_html_VkMemoryBarrier(const VkMemoryBarrier& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
}
void dump_html_VkPipelineCacheHeaderVersionOne(const VkPipelineCacheHeaderVersionOne& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.headerSize, settings, "uint32_t", "headerSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineCacheHeaderVersion>(object.headerVersion, settings, "VkPipelineCacheHeaderVersion", "headerVersion", indents + 1, dump_html_VkPipelineCacheHeaderVersion);
    dump_html_value<const uint32_t>(object.vendorID, settings, "uint32_t", "vendorID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.deviceID, settings, "uint32_t", "deviceID", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint8_t>(object.pipelineCacheUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "pipelineCacheUUID", indents + 1, dump_html_uint8_t); // ZRR
}
void dump_html_VkAllocationCallbacks(const VkAllocationCallbacks& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
    dump_html_value<const PFN_vkAllocationFunction>(object.pfnAllocation, settings, "PFN_vkAllocationFunction", "pfnAllocation", indents + 1, dump_html_PFN_vkAllocationFunction);
    dump_html_value<const PFN_vkReallocationFunction>(object.pfnReallocation, settings, "PFN_vkReallocationFunction", "pfnReallocation", indents + 1, dump_html_PFN_vkReallocationFunction);
    dump_html_value<const PFN_vkFreeFunction>(object.pfnFree, settings, "PFN_vkFreeFunction", "pfnFree", indents + 1, dump_html_PFN_vkFreeFunction);
    dump_html_value<const PFN_vkInternalAllocationNotification>(object.pfnInternalAllocation, settings, "PFN_vkInternalAllocationNotification", "pfnInternalAllocation", indents + 1, dump_html_PFN_vkInternalAllocationNotification);
    dump_html_value<const PFN_vkInternalFreeNotification>(object.pfnInternalFree, settings, "PFN_vkInternalFreeNotification", "pfnInternalFree", indents + 1, dump_html_PFN_vkInternalFreeNotification);
}
void dump_html_VkApplicationInfo(const VkApplicationInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pApplicationName, settings, "const char*", "pApplicationName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.applicationVersion, settings, "uint32_t", "applicationVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const char*>(object.pEngineName, settings, "const char*", "pEngineName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.engineVersion, settings, "uint32_t", "engineVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.apiVersion, settings, "uint32_t", "apiVersion", indents + 1, dump_html_uint32_t);
}
void dump_html_VkFormatProperties(const VkFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkFormatFeatureFlags>(object.linearTilingFeatures, settings, "VkFormatFeatureFlags", "linearTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkFormatFeatureFlags>(object.optimalTilingFeatures, settings, "VkFormatFeatureFlags", "optimalTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkFormatFeatureFlags>(object.bufferFeatures, settings, "VkFormatFeatureFlags", "bufferFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
}
void dump_html_VkImageFormatProperties(const VkImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkExtent3D>(object.maxExtent, settings, "VkExtent3D", "maxExtent", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const uint32_t>(object.maxMipLevels, settings, "uint32_t", "maxMipLevels", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxArrayLayers, settings, "uint32_t", "maxArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlags>(object.sampleCounts, settings, "VkSampleCountFlags", "sampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkDeviceSize>(object.maxResourceSize, settings, "VkDeviceSize", "maxResourceSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkInstanceCreateInfo(const VkInstanceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkInstanceCreateFlags>(object.flags, settings, "VkInstanceCreateFlags", "flags", indents + 1, dump_html_VkInstanceCreateFlags);
    dump_html_pointer<const VkApplicationInfo>(object.pApplicationInfo, settings, "const VkApplicationInfo*", "pApplicationInfo", indents + 1, dump_html_VkApplicationInfo);
    dump_html_value<const uint32_t>(object.enabledLayerCount, settings, "uint32_t", "enabledLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledLayerNames, object.enabledLayerCount, settings, "const char* const*", "const char* const", "ppEnabledLayerNames", indents + 1, dump_html_cstring); // ZRT
    dump_html_value<const uint32_t>(object.enabledExtensionCount, settings, "uint32_t", "enabledExtensionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledExtensionNames, object.enabledExtensionCount, settings, "const char* const*", "const char* const", "ppEnabledExtensionNames", indents + 1, dump_html_cstring); // ZRT
}
void dump_html_VkMemoryHeap(const VkMemoryHeap& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkMemoryHeapFlags>(object.flags, settings, "VkMemoryHeapFlags", "flags", indents + 1, dump_html_VkMemoryHeapFlags);
}
void dump_html_VkMemoryType(const VkMemoryType& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkMemoryPropertyFlags>(object.propertyFlags, settings, "VkMemoryPropertyFlags", "propertyFlags", indents + 1, dump_html_VkMemoryPropertyFlags);
    dump_html_value<const uint32_t>(object.heapIndex, settings, "uint32_t", "heapIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceFeatures(const VkPhysicalDeviceFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.robustBufferAccess, settings, "VkBool32", "robustBufferAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fullDrawIndexUint32, settings, "VkBool32", "fullDrawIndexUint32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.imageCubeArray, settings, "VkBool32", "imageCubeArray", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.independentBlend, settings, "VkBool32", "independentBlend", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.geometryShader, settings, "VkBool32", "geometryShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.tessellationShader, settings, "VkBool32", "tessellationShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sampleRateShading, settings, "VkBool32", "sampleRateShading", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dualSrcBlend, settings, "VkBool32", "dualSrcBlend", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.logicOp, settings, "VkBool32", "logicOp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiDrawIndirect, settings, "VkBool32", "multiDrawIndirect", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.drawIndirectFirstInstance, settings, "VkBool32", "drawIndirectFirstInstance", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthClamp, settings, "VkBool32", "depthClamp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthBiasClamp, settings, "VkBool32", "depthBiasClamp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fillModeNonSolid, settings, "VkBool32", "fillModeNonSolid", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthBounds, settings, "VkBool32", "depthBounds", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.wideLines, settings, "VkBool32", "wideLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.largePoints, settings, "VkBool32", "largePoints", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.alphaToOne, settings, "VkBool32", "alphaToOne", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiViewport, settings, "VkBool32", "multiViewport", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.samplerAnisotropy, settings, "VkBool32", "samplerAnisotropy", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionETC2, settings, "VkBool32", "textureCompressionETC2", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionASTC_LDR, settings, "VkBool32", "textureCompressionASTC_LDR", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionBC, settings, "VkBool32", "textureCompressionBC", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.occlusionQueryPrecise, settings, "VkBool32", "occlusionQueryPrecise", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.pipelineStatisticsQuery, settings, "VkBool32", "pipelineStatisticsQuery", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vertexPipelineStoresAndAtomics, settings, "VkBool32", "vertexPipelineStoresAndAtomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentStoresAndAtomics, settings, "VkBool32", "fragmentStoresAndAtomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTessellationAndGeometryPointSize, settings, "VkBool32", "shaderTessellationAndGeometryPointSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderImageGatherExtended, settings, "VkBool32", "shaderImageGatherExtended", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageExtendedFormats, settings, "VkBool32", "shaderStorageImageExtendedFormats", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageMultisample, settings, "VkBool32", "shaderStorageImageMultisample", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageReadWithoutFormat, settings, "VkBool32", "shaderStorageImageReadWithoutFormat", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageWriteWithoutFormat, settings, "VkBool32", "shaderStorageImageWriteWithoutFormat", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayDynamicIndexing, settings, "VkBool32", "shaderUniformBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayDynamicIndexing, settings, "VkBool32", "shaderSampledImageArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayDynamicIndexing, settings, "VkBool32", "shaderStorageBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayDynamicIndexing, settings, "VkBool32", "shaderStorageImageArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderClipDistance, settings, "VkBool32", "shaderClipDistance", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderCullDistance, settings, "VkBool32", "shaderCullDistance", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderFloat64, settings, "VkBool32", "shaderFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt64, settings, "VkBool32", "shaderInt64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt16, settings, "VkBool32", "shaderInt16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderResourceResidency, settings, "VkBool32", "shaderResourceResidency", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderResourceMinLod, settings, "VkBool32", "shaderResourceMinLod", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseBinding, settings, "VkBool32", "sparseBinding", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyBuffer, settings, "VkBool32", "sparseResidencyBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyImage2D, settings, "VkBool32", "sparseResidencyImage2D", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyImage3D, settings, "VkBool32", "sparseResidencyImage3D", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency2Samples, settings, "VkBool32", "sparseResidency2Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency4Samples, settings, "VkBool32", "sparseResidency4Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency8Samples, settings, "VkBool32", "sparseResidency8Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency16Samples, settings, "VkBool32", "sparseResidency16Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyAliased, settings, "VkBool32", "sparseResidencyAliased", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.variableMultisampleRate, settings, "VkBool32", "variableMultisampleRate", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.inheritedQueries, settings, "VkBool32", "inheritedQueries", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceLimits(const VkPhysicalDeviceLimits& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.maxImageDimension1D, settings, "uint32_t", "maxImageDimension1D", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageDimension2D, settings, "uint32_t", "maxImageDimension2D", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageDimension3D, settings, "uint32_t", "maxImageDimension3D", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageDimensionCube, settings, "uint32_t", "maxImageDimensionCube", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageArrayLayers, settings, "uint32_t", "maxImageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTexelBufferElements, settings, "uint32_t", "maxTexelBufferElements", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxUniformBufferRange, settings, "uint32_t", "maxUniformBufferRange", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStorageBufferRange, settings, "uint32_t", "maxStorageBufferRange", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPushConstantsSize, settings, "uint32_t", "maxPushConstantsSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMemoryAllocationCount, settings, "uint32_t", "maxMemoryAllocationCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSamplerAllocationCount, settings, "uint32_t", "maxSamplerAllocationCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.bufferImageGranularity, settings, "VkDeviceSize", "bufferImageGranularity", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.sparseAddressSpaceSize, settings, "VkDeviceSize", "sparseAddressSpaceSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.maxBoundDescriptorSets, settings, "uint32_t", "maxBoundDescriptorSets", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorSamplers, settings, "uint32_t", "maxPerStageDescriptorSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUniformBuffers, settings, "uint32_t", "maxPerStageDescriptorUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorStorageBuffers, settings, "uint32_t", "maxPerStageDescriptorStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorSampledImages, settings, "uint32_t", "maxPerStageDescriptorSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorStorageImages, settings, "uint32_t", "maxPerStageDescriptorStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorInputAttachments, settings, "uint32_t", "maxPerStageDescriptorInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageResources, settings, "uint32_t", "maxPerStageResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetSamplers, settings, "uint32_t", "maxDescriptorSetSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUniformBuffers, settings, "uint32_t", "maxDescriptorSetUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUniformBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUniformBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetStorageBuffers, settings, "uint32_t", "maxDescriptorSetStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetStorageBuffersDynamic, settings, "uint32_t", "maxDescriptorSetStorageBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetSampledImages, settings, "uint32_t", "maxDescriptorSetSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetStorageImages, settings, "uint32_t", "maxDescriptorSetStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetInputAttachments, settings, "uint32_t", "maxDescriptorSetInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputAttributes, settings, "uint32_t", "maxVertexInputAttributes", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputBindings, settings, "uint32_t", "maxVertexInputBindings", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputAttributeOffset, settings, "uint32_t", "maxVertexInputAttributeOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputBindingStride, settings, "uint32_t", "maxVertexInputBindingStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexOutputComponents, settings, "uint32_t", "maxVertexOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationGenerationLevel, settings, "uint32_t", "maxTessellationGenerationLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationPatchSize, settings, "uint32_t", "maxTessellationPatchSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlPerVertexInputComponents, settings, "uint32_t", "maxTessellationControlPerVertexInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlPerVertexOutputComponents, settings, "uint32_t", "maxTessellationControlPerVertexOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlPerPatchOutputComponents, settings, "uint32_t", "maxTessellationControlPerPatchOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlTotalOutputComponents, settings, "uint32_t", "maxTessellationControlTotalOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationEvaluationInputComponents, settings, "uint32_t", "maxTessellationEvaluationInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationEvaluationOutputComponents, settings, "uint32_t", "maxTessellationEvaluationOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryShaderInvocations, settings, "uint32_t", "maxGeometryShaderInvocations", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryInputComponents, settings, "uint32_t", "maxGeometryInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryOutputComponents, settings, "uint32_t", "maxGeometryOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryOutputVertices, settings, "uint32_t", "maxGeometryOutputVertices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryTotalOutputComponents, settings, "uint32_t", "maxGeometryTotalOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentInputComponents, settings, "uint32_t", "maxFragmentInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentOutputAttachments, settings, "uint32_t", "maxFragmentOutputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentDualSrcAttachments, settings, "uint32_t", "maxFragmentDualSrcAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentCombinedOutputResources, settings, "uint32_t", "maxFragmentCombinedOutputResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxComputeSharedMemorySize, settings, "uint32_t", "maxComputeSharedMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxComputeWorkGroupCount, 3, settings, "uint32_t[3]", "uint32_t", "maxComputeWorkGroupCount", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxComputeWorkGroupInvocations, settings, "uint32_t", "maxComputeWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxComputeWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxComputeWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.subPixelPrecisionBits, settings, "uint32_t", "subPixelPrecisionBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.subTexelPrecisionBits, settings, "uint32_t", "subTexelPrecisionBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.mipmapPrecisionBits, settings, "uint32_t", "mipmapPrecisionBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDrawIndexedIndexValue, settings, "uint32_t", "maxDrawIndexedIndexValue", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDrawIndirectCount, settings, "uint32_t", "maxDrawIndirectCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const float>(object.maxSamplerLodBias, settings, "float", "maxSamplerLodBias", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxSamplerAnisotropy, settings, "float", "maxSamplerAnisotropy", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.maxViewports, settings, "uint32_t", "maxViewports", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxViewportDimensions, 2, settings, "uint32_t[2]", "uint32_t", "maxViewportDimensions", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_array<const float>(object.viewportBoundsRange, 2, settings, "float[2]", "float", "viewportBoundsRange", indents + 1, dump_html_float); // ZRR
    dump_html_value<const uint32_t>(object.viewportSubPixelBits, settings, "uint32_t", "viewportSubPixelBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.minMemoryMapAlignment, settings, "size_t", "minMemoryMapAlignment", indents + 1, dump_html_size_t);
    dump_html_value<const VkDeviceSize>(object.minTexelBufferOffsetAlignment, settings, "VkDeviceSize", "minTexelBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.minUniformBufferOffsetAlignment, settings, "VkDeviceSize", "minUniformBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.minStorageBufferOffsetAlignment, settings, "VkDeviceSize", "minStorageBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const int32_t>(object.minTexelOffset, settings, "int32_t", "minTexelOffset", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.maxTexelOffset, settings, "uint32_t", "maxTexelOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const int32_t>(object.minTexelGatherOffset, settings, "int32_t", "minTexelGatherOffset", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.maxTexelGatherOffset, settings, "uint32_t", "maxTexelGatherOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const float>(object.minInterpolationOffset, settings, "float", "minInterpolationOffset", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxInterpolationOffset, settings, "float", "maxInterpolationOffset", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.subPixelInterpolationOffsetBits, settings, "uint32_t", "subPixelInterpolationOffsetBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFramebufferWidth, settings, "uint32_t", "maxFramebufferWidth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFramebufferHeight, settings, "uint32_t", "maxFramebufferHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFramebufferLayers, settings, "uint32_t", "maxFramebufferLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlags>(object.framebufferColorSampleCounts, settings, "VkSampleCountFlags", "framebufferColorSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.framebufferDepthSampleCounts, settings, "VkSampleCountFlags", "framebufferDepthSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.framebufferStencilSampleCounts, settings, "VkSampleCountFlags", "framebufferStencilSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.framebufferNoAttachmentsSampleCounts, settings, "VkSampleCountFlags", "framebufferNoAttachmentsSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const uint32_t>(object.maxColorAttachments, settings, "uint32_t", "maxColorAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageColorSampleCounts, settings, "VkSampleCountFlags", "sampledImageColorSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageIntegerSampleCounts, settings, "VkSampleCountFlags", "sampledImageIntegerSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageDepthSampleCounts, settings, "VkSampleCountFlags", "sampledImageDepthSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageStencilSampleCounts, settings, "VkSampleCountFlags", "sampledImageStencilSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.storageImageSampleCounts, settings, "VkSampleCountFlags", "storageImageSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const uint32_t>(object.maxSampleMaskWords, settings, "uint32_t", "maxSampleMaskWords", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.timestampComputeAndGraphics, settings, "VkBool32", "timestampComputeAndGraphics", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.timestampPeriod, settings, "float", "timestampPeriod", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.maxClipDistances, settings, "uint32_t", "maxClipDistances", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxCullDistances, settings, "uint32_t", "maxCullDistances", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxCombinedClipAndCullDistances, settings, "uint32_t", "maxCombinedClipAndCullDistances", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.discreteQueuePriorities, settings, "uint32_t", "discreteQueuePriorities", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.pointSizeRange, 2, settings, "float[2]", "float", "pointSizeRange", indents + 1, dump_html_float); // ZRR
    dump_html_array<const float>(object.lineWidthRange, 2, settings, "float[2]", "float", "lineWidthRange", indents + 1, dump_html_float); // ZRR
    dump_html_value<const float>(object.pointSizeGranularity, settings, "float", "pointSizeGranularity", indents + 1, dump_html_float);
    dump_html_value<const float>(object.lineWidthGranularity, settings, "float", "lineWidthGranularity", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.strictLines, settings, "VkBool32", "strictLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.standardSampleLocations, settings, "VkBool32", "standardSampleLocations", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.optimalBufferCopyOffsetAlignment, settings, "VkDeviceSize", "optimalBufferCopyOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.optimalBufferCopyRowPitchAlignment, settings, "VkDeviceSize", "optimalBufferCopyRowPitchAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.nonCoherentAtomSize, settings, "VkDeviceSize", "nonCoherentAtomSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPhysicalDeviceMemoryProperties(const VkPhysicalDeviceMemoryProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.memoryTypeCount, settings, "uint32_t", "memoryTypeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMemoryType>(object.memoryTypes, object.memoryTypeCount, settings, "VkMemoryType[VK_MAX_MEMORY_TYPES]", "VkMemoryType", "memoryTypes", indents + 1, dump_html_VkMemoryType); // ZRT
    dump_html_value<const uint32_t>(object.memoryHeapCount, settings, "uint32_t", "memoryHeapCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMemoryHeap>(object.memoryHeaps, object.memoryHeapCount, settings, "VkMemoryHeap[VK_MAX_MEMORY_HEAPS]", "VkMemoryHeap", "memoryHeaps", indents + 1, dump_html_VkMemoryHeap); // ZRT
}
void dump_html_VkPhysicalDeviceSparseProperties(const VkPhysicalDeviceSparseProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.residencyStandard2DBlockShape, settings, "VkBool32", "residencyStandard2DBlockShape", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyStandard2DMultisampleBlockShape, settings, "VkBool32", "residencyStandard2DMultisampleBlockShape", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyStandard3DBlockShape, settings, "VkBool32", "residencyStandard3DBlockShape", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyAlignedMipSize, settings, "VkBool32", "residencyAlignedMipSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyNonResidentStrict, settings, "VkBool32", "residencyNonResidentStrict", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceProperties(const VkPhysicalDeviceProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.apiVersion, settings, "uint32_t", "apiVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.driverVersion, settings, "uint32_t", "driverVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vendorID, settings, "uint32_t", "vendorID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.deviceID, settings, "uint32_t", "deviceID", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPhysicalDeviceType>(object.deviceType, settings, "VkPhysicalDeviceType", "deviceType", indents + 1, dump_html_VkPhysicalDeviceType);
    dump_html_value<const char*>(object.deviceName, settings, "char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]", "deviceName", indents + 1, dump_html_cstring);
    dump_html_array<const uint8_t>(object.pipelineCacheUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "pipelineCacheUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_value<const VkPhysicalDeviceLimits>(object.limits, settings, "VkPhysicalDeviceLimits", "limits", indents + 1, dump_html_VkPhysicalDeviceLimits);
    dump_html_value<const VkPhysicalDeviceSparseProperties>(object.sparseProperties, settings, "VkPhysicalDeviceSparseProperties", "sparseProperties", indents + 1, dump_html_VkPhysicalDeviceSparseProperties);
}
void dump_html_VkQueueFamilyProperties(const VkQueueFamilyProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkQueueFlags>(object.queueFlags, settings, "VkQueueFlags", "queueFlags", indents + 1, dump_html_VkQueueFlags);
    dump_html_value<const uint32_t>(object.queueCount, settings, "uint32_t", "queueCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.timestampValidBits, settings, "uint32_t", "timestampValidBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent3D>(object.minImageTransferGranularity, settings, "VkExtent3D", "minImageTransferGranularity", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkDeviceQueueCreateInfo(const VkDeviceQueueCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceQueueCreateFlags>(object.flags, settings, "VkDeviceQueueCreateFlags", "flags", indents + 1, dump_html_VkDeviceQueueCreateFlags);
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.queueCount, settings, "uint32_t", "queueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.pQueuePriorities, object.queueCount, settings, "const float*", "const float", "pQueuePriorities", indents + 1, dump_html_float); // ZRT
}
void dump_html_VkDeviceCreateInfo(const VkDeviceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceCreateFlags>(object.flags, settings, "VkDeviceCreateFlags", "flags", indents + 1, dump_html_VkDeviceCreateFlags);
    dump_html_value<const uint32_t>(object.queueCreateInfoCount, settings, "uint32_t", "queueCreateInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceQueueCreateInfo>(object.pQueueCreateInfos, object.queueCreateInfoCount, settings, "const VkDeviceQueueCreateInfo*", "const VkDeviceQueueCreateInfo", "pQueueCreateInfos", indents + 1, dump_html_VkDeviceQueueCreateInfo); // ZRT
    dump_html_value<const uint32_t>(object.enabledLayerCount, settings, "uint32_t", "enabledLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledLayerNames, object.enabledLayerCount, settings, "const char* const*", "const char* const", "ppEnabledLayerNames", indents + 1, dump_html_cstring); // ZRT
    dump_html_value<const uint32_t>(object.enabledExtensionCount, settings, "uint32_t", "enabledExtensionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledExtensionNames, object.enabledExtensionCount, settings, "const char* const*", "const char* const", "ppEnabledExtensionNames", indents + 1, dump_html_cstring); // ZRT
    dump_html_pointer<const VkPhysicalDeviceFeatures>(object.pEnabledFeatures, settings, "const VkPhysicalDeviceFeatures*", "pEnabledFeatures", indents + 1, dump_html_VkPhysicalDeviceFeatures);
}
void dump_html_VkExtensionProperties(const VkExtensionProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const char*>(object.extensionName, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "extensionName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.specVersion, settings, "uint32_t", "specVersion", indents + 1, dump_html_uint32_t);
}
void dump_html_VkLayerProperties(const VkLayerProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const char*>(object.layerName, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "layerName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.specVersion, settings, "uint32_t", "specVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.implementationVersion, settings, "uint32_t", "implementationVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
}
void dump_html_VkSubmitInfo(const VkSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pWaitSemaphores, object.waitSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pWaitSemaphores", indents + 1, dump_html_VkSemaphore); // ZRT
    dump_html_array<const VkPipelineStageFlags>(object.pWaitDstStageMask, object.waitSemaphoreCount, settings, "const VkPipelineStageFlags*", "const VkPipelineStageFlags", "pWaitDstStageMask", indents + 1, dump_html_VkPipelineStageFlags); // ZRT
    dump_html_value<const uint32_t>(object.commandBufferCount, settings, "uint32_t", "commandBufferCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCommandBuffer>(object.pCommandBuffers, object.commandBufferCount, settings, "const VkCommandBuffer*", "const VkCommandBuffer", "pCommandBuffers", indents + 1, dump_html_VkCommandBuffer); // ZRT
    dump_html_value<const uint32_t>(object.signalSemaphoreCount, settings, "uint32_t", "signalSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pSignalSemaphores, object.signalSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pSignalSemaphores", indents + 1, dump_html_VkSemaphore); // ZRT
}
void dump_html_VkMappedMemoryRange(const VkMappedMemoryRange& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkMemoryAllocateInfo(const VkMemoryAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.allocationSize, settings, "VkDeviceSize", "allocationSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeIndex, settings, "uint32_t", "memoryTypeIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkMemoryRequirements(const VkMemoryRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.alignment, settings, "VkDeviceSize", "alignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
void dump_html_VkSparseMemoryBind(const VkSparseMemoryBind& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.resourceOffset, settings, "VkDeviceSize", "resourceOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkSparseMemoryBindFlags>(object.flags, settings, "VkSparseMemoryBindFlags", "flags", indents + 1, dump_html_VkSparseMemoryBindFlags);
}
void dump_html_VkSparseBufferMemoryBindInfo(const VkSparseBufferMemoryBindInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const uint32_t>(object.bindCount, settings, "uint32_t", "bindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseMemoryBind>(object.pBinds, object.bindCount, settings, "const VkSparseMemoryBind*", "const VkSparseMemoryBind", "pBinds", indents + 1, dump_html_VkSparseMemoryBind); // ZRT
}
void dump_html_VkSparseImageOpaqueMemoryBindInfo(const VkSparseImageOpaqueMemoryBindInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const uint32_t>(object.bindCount, settings, "uint32_t", "bindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseMemoryBind>(object.pBinds, object.bindCount, settings, "const VkSparseMemoryBind*", "const VkSparseMemoryBind", "pBinds", indents + 1, dump_html_VkSparseMemoryBind); // ZRT
}
void dump_html_VkImageSubresource(const VkImageSubresource& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.mipLevel, settings, "uint32_t", "mipLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.arrayLayer, settings, "uint32_t", "arrayLayer", indents + 1, dump_html_uint32_t);
}
void dump_html_VkSparseImageMemoryBind(const VkSparseImageMemoryBind& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresource>(object.subresource, settings, "VkImageSubresource", "subresource", indents + 1, dump_html_VkImageSubresource);
    dump_html_value<const VkOffset3D>(object.offset, settings, "VkOffset3D", "offset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkSparseMemoryBindFlags>(object.flags, settings, "VkSparseMemoryBindFlags", "flags", indents + 1, dump_html_VkSparseMemoryBindFlags);
}
void dump_html_VkSparseImageMemoryBindInfo(const VkSparseImageMemoryBindInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const uint32_t>(object.bindCount, settings, "uint32_t", "bindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseImageMemoryBind>(object.pBinds, object.bindCount, settings, "const VkSparseImageMemoryBind*", "const VkSparseImageMemoryBind", "pBinds", indents + 1, dump_html_VkSparseImageMemoryBind); // ZRT
}
void dump_html_VkBindSparseInfo(const VkBindSparseInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pWaitSemaphores, object.waitSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pWaitSemaphores", indents + 1, dump_html_VkSemaphore); // ZRT
    dump_html_value<const uint32_t>(object.bufferBindCount, settings, "uint32_t", "bufferBindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseBufferMemoryBindInfo>(object.pBufferBinds, object.bufferBindCount, settings, "const VkSparseBufferMemoryBindInfo*", "const VkSparseBufferMemoryBindInfo", "pBufferBinds", indents + 1, dump_html_VkSparseBufferMemoryBindInfo); // ZRT
    dump_html_value<const uint32_t>(object.imageOpaqueBindCount, settings, "uint32_t", "imageOpaqueBindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseImageOpaqueMemoryBindInfo>(object.pImageOpaqueBinds, object.imageOpaqueBindCount, settings, "const VkSparseImageOpaqueMemoryBindInfo*", "const VkSparseImageOpaqueMemoryBindInfo", "pImageOpaqueBinds", indents + 1, dump_html_VkSparseImageOpaqueMemoryBindInfo); // ZRT
    dump_html_value<const uint32_t>(object.imageBindCount, settings, "uint32_t", "imageBindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseImageMemoryBindInfo>(object.pImageBinds, object.imageBindCount, settings, "const VkSparseImageMemoryBindInfo*", "const VkSparseImageMemoryBindInfo", "pImageBinds", indents + 1, dump_html_VkSparseImageMemoryBindInfo); // ZRT
    dump_html_value<const uint32_t>(object.signalSemaphoreCount, settings, "uint32_t", "signalSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pSignalSemaphores, object.signalSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pSignalSemaphores", indents + 1, dump_html_VkSemaphore); // ZRT
}
void dump_html_VkSparseImageFormatProperties(const VkSparseImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const VkExtent3D>(object.imageGranularity, settings, "VkExtent3D", "imageGranularity", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const VkSparseImageFormatFlags>(object.flags, settings, "VkSparseImageFormatFlags", "flags", indents + 1, dump_html_VkSparseImageFormatFlags);
}
void dump_html_VkSparseImageMemoryRequirements(const VkSparseImageMemoryRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSparseImageFormatProperties>(object.formatProperties, settings, "VkSparseImageFormatProperties", "formatProperties", indents + 1, dump_html_VkSparseImageFormatProperties);
    dump_html_value<const uint32_t>(object.imageMipTailFirstLod, settings, "uint32_t", "imageMipTailFirstLod", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.imageMipTailSize, settings, "VkDeviceSize", "imageMipTailSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.imageMipTailOffset, settings, "VkDeviceSize", "imageMipTailOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.imageMipTailStride, settings, "VkDeviceSize", "imageMipTailStride", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkFenceCreateInfo(const VkFenceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFenceCreateFlags>(object.flags, settings, "VkFenceCreateFlags", "flags", indents + 1, dump_html_VkFenceCreateFlags);
}
void dump_html_VkSemaphoreCreateInfo(const VkSemaphoreCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphoreCreateFlags>(object.flags, settings, "VkSemaphoreCreateFlags", "flags", indents + 1, dump_html_VkSemaphoreCreateFlags);
}
void dump_html_VkEventCreateInfo(const VkEventCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkEventCreateFlags>(object.flags, settings, "VkEventCreateFlags", "flags", indents + 1, dump_html_VkEventCreateFlags);
}
void dump_html_VkQueryPoolCreateInfo(const VkQueryPoolCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueryPoolCreateFlags>(object.flags, settings, "VkQueryPoolCreateFlags", "flags", indents + 1, dump_html_VkQueryPoolCreateFlags);
    dump_html_value<const VkQueryType>(object.queryType, settings, "VkQueryType", "queryType", indents + 1, dump_html_VkQueryType);
    dump_html_value<const uint32_t>(object.queryCount, settings, "uint32_t", "queryCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkQueryPipelineStatisticFlags>(object.pipelineStatistics, settings, "VkQueryPipelineStatisticFlags", "pipelineStatistics", indents + 1, dump_html_VkQueryPipelineStatisticFlags);
}
void dump_html_VkBufferCreateInfo(const VkBufferCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCreateFlags>(object.flags, settings, "VkBufferCreateFlags", "flags", indents + 1, dump_html_VkBufferCreateFlags);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBufferUsageFlags>(object.usage, settings, "VkBufferUsageFlags", "usage", indents + 1, dump_html_VkBufferUsageFlags);
    dump_html_value<const VkSharingMode>(object.sharingMode, settings, "VkSharingMode", "sharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    if(object.sharingMode == VK_SHARING_MODE_CONCURRENT)
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t); // ZRT
    else
        dump_html_special("UNUSED", settings, "const uint32_t*", "pQueueFamilyIndices", indents + 1);
}
void dump_html_VkBufferViewCreateInfo(const VkBufferViewCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferViewCreateFlags>(object.flags, settings, "VkBufferViewCreateFlags", "flags", indents + 1, dump_html_VkBufferViewCreateFlags);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.range, settings, "VkDeviceSize", "range", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkImageCreateInfo(const VkImageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCreateFlags>(object.flags, settings, "VkImageCreateFlags", "flags", indents + 1, dump_html_VkImageCreateFlags);
    dump_html_value<const VkImageType>(object.imageType, settings, "VkImageType", "imageType", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const uint32_t>(object.mipLevels, settings, "uint32_t", "mipLevels", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.arrayLayers, settings, "uint32_t", "arrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkImageTiling>(object.tiling, settings, "VkImageTiling", "tiling", indents + 1, dump_html_VkImageTiling);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkSharingMode>(object.sharingMode, settings, "VkSharingMode", "sharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    if(object.sharingMode == VK_SHARING_MODE_CONCURRENT)
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t); // ZRT
    else
        dump_html_special("UNUSED", settings, "const uint32_t*", "pQueueFamilyIndices", indents + 1);
    dump_html_value<const VkImageLayout>(object.initialLayout, settings, "VkImageLayout", "initialLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkSubresourceLayout(const VkSubresourceLayout& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.rowPitch, settings, "VkDeviceSize", "rowPitch", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.arrayPitch, settings, "VkDeviceSize", "arrayPitch", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.depthPitch, settings, "VkDeviceSize", "depthPitch", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkComponentMapping(const VkComponentMapping& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkComponentSwizzle>(object.r, settings, "VkComponentSwizzle", "r", indents + 1, dump_html_VkComponentSwizzle);
    dump_html_value<const VkComponentSwizzle>(object.g, settings, "VkComponentSwizzle", "g", indents + 1, dump_html_VkComponentSwizzle);
    dump_html_value<const VkComponentSwizzle>(object.b, settings, "VkComponentSwizzle", "b", indents + 1, dump_html_VkComponentSwizzle);
    dump_html_value<const VkComponentSwizzle>(object.a, settings, "VkComponentSwizzle", "a", indents + 1, dump_html_VkComponentSwizzle);
}
void dump_html_VkImageViewCreateInfo(const VkImageViewCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageViewCreateFlags>(object.flags, settings, "VkImageViewCreateFlags", "flags", indents + 1, dump_html_VkImageViewCreateFlags);
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageViewType>(object.viewType, settings, "VkImageViewType", "viewType", indents + 1, dump_html_VkImageViewType);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkComponentMapping>(object.components, settings, "VkComponentMapping", "components", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkImageSubresourceRange>(object.subresourceRange, settings, "VkImageSubresourceRange", "subresourceRange", indents + 1, dump_html_VkImageSubresourceRange);
}
void dump_html_VkShaderModuleCreateInfo(const VkShaderModuleCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderModuleCreateFlags>(object.flags, settings, "VkShaderModuleCreateFlags", "flags", indents + 1, dump_html_VkShaderModuleCreateFlags);
    dump_html_value<const size_t>(object.codeSize, settings, "size_t", "codeSize", indents + 1, dump_html_size_t);
    if(settings.showShader())
        dump_html_array<const uint32_t>(object.pCode, object.codeSize / 4, settings, "const uint32_t*", "const uint32_t", "pCode", indents + 1, dump_html_uint32_t); // ZRU
    else
        dump_html_special("SHADER DATA", settings, "const uint32_t*", "pCode", indents + 1);
}
void dump_html_VkPipelineCacheCreateInfo(const VkPipelineCacheCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCacheCreateFlags>(object.flags, settings, "VkPipelineCacheCreateFlags", "flags", indents + 1, dump_html_VkPipelineCacheCreateFlags);
    dump_html_value<const size_t>(object.initialDataSize, settings, "size_t", "initialDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pInitialData, settings, "const void*", "pInitialData", indents + 1, dump_html_void);
}
void dump_html_VkSpecializationMapEntry(const VkSpecializationMapEntry& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.constantID, settings, "uint32_t", "constantID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.size, settings, "size_t", "size", indents + 1, dump_html_size_t);
}
void dump_html_VkSpecializationInfo(const VkSpecializationInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.mapEntryCount, settings, "uint32_t", "mapEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSpecializationMapEntry>(object.pMapEntries, object.mapEntryCount, settings, "const VkSpecializationMapEntry*", "const VkSpecializationMapEntry", "pMapEntries", indents + 1, dump_html_VkSpecializationMapEntry); // ZRT
    dump_html_value<const size_t>(object.dataSize, settings, "size_t", "dataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
}
void dump_html_VkPipelineShaderStageCreateInfo(const VkPipelineShaderStageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineShaderStageCreateFlags>(object.flags, settings, "VkPipelineShaderStageCreateFlags", "flags", indents + 1, dump_html_VkPipelineShaderStageCreateFlags);
    dump_html_value<const VkShaderStageFlagBits>(object.stage, settings, "VkShaderStageFlagBits", "stage", indents + 1, dump_html_VkShaderStageFlagBits);
    dump_html_value<const VkShaderModule>(object.module, settings, "VkShaderModule", "module", indents + 1, dump_html_VkShaderModule);
    dump_html_value<const char*>(object.pName, settings, "const char*", "pName", indents + 1, dump_html_cstring);
    dump_html_pointer<const VkSpecializationInfo>(object.pSpecializationInfo, settings, "const VkSpecializationInfo*", "pSpecializationInfo", indents + 1, dump_html_VkSpecializationInfo);
}
void dump_html_VkComputePipelineCreateInfo(const VkComputePipelineCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const VkPipelineShaderStageCreateInfo>(object.stage, settings, "VkPipelineShaderStageCreateInfo", "stage", indents + 1, dump_html_VkPipelineShaderStageCreateInfo);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
}
void dump_html_VkVertexInputBindingDescription(const VkVertexInputBindingDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stride, settings, "uint32_t", "stride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkVertexInputRate>(object.inputRate, settings, "VkVertexInputRate", "inputRate", indents + 1, dump_html_VkVertexInputRate);
}
void dump_html_VkVertexInputAttributeDescription(const VkVertexInputAttributeDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.location, settings, "uint32_t", "location", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineVertexInputStateCreateInfo(const VkPipelineVertexInputStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineVertexInputStateCreateFlags>(object.flags, settings, "VkPipelineVertexInputStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineVertexInputStateCreateFlags);
    dump_html_value<const uint32_t>(object.vertexBindingDescriptionCount, settings, "uint32_t", "vertexBindingDescriptionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVertexInputBindingDescription>(object.pVertexBindingDescriptions, object.vertexBindingDescriptionCount, settings, "const VkVertexInputBindingDescription*", "const VkVertexInputBindingDescription", "pVertexBindingDescriptions", indents + 1, dump_html_VkVertexInputBindingDescription); // ZRT
    dump_html_value<const uint32_t>(object.vertexAttributeDescriptionCount, settings, "uint32_t", "vertexAttributeDescriptionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVertexInputAttributeDescription>(object.pVertexAttributeDescriptions, object.vertexAttributeDescriptionCount, settings, "const VkVertexInputAttributeDescription*", "const VkVertexInputAttributeDescription", "pVertexAttributeDescriptions", indents + 1, dump_html_VkVertexInputAttributeDescription); // ZRT
}
void dump_html_VkPipelineInputAssemblyStateCreateInfo(const VkPipelineInputAssemblyStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineInputAssemblyStateCreateFlags>(object.flags, settings, "VkPipelineInputAssemblyStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineInputAssemblyStateCreateFlags);
    dump_html_value<const VkPrimitiveTopology>(object.topology, settings, "VkPrimitiveTopology", "topology", indents + 1, dump_html_VkPrimitiveTopology);
    dump_html_value<const VkBool32>(object.primitiveRestartEnable, settings, "VkBool32", "primitiveRestartEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineTessellationStateCreateInfo(const VkPipelineTessellationStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineTessellationStateCreateFlags>(object.flags, settings, "VkPipelineTessellationStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineTessellationStateCreateFlags);
    dump_html_value<const uint32_t>(object.patchControlPoints, settings, "uint32_t", "patchControlPoints", indents + 1, dump_html_uint32_t);
}
void dump_html_VkViewport(const VkViewport& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.x, settings, "float", "x", indents + 1, dump_html_float);
    dump_html_value<const float>(object.y, settings, "float", "y", indents + 1, dump_html_float);
    dump_html_value<const float>(object.width, settings, "float", "width", indents + 1, dump_html_float);
    dump_html_value<const float>(object.height, settings, "float", "height", indents + 1, dump_html_float);
    dump_html_value<const float>(object.minDepth, settings, "float", "minDepth", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxDepth, settings, "float", "maxDepth", indents + 1, dump_html_float);
}
void dump_html_VkPipelineViewportStateCreateInfo(const VkPipelineViewportStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineViewportStateCreateFlags>(object.flags, settings, "VkPipelineViewportStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineViewportStateCreateFlags);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    if(!ApiDumpInstance::current().getIsDynamicViewport())
    dump_html_array<const VkViewport>(object.pViewports, object.viewportCount, settings, "const VkViewport*", "const VkViewport", "pViewports", indents + 1, dump_html_VkViewport); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkViewport*", "pViewports", indents + 1);
    dump_html_value<const uint32_t>(object.scissorCount, settings, "uint32_t", "scissorCount", indents + 1, dump_html_uint32_t);
    if(!ApiDumpInstance::current().getIsDynamicScissor())
    dump_html_array<const VkRect2D>(object.pScissors, object.scissorCount, settings, "const VkRect2D*", "const VkRect2D", "pScissors", indents + 1, dump_html_VkRect2D); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkRect2D*", "pScissors", indents + 1);
}
void dump_html_VkPipelineRasterizationStateCreateInfo(const VkPipelineRasterizationStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationStateCreateFlags>(object.flags, settings, "VkPipelineRasterizationStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineRasterizationStateCreateFlags);
    dump_html_value<const VkBool32>(object.depthClampEnable, settings, "VkBool32", "depthClampEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rasterizerDiscardEnable, settings, "VkBool32", "rasterizerDiscardEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkPolygonMode>(object.polygonMode, settings, "VkPolygonMode", "polygonMode", indents + 1, dump_html_VkPolygonMode);
    dump_html_value<const VkCullModeFlags>(object.cullMode, settings, "VkCullModeFlags", "cullMode", indents + 1, dump_html_VkCullModeFlags);
    dump_html_value<const VkFrontFace>(object.frontFace, settings, "VkFrontFace", "frontFace", indents + 1, dump_html_VkFrontFace);
    dump_html_value<const VkBool32>(object.depthBiasEnable, settings, "VkBool32", "depthBiasEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.depthBiasConstantFactor, settings, "float", "depthBiasConstantFactor", indents + 1, dump_html_float);
    dump_html_value<const float>(object.depthBiasClamp, settings, "float", "depthBiasClamp", indents + 1, dump_html_float);
    dump_html_value<const float>(object.depthBiasSlopeFactor, settings, "float", "depthBiasSlopeFactor", indents + 1, dump_html_float);
    dump_html_value<const float>(object.lineWidth, settings, "float", "lineWidth", indents + 1, dump_html_float);
}
void dump_html_VkPipelineMultisampleStateCreateInfo(const VkPipelineMultisampleStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineMultisampleStateCreateFlags>(object.flags, settings, "VkPipelineMultisampleStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineMultisampleStateCreateFlags);
    dump_html_value<const VkSampleCountFlagBits>(object.rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkBool32>(object.sampleShadingEnable, settings, "VkBool32", "sampleShadingEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.minSampleShading, settings, "float", "minSampleShading", indents + 1, dump_html_float);
    dump_html_array<const VkSampleMask>(object.pSampleMask, (object.rasterizationSamples + 31) / 32, settings, "const VkSampleMask*", "const VkSampleMask", "pSampleMask", indents + 1, dump_html_VkSampleMask); // ZRT
    dump_html_value<const VkBool32>(object.alphaToCoverageEnable, settings, "VkBool32", "alphaToCoverageEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.alphaToOneEnable, settings, "VkBool32", "alphaToOneEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkStencilOpState(const VkStencilOpState& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStencilOp>(object.failOp, settings, "VkStencilOp", "failOp", indents + 1, dump_html_VkStencilOp);
    dump_html_value<const VkStencilOp>(object.passOp, settings, "VkStencilOp", "passOp", indents + 1, dump_html_VkStencilOp);
    dump_html_value<const VkStencilOp>(object.depthFailOp, settings, "VkStencilOp", "depthFailOp", indents + 1, dump_html_VkStencilOp);
    dump_html_value<const VkCompareOp>(object.compareOp, settings, "VkCompareOp", "compareOp", indents + 1, dump_html_VkCompareOp);
    dump_html_value<const uint32_t>(object.compareMask, settings, "uint32_t", "compareMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.writeMask, settings, "uint32_t", "writeMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.reference, settings, "uint32_t", "reference", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineDepthStencilStateCreateInfo(const VkPipelineDepthStencilStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineDepthStencilStateCreateFlags>(object.flags, settings, "VkPipelineDepthStencilStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineDepthStencilStateCreateFlags);
    dump_html_value<const VkBool32>(object.depthTestEnable, settings, "VkBool32", "depthTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthWriteEnable, settings, "VkBool32", "depthWriteEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkCompareOp>(object.depthCompareOp, settings, "VkCompareOp", "depthCompareOp", indents + 1, dump_html_VkCompareOp);
    dump_html_value<const VkBool32>(object.depthBoundsTestEnable, settings, "VkBool32", "depthBoundsTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stencilTestEnable, settings, "VkBool32", "stencilTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkStencilOpState>(object.front, settings, "VkStencilOpState", "front", indents + 1, dump_html_VkStencilOpState);
    dump_html_value<const VkStencilOpState>(object.back, settings, "VkStencilOpState", "back", indents + 1, dump_html_VkStencilOpState);
    dump_html_value<const float>(object.minDepthBounds, settings, "float", "minDepthBounds", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxDepthBounds, settings, "float", "maxDepthBounds", indents + 1, dump_html_float);
}
void dump_html_VkPipelineColorBlendAttachmentState(const VkPipelineColorBlendAttachmentState& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.blendEnable, settings, "VkBool32", "blendEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBlendFactor>(object.srcColorBlendFactor, settings, "VkBlendFactor", "srcColorBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendFactor>(object.dstColorBlendFactor, settings, "VkBlendFactor", "dstColorBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendOp>(object.colorBlendOp, settings, "VkBlendOp", "colorBlendOp", indents + 1, dump_html_VkBlendOp);
    dump_html_value<const VkBlendFactor>(object.srcAlphaBlendFactor, settings, "VkBlendFactor", "srcAlphaBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendFactor>(object.dstAlphaBlendFactor, settings, "VkBlendFactor", "dstAlphaBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendOp>(object.alphaBlendOp, settings, "VkBlendOp", "alphaBlendOp", indents + 1, dump_html_VkBlendOp);
    dump_html_value<const VkColorComponentFlags>(object.colorWriteMask, settings, "VkColorComponentFlags", "colorWriteMask", indents + 1, dump_html_VkColorComponentFlags);
}
void dump_html_VkPipelineColorBlendStateCreateInfo(const VkPipelineColorBlendStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineColorBlendStateCreateFlags>(object.flags, settings, "VkPipelineColorBlendStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineColorBlendStateCreateFlags);
    dump_html_value<const VkBool32>(object.logicOpEnable, settings, "VkBool32", "logicOpEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkLogicOp>(object.logicOp, settings, "VkLogicOp", "logicOp", indents + 1, dump_html_VkLogicOp);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineColorBlendAttachmentState>(object.pAttachments, object.attachmentCount, settings, "const VkPipelineColorBlendAttachmentState*", "const VkPipelineColorBlendAttachmentState", "pAttachments", indents + 1, dump_html_VkPipelineColorBlendAttachmentState); // ZRT
    dump_html_array<const float>(object.blendConstants, 4, settings, "float[4]", "float", "blendConstants", indents + 1, dump_html_float); // ZRR
}
void dump_html_VkPipelineDynamicStateCreateInfo(const VkPipelineDynamicStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineDynamicStateCreateFlags>(object.flags, settings, "VkPipelineDynamicStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineDynamicStateCreateFlags);
    dump_html_value<const uint32_t>(object.dynamicStateCount, settings, "uint32_t", "dynamicStateCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDynamicState>(object.pDynamicStates, object.dynamicStateCount, settings, "const VkDynamicState*", "const VkDynamicState", "pDynamicStates", indents + 1, dump_html_VkDynamicState); // ZRT
}
void dump_html_VkGraphicsPipelineCreateInfo(const VkGraphicsPipelineCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    ApiDumpInstance::current().setIsDynamicViewport(object.pDynamicState && std::count(object.pDynamicState->pDynamicStates, object.pDynamicState->pDynamicStates + object.pDynamicState->dynamicStateCount, VK_DYNAMIC_STATE_VIEWPORT) > 0);ApiDumpInstance::current().setIsDynamicScissor(object.pDynamicState && std::count(object.pDynamicState->pDynamicStates, object.pDynamicState->pDynamicStates + object.pDynamicState->dynamicStateCount, VK_DYNAMIC_STATE_SCISSOR));ApiDumpInstance::current().setIsGPLPreRasterOrFragmentShader(checkForGPLPreRasterOrFragmentShader(object));
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo); // ZRT
    dump_html_pointer<const VkPipelineVertexInputStateCreateInfo>(object.pVertexInputState, settings, "const VkPipelineVertexInputStateCreateInfo*", "pVertexInputState", indents + 1, dump_html_VkPipelineVertexInputStateCreateInfo);
    dump_html_pointer<const VkPipelineInputAssemblyStateCreateInfo>(object.pInputAssemblyState, settings, "const VkPipelineInputAssemblyStateCreateInfo*", "pInputAssemblyState", indents + 1, dump_html_VkPipelineInputAssemblyStateCreateInfo);
    dump_html_pointer<const VkPipelineTessellationStateCreateInfo>(object.pTessellationState, settings, "const VkPipelineTessellationStateCreateInfo*", "pTessellationState", indents + 1, dump_html_VkPipelineTessellationStateCreateInfo);
    dump_html_pointer<const VkPipelineViewportStateCreateInfo>(object.pViewportState, settings, "const VkPipelineViewportStateCreateInfo*", "pViewportState", indents + 1, dump_html_VkPipelineViewportStateCreateInfo);
    dump_html_pointer<const VkPipelineRasterizationStateCreateInfo>(object.pRasterizationState, settings, "const VkPipelineRasterizationStateCreateInfo*", "pRasterizationState", indents + 1, dump_html_VkPipelineRasterizationStateCreateInfo);
    dump_html_pointer<const VkPipelineMultisampleStateCreateInfo>(object.pMultisampleState, settings, "const VkPipelineMultisampleStateCreateInfo*", "pMultisampleState", indents + 1, dump_html_VkPipelineMultisampleStateCreateInfo);
    dump_html_pointer<const VkPipelineDepthStencilStateCreateInfo>(object.pDepthStencilState, settings, "const VkPipelineDepthStencilStateCreateInfo*", "pDepthStencilState", indents + 1, dump_html_VkPipelineDepthStencilStateCreateInfo);
    dump_html_pointer<const VkPipelineColorBlendStateCreateInfo>(object.pColorBlendState, settings, "const VkPipelineColorBlendStateCreateInfo*", "pColorBlendState", indents + 1, dump_html_VkPipelineColorBlendStateCreateInfo);
    dump_html_pointer<const VkPipelineDynamicStateCreateInfo>(object.pDynamicState, settings, "const VkPipelineDynamicStateCreateInfo*", "pDynamicState", indents + 1, dump_html_VkPipelineDynamicStateCreateInfo);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
}
void dump_html_VkPushConstantRange(const VkPushConstantRange& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.size, settings, "uint32_t", "size", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineLayoutCreateInfo(const VkPipelineLayoutCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineLayoutCreateFlags>(object.flags, settings, "VkPipelineLayoutCreateFlags", "flags", indents + 1, dump_html_VkPipelineLayoutCreateFlags);
    dump_html_value<const uint32_t>(object.setLayoutCount, settings, "uint32_t", "setLayoutCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayout>(object.pSetLayouts, object.setLayoutCount, settings, "const VkDescriptorSetLayout*", "const VkDescriptorSetLayout", "pSetLayouts", indents + 1, dump_html_VkDescriptorSetLayout); // ZRT
    dump_html_value<const uint32_t>(object.pushConstantRangeCount, settings, "uint32_t", "pushConstantRangeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPushConstantRange>(object.pPushConstantRanges, object.pushConstantRangeCount, settings, "const VkPushConstantRange*", "const VkPushConstantRange", "pPushConstantRanges", indents + 1, dump_html_VkPushConstantRange); // ZRT
}
void dump_html_VkSamplerCreateInfo(const VkSamplerCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSamplerCreateFlags>(object.flags, settings, "VkSamplerCreateFlags", "flags", indents + 1, dump_html_VkSamplerCreateFlags);
    dump_html_value<const VkFilter>(object.magFilter, settings, "VkFilter", "magFilter", indents + 1, dump_html_VkFilter);
    dump_html_value<const VkFilter>(object.minFilter, settings, "VkFilter", "minFilter", indents + 1, dump_html_VkFilter);
    dump_html_value<const VkSamplerMipmapMode>(object.mipmapMode, settings, "VkSamplerMipmapMode", "mipmapMode", indents + 1, dump_html_VkSamplerMipmapMode);
    dump_html_value<const VkSamplerAddressMode>(object.addressModeU, settings, "VkSamplerAddressMode", "addressModeU", indents + 1, dump_html_VkSamplerAddressMode);
    dump_html_value<const VkSamplerAddressMode>(object.addressModeV, settings, "VkSamplerAddressMode", "addressModeV", indents + 1, dump_html_VkSamplerAddressMode);
    dump_html_value<const VkSamplerAddressMode>(object.addressModeW, settings, "VkSamplerAddressMode", "addressModeW", indents + 1, dump_html_VkSamplerAddressMode);
    dump_html_value<const float>(object.mipLodBias, settings, "float", "mipLodBias", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.anisotropyEnable, settings, "VkBool32", "anisotropyEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.maxAnisotropy, settings, "float", "maxAnisotropy", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.compareEnable, settings, "VkBool32", "compareEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkCompareOp>(object.compareOp, settings, "VkCompareOp", "compareOp", indents + 1, dump_html_VkCompareOp);
    dump_html_value<const float>(object.minLod, settings, "float", "minLod", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxLod, settings, "float", "maxLod", indents + 1, dump_html_float);
    dump_html_value<const VkBorderColor>(object.borderColor, settings, "VkBorderColor", "borderColor", indents + 1, dump_html_VkBorderColor);
    dump_html_value<const VkBool32>(object.unnormalizedCoordinates, settings, "VkBool32", "unnormalizedCoordinates", indents + 1, dump_html_VkBool32);
}
void dump_html_VkCopyDescriptorSet(const VkCopyDescriptorSet& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSet>(object.srcSet, settings, "VkDescriptorSet", "srcSet", indents + 1, dump_html_VkDescriptorSet);
    dump_html_value<const uint32_t>(object.srcBinding, settings, "uint32_t", "srcBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.srcArrayElement, settings, "uint32_t", "srcArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorSet>(object.dstSet, settings, "VkDescriptorSet", "dstSet", indents + 1, dump_html_VkDescriptorSet);
    dump_html_value<const uint32_t>(object.dstBinding, settings, "uint32_t", "dstBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstArrayElement, settings, "uint32_t", "dstArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDescriptorBufferInfo(const VkDescriptorBufferInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.range, settings, "VkDeviceSize", "range", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkDescriptorImageInfo(const VkDescriptorImageInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSampler>(object.sampler, settings, "VkSampler", "sampler", indents + 1, dump_html_VkSampler);
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkImageLayout>(object.imageLayout, settings, "VkImageLayout", "imageLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkDescriptorPoolSize(const VkDescriptorPoolSize& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDescriptorType>(object.type, settings, "VkDescriptorType", "type", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDescriptorPoolCreateInfo(const VkDescriptorPoolCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorPoolCreateFlags>(object.flags, settings, "VkDescriptorPoolCreateFlags", "flags", indents + 1, dump_html_VkDescriptorPoolCreateFlags);
    dump_html_value<const uint32_t>(object.maxSets, settings, "uint32_t", "maxSets", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.poolSizeCount, settings, "uint32_t", "poolSizeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorPoolSize>(object.pPoolSizes, object.poolSizeCount, settings, "const VkDescriptorPoolSize*", "const VkDescriptorPoolSize", "pPoolSizes", indents + 1, dump_html_VkDescriptorPoolSize); // ZRT
}
void dump_html_VkDescriptorSetAllocateInfo(const VkDescriptorSetAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorPool>(object.descriptorPool, settings, "VkDescriptorPool", "descriptorPool", indents + 1, dump_html_VkDescriptorPool);
    dump_html_value<const uint32_t>(object.descriptorSetCount, settings, "uint32_t", "descriptorSetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayout>(object.pSetLayouts, object.descriptorSetCount, settings, "const VkDescriptorSetLayout*", "const VkDescriptorSetLayout", "pSetLayouts", indents + 1, dump_html_VkDescriptorSetLayout); // ZRT
}
void dump_html_VkDescriptorSetLayoutBinding(const VkDescriptorSetLayoutBinding& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER))
    dump_html_array<const VkSampler>(object.pImmutableSamplers, object.descriptorCount, settings, "const VkSampler*", "const VkSampler", "pImmutableSamplers", indents + 1, dump_html_VkSampler); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkSampler*", "pImmutableSamplers", indents + 1);
}
void dump_html_VkDescriptorSetLayoutCreateInfo(const VkDescriptorSetLayoutCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSetLayoutCreateFlags>(object.flags, settings, "VkDescriptorSetLayoutCreateFlags", "flags", indents + 1, dump_html_VkDescriptorSetLayoutCreateFlags);
    dump_html_value<const uint32_t>(object.bindingCount, settings, "uint32_t", "bindingCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayoutBinding>(object.pBindings, object.bindingCount, settings, "const VkDescriptorSetLayoutBinding*", "const VkDescriptorSetLayoutBinding", "pBindings", indents + 1, dump_html_VkDescriptorSetLayoutBinding); // ZRT
}
void dump_html_VkWriteDescriptorSet(const VkWriteDescriptorSet& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSet>(object.dstSet, settings, "VkDescriptorSet", "dstSet", indents + 1, dump_html_VkDescriptorSet);
    dump_html_value<const uint32_t>(object.dstBinding, settings, "uint32_t", "dstBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstArrayElement, settings, "uint32_t", "dstArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE) || (object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) || (object.descriptorType == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT))
    dump_html_array<const VkDescriptorImageInfo>(object.pImageInfo, object.descriptorCount, settings, "const VkDescriptorImageInfo*", "const VkDescriptorImageInfo", "pImageInfo", indents + 1, dump_html_VkDescriptorImageInfo); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkDescriptorImageInfo*", "pImageInfo", indents + 1);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC) || (object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC))
    dump_html_array<const VkDescriptorBufferInfo>(object.pBufferInfo, object.descriptorCount, settings, "const VkDescriptorBufferInfo*", "const VkDescriptorBufferInfo", "pBufferInfo", indents + 1, dump_html_VkDescriptorBufferInfo); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkDescriptorBufferInfo*", "pBufferInfo", indents + 1);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER))
    dump_html_array<const VkBufferView>(object.pTexelBufferView, object.descriptorCount, settings, "const VkBufferView*", "const VkBufferView", "pTexelBufferView", indents + 1, dump_html_VkBufferView); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkBufferView*", "pTexelBufferView", indents + 1);
}
void dump_html_VkAttachmentDescription(const VkAttachmentDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkAttachmentDescriptionFlags>(object.flags, settings, "VkAttachmentDescriptionFlags", "flags", indents + 1, dump_html_VkAttachmentDescriptionFlags);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkAttachmentLoadOp>(object.loadOp, settings, "VkAttachmentLoadOp", "loadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.storeOp, settings, "VkAttachmentStoreOp", "storeOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkAttachmentLoadOp>(object.stencilLoadOp, settings, "VkAttachmentLoadOp", "stencilLoadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.stencilStoreOp, settings, "VkAttachmentStoreOp", "stencilStoreOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkImageLayout>(object.initialLayout, settings, "VkImageLayout", "initialLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.finalLayout, settings, "VkImageLayout", "finalLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkAttachmentReference(const VkAttachmentReference& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.attachment, settings, "uint32_t", "attachment", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageLayout>(object.layout, settings, "VkImageLayout", "layout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkFramebufferCreateInfo(const VkFramebufferCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFramebufferCreateFlags>(object.flags, settings, "VkFramebufferCreateFlags", "flags", indents + 1, dump_html_VkFramebufferCreateFlags);
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageView>(object.pAttachments, object.attachmentCount, settings, "const VkImageView*", "const VkImageView", "pAttachments", indents + 1, dump_html_VkImageView); // ZRT
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layers, settings, "uint32_t", "layers", indents + 1, dump_html_uint32_t);
}
void dump_html_VkSubpassDescription(const VkSubpassDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSubpassDescriptionFlags>(object.flags, settings, "VkSubpassDescriptionFlags", "flags", indents + 1, dump_html_VkSubpassDescriptionFlags);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const uint32_t>(object.inputAttachmentCount, settings, "uint32_t", "inputAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference>(object.pInputAttachments, object.inputAttachmentCount, settings, "const VkAttachmentReference*", "const VkAttachmentReference", "pInputAttachments", indents + 1, dump_html_VkAttachmentReference); // ZRT
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference>(object.pColorAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference*", "const VkAttachmentReference", "pColorAttachments", indents + 1, dump_html_VkAttachmentReference); // ZRT
    dump_html_array<const VkAttachmentReference>(object.pResolveAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference*", "const VkAttachmentReference", "pResolveAttachments", indents + 1, dump_html_VkAttachmentReference); // ZRT
    dump_html_pointer<const VkAttachmentReference>(object.pDepthStencilAttachment, settings, "const VkAttachmentReference*", "pDepthStencilAttachment", indents + 1, dump_html_VkAttachmentReference);
    dump_html_value<const uint32_t>(object.preserveAttachmentCount, settings, "uint32_t", "preserveAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pPreserveAttachments, object.preserveAttachmentCount, settings, "const uint32_t*", "const uint32_t", "pPreserveAttachments", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkSubpassDependency(const VkSubpassDependency& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.srcSubpass, settings, "uint32_t", "srcSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstSubpass, settings, "uint32_t", "dstSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineStageFlags>(object.srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkPipelineStageFlags>(object.dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkDependencyFlags>(object.dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", indents + 1, dump_html_VkDependencyFlags);
}
void dump_html_VkRenderPassCreateInfo(const VkRenderPassCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPassCreateFlags>(object.flags, settings, "VkRenderPassCreateFlags", "flags", indents + 1, dump_html_VkRenderPassCreateFlags);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentDescription>(object.pAttachments, object.attachmentCount, settings, "const VkAttachmentDescription*", "const VkAttachmentDescription", "pAttachments", indents + 1, dump_html_VkAttachmentDescription); // ZRT
    dump_html_value<const uint32_t>(object.subpassCount, settings, "uint32_t", "subpassCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDescription>(object.pSubpasses, object.subpassCount, settings, "const VkSubpassDescription*", "const VkSubpassDescription", "pSubpasses", indents + 1, dump_html_VkSubpassDescription); // ZRT
    dump_html_value<const uint32_t>(object.dependencyCount, settings, "uint32_t", "dependencyCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDependency>(object.pDependencies, object.dependencyCount, settings, "const VkSubpassDependency*", "const VkSubpassDependency", "pDependencies", indents + 1, dump_html_VkSubpassDependency); // ZRT
}
void dump_html_VkCommandPoolCreateInfo(const VkCommandPoolCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandPoolCreateFlags>(object.flags, settings, "VkCommandPoolCreateFlags", "flags", indents + 1, dump_html_VkCommandPoolCreateFlags);
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCommandBufferAllocateInfo(const VkCommandBufferAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandPool>(object.commandPool, settings, "VkCommandPool", "commandPool", indents + 1, dump_html_VkCommandPool);
    dump_html_value<const VkCommandBufferLevel>(object.level, settings, "VkCommandBufferLevel", "level", indents + 1, dump_html_VkCommandBufferLevel);
    dump_html_value<const uint32_t>(object.commandBufferCount, settings, "uint32_t", "commandBufferCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCommandBufferInheritanceInfo(const VkCommandBufferInheritanceInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFramebuffer>(object.framebuffer, settings, "VkFramebuffer", "framebuffer", indents + 1, dump_html_VkFramebuffer);
    dump_html_value<const VkBool32>(object.occlusionQueryEnable, settings, "VkBool32", "occlusionQueryEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkQueryControlFlags>(object.queryFlags, settings, "VkQueryControlFlags", "queryFlags", indents + 1, dump_html_VkQueryControlFlags);
    dump_html_value<const VkQueryPipelineStatisticFlags>(object.pipelineStatistics, settings, "VkQueryPipelineStatisticFlags", "pipelineStatistics", indents + 1, dump_html_VkQueryPipelineStatisticFlags);
}
void dump_html_VkCommandBufferBeginInfo(const VkCommandBufferBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandBufferUsageFlags>(object.flags, settings, "VkCommandBufferUsageFlags", "flags", indents + 1, dump_html_VkCommandBufferUsageFlags);
    if(ApiDumpInstance::current().getCmdBufferLevel() == VK_COMMAND_BUFFER_LEVEL_SECONDARY)
    dump_html_pointer<const VkCommandBufferInheritanceInfo>(object.pInheritanceInfo, settings, "const VkCommandBufferInheritanceInfo*", "pInheritanceInfo", indents + 1, dump_html_VkCommandBufferInheritanceInfo);
    else
        dump_html_special("UNUSED", settings, "const VkCommandBufferInheritanceInfo*", "pInheritanceInfo", indents + 1);
}
void dump_html_VkBufferCopy(const VkBufferCopy& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.srcOffset, settings, "VkDeviceSize", "srcOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.dstOffset, settings, "VkDeviceSize", "dstOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkImageSubresourceLayers(const VkImageSubresourceLayers& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.mipLevel, settings, "uint32_t", "mipLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkBufferImageCopy(const VkBufferImageCopy& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.bufferOffset, settings, "VkDeviceSize", "bufferOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.bufferRowLength, settings, "uint32_t", "bufferRowLength", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.bufferImageHeight, settings, "uint32_t", "bufferImageHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageSubresourceLayers>(object.imageSubresource, settings, "VkImageSubresourceLayers", "imageSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.imageOffset, settings, "VkOffset3D", "imageOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.imageExtent, settings, "VkExtent3D", "imageExtent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkClearDepthStencilValue(const VkClearDepthStencilValue& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.depth, settings, "float", "depth", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.stencil, settings, "uint32_t", "stencil", indents + 1, dump_html_uint32_t);
}
void dump_html_VkClearAttachment(const VkClearAttachment& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.colorAttachment, settings, "uint32_t", "colorAttachment", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkClearValue>(object.clearValue, settings, "VkClearValue", "clearValue", indents + 1, dump_html_VkClearValue);
}
void dump_html_VkClearRect(const VkClearRect& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkRect2D>(object.rect, settings, "VkRect2D", "rect", indents + 1, dump_html_VkRect2D);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkImageBlit(const VkImageBlit& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_array<const VkOffset3D>(object.srcOffsets, 2, settings, "VkOffset3D[2]", "VkOffset3D", "srcOffsets", indents + 1, dump_html_VkOffset3D); // ZRR
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_array<const VkOffset3D>(object.dstOffsets, 2, settings, "VkOffset3D[2]", "VkOffset3D", "dstOffsets", indents + 1, dump_html_VkOffset3D); // ZRR
}
void dump_html_VkImageCopy(const VkImageCopy& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.srcOffset, settings, "VkOffset3D", "srcOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.dstOffset, settings, "VkOffset3D", "dstOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkImageResolve(const VkImageResolve& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.srcOffset, settings, "VkOffset3D", "srcOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.dstOffset, settings, "VkOffset3D", "dstOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkRenderPassBeginInfo(const VkRenderPassBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const VkFramebuffer>(object.framebuffer, settings, "VkFramebuffer", "framebuffer", indents + 1, dump_html_VkFramebuffer);
    dump_html_value<const VkRect2D>(object.renderArea, settings, "VkRect2D", "renderArea", indents + 1, dump_html_VkRect2D);
    dump_html_value<const uint32_t>(object.clearValueCount, settings, "uint32_t", "clearValueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkClearValue>(object.pClearValues, object.clearValueCount, settings, "const VkClearValue*", "const VkClearValue", "pClearValues", indents + 1, dump_html_VkClearValue); // ZRT
}
void dump_html_VkPhysicalDeviceSubgroupProperties(const VkPhysicalDeviceSubgroupProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.subgroupSize, settings, "uint32_t", "subgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.supportedStages, settings, "VkShaderStageFlags", "supportedStages", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkSubgroupFeatureFlags>(object.supportedOperations, settings, "VkSubgroupFeatureFlags", "supportedOperations", indents + 1, dump_html_VkSubgroupFeatureFlags);
    dump_html_value<const VkBool32>(object.quadOperationsInAllStages, settings, "VkBool32", "quadOperationsInAllStages", indents + 1, dump_html_VkBool32);
}
void dump_html_VkBindBufferMemoryInfo(const VkBindBufferMemoryInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkBindImageMemoryInfo(const VkBindImageMemoryInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPhysicalDevice16BitStorageFeatures(const VkPhysicalDevice16BitStorageFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.storageBuffer16BitAccess, settings, "VkBool32", "storageBuffer16BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformAndStorageBuffer16BitAccess, settings, "VkBool32", "uniformAndStorageBuffer16BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storagePushConstant16, settings, "VkBool32", "storagePushConstant16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storageInputOutput16, settings, "VkBool32", "storageInputOutput16", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMemoryDedicatedRequirements(const VkMemoryDedicatedRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.prefersDedicatedAllocation, settings, "VkBool32", "prefersDedicatedAllocation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.requiresDedicatedAllocation, settings, "VkBool32", "requiresDedicatedAllocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMemoryDedicatedAllocateInfo(const VkMemoryDedicatedAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
}
void dump_html_VkMemoryAllocateFlagsInfo(const VkMemoryAllocateFlagsInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryAllocateFlags>(object.flags, settings, "VkMemoryAllocateFlags", "flags", indents + 1, dump_html_VkMemoryAllocateFlags);
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDeviceGroupRenderPassBeginInfo(const VkDeviceGroupRenderPassBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.deviceRenderAreaCount, settings, "uint32_t", "deviceRenderAreaCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pDeviceRenderAreas, object.deviceRenderAreaCount, settings, "const VkRect2D*", "const VkRect2D", "pDeviceRenderAreas", indents + 1, dump_html_VkRect2D); // ZRT
}
void dump_html_VkDeviceGroupCommandBufferBeginInfo(const VkDeviceGroupCommandBufferBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDeviceGroupSubmitInfo(const VkDeviceGroupSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pWaitSemaphoreDeviceIndices, object.waitSemaphoreCount, settings, "const uint32_t*", "const uint32_t", "pWaitSemaphoreDeviceIndices", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const uint32_t>(object.commandBufferCount, settings, "uint32_t", "commandBufferCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCommandBufferDeviceMasks, object.commandBufferCount, settings, "const uint32_t*", "const uint32_t", "pCommandBufferDeviceMasks", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const uint32_t>(object.signalSemaphoreCount, settings, "uint32_t", "signalSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pSignalSemaphoreDeviceIndices, object.signalSemaphoreCount, settings, "const uint32_t*", "const uint32_t", "pSignalSemaphoreDeviceIndices", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkDeviceGroupBindSparseInfo(const VkDeviceGroupBindSparseInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.resourceDeviceIndex, settings, "uint32_t", "resourceDeviceIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.memoryDeviceIndex, settings, "uint32_t", "memoryDeviceIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkBindBufferMemoryDeviceGroupInfo(const VkBindBufferMemoryDeviceGroupInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceIndexCount, settings, "uint32_t", "deviceIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceIndices, object.deviceIndexCount, settings, "const uint32_t*", "const uint32_t", "pDeviceIndices", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkBindImageMemoryDeviceGroupInfo(const VkBindImageMemoryDeviceGroupInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceIndexCount, settings, "uint32_t", "deviceIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceIndices, object.deviceIndexCount, settings, "const uint32_t*", "const uint32_t", "pDeviceIndices", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const uint32_t>(object.splitInstanceBindRegionCount, settings, "uint32_t", "splitInstanceBindRegionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pSplitInstanceBindRegions, object.splitInstanceBindRegionCount, settings, "const VkRect2D*", "const VkRect2D", "pSplitInstanceBindRegions", indents + 1, dump_html_VkRect2D); // ZRT
}
void dump_html_VkPhysicalDeviceGroupProperties(const VkPhysicalDeviceGroupProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.physicalDeviceCount, settings, "uint32_t", "physicalDeviceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPhysicalDevice>(object.physicalDevices, object.physicalDeviceCount, settings, "VkPhysicalDevice[VK_MAX_DEVICE_GROUP_SIZE]", "VkPhysicalDevice", "physicalDevices", indents + 1, dump_html_VkPhysicalDevice); // ZRT
    dump_html_value<const VkBool32>(object.subsetAllocation, settings, "VkBool32", "subsetAllocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceGroupDeviceCreateInfo(const VkDeviceGroupDeviceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.physicalDeviceCount, settings, "uint32_t", "physicalDeviceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPhysicalDevice>(object.pPhysicalDevices, object.physicalDeviceCount, settings, "const VkPhysicalDevice*", "const VkPhysicalDevice", "pPhysicalDevices", indents + 1, dump_html_VkPhysicalDevice); // ZRT
}
void dump_html_VkBufferMemoryRequirementsInfo2(const VkBufferMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
}
void dump_html_VkImageMemoryRequirementsInfo2(const VkImageMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
}
void dump_html_VkImageSparseMemoryRequirementsInfo2(const VkImageSparseMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
}
void dump_html_VkMemoryRequirements2(const VkMemoryRequirements2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryRequirements>(object.memoryRequirements, settings, "VkMemoryRequirements", "memoryRequirements", indents + 1, dump_html_VkMemoryRequirements);
}
void dump_html_VkSparseImageMemoryRequirements2(const VkSparseImageMemoryRequirements2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSparseImageMemoryRequirements>(object.memoryRequirements, settings, "VkSparseImageMemoryRequirements", "memoryRequirements", indents + 1, dump_html_VkSparseImageMemoryRequirements);
}
void dump_html_VkPhysicalDeviceFeatures2(const VkPhysicalDeviceFeatures2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceFeatures>(object.features, settings, "VkPhysicalDeviceFeatures", "features", indents + 1, dump_html_VkPhysicalDeviceFeatures);
}
void dump_html_VkPhysicalDeviceProperties2(const VkPhysicalDeviceProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceProperties>(object.properties, settings, "VkPhysicalDeviceProperties", "properties", indents + 1, dump_html_VkPhysicalDeviceProperties);
}
void dump_html_VkFormatProperties2(const VkFormatProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormatProperties>(object.formatProperties, settings, "VkFormatProperties", "formatProperties", indents + 1, dump_html_VkFormatProperties);
}
void dump_html_VkImageFormatProperties2(const VkImageFormatProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageFormatProperties>(object.imageFormatProperties, settings, "VkImageFormatProperties", "imageFormatProperties", indents + 1, dump_html_VkImageFormatProperties);
}
void dump_html_VkPhysicalDeviceImageFormatInfo2(const VkPhysicalDeviceImageFormatInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkImageType>(object.type, settings, "VkImageType", "type", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkImageTiling>(object.tiling, settings, "VkImageTiling", "tiling", indents + 1, dump_html_VkImageTiling);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkImageCreateFlags>(object.flags, settings, "VkImageCreateFlags", "flags", indents + 1, dump_html_VkImageCreateFlags);
}
void dump_html_VkQueueFamilyProperties2(const VkQueueFamilyProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueueFamilyProperties>(object.queueFamilyProperties, settings, "VkQueueFamilyProperties", "queueFamilyProperties", indents + 1, dump_html_VkQueueFamilyProperties);
}
void dump_html_VkPhysicalDeviceMemoryProperties2(const VkPhysicalDeviceMemoryProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    ApiDumpInstance::current().setMemoryHeapCount(object.memoryProperties.memoryHeapCount);
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceMemoryProperties>(object.memoryProperties, settings, "VkPhysicalDeviceMemoryProperties", "memoryProperties", indents + 1, dump_html_VkPhysicalDeviceMemoryProperties);
}
void dump_html_VkSparseImageFormatProperties2(const VkSparseImageFormatProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSparseImageFormatProperties>(object.properties, settings, "VkSparseImageFormatProperties", "properties", indents + 1, dump_html_VkSparseImageFormatProperties);
}
void dump_html_VkPhysicalDeviceSparseImageFormatInfo2(const VkPhysicalDeviceSparseImageFormatInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkImageType>(object.type, settings, "VkImageType", "type", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkImageTiling>(object.tiling, settings, "VkImageTiling", "tiling", indents + 1, dump_html_VkImageTiling);
}
void dump_html_VkPhysicalDevicePointClippingProperties(const VkPhysicalDevicePointClippingProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPointClippingBehavior>(object.pointClippingBehavior, settings, "VkPointClippingBehavior", "pointClippingBehavior", indents + 1, dump_html_VkPointClippingBehavior);
}
void dump_html_VkInputAttachmentAspectReference(const VkInputAttachmentAspectReference& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.inputAttachmentIndex, settings, "uint32_t", "inputAttachmentIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
}
void dump_html_VkRenderPassInputAttachmentAspectCreateInfo(const VkRenderPassInputAttachmentAspectCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.aspectReferenceCount, settings, "uint32_t", "aspectReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkInputAttachmentAspectReference>(object.pAspectReferences, object.aspectReferenceCount, settings, "const VkInputAttachmentAspectReference*", "const VkInputAttachmentAspectReference", "pAspectReferences", indents + 1, dump_html_VkInputAttachmentAspectReference); // ZRT
}
void dump_html_VkImageViewUsageCreateInfo(const VkImageViewUsageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
}
void dump_html_VkPipelineTessellationDomainOriginStateCreateInfo(const VkPipelineTessellationDomainOriginStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkTessellationDomainOrigin>(object.domainOrigin, settings, "VkTessellationDomainOrigin", "domainOrigin", indents + 1, dump_html_VkTessellationDomainOrigin);
}
void dump_html_VkRenderPassMultiviewCreateInfo(const VkRenderPassMultiviewCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.subpassCount, settings, "uint32_t", "subpassCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pViewMasks, object.subpassCount, settings, "const uint32_t*", "const uint32_t", "pViewMasks", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const uint32_t>(object.dependencyCount, settings, "uint32_t", "dependencyCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const int32_t>(object.pViewOffsets, object.dependencyCount, settings, "const int32_t*", "const int32_t", "pViewOffsets", indents + 1, dump_html_int32_t); // ZRT
    dump_html_value<const uint32_t>(object.correlationMaskCount, settings, "uint32_t", "correlationMaskCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCorrelationMasks, object.correlationMaskCount, settings, "const uint32_t*", "const uint32_t", "pCorrelationMasks", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkPhysicalDeviceMultiviewFeatures(const VkPhysicalDeviceMultiviewFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multiview, settings, "VkBool32", "multiview", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewGeometryShader, settings, "VkBool32", "multiviewGeometryShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewTessellationShader, settings, "VkBool32", "multiviewTessellationShader", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMultiviewProperties(const VkPhysicalDeviceMultiviewProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxMultiviewViewCount, settings, "uint32_t", "maxMultiviewViewCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMultiviewInstanceIndex, settings, "uint32_t", "maxMultiviewInstanceIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceVariablePointersFeatures(const VkPhysicalDeviceVariablePointersFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.variablePointersStorageBuffer, settings, "VkBool32", "variablePointersStorageBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.variablePointers, settings, "VkBool32", "variablePointers", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceProtectedMemoryFeatures(const VkPhysicalDeviceProtectedMemoryFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.protectedMemory, settings, "VkBool32", "protectedMemory", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceProtectedMemoryProperties(const VkPhysicalDeviceProtectedMemoryProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.protectedNoFault, settings, "VkBool32", "protectedNoFault", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceQueueInfo2(const VkDeviceQueueInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceQueueCreateFlags>(object.flags, settings, "VkDeviceQueueCreateFlags", "flags", indents + 1, dump_html_VkDeviceQueueCreateFlags);
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.queueIndex, settings, "uint32_t", "queueIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkProtectedSubmitInfo(const VkProtectedSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.protectedSubmit, settings, "VkBool32", "protectedSubmit", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSamplerYcbcrConversionCreateInfo(const VkSamplerYcbcrConversionCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.ycbcrModel, settings, "VkSamplerYcbcrModelConversion", "ycbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.ycbcrRange, settings, "VkSamplerYcbcrRange", "ycbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkComponentMapping>(object.components, settings, "VkComponentMapping", "components", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkChromaLocation>(object.xChromaOffset, settings, "VkChromaLocation", "xChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.yChromaOffset, settings, "VkChromaLocation", "yChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkFilter>(object.chromaFilter, settings, "VkFilter", "chromaFilter", indents + 1, dump_html_VkFilter);
    dump_html_value<const VkBool32>(object.forceExplicitReconstruction, settings, "VkBool32", "forceExplicitReconstruction", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSamplerYcbcrConversionInfo(const VkSamplerYcbcrConversionInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSamplerYcbcrConversion>(object.conversion, settings, "VkSamplerYcbcrConversion", "conversion", indents + 1, dump_html_VkSamplerYcbcrConversion);
}
void dump_html_VkBindImagePlaneMemoryInfo(const VkBindImagePlaneMemoryInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageAspectFlagBits>(object.planeAspect, settings, "VkImageAspectFlagBits", "planeAspect", indents + 1, dump_html_VkImageAspectFlagBits);
}
void dump_html_VkImagePlaneMemoryRequirementsInfo(const VkImagePlaneMemoryRequirementsInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageAspectFlagBits>(object.planeAspect, settings, "VkImageAspectFlagBits", "planeAspect", indents + 1, dump_html_VkImageAspectFlagBits);
}
void dump_html_VkPhysicalDeviceSamplerYcbcrConversionFeatures(const VkPhysicalDeviceSamplerYcbcrConversionFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.samplerYcbcrConversion, settings, "VkBool32", "samplerYcbcrConversion", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSamplerYcbcrConversionImageFormatProperties(const VkSamplerYcbcrConversionImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.combinedImageSamplerDescriptorCount, settings, "uint32_t", "combinedImageSamplerDescriptorCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDescriptorUpdateTemplateEntry(const VkDescriptorUpdateTemplateEntry& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.dstBinding, settings, "uint32_t", "dstBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstArrayElement, settings, "uint32_t", "dstArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const size_t>(object.offset, settings, "size_t", "offset", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.stride, settings, "size_t", "stride", indents + 1, dump_html_size_t);
}
void dump_html_VkDescriptorUpdateTemplateCreateInfo(const VkDescriptorUpdateTemplateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorUpdateTemplateCreateFlags>(object.flags, settings, "VkDescriptorUpdateTemplateCreateFlags", "flags", indents + 1, dump_html_VkDescriptorUpdateTemplateCreateFlags);
    dump_html_value<const uint32_t>(object.descriptorUpdateEntryCount, settings, "uint32_t", "descriptorUpdateEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorUpdateTemplateEntry>(object.pDescriptorUpdateEntries, object.descriptorUpdateEntryCount, settings, "const VkDescriptorUpdateTemplateEntry*", "const VkDescriptorUpdateTemplateEntry", "pDescriptorUpdateEntries", indents + 1, dump_html_VkDescriptorUpdateTemplateEntry); // ZRT
    dump_html_value<const VkDescriptorUpdateTemplateType>(object.templateType, settings, "VkDescriptorUpdateTemplateType", "templateType", indents + 1, dump_html_VkDescriptorUpdateTemplateType);
    dump_html_value<const VkDescriptorSetLayout>(object.descriptorSetLayout, settings, "VkDescriptorSetLayout", "descriptorSetLayout", indents + 1, dump_html_VkDescriptorSetLayout);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const VkPipelineLayout>(object.pipelineLayout, settings, "VkPipelineLayout", "pipelineLayout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.set, settings, "uint32_t", "set", indents + 1, dump_html_uint32_t);
}
void dump_html_VkExternalMemoryProperties(const VkExternalMemoryProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkExternalMemoryFeatureFlags>(object.externalMemoryFeatures, settings, "VkExternalMemoryFeatureFlags", "externalMemoryFeatures", indents + 1, dump_html_VkExternalMemoryFeatureFlags);
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.exportFromImportedHandleTypes, settings, "VkExternalMemoryHandleTypeFlags", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.compatibleHandleTypes, settings, "VkExternalMemoryHandleTypeFlags", "compatibleHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
}
void dump_html_VkPhysicalDeviceExternalImageFormatInfo(const VkPhysicalDeviceExternalImageFormatInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
}
void dump_html_VkExternalImageFormatProperties(const VkExternalImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryProperties>(object.externalMemoryProperties, settings, "VkExternalMemoryProperties", "externalMemoryProperties", indents + 1, dump_html_VkExternalMemoryProperties);
}
void dump_html_VkPhysicalDeviceExternalBufferInfo(const VkPhysicalDeviceExternalBufferInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCreateFlags>(object.flags, settings, "VkBufferCreateFlags", "flags", indents + 1, dump_html_VkBufferCreateFlags);
    dump_html_value<const VkBufferUsageFlags>(object.usage, settings, "VkBufferUsageFlags", "usage", indents + 1, dump_html_VkBufferUsageFlags);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
}
void dump_html_VkExternalBufferProperties(const VkExternalBufferProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryProperties>(object.externalMemoryProperties, settings, "VkExternalMemoryProperties", "externalMemoryProperties", indents + 1, dump_html_VkExternalMemoryProperties);
}
void dump_html_VkPhysicalDeviceIDProperties(const VkPhysicalDeviceIDProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.deviceUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "deviceUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_array<const uint8_t>(object.driverUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "driverUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_array<const uint8_t>(object.deviceLUID, 8, settings, "uint8_t[VK_LUID_SIZE]", "uint8_t", "deviceLUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_value<const uint32_t>(object.deviceNodeMask, settings, "uint32_t", "deviceNodeMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.deviceLUIDValid, settings, "VkBool32", "deviceLUIDValid", indents + 1, dump_html_VkBool32);
}
void dump_html_VkExternalMemoryImageCreateInfo(const VkExternalMemoryImageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
}
void dump_html_VkExternalMemoryBufferCreateInfo(const VkExternalMemoryBufferCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
}
void dump_html_VkExportMemoryAllocateInfo(const VkExportMemoryAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
}
void dump_html_VkPhysicalDeviceExternalFenceInfo(const VkPhysicalDeviceExternalFenceInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
}
void dump_html_VkExternalFenceProperties(const VkExternalFenceProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalFenceHandleTypeFlags>(object.exportFromImportedHandleTypes, settings, "VkExternalFenceHandleTypeFlags", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalFenceHandleTypeFlags);
    dump_html_value<const VkExternalFenceHandleTypeFlags>(object.compatibleHandleTypes, settings, "VkExternalFenceHandleTypeFlags", "compatibleHandleTypes", indents + 1, dump_html_VkExternalFenceHandleTypeFlags);
    dump_html_value<const VkExternalFenceFeatureFlags>(object.externalFenceFeatures, settings, "VkExternalFenceFeatureFlags", "externalFenceFeatures", indents + 1, dump_html_VkExternalFenceFeatureFlags);
}
void dump_html_VkExportFenceCreateInfo(const VkExportFenceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalFenceHandleTypeFlags>(object.handleTypes, settings, "VkExternalFenceHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalFenceHandleTypeFlags);
}
void dump_html_VkExportSemaphoreCreateInfo(const VkExportSemaphoreCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalSemaphoreHandleTypeFlags>(object.handleTypes, settings, "VkExternalSemaphoreHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlags);
}
void dump_html_VkPhysicalDeviceExternalSemaphoreInfo(const VkPhysicalDeviceExternalSemaphoreInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
}
void dump_html_VkExternalSemaphoreProperties(const VkExternalSemaphoreProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalSemaphoreHandleTypeFlags>(object.exportFromImportedHandleTypes, settings, "VkExternalSemaphoreHandleTypeFlags", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlags>(object.compatibleHandleTypes, settings, "VkExternalSemaphoreHandleTypeFlags", "compatibleHandleTypes", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlags);
    dump_html_value<const VkExternalSemaphoreFeatureFlags>(object.externalSemaphoreFeatures, settings, "VkExternalSemaphoreFeatureFlags", "externalSemaphoreFeatures", indents + 1, dump_html_VkExternalSemaphoreFeatureFlags);
}
void dump_html_VkPhysicalDeviceMaintenance3Properties(const VkPhysicalDeviceMaintenance3Properties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxPerSetDescriptors, settings, "uint32_t", "maxPerSetDescriptors", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.maxMemoryAllocationSize, settings, "VkDeviceSize", "maxMemoryAllocationSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkDescriptorSetLayoutSupport(const VkDescriptorSetLayoutSupport& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.supported, settings, "VkBool32", "supported", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderDrawParametersFeatures(const VkPhysicalDeviceShaderDrawParametersFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderDrawParameters, settings, "VkBool32", "shaderDrawParameters", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceVulkan11Features(const VkPhysicalDeviceVulkan11Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.storageBuffer16BitAccess, settings, "VkBool32", "storageBuffer16BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformAndStorageBuffer16BitAccess, settings, "VkBool32", "uniformAndStorageBuffer16BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storagePushConstant16, settings, "VkBool32", "storagePushConstant16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storageInputOutput16, settings, "VkBool32", "storageInputOutput16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiview, settings, "VkBool32", "multiview", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewGeometryShader, settings, "VkBool32", "multiviewGeometryShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewTessellationShader, settings, "VkBool32", "multiviewTessellationShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.variablePointersStorageBuffer, settings, "VkBool32", "variablePointersStorageBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.variablePointers, settings, "VkBool32", "variablePointers", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.protectedMemory, settings, "VkBool32", "protectedMemory", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.samplerYcbcrConversion, settings, "VkBool32", "samplerYcbcrConversion", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDrawParameters, settings, "VkBool32", "shaderDrawParameters", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceVulkan11Properties(const VkPhysicalDeviceVulkan11Properties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.deviceUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "deviceUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_array<const uint8_t>(object.driverUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "driverUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_array<const uint8_t>(object.deviceLUID, 8, settings, "uint8_t[VK_LUID_SIZE]", "uint8_t", "deviceLUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_value<const uint32_t>(object.deviceNodeMask, settings, "uint32_t", "deviceNodeMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.deviceLUIDValid, settings, "VkBool32", "deviceLUIDValid", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.subgroupSize, settings, "uint32_t", "subgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.subgroupSupportedStages, settings, "VkShaderStageFlags", "subgroupSupportedStages", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkSubgroupFeatureFlags>(object.subgroupSupportedOperations, settings, "VkSubgroupFeatureFlags", "subgroupSupportedOperations", indents + 1, dump_html_VkSubgroupFeatureFlags);
    dump_html_value<const VkBool32>(object.subgroupQuadOperationsInAllStages, settings, "VkBool32", "subgroupQuadOperationsInAllStages", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkPointClippingBehavior>(object.pointClippingBehavior, settings, "VkPointClippingBehavior", "pointClippingBehavior", indents + 1, dump_html_VkPointClippingBehavior);
    dump_html_value<const uint32_t>(object.maxMultiviewViewCount, settings, "uint32_t", "maxMultiviewViewCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMultiviewInstanceIndex, settings, "uint32_t", "maxMultiviewInstanceIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.protectedNoFault, settings, "VkBool32", "protectedNoFault", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxPerSetDescriptors, settings, "uint32_t", "maxPerSetDescriptors", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.maxMemoryAllocationSize, settings, "VkDeviceSize", "maxMemoryAllocationSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPhysicalDeviceVulkan12Features(const VkPhysicalDeviceVulkan12Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.samplerMirrorClampToEdge, settings, "VkBool32", "samplerMirrorClampToEdge", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.drawIndirectCount, settings, "VkBool32", "drawIndirectCount", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storageBuffer8BitAccess, settings, "VkBool32", "storageBuffer8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformAndStorageBuffer8BitAccess, settings, "VkBool32", "uniformAndStorageBuffer8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storagePushConstant8, settings, "VkBool32", "storagePushConstant8", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferInt64Atomics, settings, "VkBool32", "shaderBufferInt64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedInt64Atomics, settings, "VkBool32", "shaderSharedInt64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderFloat16, settings, "VkBool32", "shaderFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt8, settings, "VkBool32", "shaderInt8", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorIndexing, settings, "VkBool32", "descriptorIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayDynamicIndexing, settings, "VkBool32", "shaderInputAttachmentArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformTexelBufferArrayDynamicIndexing, settings, "VkBool32", "shaderUniformTexelBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageTexelBufferArrayDynamicIndexing, settings, "VkBool32", "shaderStorageTexelBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderUniformBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayNonUniformIndexing, settings, "VkBool32", "shaderSampledImageArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageImageArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayNonUniformIndexing, settings, "VkBool32", "shaderInputAttachmentArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformTexelBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderUniformTexelBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageTexelBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageTexelBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUniformBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingUniformBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingSampledImageUpdateAfterBind, settings, "VkBool32", "descriptorBindingSampledImageUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageImageUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageImageUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUniformTexelBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingUniformTexelBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageTexelBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageTexelBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUpdateUnusedWhilePending, settings, "VkBool32", "descriptorBindingUpdateUnusedWhilePending", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingPartiallyBound, settings, "VkBool32", "descriptorBindingPartiallyBound", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingVariableDescriptorCount, settings, "VkBool32", "descriptorBindingVariableDescriptorCount", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.runtimeDescriptorArray, settings, "VkBool32", "runtimeDescriptorArray", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.samplerFilterMinmax, settings, "VkBool32", "samplerFilterMinmax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.scalarBlockLayout, settings, "VkBool32", "scalarBlockLayout", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.imagelessFramebuffer, settings, "VkBool32", "imagelessFramebuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformBufferStandardLayout, settings, "VkBool32", "uniformBufferStandardLayout", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSubgroupExtendedTypes, settings, "VkBool32", "shaderSubgroupExtendedTypes", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.separateDepthStencilLayouts, settings, "VkBool32", "separateDepthStencilLayouts", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.hostQueryReset, settings, "VkBool32", "hostQueryReset", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.timelineSemaphore, settings, "VkBool32", "timelineSemaphore", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddress, settings, "VkBool32", "bufferDeviceAddress", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressCaptureReplay, settings, "VkBool32", "bufferDeviceAddressCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressMultiDevice, settings, "VkBool32", "bufferDeviceAddressMultiDevice", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModel, settings, "VkBool32", "vulkanMemoryModel", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModelDeviceScope, settings, "VkBool32", "vulkanMemoryModelDeviceScope", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModelAvailabilityVisibilityChains, settings, "VkBool32", "vulkanMemoryModelAvailabilityVisibilityChains", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderOutputViewportIndex, settings, "VkBool32", "shaderOutputViewportIndex", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderOutputLayer, settings, "VkBool32", "shaderOutputLayer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.subgroupBroadcastDynamicId, settings, "VkBool32", "subgroupBroadcastDynamicId", indents + 1, dump_html_VkBool32);
}
void dump_html_VkConformanceVersion(const VkConformanceVersion& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint8_t>(object.major, settings, "uint8_t", "major", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint8_t>(object.minor, settings, "uint8_t", "minor", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint8_t>(object.subminor, settings, "uint8_t", "subminor", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint8_t>(object.patch, settings, "uint8_t", "patch", indents + 1, dump_html_uint8_t);
}
void dump_html_VkPhysicalDeviceVulkan12Properties(const VkPhysicalDeviceVulkan12Properties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDriverId>(object.driverID, settings, "VkDriverId", "driverID", indents + 1, dump_html_VkDriverId);
    dump_html_value<const char*>(object.driverName, settings, "char[VK_MAX_DRIVER_NAME_SIZE]", "driverName", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.driverInfo, settings, "char[VK_MAX_DRIVER_INFO_SIZE]", "driverInfo", indents + 1, dump_html_cstring);
    dump_html_value<const VkConformanceVersion>(object.conformanceVersion, settings, "VkConformanceVersion", "conformanceVersion", indents + 1, dump_html_VkConformanceVersion);
    dump_html_value<const VkShaderFloatControlsIndependence>(object.denormBehaviorIndependence, settings, "VkShaderFloatControlsIndependence", "denormBehaviorIndependence", indents + 1, dump_html_VkShaderFloatControlsIndependence);
    dump_html_value<const VkShaderFloatControlsIndependence>(object.roundingModeIndependence, settings, "VkShaderFloatControlsIndependence", "roundingModeIndependence", indents + 1, dump_html_VkShaderFloatControlsIndependence);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat16, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat32, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat64, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat16, settings, "VkBool32", "shaderDenormPreserveFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat32, settings, "VkBool32", "shaderDenormPreserveFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat64, settings, "VkBool32", "shaderDenormPreserveFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat16, settings, "VkBool32", "shaderDenormFlushToZeroFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat32, settings, "VkBool32", "shaderDenormFlushToZeroFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat64, settings, "VkBool32", "shaderDenormFlushToZeroFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat16, settings, "VkBool32", "shaderRoundingModeRTEFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat32, settings, "VkBool32", "shaderRoundingModeRTEFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat64, settings, "VkBool32", "shaderRoundingModeRTEFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat16, settings, "VkBool32", "shaderRoundingModeRTZFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat32, settings, "VkBool32", "shaderRoundingModeRTZFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat64, settings, "VkBool32", "shaderRoundingModeRTZFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxUpdateAfterBindDescriptorsInAllPools, settings, "uint32_t", "maxUpdateAfterBindDescriptorsInAllPools", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayNonUniformIndexingNative, settings, "VkBool32", "shaderUniformBufferArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayNonUniformIndexingNative, settings, "VkBool32", "shaderSampledImageArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayNonUniformIndexingNative, settings, "VkBool32", "shaderStorageBufferArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayNonUniformIndexingNative, settings, "VkBool32", "shaderStorageImageArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayNonUniformIndexingNative, settings, "VkBool32", "shaderInputAttachmentArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.robustBufferAccessUpdateAfterBind, settings, "VkBool32", "robustBufferAccessUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.quadDivergentImplicitLod, settings, "VkBool32", "quadDivergentImplicitLod", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindSamplers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindUniformBuffers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindStorageBuffers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindSampledImages, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindStorageImages, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindInputAttachments, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageUpdateAfterBindResources, settings, "uint32_t", "maxPerStageUpdateAfterBindResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindSamplers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindUniformBuffers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageBuffers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindSampledImages, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageImages, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindInputAttachments, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkResolveModeFlags>(object.supportedDepthResolveModes, settings, "VkResolveModeFlags", "supportedDepthResolveModes", indents + 1, dump_html_VkResolveModeFlags);
    dump_html_value<const VkResolveModeFlags>(object.supportedStencilResolveModes, settings, "VkResolveModeFlags", "supportedStencilResolveModes", indents + 1, dump_html_VkResolveModeFlags);
    dump_html_value<const VkBool32>(object.independentResolveNone, settings, "VkBool32", "independentResolveNone", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.independentResolve, settings, "VkBool32", "independentResolve", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.filterMinmaxSingleComponentFormats, settings, "VkBool32", "filterMinmaxSingleComponentFormats", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.filterMinmaxImageComponentMapping, settings, "VkBool32", "filterMinmaxImageComponentMapping", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint64_t>(object.maxTimelineSemaphoreValueDifference, settings, "uint64_t", "maxTimelineSemaphoreValueDifference", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkSampleCountFlags>(object.framebufferIntegerColorSampleCounts, settings, "VkSampleCountFlags", "framebufferIntegerColorSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
}
void dump_html_VkImageFormatListCreateInfo(const VkImageFormatListCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.viewFormatCount, settings, "uint32_t", "viewFormatCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFormat>(object.pViewFormats, object.viewFormatCount, settings, "const VkFormat*", "const VkFormat", "pViewFormats", indents + 1, dump_html_VkFormat); // ZRT
}
void dump_html_VkAttachmentDescription2(const VkAttachmentDescription2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAttachmentDescriptionFlags>(object.flags, settings, "VkAttachmentDescriptionFlags", "flags", indents + 1, dump_html_VkAttachmentDescriptionFlags);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkAttachmentLoadOp>(object.loadOp, settings, "VkAttachmentLoadOp", "loadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.storeOp, settings, "VkAttachmentStoreOp", "storeOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkAttachmentLoadOp>(object.stencilLoadOp, settings, "VkAttachmentLoadOp", "stencilLoadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.stencilStoreOp, settings, "VkAttachmentStoreOp", "stencilStoreOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkImageLayout>(object.initialLayout, settings, "VkImageLayout", "initialLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.finalLayout, settings, "VkImageLayout", "finalLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkAttachmentReference2(const VkAttachmentReference2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachment, settings, "uint32_t", "attachment", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageLayout>(object.layout, settings, "VkImageLayout", "layout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
}
void dump_html_VkSubpassDescription2(const VkSubpassDescription2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSubpassDescriptionFlags>(object.flags, settings, "VkSubpassDescriptionFlags", "flags", indents + 1, dump_html_VkSubpassDescriptionFlags);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const uint32_t>(object.viewMask, settings, "uint32_t", "viewMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.inputAttachmentCount, settings, "uint32_t", "inputAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference2>(object.pInputAttachments, object.inputAttachmentCount, settings, "const VkAttachmentReference2*", "const VkAttachmentReference2", "pInputAttachments", indents + 1, dump_html_VkAttachmentReference2); // ZRT
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference2>(object.pColorAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference2*", "const VkAttachmentReference2", "pColorAttachments", indents + 1, dump_html_VkAttachmentReference2); // ZRT
    dump_html_array<const VkAttachmentReference2>(object.pResolveAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference2*", "const VkAttachmentReference2", "pResolveAttachments", indents + 1, dump_html_VkAttachmentReference2); // ZRT
    dump_html_pointer<const VkAttachmentReference2>(object.pDepthStencilAttachment, settings, "const VkAttachmentReference2*", "pDepthStencilAttachment", indents + 1, dump_html_VkAttachmentReference2);
    dump_html_value<const uint32_t>(object.preserveAttachmentCount, settings, "uint32_t", "preserveAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pPreserveAttachments, object.preserveAttachmentCount, settings, "const uint32_t*", "const uint32_t", "pPreserveAttachments", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkSubpassDependency2(const VkSubpassDependency2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.srcSubpass, settings, "uint32_t", "srcSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstSubpass, settings, "uint32_t", "dstSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineStageFlags>(object.srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkPipelineStageFlags>(object.dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkDependencyFlags>(object.dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", indents + 1, dump_html_VkDependencyFlags);
    dump_html_value<const int32_t>(object.viewOffset, settings, "int32_t", "viewOffset", indents + 1, dump_html_int32_t);
}
void dump_html_VkRenderPassCreateInfo2(const VkRenderPassCreateInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPassCreateFlags>(object.flags, settings, "VkRenderPassCreateFlags", "flags", indents + 1, dump_html_VkRenderPassCreateFlags);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentDescription2>(object.pAttachments, object.attachmentCount, settings, "const VkAttachmentDescription2*", "const VkAttachmentDescription2", "pAttachments", indents + 1, dump_html_VkAttachmentDescription2); // ZRT
    dump_html_value<const uint32_t>(object.subpassCount, settings, "uint32_t", "subpassCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDescription2>(object.pSubpasses, object.subpassCount, settings, "const VkSubpassDescription2*", "const VkSubpassDescription2", "pSubpasses", indents + 1, dump_html_VkSubpassDescription2); // ZRT
    dump_html_value<const uint32_t>(object.dependencyCount, settings, "uint32_t", "dependencyCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDependency2>(object.pDependencies, object.dependencyCount, settings, "const VkSubpassDependency2*", "const VkSubpassDependency2", "pDependencies", indents + 1, dump_html_VkSubpassDependency2); // ZRT
    dump_html_value<const uint32_t>(object.correlatedViewMaskCount, settings, "uint32_t", "correlatedViewMaskCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCorrelatedViewMasks, object.correlatedViewMaskCount, settings, "const uint32_t*", "const uint32_t", "pCorrelatedViewMasks", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkSubpassBeginInfo(const VkSubpassBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSubpassContents>(object.contents, settings, "VkSubpassContents", "contents", indents + 1, dump_html_VkSubpassContents);
}
void dump_html_VkSubpassEndInfo(const VkSubpassEndInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
}
void dump_html_VkPhysicalDevice8BitStorageFeatures(const VkPhysicalDevice8BitStorageFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.storageBuffer8BitAccess, settings, "VkBool32", "storageBuffer8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformAndStorageBuffer8BitAccess, settings, "VkBool32", "uniformAndStorageBuffer8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storagePushConstant8, settings, "VkBool32", "storagePushConstant8", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDriverProperties(const VkPhysicalDeviceDriverProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDriverId>(object.driverID, settings, "VkDriverId", "driverID", indents + 1, dump_html_VkDriverId);
    dump_html_value<const char*>(object.driverName, settings, "char[VK_MAX_DRIVER_NAME_SIZE]", "driverName", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.driverInfo, settings, "char[VK_MAX_DRIVER_INFO_SIZE]", "driverInfo", indents + 1, dump_html_cstring);
    dump_html_value<const VkConformanceVersion>(object.conformanceVersion, settings, "VkConformanceVersion", "conformanceVersion", indents + 1, dump_html_VkConformanceVersion);
}
void dump_html_VkPhysicalDeviceShaderAtomicInt64Features(const VkPhysicalDeviceShaderAtomicInt64Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderBufferInt64Atomics, settings, "VkBool32", "shaderBufferInt64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedInt64Atomics, settings, "VkBool32", "shaderSharedInt64Atomics", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderFloat16Int8Features(const VkPhysicalDeviceShaderFloat16Int8Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderFloat16, settings, "VkBool32", "shaderFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt8, settings, "VkBool32", "shaderInt8", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFloatControlsProperties(const VkPhysicalDeviceFloatControlsProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderFloatControlsIndependence>(object.denormBehaviorIndependence, settings, "VkShaderFloatControlsIndependence", "denormBehaviorIndependence", indents + 1, dump_html_VkShaderFloatControlsIndependence);
    dump_html_value<const VkShaderFloatControlsIndependence>(object.roundingModeIndependence, settings, "VkShaderFloatControlsIndependence", "roundingModeIndependence", indents + 1, dump_html_VkShaderFloatControlsIndependence);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat16, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat32, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat64, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat16, settings, "VkBool32", "shaderDenormPreserveFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat32, settings, "VkBool32", "shaderDenormPreserveFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat64, settings, "VkBool32", "shaderDenormPreserveFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat16, settings, "VkBool32", "shaderDenormFlushToZeroFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat32, settings, "VkBool32", "shaderDenormFlushToZeroFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat64, settings, "VkBool32", "shaderDenormFlushToZeroFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat16, settings, "VkBool32", "shaderRoundingModeRTEFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat32, settings, "VkBool32", "shaderRoundingModeRTEFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat64, settings, "VkBool32", "shaderRoundingModeRTEFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat16, settings, "VkBool32", "shaderRoundingModeRTZFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat32, settings, "VkBool32", "shaderRoundingModeRTZFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat64, settings, "VkBool32", "shaderRoundingModeRTZFloat64", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDescriptorSetLayoutBindingFlagsCreateInfo(const VkDescriptorSetLayoutBindingFlagsCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.bindingCount, settings, "uint32_t", "bindingCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorBindingFlags>(object.pBindingFlags, object.bindingCount, settings, "const VkDescriptorBindingFlags*", "const VkDescriptorBindingFlags", "pBindingFlags", indents + 1, dump_html_VkDescriptorBindingFlags); // ZRT
}
void dump_html_VkPhysicalDeviceDescriptorIndexingFeatures(const VkPhysicalDeviceDescriptorIndexingFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayDynamicIndexing, settings, "VkBool32", "shaderInputAttachmentArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformTexelBufferArrayDynamicIndexing, settings, "VkBool32", "shaderUniformTexelBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageTexelBufferArrayDynamicIndexing, settings, "VkBool32", "shaderStorageTexelBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderUniformBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayNonUniformIndexing, settings, "VkBool32", "shaderSampledImageArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageImageArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayNonUniformIndexing, settings, "VkBool32", "shaderInputAttachmentArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformTexelBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderUniformTexelBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageTexelBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageTexelBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUniformBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingUniformBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingSampledImageUpdateAfterBind, settings, "VkBool32", "descriptorBindingSampledImageUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageImageUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageImageUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUniformTexelBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingUniformTexelBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageTexelBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageTexelBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUpdateUnusedWhilePending, settings, "VkBool32", "descriptorBindingUpdateUnusedWhilePending", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingPartiallyBound, settings, "VkBool32", "descriptorBindingPartiallyBound", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingVariableDescriptorCount, settings, "VkBool32", "descriptorBindingVariableDescriptorCount", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.runtimeDescriptorArray, settings, "VkBool32", "runtimeDescriptorArray", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDescriptorIndexingProperties(const VkPhysicalDeviceDescriptorIndexingProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxUpdateAfterBindDescriptorsInAllPools, settings, "uint32_t", "maxUpdateAfterBindDescriptorsInAllPools", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayNonUniformIndexingNative, settings, "VkBool32", "shaderUniformBufferArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayNonUniformIndexingNative, settings, "VkBool32", "shaderSampledImageArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayNonUniformIndexingNative, settings, "VkBool32", "shaderStorageBufferArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayNonUniformIndexingNative, settings, "VkBool32", "shaderStorageImageArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayNonUniformIndexingNative, settings, "VkBool32", "shaderInputAttachmentArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.robustBufferAccessUpdateAfterBind, settings, "VkBool32", "robustBufferAccessUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.quadDivergentImplicitLod, settings, "VkBool32", "quadDivergentImplicitLod", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindSamplers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindUniformBuffers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindStorageBuffers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindSampledImages, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindStorageImages, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindInputAttachments, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageUpdateAfterBindResources, settings, "uint32_t", "maxPerStageUpdateAfterBindResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindSamplers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindUniformBuffers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageBuffers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindSampledImages, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageImages, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindInputAttachments, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindInputAttachments", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDescriptorSetVariableDescriptorCountAllocateInfo(const VkDescriptorSetVariableDescriptorCountAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.descriptorSetCount, settings, "uint32_t", "descriptorSetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDescriptorCounts, object.descriptorSetCount, settings, "const uint32_t*", "const uint32_t", "pDescriptorCounts", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkDescriptorSetVariableDescriptorCountLayoutSupport(const VkDescriptorSetVariableDescriptorCountLayoutSupport& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxVariableDescriptorCount, settings, "uint32_t", "maxVariableDescriptorCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkSubpassDescriptionDepthStencilResolve(const VkSubpassDescriptionDepthStencilResolve& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkResolveModeFlagBits>(object.depthResolveMode, settings, "VkResolveModeFlagBits", "depthResolveMode", indents + 1, dump_html_VkResolveModeFlagBits);
    dump_html_value<const VkResolveModeFlagBits>(object.stencilResolveMode, settings, "VkResolveModeFlagBits", "stencilResolveMode", indents + 1, dump_html_VkResolveModeFlagBits);
    dump_html_pointer<const VkAttachmentReference2>(object.pDepthStencilResolveAttachment, settings, "const VkAttachmentReference2*", "pDepthStencilResolveAttachment", indents + 1, dump_html_VkAttachmentReference2);
}
void dump_html_VkPhysicalDeviceDepthStencilResolveProperties(const VkPhysicalDeviceDepthStencilResolveProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkResolveModeFlags>(object.supportedDepthResolveModes, settings, "VkResolveModeFlags", "supportedDepthResolveModes", indents + 1, dump_html_VkResolveModeFlags);
    dump_html_value<const VkResolveModeFlags>(object.supportedStencilResolveModes, settings, "VkResolveModeFlags", "supportedStencilResolveModes", indents + 1, dump_html_VkResolveModeFlags);
    dump_html_value<const VkBool32>(object.independentResolveNone, settings, "VkBool32", "independentResolveNone", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.independentResolve, settings, "VkBool32", "independentResolve", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceScalarBlockLayoutFeatures(const VkPhysicalDeviceScalarBlockLayoutFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.scalarBlockLayout, settings, "VkBool32", "scalarBlockLayout", indents + 1, dump_html_VkBool32);
}
void dump_html_VkImageStencilUsageCreateInfo(const VkImageStencilUsageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.stencilUsage, settings, "VkImageUsageFlags", "stencilUsage", indents + 1, dump_html_VkImageUsageFlags);
}
void dump_html_VkSamplerReductionModeCreateInfo(const VkSamplerReductionModeCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSamplerReductionMode>(object.reductionMode, settings, "VkSamplerReductionMode", "reductionMode", indents + 1, dump_html_VkSamplerReductionMode);
}
void dump_html_VkPhysicalDeviceSamplerFilterMinmaxProperties(const VkPhysicalDeviceSamplerFilterMinmaxProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.filterMinmaxSingleComponentFormats, settings, "VkBool32", "filterMinmaxSingleComponentFormats", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.filterMinmaxImageComponentMapping, settings, "VkBool32", "filterMinmaxImageComponentMapping", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceVulkanMemoryModelFeatures(const VkPhysicalDeviceVulkanMemoryModelFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.vulkanMemoryModel, settings, "VkBool32", "vulkanMemoryModel", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModelDeviceScope, settings, "VkBool32", "vulkanMemoryModelDeviceScope", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModelAvailabilityVisibilityChains, settings, "VkBool32", "vulkanMemoryModelAvailabilityVisibilityChains", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImagelessFramebufferFeatures(const VkPhysicalDeviceImagelessFramebufferFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imagelessFramebuffer, settings, "VkBool32", "imagelessFramebuffer", indents + 1, dump_html_VkBool32);
}
void dump_html_VkFramebufferAttachmentImageInfo(const VkFramebufferAttachmentImageInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCreateFlags>(object.flags, settings, "VkImageCreateFlags", "flags", indents + 1, dump_html_VkImageCreateFlags);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.viewFormatCount, settings, "uint32_t", "viewFormatCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFormat>(object.pViewFormats, object.viewFormatCount, settings, "const VkFormat*", "const VkFormat", "pViewFormats", indents + 1, dump_html_VkFormat); // ZRT
}
void dump_html_VkFramebufferAttachmentsCreateInfo(const VkFramebufferAttachmentsCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentImageInfoCount, settings, "uint32_t", "attachmentImageInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFramebufferAttachmentImageInfo>(object.pAttachmentImageInfos, object.attachmentImageInfoCount, settings, "const VkFramebufferAttachmentImageInfo*", "const VkFramebufferAttachmentImageInfo", "pAttachmentImageInfos", indents + 1, dump_html_VkFramebufferAttachmentImageInfo); // ZRT
}
void dump_html_VkRenderPassAttachmentBeginInfo(const VkRenderPassAttachmentBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageView>(object.pAttachments, object.attachmentCount, settings, "const VkImageView*", "const VkImageView", "pAttachments", indents + 1, dump_html_VkImageView); // ZRT
}
void dump_html_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(const VkPhysicalDeviceUniformBufferStandardLayoutFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.uniformBufferStandardLayout, settings, "VkBool32", "uniformBufferStandardLayout", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSubgroupExtendedTypes, settings, "VkBool32", "shaderSubgroupExtendedTypes", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.separateDepthStencilLayouts, settings, "VkBool32", "separateDepthStencilLayouts", indents + 1, dump_html_VkBool32);
}
void dump_html_VkAttachmentReferenceStencilLayout(const VkAttachmentReferenceStencilLayout& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageLayout>(object.stencilLayout, settings, "VkImageLayout", "stencilLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkAttachmentDescriptionStencilLayout(const VkAttachmentDescriptionStencilLayout& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageLayout>(object.stencilInitialLayout, settings, "VkImageLayout", "stencilInitialLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.stencilFinalLayout, settings, "VkImageLayout", "stencilFinalLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkPhysicalDeviceHostQueryResetFeatures(const VkPhysicalDeviceHostQueryResetFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hostQueryReset, settings, "VkBool32", "hostQueryReset", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceTimelineSemaphoreFeatures(const VkPhysicalDeviceTimelineSemaphoreFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.timelineSemaphore, settings, "VkBool32", "timelineSemaphore", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceTimelineSemaphoreProperties(const VkPhysicalDeviceTimelineSemaphoreProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.maxTimelineSemaphoreValueDifference, settings, "uint64_t", "maxTimelineSemaphoreValueDifference", indents + 1, dump_html_uint64_t);
}
void dump_html_VkSemaphoreTypeCreateInfo(const VkSemaphoreTypeCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphoreType>(object.semaphoreType, settings, "VkSemaphoreType", "semaphoreType", indents + 1, dump_html_VkSemaphoreType);
    dump_html_value<const uint64_t>(object.initialValue, settings, "uint64_t", "initialValue", indents + 1, dump_html_uint64_t);
}
void dump_html_VkTimelineSemaphoreSubmitInfo(const VkTimelineSemaphoreSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreValueCount, settings, "uint32_t", "waitSemaphoreValueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pWaitSemaphoreValues, object.waitSemaphoreValueCount, settings, "const uint64_t*", "const uint64_t", "pWaitSemaphoreValues", indents + 1, dump_html_uint64_t); // ZRT
    dump_html_value<const uint32_t>(object.signalSemaphoreValueCount, settings, "uint32_t", "signalSemaphoreValueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pSignalSemaphoreValues, object.signalSemaphoreValueCount, settings, "const uint64_t*", "const uint64_t", "pSignalSemaphoreValues", indents + 1, dump_html_uint64_t); // ZRT
}
void dump_html_VkSemaphoreWaitInfo(const VkSemaphoreWaitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphoreWaitFlags>(object.flags, settings, "VkSemaphoreWaitFlags", "flags", indents + 1, dump_html_VkSemaphoreWaitFlags);
    dump_html_value<const uint32_t>(object.semaphoreCount, settings, "uint32_t", "semaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pSemaphores, object.semaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pSemaphores", indents + 1, dump_html_VkSemaphore); // ZRT
    dump_html_array<const uint64_t>(object.pValues, object.semaphoreCount, settings, "const uint64_t*", "const uint64_t", "pValues", indents + 1, dump_html_uint64_t); // ZRT
}
void dump_html_VkSemaphoreSignalInfo(const VkSemaphoreSignalInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const uint64_t>(object.value, settings, "uint64_t", "value", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPhysicalDeviceBufferDeviceAddressFeatures(const VkPhysicalDeviceBufferDeviceAddressFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.bufferDeviceAddress, settings, "VkBool32", "bufferDeviceAddress", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressCaptureReplay, settings, "VkBool32", "bufferDeviceAddressCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressMultiDevice, settings, "VkBool32", "bufferDeviceAddressMultiDevice", indents + 1, dump_html_VkBool32);
}
void dump_html_VkBufferDeviceAddressInfo(const VkBufferDeviceAddressInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
}
void dump_html_VkBufferOpaqueCaptureAddressCreateInfo(const VkBufferOpaqueCaptureAddressCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.opaqueCaptureAddress, settings, "uint64_t", "opaqueCaptureAddress", indents + 1, dump_html_uint64_t);
}
void dump_html_VkMemoryOpaqueCaptureAddressAllocateInfo(const VkMemoryOpaqueCaptureAddressAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.opaqueCaptureAddress, settings, "uint64_t", "opaqueCaptureAddress", indents + 1, dump_html_uint64_t);
}
void dump_html_VkDeviceMemoryOpaqueCaptureAddressInfo(const VkDeviceMemoryOpaqueCaptureAddressInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
}
void dump_html_VkPhysicalDeviceVulkan13Features(const VkPhysicalDeviceVulkan13Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.robustImageAccess, settings, "VkBool32", "robustImageAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.inlineUniformBlock, settings, "VkBool32", "inlineUniformBlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingInlineUniformBlockUpdateAfterBind, settings, "VkBool32", "descriptorBindingInlineUniformBlockUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.pipelineCreationCacheControl, settings, "VkBool32", "pipelineCreationCacheControl", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.privateData, settings, "VkBool32", "privateData", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDemoteToHelperInvocation, settings, "VkBool32", "shaderDemoteToHelperInvocation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTerminateInvocation, settings, "VkBool32", "shaderTerminateInvocation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.subgroupSizeControl, settings, "VkBool32", "subgroupSizeControl", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.computeFullSubgroups, settings, "VkBool32", "computeFullSubgroups", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.synchronization2, settings, "VkBool32", "synchronization2", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionASTC_HDR, settings, "VkBool32", "textureCompressionASTC_HDR", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderZeroInitializeWorkgroupMemory, settings, "VkBool32", "shaderZeroInitializeWorkgroupMemory", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dynamicRendering, settings, "VkBool32", "dynamicRendering", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderIntegerDotProduct, settings, "VkBool32", "shaderIntegerDotProduct", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.maintenance4, settings, "VkBool32", "maintenance4", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceVulkan13Properties(const VkPhysicalDeviceVulkan13Properties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minSubgroupSize, settings, "uint32_t", "minSubgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSubgroupSize, settings, "uint32_t", "maxSubgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxComputeWorkgroupSubgroups, settings, "uint32_t", "maxComputeWorkgroupSubgroups", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.requiredSubgroupSizeStages, settings, "VkShaderStageFlags", "requiredSubgroupSizeStages", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const uint32_t>(object.maxInlineUniformBlockSize, settings, "uint32_t", "maxInlineUniformBlockSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorInlineUniformBlocks, settings, "uint32_t", "maxPerStageDescriptorInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetInlineUniformBlocks, settings, "uint32_t", "maxDescriptorSetInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxInlineUniformTotalSize, settings, "uint32_t", "maxInlineUniformTotalSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.integerDotProduct8BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct8BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct8BitSignedAccelerated, settings, "VkBool32", "integerDotProduct8BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct8BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct8BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct4x8BitPackedUnsignedAccelerated, settings, "VkBool32", "integerDotProduct4x8BitPackedUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct4x8BitPackedSignedAccelerated, settings, "VkBool32", "integerDotProduct4x8BitPackedSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct4x8BitPackedMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct4x8BitPackedMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct16BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct16BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct16BitSignedAccelerated, settings, "VkBool32", "integerDotProduct16BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct16BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct16BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct32BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct32BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct32BitSignedAccelerated, settings, "VkBool32", "integerDotProduct32BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct32BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct32BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct64BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct64BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct64BitSignedAccelerated, settings, "VkBool32", "integerDotProduct64BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct64BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct64BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating8BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating8BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating16BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating16BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating32BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating32BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating64BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating64BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.storageTexelBufferOffsetAlignmentBytes, settings, "VkDeviceSize", "storageTexelBufferOffsetAlignmentBytes", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.storageTexelBufferOffsetSingleTexelAlignment, settings, "VkBool32", "storageTexelBufferOffsetSingleTexelAlignment", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.uniformTexelBufferOffsetAlignmentBytes, settings, "VkDeviceSize", "uniformTexelBufferOffsetAlignmentBytes", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.uniformTexelBufferOffsetSingleTexelAlignment, settings, "VkBool32", "uniformTexelBufferOffsetSingleTexelAlignment", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.maxBufferSize, settings, "VkDeviceSize", "maxBufferSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPipelineCreationFeedback(const VkPipelineCreationFeedback& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkPipelineCreationFeedbackFlags>(object.flags, settings, "VkPipelineCreationFeedbackFlags", "flags", indents + 1, dump_html_VkPipelineCreationFeedbackFlags);
    dump_html_value<const uint64_t>(object.duration, settings, "uint64_t", "duration", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPipelineCreationFeedbackCreateInfo(const VkPipelineCreationFeedbackCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkPipelineCreationFeedback>(object.pPipelineCreationFeedback, settings, "VkPipelineCreationFeedback*", "pPipelineCreationFeedback", indents + 1, dump_html_VkPipelineCreationFeedback);
    dump_html_value<const uint32_t>(object.pipelineStageCreationFeedbackCount, settings, "uint32_t", "pipelineStageCreationFeedbackCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineCreationFeedback>(object.pPipelineStageCreationFeedbacks, object.pipelineStageCreationFeedbackCount, settings, "VkPipelineCreationFeedback*", "VkPipelineCreationFeedback", "pPipelineStageCreationFeedbacks", indents + 1, dump_html_VkPipelineCreationFeedback); // ZRT
}
void dump_html_VkPhysicalDeviceShaderTerminateInvocationFeatures(const VkPhysicalDeviceShaderTerminateInvocationFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderTerminateInvocation, settings, "VkBool32", "shaderTerminateInvocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceToolProperties(const VkPhysicalDeviceToolProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.version, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "version", indents + 1, dump_html_cstring);
    dump_html_value<const VkToolPurposeFlags>(object.purposes, settings, "VkToolPurposeFlags", "purposes", indents + 1, dump_html_VkToolPurposeFlags);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.layer, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "layer", indents + 1, dump_html_cstring);
}
void dump_html_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderDemoteToHelperInvocation, settings, "VkBool32", "shaderDemoteToHelperInvocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePrivateDataFeatures(const VkPhysicalDevicePrivateDataFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.privateData, settings, "VkBool32", "privateData", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDevicePrivateDataCreateInfo(const VkDevicePrivateDataCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.privateDataSlotRequestCount, settings, "uint32_t", "privateDataSlotRequestCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPrivateDataSlotCreateInfo(const VkPrivateDataSlotCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPrivateDataSlotCreateFlags>(object.flags, settings, "VkPrivateDataSlotCreateFlags", "flags", indents + 1, dump_html_VkPrivateDataSlotCreateFlags);
}
void dump_html_VkPhysicalDevicePipelineCreationCacheControlFeatures(const VkPhysicalDevicePipelineCreationCacheControlFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineCreationCacheControl, settings, "VkBool32", "pipelineCreationCacheControl", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMemoryBarrier2(const VkMemoryBarrier2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags2>(object.srcStageMask, settings, "VkPipelineStageFlags2", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const VkAccessFlags2>(object.srcAccessMask, settings, "VkAccessFlags2", "srcAccessMask", indents + 1, dump_html_VkAccessFlags2);
    dump_html_value<const VkPipelineStageFlags2>(object.dstStageMask, settings, "VkPipelineStageFlags2", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const VkAccessFlags2>(object.dstAccessMask, settings, "VkAccessFlags2", "dstAccessMask", indents + 1, dump_html_VkAccessFlags2);
}
void dump_html_VkBufferMemoryBarrier2(const VkBufferMemoryBarrier2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags2>(object.srcStageMask, settings, "VkPipelineStageFlags2", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const VkAccessFlags2>(object.srcAccessMask, settings, "VkAccessFlags2", "srcAccessMask", indents + 1, dump_html_VkAccessFlags2);
    dump_html_value<const VkPipelineStageFlags2>(object.dstStageMask, settings, "VkPipelineStageFlags2", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const VkAccessFlags2>(object.dstAccessMask, settings, "VkAccessFlags2", "dstAccessMask", indents + 1, dump_html_VkAccessFlags2);
    dump_html_value<const uint32_t>(object.srcQueueFamilyIndex, settings, "uint32_t", "srcQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstQueueFamilyIndex, settings, "uint32_t", "dstQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkImageMemoryBarrier2(const VkImageMemoryBarrier2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags2>(object.srcStageMask, settings, "VkPipelineStageFlags2", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const VkAccessFlags2>(object.srcAccessMask, settings, "VkAccessFlags2", "srcAccessMask", indents + 1, dump_html_VkAccessFlags2);
    dump_html_value<const VkPipelineStageFlags2>(object.dstStageMask, settings, "VkPipelineStageFlags2", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const VkAccessFlags2>(object.dstAccessMask, settings, "VkAccessFlags2", "dstAccessMask", indents + 1, dump_html_VkAccessFlags2);
    dump_html_value<const VkImageLayout>(object.oldLayout, settings, "VkImageLayout", "oldLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.newLayout, settings, "VkImageLayout", "newLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.srcQueueFamilyIndex, settings, "uint32_t", "srcQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstQueueFamilyIndex, settings, "uint32_t", "dstQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageSubresourceRange>(object.subresourceRange, settings, "VkImageSubresourceRange", "subresourceRange", indents + 1, dump_html_VkImageSubresourceRange);
}
void dump_html_VkDependencyInfo(const VkDependencyInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDependencyFlags>(object.dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", indents + 1, dump_html_VkDependencyFlags);
    dump_html_value<const uint32_t>(object.memoryBarrierCount, settings, "uint32_t", "memoryBarrierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMemoryBarrier2>(object.pMemoryBarriers, object.memoryBarrierCount, settings, "const VkMemoryBarrier2*", "const VkMemoryBarrier2", "pMemoryBarriers", indents + 1, dump_html_VkMemoryBarrier2); // ZRT
    dump_html_value<const uint32_t>(object.bufferMemoryBarrierCount, settings, "uint32_t", "bufferMemoryBarrierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkBufferMemoryBarrier2>(object.pBufferMemoryBarriers, object.bufferMemoryBarrierCount, settings, "const VkBufferMemoryBarrier2*", "const VkBufferMemoryBarrier2", "pBufferMemoryBarriers", indents + 1, dump_html_VkBufferMemoryBarrier2); // ZRT
    dump_html_value<const uint32_t>(object.imageMemoryBarrierCount, settings, "uint32_t", "imageMemoryBarrierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageMemoryBarrier2>(object.pImageMemoryBarriers, object.imageMemoryBarrierCount, settings, "const VkImageMemoryBarrier2*", "const VkImageMemoryBarrier2", "pImageMemoryBarriers", indents + 1, dump_html_VkImageMemoryBarrier2); // ZRT
}
void dump_html_VkSemaphoreSubmitInfo(const VkSemaphoreSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const uint64_t>(object.value, settings, "uint64_t", "value", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkPipelineStageFlags2>(object.stageMask, settings, "VkPipelineStageFlags2", "stageMask", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const uint32_t>(object.deviceIndex, settings, "uint32_t", "deviceIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCommandBufferSubmitInfo(const VkCommandBufferSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandBuffer>(object.commandBuffer, settings, "VkCommandBuffer", "commandBuffer", indents + 1, dump_html_VkCommandBuffer);
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
}
void dump_html_VkSubmitInfo2(const VkSubmitInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSubmitFlags>(object.flags, settings, "VkSubmitFlags", "flags", indents + 1, dump_html_VkSubmitFlags);
    dump_html_value<const uint32_t>(object.waitSemaphoreInfoCount, settings, "uint32_t", "waitSemaphoreInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphoreSubmitInfo>(object.pWaitSemaphoreInfos, object.waitSemaphoreInfoCount, settings, "const VkSemaphoreSubmitInfo*", "const VkSemaphoreSubmitInfo", "pWaitSemaphoreInfos", indents + 1, dump_html_VkSemaphoreSubmitInfo); // ZRT
    dump_html_value<const uint32_t>(object.commandBufferInfoCount, settings, "uint32_t", "commandBufferInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCommandBufferSubmitInfo>(object.pCommandBufferInfos, object.commandBufferInfoCount, settings, "const VkCommandBufferSubmitInfo*", "const VkCommandBufferSubmitInfo", "pCommandBufferInfos", indents + 1, dump_html_VkCommandBufferSubmitInfo); // ZRT
    dump_html_value<const uint32_t>(object.signalSemaphoreInfoCount, settings, "uint32_t", "signalSemaphoreInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphoreSubmitInfo>(object.pSignalSemaphoreInfos, object.signalSemaphoreInfoCount, settings, "const VkSemaphoreSubmitInfo*", "const VkSemaphoreSubmitInfo", "pSignalSemaphoreInfos", indents + 1, dump_html_VkSemaphoreSubmitInfo); // ZRT
}
void dump_html_VkPhysicalDeviceSynchronization2Features(const VkPhysicalDeviceSynchronization2Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.synchronization2, settings, "VkBool32", "synchronization2", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderZeroInitializeWorkgroupMemory, settings, "VkBool32", "shaderZeroInitializeWorkgroupMemory", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageRobustnessFeatures(const VkPhysicalDeviceImageRobustnessFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.robustImageAccess, settings, "VkBool32", "robustImageAccess", indents + 1, dump_html_VkBool32);
}
void dump_html_VkBufferCopy2(const VkBufferCopy2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.srcOffset, settings, "VkDeviceSize", "srcOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.dstOffset, settings, "VkDeviceSize", "dstOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkCopyBufferInfo2(const VkCopyBufferInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.srcBuffer, settings, "VkBuffer", "srcBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkBuffer>(object.dstBuffer, settings, "VkBuffer", "dstBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkBufferCopy2>(object.pRegions, object.regionCount, settings, "const VkBufferCopy2*", "const VkBufferCopy2", "pRegions", indents + 1, dump_html_VkBufferCopy2); // ZRT
}
void dump_html_VkImageCopy2(const VkImageCopy2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.srcOffset, settings, "VkOffset3D", "srcOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.dstOffset, settings, "VkOffset3D", "dstOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkCopyImageInfo2(const VkCopyImageInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.srcImage, settings, "VkImage", "srcImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.srcImageLayout, settings, "VkImageLayout", "srcImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImage>(object.dstImage, settings, "VkImage", "dstImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.dstImageLayout, settings, "VkImageLayout", "dstImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageCopy2>(object.pRegions, object.regionCount, settings, "const VkImageCopy2*", "const VkImageCopy2", "pRegions", indents + 1, dump_html_VkImageCopy2); // ZRT
}
void dump_html_VkBufferImageCopy2(const VkBufferImageCopy2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.bufferOffset, settings, "VkDeviceSize", "bufferOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.bufferRowLength, settings, "uint32_t", "bufferRowLength", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.bufferImageHeight, settings, "uint32_t", "bufferImageHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageSubresourceLayers>(object.imageSubresource, settings, "VkImageSubresourceLayers", "imageSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.imageOffset, settings, "VkOffset3D", "imageOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.imageExtent, settings, "VkExtent3D", "imageExtent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkCopyBufferToImageInfo2(const VkCopyBufferToImageInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.srcBuffer, settings, "VkBuffer", "srcBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkImage>(object.dstImage, settings, "VkImage", "dstImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.dstImageLayout, settings, "VkImageLayout", "dstImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkBufferImageCopy2>(object.pRegions, object.regionCount, settings, "const VkBufferImageCopy2*", "const VkBufferImageCopy2", "pRegions", indents + 1, dump_html_VkBufferImageCopy2); // ZRT
}
void dump_html_VkCopyImageToBufferInfo2(const VkCopyImageToBufferInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.srcImage, settings, "VkImage", "srcImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.srcImageLayout, settings, "VkImageLayout", "srcImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkBuffer>(object.dstBuffer, settings, "VkBuffer", "dstBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkBufferImageCopy2>(object.pRegions, object.regionCount, settings, "const VkBufferImageCopy2*", "const VkBufferImageCopy2", "pRegions", indents + 1, dump_html_VkBufferImageCopy2); // ZRT
}
void dump_html_VkImageBlit2(const VkImageBlit2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_array<const VkOffset3D>(object.srcOffsets, 2, settings, "VkOffset3D[2]", "VkOffset3D", "srcOffsets", indents + 1, dump_html_VkOffset3D); // ZRR
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_array<const VkOffset3D>(object.dstOffsets, 2, settings, "VkOffset3D[2]", "VkOffset3D", "dstOffsets", indents + 1, dump_html_VkOffset3D); // ZRR
}
void dump_html_VkBlitImageInfo2(const VkBlitImageInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.srcImage, settings, "VkImage", "srcImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.srcImageLayout, settings, "VkImageLayout", "srcImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImage>(object.dstImage, settings, "VkImage", "dstImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.dstImageLayout, settings, "VkImageLayout", "dstImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageBlit2>(object.pRegions, object.regionCount, settings, "const VkImageBlit2*", "const VkImageBlit2", "pRegions", indents + 1, dump_html_VkImageBlit2); // ZRT
    dump_html_value<const VkFilter>(object.filter, settings, "VkFilter", "filter", indents + 1, dump_html_VkFilter);
}
void dump_html_VkImageResolve2(const VkImageResolve2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.srcOffset, settings, "VkOffset3D", "srcOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.dstOffset, settings, "VkOffset3D", "dstOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkResolveImageInfo2(const VkResolveImageInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.srcImage, settings, "VkImage", "srcImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.srcImageLayout, settings, "VkImageLayout", "srcImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImage>(object.dstImage, settings, "VkImage", "dstImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.dstImageLayout, settings, "VkImageLayout", "dstImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageResolve2>(object.pRegions, object.regionCount, settings, "const VkImageResolve2*", "const VkImageResolve2", "pRegions", indents + 1, dump_html_VkImageResolve2); // ZRT
}
void dump_html_VkPhysicalDeviceSubgroupSizeControlFeatures(const VkPhysicalDeviceSubgroupSizeControlFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.subgroupSizeControl, settings, "VkBool32", "subgroupSizeControl", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.computeFullSubgroups, settings, "VkBool32", "computeFullSubgroups", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceSubgroupSizeControlProperties(const VkPhysicalDeviceSubgroupSizeControlProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minSubgroupSize, settings, "uint32_t", "minSubgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSubgroupSize, settings, "uint32_t", "maxSubgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxComputeWorkgroupSubgroups, settings, "uint32_t", "maxComputeWorkgroupSubgroups", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.requiredSubgroupSizeStages, settings, "VkShaderStageFlags", "requiredSubgroupSizeStages", indents + 1, dump_html_VkShaderStageFlags);
}
void dump_html_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.requiredSubgroupSize, settings, "uint32_t", "requiredSubgroupSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceInlineUniformBlockFeatures(const VkPhysicalDeviceInlineUniformBlockFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.inlineUniformBlock, settings, "VkBool32", "inlineUniformBlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingInlineUniformBlockUpdateAfterBind, settings, "VkBool32", "descriptorBindingInlineUniformBlockUpdateAfterBind", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceInlineUniformBlockProperties(const VkPhysicalDeviceInlineUniformBlockProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxInlineUniformBlockSize, settings, "uint32_t", "maxInlineUniformBlockSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorInlineUniformBlocks, settings, "uint32_t", "maxPerStageDescriptorInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetInlineUniformBlocks, settings, "uint32_t", "maxDescriptorSetInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindInlineUniformBlocks", indents + 1, dump_html_uint32_t);
}
void dump_html_VkWriteDescriptorSetInlineUniformBlock(const VkWriteDescriptorSetInlineUniformBlock& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.dataSize, settings, "uint32_t", "dataSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
}
void dump_html_VkDescriptorPoolInlineUniformBlockCreateInfo(const VkDescriptorPoolInlineUniformBlockCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxInlineUniformBlockBindings, settings, "uint32_t", "maxInlineUniformBlockBindings", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(const VkPhysicalDeviceTextureCompressionASTCHDRFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.textureCompressionASTC_HDR, settings, "VkBool32", "textureCompressionASTC_HDR", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderingAttachmentInfo(const VkRenderingAttachmentInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkImageLayout>(object.imageLayout, settings, "VkImageLayout", "imageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkResolveModeFlagBits>(object.resolveMode, settings, "VkResolveModeFlagBits", "resolveMode", indents + 1, dump_html_VkResolveModeFlagBits);
    dump_html_value<const VkImageView>(object.resolveImageView, settings, "VkImageView", "resolveImageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkImageLayout>(object.resolveImageLayout, settings, "VkImageLayout", "resolveImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkAttachmentLoadOp>(object.loadOp, settings, "VkAttachmentLoadOp", "loadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.storeOp, settings, "VkAttachmentStoreOp", "storeOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkClearValue>(object.clearValue, settings, "VkClearValue", "clearValue", indents + 1, dump_html_VkClearValue);
}
void dump_html_VkRenderingInfo(const VkRenderingInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderingFlags>(object.flags, settings, "VkRenderingFlags", "flags", indents + 1, dump_html_VkRenderingFlags);
    dump_html_value<const VkRect2D>(object.renderArea, settings, "VkRect2D", "renderArea", indents + 1, dump_html_VkRect2D);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.viewMask, settings, "uint32_t", "viewMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRenderingAttachmentInfo>(object.pColorAttachments, object.colorAttachmentCount, settings, "const VkRenderingAttachmentInfo*", "const VkRenderingAttachmentInfo", "pColorAttachments", indents + 1, dump_html_VkRenderingAttachmentInfo); // ZRT
    dump_html_pointer<const VkRenderingAttachmentInfo>(object.pDepthAttachment, settings, "const VkRenderingAttachmentInfo*", "pDepthAttachment", indents + 1, dump_html_VkRenderingAttachmentInfo);
    dump_html_pointer<const VkRenderingAttachmentInfo>(object.pStencilAttachment, settings, "const VkRenderingAttachmentInfo*", "pStencilAttachment", indents + 1, dump_html_VkRenderingAttachmentInfo);
}
void dump_html_VkPipelineRenderingCreateInfo(const VkPipelineRenderingCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.viewMask, settings, "uint32_t", "viewMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    if(!ApiDumpInstance::current().getIsGPLPreRasterOrFragmentShader())
    dump_html_array<const VkFormat>(object.pColorAttachmentFormats, object.colorAttachmentCount, settings, "const VkFormat*", "const VkFormat", "pColorAttachmentFormats", indents + 1, dump_html_VkFormat); // ZRT
    else
        dump_html_special("UNUSED", settings, "const VkFormat*", "pColorAttachmentFormats", indents + 1);
    if(!ApiDumpInstance::current().getIsGPLPreRasterOrFragmentShader())
    dump_html_value<const VkFormat>(object.depthAttachmentFormat, settings, "VkFormat", "depthAttachmentFormat", indents + 1, dump_html_VkFormat);
    else
        dump_html_special("UNUSED", settings, "VkFormat", "depthAttachmentFormat", indents + 1);
    if(!ApiDumpInstance::current().getIsGPLPreRasterOrFragmentShader())
    dump_html_value<const VkFormat>(object.stencilAttachmentFormat, settings, "VkFormat", "stencilAttachmentFormat", indents + 1, dump_html_VkFormat);
    else
        dump_html_special("UNUSED", settings, "VkFormat", "stencilAttachmentFormat", indents + 1);
}
void dump_html_VkPhysicalDeviceDynamicRenderingFeatures(const VkPhysicalDeviceDynamicRenderingFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dynamicRendering, settings, "VkBool32", "dynamicRendering", indents + 1, dump_html_VkBool32);
}
void dump_html_VkCommandBufferInheritanceRenderingInfo(const VkCommandBufferInheritanceRenderingInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderingFlags>(object.flags, settings, "VkRenderingFlags", "flags", indents + 1, dump_html_VkRenderingFlags);
    dump_html_value<const uint32_t>(object.viewMask, settings, "uint32_t", "viewMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFormat>(object.pColorAttachmentFormats, object.colorAttachmentCount, settings, "const VkFormat*", "const VkFormat", "pColorAttachmentFormats", indents + 1, dump_html_VkFormat); // ZRT
    dump_html_value<const VkFormat>(object.depthAttachmentFormat, settings, "VkFormat", "depthAttachmentFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkFormat>(object.stencilAttachmentFormat, settings, "VkFormat", "stencilAttachmentFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSampleCountFlagBits>(object.rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
}
void dump_html_VkPhysicalDeviceShaderIntegerDotProductFeatures(const VkPhysicalDeviceShaderIntegerDotProductFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderIntegerDotProduct, settings, "VkBool32", "shaderIntegerDotProduct", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderIntegerDotProductProperties(const VkPhysicalDeviceShaderIntegerDotProductProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.integerDotProduct8BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct8BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct8BitSignedAccelerated, settings, "VkBool32", "integerDotProduct8BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct8BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct8BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct4x8BitPackedUnsignedAccelerated, settings, "VkBool32", "integerDotProduct4x8BitPackedUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct4x8BitPackedSignedAccelerated, settings, "VkBool32", "integerDotProduct4x8BitPackedSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct4x8BitPackedMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct4x8BitPackedMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct16BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct16BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct16BitSignedAccelerated, settings, "VkBool32", "integerDotProduct16BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct16BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct16BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct32BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct32BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct32BitSignedAccelerated, settings, "VkBool32", "integerDotProduct32BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct32BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct32BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct64BitUnsignedAccelerated, settings, "VkBool32", "integerDotProduct64BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct64BitSignedAccelerated, settings, "VkBool32", "integerDotProduct64BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProduct64BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProduct64BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating8BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating8BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating16BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating16BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating32BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating32BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating64BitSignedAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating64BitSignedAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated, settings, "VkBool32", "integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceTexelBufferAlignmentProperties(const VkPhysicalDeviceTexelBufferAlignmentProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.storageTexelBufferOffsetAlignmentBytes, settings, "VkDeviceSize", "storageTexelBufferOffsetAlignmentBytes", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.storageTexelBufferOffsetSingleTexelAlignment, settings, "VkBool32", "storageTexelBufferOffsetSingleTexelAlignment", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.uniformTexelBufferOffsetAlignmentBytes, settings, "VkDeviceSize", "uniformTexelBufferOffsetAlignmentBytes", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.uniformTexelBufferOffsetSingleTexelAlignment, settings, "VkBool32", "uniformTexelBufferOffsetSingleTexelAlignment", indents + 1, dump_html_VkBool32);
}
void dump_html_VkFormatProperties3(const VkFormatProperties3& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormatFeatureFlags2>(object.linearTilingFeatures, settings, "VkFormatFeatureFlags2", "linearTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags2);
    dump_html_value<const VkFormatFeatureFlags2>(object.optimalTilingFeatures, settings, "VkFormatFeatureFlags2", "optimalTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags2);
    dump_html_value<const VkFormatFeatureFlags2>(object.bufferFeatures, settings, "VkFormatFeatureFlags2", "bufferFeatures", indents + 1, dump_html_VkFormatFeatureFlags2);
}
void dump_html_VkPhysicalDeviceMaintenance4Features(const VkPhysicalDeviceMaintenance4Features& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.maintenance4, settings, "VkBool32", "maintenance4", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMaintenance4Properties(const VkPhysicalDeviceMaintenance4Properties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.maxBufferSize, settings, "VkDeviceSize", "maxBufferSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkDeviceBufferMemoryRequirements(const VkDeviceBufferMemoryRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkBufferCreateInfo>(object.pCreateInfo, settings, "const VkBufferCreateInfo*", "pCreateInfo", indents + 1, dump_html_VkBufferCreateInfo);
}
void dump_html_VkDeviceImageMemoryRequirements(const VkDeviceImageMemoryRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkImageCreateInfo>(object.pCreateInfo, settings, "const VkImageCreateInfo*", "pCreateInfo", indents + 1, dump_html_VkImageCreateInfo);
    dump_html_value<const VkImageAspectFlagBits>(object.planeAspect, settings, "VkImageAspectFlagBits", "planeAspect", indents + 1, dump_html_VkImageAspectFlagBits);
}
void dump_html_VkSurfaceCapabilitiesKHR(const VkSurfaceCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.minImageCount, settings, "uint32_t", "minImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageCount, settings, "uint32_t", "maxImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.currentExtent, settings, "VkExtent2D", "currentExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.minImageExtent, settings, "VkExtent2D", "minImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxImageExtent, settings, "VkExtent2D", "maxImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxImageArrayLayers, settings, "uint32_t", "maxImageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSurfaceTransformFlagsKHR>(object.supportedTransforms, settings, "VkSurfaceTransformFlagsKHR", "supportedTransforms", indents + 1, dump_html_VkSurfaceTransformFlagsKHR);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.currentTransform, settings, "VkSurfaceTransformFlagBitsKHR", "currentTransform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkCompositeAlphaFlagsKHR>(object.supportedCompositeAlpha, settings, "VkCompositeAlphaFlagsKHR", "supportedCompositeAlpha", indents + 1, dump_html_VkCompositeAlphaFlagsKHR);
    dump_html_value<const VkImageUsageFlags>(object.supportedUsageFlags, settings, "VkImageUsageFlags", "supportedUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
}
void dump_html_VkSurfaceFormatKHR(const VkSurfaceFormatKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkColorSpaceKHR>(object.colorSpace, settings, "VkColorSpaceKHR", "colorSpace", indents + 1, dump_html_VkColorSpaceKHR);
}
void dump_html_VkSwapchainCreateInfoKHR(const VkSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainCreateFlagsKHR>(object.flags, settings, "VkSwapchainCreateFlagsKHR", "flags", indents + 1, dump_html_VkSwapchainCreateFlagsKHR);
    dump_html_value<const VkSurfaceKHR>(object.surface, settings, "VkSurfaceKHR", "surface", indents + 1, dump_html_VkSurfaceKHR);
    dump_html_value<const uint32_t>(object.minImageCount, settings, "uint32_t", "minImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormat>(object.imageFormat, settings, "VkFormat", "imageFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkColorSpaceKHR>(object.imageColorSpace, settings, "VkColorSpaceKHR", "imageColorSpace", indents + 1, dump_html_VkColorSpaceKHR);
    dump_html_value<const VkExtent2D>(object.imageExtent, settings, "VkExtent2D", "imageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.imageArrayLayers, settings, "uint32_t", "imageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageUsageFlags>(object.imageUsage, settings, "VkImageUsageFlags", "imageUsage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkSharingMode>(object.imageSharingMode, settings, "VkSharingMode", "imageSharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    if(object.imageSharingMode == VK_SHARING_MODE_CONCURRENT)
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t); // ZRT
    else
        dump_html_special("UNUSED", settings, "const uint32_t*", "pQueueFamilyIndices", indents + 1);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.preTransform, settings, "VkSurfaceTransformFlagBitsKHR", "preTransform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkCompositeAlphaFlagBitsKHR>(object.compositeAlpha, settings, "VkCompositeAlphaFlagBitsKHR", "compositeAlpha", indents + 1, dump_html_VkCompositeAlphaFlagBitsKHR);
    dump_html_value<const VkPresentModeKHR>(object.presentMode, settings, "VkPresentModeKHR", "presentMode", indents + 1, dump_html_VkPresentModeKHR);
    dump_html_value<const VkBool32>(object.clipped, settings, "VkBool32", "clipped", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkSwapchainKHR>(object.oldSwapchain, settings, "VkSwapchainKHR", "oldSwapchain", indents + 1, dump_html_VkSwapchainKHR);
}
void dump_html_VkPresentInfoKHR(const VkPresentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pWaitSemaphores, object.waitSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pWaitSemaphores", indents + 1, dump_html_VkSemaphore); // ZRT
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSwapchainKHR>(object.pSwapchains, object.swapchainCount, settings, "const VkSwapchainKHR*", "const VkSwapchainKHR", "pSwapchains", indents + 1, dump_html_VkSwapchainKHR); // ZRT
    dump_html_array<const uint32_t>(object.pImageIndices, object.swapchainCount, settings, "const uint32_t*", "const uint32_t", "pImageIndices", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_array<const VkResult>(object.pResults, object.swapchainCount, settings, "VkResult*", "VkResult", "pResults", indents + 1, dump_html_VkResult); // ZRT
}
void dump_html_VkImageSwapchainCreateInfoKHR(const VkImageSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
}
void dump_html_VkBindImageMemorySwapchainInfoKHR(const VkBindImageMemorySwapchainInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
    dump_html_value<const uint32_t>(object.imageIndex, settings, "uint32_t", "imageIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkAcquireNextImageInfoKHR(const VkAcquireNextImageInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
    dump_html_value<const uint64_t>(object.timeout, settings, "uint64_t", "timeout", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDeviceGroupPresentCapabilitiesKHR(const VkDeviceGroupPresentCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint32_t>(object.presentMask, 32, settings, "uint32_t[VK_MAX_DEVICE_GROUP_SIZE]", "uint32_t", "presentMask", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const VkDeviceGroupPresentModeFlagsKHR>(object.modes, settings, "VkDeviceGroupPresentModeFlagsKHR", "modes", indents + 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
}
void dump_html_VkDeviceGroupPresentInfoKHR(const VkDeviceGroupPresentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceMasks, object.swapchainCount, settings, "const uint32_t*", "const uint32_t", "pDeviceMasks", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const VkDeviceGroupPresentModeFlagBitsKHR>(object.mode, settings, "VkDeviceGroupPresentModeFlagBitsKHR", "mode", indents + 1, dump_html_VkDeviceGroupPresentModeFlagBitsKHR);
}
void dump_html_VkDeviceGroupSwapchainCreateInfoKHR(const VkDeviceGroupSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceGroupPresentModeFlagsKHR>(object.modes, settings, "VkDeviceGroupPresentModeFlagsKHR", "modes", indents + 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
}
void dump_html_VkDisplayModeParametersKHR(const VkDisplayModeParametersKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkExtent2D>(object.visibleRegion, settings, "VkExtent2D", "visibleRegion", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.refreshRate, settings, "uint32_t", "refreshRate", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDisplayModeCreateInfoKHR(const VkDisplayModeCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayModeCreateFlagsKHR>(object.flags, settings, "VkDisplayModeCreateFlagsKHR", "flags", indents + 1, dump_html_VkDisplayModeCreateFlagsKHR);
    dump_html_value<const VkDisplayModeParametersKHR>(object.parameters, settings, "VkDisplayModeParametersKHR", "parameters", indents + 1, dump_html_VkDisplayModeParametersKHR);
}
void dump_html_VkDisplayModePropertiesKHR(const VkDisplayModePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayModeKHR>(object.displayMode, settings, "VkDisplayModeKHR", "displayMode", indents + 1, dump_html_VkDisplayModeKHR);
    dump_html_value<const VkDisplayModeParametersKHR>(object.parameters, settings, "VkDisplayModeParametersKHR", "parameters", indents + 1, dump_html_VkDisplayModeParametersKHR);
}
void dump_html_VkDisplayPlaneCapabilitiesKHR(const VkDisplayPlaneCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayPlaneAlphaFlagsKHR>(object.supportedAlpha, settings, "VkDisplayPlaneAlphaFlagsKHR", "supportedAlpha", indents + 1, dump_html_VkDisplayPlaneAlphaFlagsKHR);
    dump_html_value<const VkOffset2D>(object.minSrcPosition, settings, "VkOffset2D", "minSrcPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkOffset2D>(object.maxSrcPosition, settings, "VkOffset2D", "maxSrcPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.minSrcExtent, settings, "VkExtent2D", "minSrcExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxSrcExtent, settings, "VkExtent2D", "maxSrcExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkOffset2D>(object.minDstPosition, settings, "VkOffset2D", "minDstPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkOffset2D>(object.maxDstPosition, settings, "VkOffset2D", "maxDstPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.minDstExtent, settings, "VkExtent2D", "minDstExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxDstExtent, settings, "VkExtent2D", "maxDstExtent", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkDisplayPlanePropertiesKHR(const VkDisplayPlanePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayKHR>(object.currentDisplay, settings, "VkDisplayKHR", "currentDisplay", indents + 1, dump_html_VkDisplayKHR);
    dump_html_value<const uint32_t>(object.currentStackIndex, settings, "uint32_t", "currentStackIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDisplayPropertiesKHR(const VkDisplayPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayKHR>(object.display, settings, "VkDisplayKHR", "display", indents + 1, dump_html_VkDisplayKHR);
    dump_html_value<const char*>(object.displayName, settings, "const char*", "displayName", indents + 1, dump_html_cstring);
    dump_html_value<const VkExtent2D>(object.physicalDimensions, settings, "VkExtent2D", "physicalDimensions", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.physicalResolution, settings, "VkExtent2D", "physicalResolution", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkSurfaceTransformFlagsKHR>(object.supportedTransforms, settings, "VkSurfaceTransformFlagsKHR", "supportedTransforms", indents + 1, dump_html_VkSurfaceTransformFlagsKHR);
    dump_html_value<const VkBool32>(object.planeReorderPossible, settings, "VkBool32", "planeReorderPossible", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.persistentContent, settings, "VkBool32", "persistentContent", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDisplaySurfaceCreateInfoKHR(const VkDisplaySurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplaySurfaceCreateFlagsKHR>(object.flags, settings, "VkDisplaySurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkDisplaySurfaceCreateFlagsKHR);
    dump_html_value<const VkDisplayModeKHR>(object.displayMode, settings, "VkDisplayModeKHR", "displayMode", indents + 1, dump_html_VkDisplayModeKHR);
    dump_html_value<const uint32_t>(object.planeIndex, settings, "uint32_t", "planeIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.planeStackIndex, settings, "uint32_t", "planeStackIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.transform, settings, "VkSurfaceTransformFlagBitsKHR", "transform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const float>(object.globalAlpha, settings, "float", "globalAlpha", indents + 1, dump_html_float);
    dump_html_value<const VkDisplayPlaneAlphaFlagBitsKHR>(object.alphaMode, settings, "VkDisplayPlaneAlphaFlagBitsKHR", "alphaMode", indents + 1, dump_html_VkDisplayPlaneAlphaFlagBitsKHR);
    dump_html_value<const VkExtent2D>(object.imageExtent, settings, "VkExtent2D", "imageExtent", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkDisplayPresentInfoKHR(const VkDisplayPresentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRect2D>(object.srcRect, settings, "VkRect2D", "srcRect", indents + 1, dump_html_VkRect2D);
    dump_html_value<const VkRect2D>(object.dstRect, settings, "VkRect2D", "dstRect", indents + 1, dump_html_VkRect2D);
    dump_html_value<const VkBool32>(object.persistent, settings, "VkBool32", "persistent", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_VkXlibSurfaceCreateInfoKHR(const VkXlibSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkXlibSurfaceCreateFlagsKHR>(object.flags, settings, "VkXlibSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkXlibSurfaceCreateFlagsKHR);
    dump_html_value<const Display*>(object.dpy, settings, "Display*", "dpy", indents + 1, dump_html_Display);
    dump_html_value<const Window>(object.window, settings, "Window", "window", indents + 1, dump_html_Window);
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_VkXcbSurfaceCreateInfoKHR(const VkXcbSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkXcbSurfaceCreateFlagsKHR>(object.flags, settings, "VkXcbSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkXcbSurfaceCreateFlagsKHR);
    dump_html_value<const xcb_connection_t*>(object.connection, settings, "xcb_connection_t*", "connection", indents + 1, dump_html_xcb_connection_t);
    dump_html_value<const xcb_window_t>(object.window, settings, "xcb_window_t", "window", indents + 1, dump_html_xcb_window_t);
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
void dump_html_VkWaylandSurfaceCreateInfoKHR(const VkWaylandSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkWaylandSurfaceCreateFlagsKHR>(object.flags, settings, "VkWaylandSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkWaylandSurfaceCreateFlagsKHR);
    dump_html_value<const wl_display*>(object.display, settings, "struct wl_display*", "display", indents + 1, dump_html_wl_display);
    dump_html_value<const wl_surface*>(object.surface, settings, "struct wl_surface*", "surface", indents + 1, dump_html_wl_surface);
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidSurfaceCreateInfoKHR(const VkAndroidSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAndroidSurfaceCreateFlagsKHR>(object.flags, settings, "VkAndroidSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkAndroidSurfaceCreateFlagsKHR);
    dump_html_value<const ANativeWindow*>(object.window, settings, "struct ANativeWindow*", "window", indents + 1, dump_html_ANativeWindow);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkWin32SurfaceCreateInfoKHR(const VkWin32SurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkWin32SurfaceCreateFlagsKHR>(object.flags, settings, "VkWin32SurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkWin32SurfaceCreateFlagsKHR);
    dump_html_value<const HINSTANCE>(object.hinstance, settings, "HINSTANCE", "hinstance", indents + 1, dump_html_HINSTANCE);
    dump_html_value<const HWND>(object.hwnd, settings, "HWND", "hwnd", indents + 1, dump_html_HWND);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkDebugReportCallbackCreateInfoEXT(const VkDebugReportCallbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugReportFlagsEXT>(object.flags, settings, "VkDebugReportFlagsEXT", "flags", indents + 1, dump_html_VkDebugReportFlagsEXT);
    dump_html_value<const PFN_vkDebugReportCallbackEXT>(object.pfnCallback, settings, "PFN_vkDebugReportCallbackEXT", "pfnCallback", indents + 1, dump_html_PFN_vkDebugReportCallbackEXT);
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
}
void dump_html_VkPipelineRasterizationStateRasterizationOrderAMD(const VkPipelineRasterizationStateRasterizationOrderAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRasterizationOrderAMD>(object.rasterizationOrder, settings, "VkRasterizationOrderAMD", "rasterizationOrder", indents + 1, dump_html_VkRasterizationOrderAMD);
}
void dump_html_VkDebugMarkerObjectNameInfoEXT(const VkDebugMarkerObjectNameInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugReportObjectTypeEXT>(object.objectType, settings, "VkDebugReportObjectTypeEXT", "objectType", indents + 1, dump_html_VkDebugReportObjectTypeEXT);
    dump_html_value<const uint64_t>(object.object, settings, "uint64_t", "object", indents + 1, dump_html_uint64_t);
    dump_html_value<const char*>(object.pObjectName, settings, "const char*", "pObjectName", indents + 1, dump_html_cstring);
}
void dump_html_VkDebugMarkerObjectTagInfoEXT(const VkDebugMarkerObjectTagInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugReportObjectTypeEXT>(object.objectType, settings, "VkDebugReportObjectTypeEXT", "objectType", indents + 1, dump_html_VkDebugReportObjectTypeEXT);
    dump_html_value<const uint64_t>(object.object, settings, "uint64_t", "object", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.tagName, settings, "uint64_t", "tagName", indents + 1, dump_html_uint64_t);
    dump_html_value<const size_t>(object.tagSize, settings, "size_t", "tagSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pTag, settings, "const void*", "pTag", indents + 1, dump_html_void);
}
void dump_html_VkDebugMarkerMarkerInfoEXT(const VkDebugMarkerMarkerInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pMarkerName, settings, "const char*", "pMarkerName", indents + 1, dump_html_cstring);
    dump_html_array<const float>(object.color, 4, settings, "float[4]", "float", "color", indents + 1, dump_html_float); // ZRR
}
void dump_html_VkQueueFamilyQueryResultStatusPropertiesKHR(const VkQueueFamilyQueryResultStatusPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.queryResultStatusSupport, settings, "VkBool32", "queryResultStatusSupport", indents + 1, dump_html_VkBool32);
}
void dump_html_VkQueueFamilyVideoPropertiesKHR(const VkQueueFamilyVideoPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoCodecOperationFlagsKHR>(object.videoCodecOperations, settings, "VkVideoCodecOperationFlagsKHR", "videoCodecOperations", indents + 1, dump_html_VkVideoCodecOperationFlagsKHR);
}
void dump_html_VkVideoProfileInfoKHR(const VkVideoProfileInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoCodecOperationFlagBitsKHR>(object.videoCodecOperation, settings, "VkVideoCodecOperationFlagBitsKHR", "videoCodecOperation", indents + 1, dump_html_VkVideoCodecOperationFlagBitsKHR);
    dump_html_value<const VkVideoChromaSubsamplingFlagsKHR>(object.chromaSubsampling, settings, "VkVideoChromaSubsamplingFlagsKHR", "chromaSubsampling", indents + 1, dump_html_VkVideoChromaSubsamplingFlagsKHR);
    dump_html_value<const VkVideoComponentBitDepthFlagsKHR>(object.lumaBitDepth, settings, "VkVideoComponentBitDepthFlagsKHR", "lumaBitDepth", indents + 1, dump_html_VkVideoComponentBitDepthFlagsKHR);
    dump_html_value<const VkVideoComponentBitDepthFlagsKHR>(object.chromaBitDepth, settings, "VkVideoComponentBitDepthFlagsKHR", "chromaBitDepth", indents + 1, dump_html_VkVideoComponentBitDepthFlagsKHR);
}
void dump_html_VkVideoProfileListInfoKHR(const VkVideoProfileListInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.profileCount, settings, "uint32_t", "profileCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoProfileInfoKHR>(object.pProfiles, object.profileCount, settings, "const VkVideoProfileInfoKHR*", "const VkVideoProfileInfoKHR", "pProfiles", indents + 1, dump_html_VkVideoProfileInfoKHR); // ZRT
}
void dump_html_VkVideoCapabilitiesKHR(const VkVideoCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoCapabilityFlagsKHR>(object.flags, settings, "VkVideoCapabilityFlagsKHR", "flags", indents + 1, dump_html_VkVideoCapabilityFlagsKHR);
    dump_html_value<const VkDeviceSize>(object.minBitstreamBufferOffsetAlignment, settings, "VkDeviceSize", "minBitstreamBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.minBitstreamBufferSizeAlignment, settings, "VkDeviceSize", "minBitstreamBufferSizeAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkExtent2D>(object.pictureAccessGranularity, settings, "VkExtent2D", "pictureAccessGranularity", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.minCodedExtent, settings, "VkExtent2D", "minCodedExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxCodedExtent, settings, "VkExtent2D", "maxCodedExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxDpbSlots, settings, "uint32_t", "maxDpbSlots", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxActiveReferencePictures, settings, "uint32_t", "maxActiveReferencePictures", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtensionProperties>(object.stdHeaderVersion, settings, "VkExtensionProperties", "stdHeaderVersion", indents + 1, dump_html_VkExtensionProperties);
}
void dump_html_VkPhysicalDeviceVideoFormatInfoKHR(const VkPhysicalDeviceVideoFormatInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.imageUsage, settings, "VkImageUsageFlags", "imageUsage", indents + 1, dump_html_VkImageUsageFlags);
}
void dump_html_VkVideoFormatPropertiesKHR(const VkVideoFormatPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkComponentMapping>(object.componentMapping, settings, "VkComponentMapping", "componentMapping", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkImageCreateFlags>(object.imageCreateFlags, settings, "VkImageCreateFlags", "imageCreateFlags", indents + 1, dump_html_VkImageCreateFlags);
    dump_html_value<const VkImageType>(object.imageType, settings, "VkImageType", "imageType", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkImageTiling>(object.imageTiling, settings, "VkImageTiling", "imageTiling", indents + 1, dump_html_VkImageTiling);
    dump_html_value<const VkImageUsageFlags>(object.imageUsageFlags, settings, "VkImageUsageFlags", "imageUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
}
void dump_html_VkVideoPictureResourceInfoKHR(const VkVideoPictureResourceInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkOffset2D>(object.codedOffset, settings, "VkOffset2D", "codedOffset", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.codedExtent, settings, "VkExtent2D", "codedExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageView>(object.imageViewBinding, settings, "VkImageView", "imageViewBinding", indents + 1, dump_html_VkImageView);
}
void dump_html_VkVideoReferenceSlotInfoKHR(const VkVideoReferenceSlotInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const int32_t>(object.slotIndex, settings, "int32_t", "slotIndex", indents + 1, dump_html_int32_t);
    dump_html_pointer<const VkVideoPictureResourceInfoKHR>(object.pPictureResource, settings, "const VkVideoPictureResourceInfoKHR*", "pPictureResource", indents + 1, dump_html_VkVideoPictureResourceInfoKHR);
}
void dump_html_VkVideoSessionMemoryRequirementsKHR(const VkVideoSessionMemoryRequirementsKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryBindIndex, settings, "uint32_t", "memoryBindIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkMemoryRequirements>(object.memoryRequirements, settings, "VkMemoryRequirements", "memoryRequirements", indents + 1, dump_html_VkMemoryRequirements);
}
void dump_html_VkBindVideoSessionMemoryInfoKHR(const VkBindVideoSessionMemoryInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryBindIndex, settings, "uint32_t", "memoryBindIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.memorySize, settings, "VkDeviceSize", "memorySize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkVideoSessionCreateInfoKHR(const VkVideoSessionCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkVideoSessionCreateFlagsKHR>(object.flags, settings, "VkVideoSessionCreateFlagsKHR", "flags", indents + 1, dump_html_VkVideoSessionCreateFlagsKHR);
    dump_html_pointer<const VkVideoProfileInfoKHR>(object.pVideoProfile, settings, "const VkVideoProfileInfoKHR*", "pVideoProfile", indents + 1, dump_html_VkVideoProfileInfoKHR);
    dump_html_value<const VkFormat>(object.pictureFormat, settings, "VkFormat", "pictureFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkExtent2D>(object.maxCodedExtent, settings, "VkExtent2D", "maxCodedExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkFormat>(object.referencePictureFormat, settings, "VkFormat", "referencePictureFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint32_t>(object.maxDpbSlots, settings, "uint32_t", "maxDpbSlots", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxActiveReferencePictures, settings, "uint32_t", "maxActiveReferencePictures", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkExtensionProperties>(object.pStdHeaderVersion, settings, "const VkExtensionProperties*", "pStdHeaderVersion", indents + 1, dump_html_VkExtensionProperties);
}
void dump_html_VkVideoSessionParametersCreateInfoKHR(const VkVideoSessionParametersCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoSessionParametersCreateFlagsKHR>(object.flags, settings, "VkVideoSessionParametersCreateFlagsKHR", "flags", indents + 1, dump_html_VkVideoSessionParametersCreateFlagsKHR);
    dump_html_value<const VkVideoSessionParametersKHR>(object.videoSessionParametersTemplate, settings, "VkVideoSessionParametersKHR", "videoSessionParametersTemplate", indents + 1, dump_html_VkVideoSessionParametersKHR);
    dump_html_value<const VkVideoSessionKHR>(object.videoSession, settings, "VkVideoSessionKHR", "videoSession", indents + 1, dump_html_VkVideoSessionKHR);
}
void dump_html_VkVideoSessionParametersUpdateInfoKHR(const VkVideoSessionParametersUpdateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.updateSequenceCount, settings, "uint32_t", "updateSequenceCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoBeginCodingInfoKHR(const VkVideoBeginCodingInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoBeginCodingFlagsKHR>(object.flags, settings, "VkVideoBeginCodingFlagsKHR", "flags", indents + 1, dump_html_VkVideoBeginCodingFlagsKHR);
    dump_html_value<const VkVideoSessionKHR>(object.videoSession, settings, "VkVideoSessionKHR", "videoSession", indents + 1, dump_html_VkVideoSessionKHR);
    dump_html_value<const VkVideoSessionParametersKHR>(object.videoSessionParameters, settings, "VkVideoSessionParametersKHR", "videoSessionParameters", indents + 1, dump_html_VkVideoSessionParametersKHR);
    dump_html_value<const uint32_t>(object.referenceSlotCount, settings, "uint32_t", "referenceSlotCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoReferenceSlotInfoKHR>(object.pReferenceSlots, object.referenceSlotCount, settings, "const VkVideoReferenceSlotInfoKHR*", "const VkVideoReferenceSlotInfoKHR", "pReferenceSlots", indents + 1, dump_html_VkVideoReferenceSlotInfoKHR); // ZRT
}
void dump_html_VkVideoEndCodingInfoKHR(const VkVideoEndCodingInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEndCodingFlagsKHR>(object.flags, settings, "VkVideoEndCodingFlagsKHR", "flags", indents + 1, dump_html_VkVideoEndCodingFlagsKHR);
}
void dump_html_VkVideoCodingControlInfoKHR(const VkVideoCodingControlInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoCodingControlFlagsKHR>(object.flags, settings, "VkVideoCodingControlFlagsKHR", "flags", indents + 1, dump_html_VkVideoCodingControlFlagsKHR);
}
void dump_html_VkVideoDecodeCapabilitiesKHR(const VkVideoDecodeCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoDecodeCapabilityFlagsKHR>(object.flags, settings, "VkVideoDecodeCapabilityFlagsKHR", "flags", indents + 1, dump_html_VkVideoDecodeCapabilityFlagsKHR);
}
void dump_html_VkVideoDecodeUsageInfoKHR(const VkVideoDecodeUsageInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoDecodeUsageFlagsKHR>(object.videoUsageHints, settings, "VkVideoDecodeUsageFlagsKHR", "videoUsageHints", indents + 1, dump_html_VkVideoDecodeUsageFlagsKHR);
}
void dump_html_VkVideoDecodeInfoKHR(const VkVideoDecodeInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoDecodeFlagsKHR>(object.flags, settings, "VkVideoDecodeFlagsKHR", "flags", indents + 1, dump_html_VkVideoDecodeFlagsKHR);
    dump_html_value<const VkBuffer>(object.srcBuffer, settings, "VkBuffer", "srcBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.srcBufferOffset, settings, "VkDeviceSize", "srcBufferOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.srcBufferRange, settings, "VkDeviceSize", "srcBufferRange", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkVideoPictureResourceInfoKHR>(object.dstPictureResource, settings, "VkVideoPictureResourceInfoKHR", "dstPictureResource", indents + 1, dump_html_VkVideoPictureResourceInfoKHR);
    dump_html_pointer<const VkVideoReferenceSlotInfoKHR>(object.pSetupReferenceSlot, settings, "const VkVideoReferenceSlotInfoKHR*", "pSetupReferenceSlot", indents + 1, dump_html_VkVideoReferenceSlotInfoKHR);
    dump_html_value<const uint32_t>(object.referenceSlotCount, settings, "uint32_t", "referenceSlotCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoReferenceSlotInfoKHR>(object.pReferenceSlots, object.referenceSlotCount, settings, "const VkVideoReferenceSlotInfoKHR*", "const VkVideoReferenceSlotInfoKHR", "pReferenceSlots", indents + 1, dump_html_VkVideoReferenceSlotInfoKHR); // ZRT
}
void dump_html_VkDedicatedAllocationImageCreateInfoNV(const VkDedicatedAllocationImageCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dedicatedAllocation, settings, "VkBool32", "dedicatedAllocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDedicatedAllocationBufferCreateInfoNV(const VkDedicatedAllocationBufferCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dedicatedAllocation, settings, "VkBool32", "dedicatedAllocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDedicatedAllocationMemoryAllocateInfoNV(const VkDedicatedAllocationMemoryAllocateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
}
void dump_html_VkPhysicalDeviceTransformFeedbackFeaturesEXT(const VkPhysicalDeviceTransformFeedbackFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.transformFeedback, settings, "VkBool32", "transformFeedback", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.geometryStreams, settings, "VkBool32", "geometryStreams", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceTransformFeedbackPropertiesEXT(const VkPhysicalDeviceTransformFeedbackPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxTransformFeedbackStreams, settings, "uint32_t", "maxTransformFeedbackStreams", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackBuffers, settings, "uint32_t", "maxTransformFeedbackBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.maxTransformFeedbackBufferSize, settings, "VkDeviceSize", "maxTransformFeedbackBufferSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackStreamDataSize, settings, "uint32_t", "maxTransformFeedbackStreamDataSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackBufferDataSize, settings, "uint32_t", "maxTransformFeedbackBufferDataSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackBufferDataStride, settings, "uint32_t", "maxTransformFeedbackBufferDataStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.transformFeedbackQueries, settings, "VkBool32", "transformFeedbackQueries", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackStreamsLinesTriangles, settings, "VkBool32", "transformFeedbackStreamsLinesTriangles", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackRasterizationStreamSelect, settings, "VkBool32", "transformFeedbackRasterizationStreamSelect", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackDraw, settings, "VkBool32", "transformFeedbackDraw", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineRasterizationStateStreamCreateInfoEXT(const VkPipelineRasterizationStateStreamCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationStateStreamCreateFlagsEXT>(object.flags, settings, "VkPipelineRasterizationStateStreamCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineRasterizationStateStreamCreateFlagsEXT);
    dump_html_value<const uint32_t>(object.rasterizationStream, settings, "uint32_t", "rasterizationStream", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCuModuleCreateInfoNVX(const VkCuModuleCreateInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const size_t>(object.dataSize, settings, "size_t", "dataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
}
void dump_html_VkCuFunctionCreateInfoNVX(const VkCuFunctionCreateInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCuModuleNVX>(object.module, settings, "VkCuModuleNVX", "module", indents + 1, dump_html_VkCuModuleNVX);
    dump_html_value<const char*>(object.pName, settings, "const char*", "pName", indents + 1, dump_html_cstring);
}
void dump_html_VkCuLaunchInfoNVX(const VkCuLaunchInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCuFunctionNVX>(object.function, settings, "VkCuFunctionNVX", "function", indents + 1, dump_html_VkCuFunctionNVX);
    dump_html_value<const uint32_t>(object.gridDimX, settings, "uint32_t", "gridDimX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gridDimY, settings, "uint32_t", "gridDimY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gridDimZ, settings, "uint32_t", "gridDimZ", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.blockDimX, settings, "uint32_t", "blockDimX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.blockDimY, settings, "uint32_t", "blockDimY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.blockDimZ, settings, "uint32_t", "blockDimZ", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sharedMemBytes, settings, "uint32_t", "sharedMemBytes", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.paramCount, settings, "size_t", "paramCount", indents + 1, dump_html_size_t);
    dump_html_array<const void*>(object.pParams, object.paramCount, settings, "const void* const *", "const void* const ", "pParams", indents + 1, dump_html_void); // ZRT
    dump_html_value<const size_t>(object.extraCount, settings, "size_t", "extraCount", indents + 1, dump_html_size_t);
    dump_html_array<const void*>(object.pExtras, object.extraCount, settings, "const void* const *", "const void* const ", "pExtras", indents + 1, dump_html_void); // ZRT
}
void dump_html_VkImageViewHandleInfoNVX(const VkImageViewHandleInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const VkSampler>(object.sampler, settings, "VkSampler", "sampler", indents + 1, dump_html_VkSampler);
}
void dump_html_VkImageViewAddressPropertiesNVX(const VkImageViewAddressPropertiesNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkVideoEncodeH264CapabilitiesKHR(const VkVideoEncodeH264CapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeH264CapabilityFlagsKHR>(object.flags, settings, "VkVideoEncodeH264CapabilityFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeH264CapabilityFlagsKHR);
    dump_html_value<const StdVideoH264LevelIdc>(object.maxLevelIdc, settings, "StdVideoH264LevelIdc", "maxLevelIdc", indents + 1, dump_html_StdVideoH264LevelIdc);
    dump_html_value<const uint32_t>(object.maxSliceCount, settings, "uint32_t", "maxSliceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPPictureL0ReferenceCount, settings, "uint32_t", "maxPPictureL0ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxBPictureL0ReferenceCount, settings, "uint32_t", "maxBPictureL0ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxL1ReferenceCount, settings, "uint32_t", "maxL1ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTemporalLayerCount, settings, "uint32_t", "maxTemporalLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.expectDyadicTemporalLayerPattern, settings, "VkBool32", "expectDyadicTemporalLayerPattern", indents + 1, dump_html_VkBool32);
    dump_html_value<const int32_t>(object.minQp, settings, "int32_t", "minQp", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.maxQp, settings, "int32_t", "maxQp", indents + 1, dump_html_int32_t);
    dump_html_value<const VkBool32>(object.prefersGopRemainingFrames, settings, "VkBool32", "prefersGopRemainingFrames", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.requiresGopRemainingFrames, settings, "VkBool32", "requiresGopRemainingFrames", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH264StdFlagsKHR>(object.stdSyntaxFlags, settings, "VkVideoEncodeH264StdFlagsKHR", "stdSyntaxFlags", indents + 1, dump_html_VkVideoEncodeH264StdFlagsKHR);
}
void dump_html_VkVideoEncodeH264QpKHR(const VkVideoEncodeH264QpKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.qpI, settings, "int32_t", "qpI", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.qpP, settings, "int32_t", "qpP", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.qpB, settings, "int32_t", "qpB", indents + 1, dump_html_int32_t);
}
void dump_html_VkVideoEncodeH264QualityLevelPropertiesKHR(const VkVideoEncodeH264QualityLevelPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeH264RateControlFlagsKHR>(object.preferredRateControlFlags, settings, "VkVideoEncodeH264RateControlFlagsKHR", "preferredRateControlFlags", indents + 1, dump_html_VkVideoEncodeH264RateControlFlagsKHR);
    dump_html_value<const uint32_t>(object.preferredGopFrameCount, settings, "uint32_t", "preferredGopFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredIdrPeriod, settings, "uint32_t", "preferredIdrPeriod", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredConsecutiveBFrameCount, settings, "uint32_t", "preferredConsecutiveBFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredTemporalLayerCount, settings, "uint32_t", "preferredTemporalLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkVideoEncodeH264QpKHR>(object.preferredConstantQp, settings, "VkVideoEncodeH264QpKHR", "preferredConstantQp", indents + 1, dump_html_VkVideoEncodeH264QpKHR);
    dump_html_value<const uint32_t>(object.preferredMaxL0ReferenceCount, settings, "uint32_t", "preferredMaxL0ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredMaxL1ReferenceCount, settings, "uint32_t", "preferredMaxL1ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.preferredStdEntropyCodingModeFlag, settings, "VkBool32", "preferredStdEntropyCodingModeFlag", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoEncodeH264SessionCreateInfoKHR(const VkVideoEncodeH264SessionCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.useMaxLevelIdc, settings, "VkBool32", "useMaxLevelIdc", indents + 1, dump_html_VkBool32);
    dump_html_value<const StdVideoH264LevelIdc>(object.maxLevelIdc, settings, "StdVideoH264LevelIdc", "maxLevelIdc", indents + 1, dump_html_StdVideoH264LevelIdc);
}
void dump_html_VkVideoEncodeH264SessionParametersAddInfoKHR(const VkVideoEncodeH264SessionParametersAddInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stdSPSCount, settings, "uint32_t", "stdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH264SequenceParameterSet>(object.pStdSPSs, object.stdSPSCount, settings, "const StdVideoH264SequenceParameterSet*", "const StdVideoH264SequenceParameterSet", "pStdSPSs", indents + 1, dump_html_StdVideoH264SequenceParameterSet); // ZRT
    dump_html_value<const uint32_t>(object.stdPPSCount, settings, "uint32_t", "stdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH264PictureParameterSet>(object.pStdPPSs, object.stdPPSCount, settings, "const StdVideoH264PictureParameterSet*", "const StdVideoH264PictureParameterSet", "pStdPPSs", indents + 1, dump_html_StdVideoH264PictureParameterSet); // ZRT
}
void dump_html_VkVideoEncodeH264SessionParametersCreateInfoKHR(const VkVideoEncodeH264SessionParametersCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxStdSPSCount, settings, "uint32_t", "maxStdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStdPPSCount, settings, "uint32_t", "maxStdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkVideoEncodeH264SessionParametersAddInfoKHR>(object.pParametersAddInfo, settings, "const VkVideoEncodeH264SessionParametersAddInfoKHR*", "pParametersAddInfo", indents + 1, dump_html_VkVideoEncodeH264SessionParametersAddInfoKHR);
}
void dump_html_VkVideoEncodeH264SessionParametersGetInfoKHR(const VkVideoEncodeH264SessionParametersGetInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.writeStdSPS, settings, "VkBool32", "writeStdSPS", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.writeStdPPS, settings, "VkBool32", "writeStdPPS", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.stdSPSId, settings, "uint32_t", "stdSPSId", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stdPPSId, settings, "uint32_t", "stdPPSId", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(const VkVideoEncodeH264SessionParametersFeedbackInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hasStdSPSOverrides, settings, "VkBool32", "hasStdSPSOverrides", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.hasStdPPSOverrides, settings, "VkBool32", "hasStdPPSOverrides", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoEncodeH264NaluSliceInfoKHR(const VkVideoEncodeH264NaluSliceInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const int32_t>(object.constantQp, settings, "int32_t", "constantQp", indents + 1, dump_html_int32_t);
    dump_html_pointer<const StdVideoEncodeH264SliceHeader>(object.pStdSliceHeader, settings, "const StdVideoEncodeH264SliceHeader*", "pStdSliceHeader", indents + 1, dump_html_StdVideoEncodeH264SliceHeader);
}
void dump_html_VkVideoEncodeH264PictureInfoKHR(const VkVideoEncodeH264PictureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.naluSliceEntryCount, settings, "uint32_t", "naluSliceEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoEncodeH264NaluSliceInfoKHR>(object.pNaluSliceEntries, object.naluSliceEntryCount, settings, "const VkVideoEncodeH264NaluSliceInfoKHR*", "const VkVideoEncodeH264NaluSliceInfoKHR", "pNaluSliceEntries", indents + 1, dump_html_VkVideoEncodeH264NaluSliceInfoKHR); // ZRT
    dump_html_pointer<const StdVideoEncodeH264PictureInfo>(object.pStdPictureInfo, settings, "const StdVideoEncodeH264PictureInfo*", "pStdPictureInfo", indents + 1, dump_html_StdVideoEncodeH264PictureInfo);
    dump_html_value<const VkBool32>(object.generatePrefixNalu, settings, "VkBool32", "generatePrefixNalu", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoEncodeH264DpbSlotInfoKHR(const VkVideoEncodeH264DpbSlotInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoEncodeH264ReferenceInfo>(object.pStdReferenceInfo, settings, "const StdVideoEncodeH264ReferenceInfo*", "pStdReferenceInfo", indents + 1, dump_html_StdVideoEncodeH264ReferenceInfo);
}
void dump_html_VkVideoEncodeH264ProfileInfoKHR(const VkVideoEncodeH264ProfileInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoH264ProfileIdc>(object.stdProfileIdc, settings, "StdVideoH264ProfileIdc", "stdProfileIdc", indents + 1, dump_html_StdVideoH264ProfileIdc);
}
void dump_html_VkVideoEncodeH264RateControlInfoKHR(const VkVideoEncodeH264RateControlInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeH264RateControlFlagsKHR>(object.flags, settings, "VkVideoEncodeH264RateControlFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeH264RateControlFlagsKHR);
    dump_html_value<const uint32_t>(object.gopFrameCount, settings, "uint32_t", "gopFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.idrPeriod, settings, "uint32_t", "idrPeriod", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.consecutiveBFrameCount, settings, "uint32_t", "consecutiveBFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.temporalLayerCount, settings, "uint32_t", "temporalLayerCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH264FrameSizeKHR(const VkVideoEncodeH264FrameSizeKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.frameISize, settings, "uint32_t", "frameISize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.framePSize, settings, "uint32_t", "framePSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.frameBSize, settings, "uint32_t", "frameBSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH264RateControlLayerInfoKHR(const VkVideoEncodeH264RateControlLayerInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.useMinQp, settings, "VkBool32", "useMinQp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH264QpKHR>(object.minQp, settings, "VkVideoEncodeH264QpKHR", "minQp", indents + 1, dump_html_VkVideoEncodeH264QpKHR);
    dump_html_value<const VkBool32>(object.useMaxQp, settings, "VkBool32", "useMaxQp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH264QpKHR>(object.maxQp, settings, "VkVideoEncodeH264QpKHR", "maxQp", indents + 1, dump_html_VkVideoEncodeH264QpKHR);
    dump_html_value<const VkBool32>(object.useMaxFrameSize, settings, "VkBool32", "useMaxFrameSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH264FrameSizeKHR>(object.maxFrameSize, settings, "VkVideoEncodeH264FrameSizeKHR", "maxFrameSize", indents + 1, dump_html_VkVideoEncodeH264FrameSizeKHR);
}
void dump_html_VkVideoEncodeH264GopRemainingFrameInfoKHR(const VkVideoEncodeH264GopRemainingFrameInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.useGopRemainingFrames, settings, "VkBool32", "useGopRemainingFrames", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.gopRemainingI, settings, "uint32_t", "gopRemainingI", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gopRemainingP, settings, "uint32_t", "gopRemainingP", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gopRemainingB, settings, "uint32_t", "gopRemainingB", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH265CapabilitiesKHR(const VkVideoEncodeH265CapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeH265CapabilityFlagsKHR>(object.flags, settings, "VkVideoEncodeH265CapabilityFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeH265CapabilityFlagsKHR);
    dump_html_value<const StdVideoH265LevelIdc>(object.maxLevelIdc, settings, "StdVideoH265LevelIdc", "maxLevelIdc", indents + 1, dump_html_StdVideoH265LevelIdc);
    dump_html_value<const uint32_t>(object.maxSliceSegmentCount, settings, "uint32_t", "maxSliceSegmentCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.maxTiles, settings, "VkExtent2D", "maxTiles", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkVideoEncodeH265CtbSizeFlagsKHR>(object.ctbSizes, settings, "VkVideoEncodeH265CtbSizeFlagsKHR", "ctbSizes", indents + 1, dump_html_VkVideoEncodeH265CtbSizeFlagsKHR);
    dump_html_value<const VkVideoEncodeH265TransformBlockSizeFlagsKHR>(object.transformBlockSizes, settings, "VkVideoEncodeH265TransformBlockSizeFlagsKHR", "transformBlockSizes", indents + 1, dump_html_VkVideoEncodeH265TransformBlockSizeFlagsKHR);
    dump_html_value<const uint32_t>(object.maxPPictureL0ReferenceCount, settings, "uint32_t", "maxPPictureL0ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxBPictureL0ReferenceCount, settings, "uint32_t", "maxBPictureL0ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxL1ReferenceCount, settings, "uint32_t", "maxL1ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSubLayerCount, settings, "uint32_t", "maxSubLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.expectDyadicTemporalSubLayerPattern, settings, "VkBool32", "expectDyadicTemporalSubLayerPattern", indents + 1, dump_html_VkBool32);
    dump_html_value<const int32_t>(object.minQp, settings, "int32_t", "minQp", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.maxQp, settings, "int32_t", "maxQp", indents + 1, dump_html_int32_t);
    dump_html_value<const VkBool32>(object.prefersGopRemainingFrames, settings, "VkBool32", "prefersGopRemainingFrames", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.requiresGopRemainingFrames, settings, "VkBool32", "requiresGopRemainingFrames", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH265StdFlagsKHR>(object.stdSyntaxFlags, settings, "VkVideoEncodeH265StdFlagsKHR", "stdSyntaxFlags", indents + 1, dump_html_VkVideoEncodeH265StdFlagsKHR);
}
void dump_html_VkVideoEncodeH265SessionCreateInfoKHR(const VkVideoEncodeH265SessionCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.useMaxLevelIdc, settings, "VkBool32", "useMaxLevelIdc", indents + 1, dump_html_VkBool32);
    dump_html_value<const StdVideoH265LevelIdc>(object.maxLevelIdc, settings, "StdVideoH265LevelIdc", "maxLevelIdc", indents + 1, dump_html_StdVideoH265LevelIdc);
}
void dump_html_VkVideoEncodeH265QpKHR(const VkVideoEncodeH265QpKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.qpI, settings, "int32_t", "qpI", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.qpP, settings, "int32_t", "qpP", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.qpB, settings, "int32_t", "qpB", indents + 1, dump_html_int32_t);
}
void dump_html_VkVideoEncodeH265QualityLevelPropertiesKHR(const VkVideoEncodeH265QualityLevelPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeH265RateControlFlagsKHR>(object.preferredRateControlFlags, settings, "VkVideoEncodeH265RateControlFlagsKHR", "preferredRateControlFlags", indents + 1, dump_html_VkVideoEncodeH265RateControlFlagsKHR);
    dump_html_value<const uint32_t>(object.preferredGopFrameCount, settings, "uint32_t", "preferredGopFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredIdrPeriod, settings, "uint32_t", "preferredIdrPeriod", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredConsecutiveBFrameCount, settings, "uint32_t", "preferredConsecutiveBFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredSubLayerCount, settings, "uint32_t", "preferredSubLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkVideoEncodeH265QpKHR>(object.preferredConstantQp, settings, "VkVideoEncodeH265QpKHR", "preferredConstantQp", indents + 1, dump_html_VkVideoEncodeH265QpKHR);
    dump_html_value<const uint32_t>(object.preferredMaxL0ReferenceCount, settings, "uint32_t", "preferredMaxL0ReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.preferredMaxL1ReferenceCount, settings, "uint32_t", "preferredMaxL1ReferenceCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH265SessionParametersAddInfoKHR(const VkVideoEncodeH265SessionParametersAddInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stdVPSCount, settings, "uint32_t", "stdVPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH265VideoParameterSet>(object.pStdVPSs, object.stdVPSCount, settings, "const StdVideoH265VideoParameterSet*", "const StdVideoH265VideoParameterSet", "pStdVPSs", indents + 1, dump_html_StdVideoH265VideoParameterSet); // ZRT
    dump_html_value<const uint32_t>(object.stdSPSCount, settings, "uint32_t", "stdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH265SequenceParameterSet>(object.pStdSPSs, object.stdSPSCount, settings, "const StdVideoH265SequenceParameterSet*", "const StdVideoH265SequenceParameterSet", "pStdSPSs", indents + 1, dump_html_StdVideoH265SequenceParameterSet); // ZRT
    dump_html_value<const uint32_t>(object.stdPPSCount, settings, "uint32_t", "stdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH265PictureParameterSet>(object.pStdPPSs, object.stdPPSCount, settings, "const StdVideoH265PictureParameterSet*", "const StdVideoH265PictureParameterSet", "pStdPPSs", indents + 1, dump_html_StdVideoH265PictureParameterSet); // ZRT
}
void dump_html_VkVideoEncodeH265SessionParametersCreateInfoKHR(const VkVideoEncodeH265SessionParametersCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxStdVPSCount, settings, "uint32_t", "maxStdVPSCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStdSPSCount, settings, "uint32_t", "maxStdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStdPPSCount, settings, "uint32_t", "maxStdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkVideoEncodeH265SessionParametersAddInfoKHR>(object.pParametersAddInfo, settings, "const VkVideoEncodeH265SessionParametersAddInfoKHR*", "pParametersAddInfo", indents + 1, dump_html_VkVideoEncodeH265SessionParametersAddInfoKHR);
}
void dump_html_VkVideoEncodeH265SessionParametersGetInfoKHR(const VkVideoEncodeH265SessionParametersGetInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.writeStdVPS, settings, "VkBool32", "writeStdVPS", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.writeStdSPS, settings, "VkBool32", "writeStdSPS", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.writeStdPPS, settings, "VkBool32", "writeStdPPS", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.stdVPSId, settings, "uint32_t", "stdVPSId", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stdSPSId, settings, "uint32_t", "stdSPSId", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stdPPSId, settings, "uint32_t", "stdPPSId", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(const VkVideoEncodeH265SessionParametersFeedbackInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hasStdVPSOverrides, settings, "VkBool32", "hasStdVPSOverrides", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.hasStdSPSOverrides, settings, "VkBool32", "hasStdSPSOverrides", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.hasStdPPSOverrides, settings, "VkBool32", "hasStdPPSOverrides", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoEncodeH265NaluSliceSegmentInfoKHR(const VkVideoEncodeH265NaluSliceSegmentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const int32_t>(object.constantQp, settings, "int32_t", "constantQp", indents + 1, dump_html_int32_t);
    dump_html_pointer<const StdVideoEncodeH265SliceSegmentHeader>(object.pStdSliceSegmentHeader, settings, "const StdVideoEncodeH265SliceSegmentHeader*", "pStdSliceSegmentHeader", indents + 1, dump_html_StdVideoEncodeH265SliceSegmentHeader);
}
void dump_html_VkVideoEncodeH265PictureInfoKHR(const VkVideoEncodeH265PictureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.naluSliceSegmentEntryCount, settings, "uint32_t", "naluSliceSegmentEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoEncodeH265NaluSliceSegmentInfoKHR>(object.pNaluSliceSegmentEntries, object.naluSliceSegmentEntryCount, settings, "const VkVideoEncodeH265NaluSliceSegmentInfoKHR*", "const VkVideoEncodeH265NaluSliceSegmentInfoKHR", "pNaluSliceSegmentEntries", indents + 1, dump_html_VkVideoEncodeH265NaluSliceSegmentInfoKHR); // ZRT
    dump_html_pointer<const StdVideoEncodeH265PictureInfo>(object.pStdPictureInfo, settings, "const StdVideoEncodeH265PictureInfo*", "pStdPictureInfo", indents + 1, dump_html_StdVideoEncodeH265PictureInfo);
}
void dump_html_VkVideoEncodeH265DpbSlotInfoKHR(const VkVideoEncodeH265DpbSlotInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoEncodeH265ReferenceInfo>(object.pStdReferenceInfo, settings, "const StdVideoEncodeH265ReferenceInfo*", "pStdReferenceInfo", indents + 1, dump_html_StdVideoEncodeH265ReferenceInfo);
}
void dump_html_VkVideoEncodeH265ProfileInfoKHR(const VkVideoEncodeH265ProfileInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoH265ProfileIdc>(object.stdProfileIdc, settings, "StdVideoH265ProfileIdc", "stdProfileIdc", indents + 1, dump_html_StdVideoH265ProfileIdc);
}
void dump_html_VkVideoEncodeH265RateControlInfoKHR(const VkVideoEncodeH265RateControlInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeH265RateControlFlagsKHR>(object.flags, settings, "VkVideoEncodeH265RateControlFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeH265RateControlFlagsKHR);
    dump_html_value<const uint32_t>(object.gopFrameCount, settings, "uint32_t", "gopFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.idrPeriod, settings, "uint32_t", "idrPeriod", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.consecutiveBFrameCount, settings, "uint32_t", "consecutiveBFrameCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.subLayerCount, settings, "uint32_t", "subLayerCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH265FrameSizeKHR(const VkVideoEncodeH265FrameSizeKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.frameISize, settings, "uint32_t", "frameISize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.framePSize, settings, "uint32_t", "framePSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.frameBSize, settings, "uint32_t", "frameBSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeH265RateControlLayerInfoKHR(const VkVideoEncodeH265RateControlLayerInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.useMinQp, settings, "VkBool32", "useMinQp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH265QpKHR>(object.minQp, settings, "VkVideoEncodeH265QpKHR", "minQp", indents + 1, dump_html_VkVideoEncodeH265QpKHR);
    dump_html_value<const VkBool32>(object.useMaxQp, settings, "VkBool32", "useMaxQp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH265QpKHR>(object.maxQp, settings, "VkVideoEncodeH265QpKHR", "maxQp", indents + 1, dump_html_VkVideoEncodeH265QpKHR);
    dump_html_value<const VkBool32>(object.useMaxFrameSize, settings, "VkBool32", "useMaxFrameSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkVideoEncodeH265FrameSizeKHR>(object.maxFrameSize, settings, "VkVideoEncodeH265FrameSizeKHR", "maxFrameSize", indents + 1, dump_html_VkVideoEncodeH265FrameSizeKHR);
}
void dump_html_VkVideoEncodeH265GopRemainingFrameInfoKHR(const VkVideoEncodeH265GopRemainingFrameInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.useGopRemainingFrames, settings, "VkBool32", "useGopRemainingFrames", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.gopRemainingI, settings, "uint32_t", "gopRemainingI", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gopRemainingP, settings, "uint32_t", "gopRemainingP", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gopRemainingB, settings, "uint32_t", "gopRemainingB", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoDecodeH264ProfileInfoKHR(const VkVideoDecodeH264ProfileInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoH264ProfileIdc>(object.stdProfileIdc, settings, "StdVideoH264ProfileIdc", "stdProfileIdc", indents + 1, dump_html_StdVideoH264ProfileIdc);
    dump_html_value<const VkVideoDecodeH264PictureLayoutFlagBitsKHR>(object.pictureLayout, settings, "VkVideoDecodeH264PictureLayoutFlagBitsKHR", "pictureLayout", indents + 1, dump_html_VkVideoDecodeH264PictureLayoutFlagBitsKHR);
}
void dump_html_VkVideoDecodeH264CapabilitiesKHR(const VkVideoDecodeH264CapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoH264LevelIdc>(object.maxLevelIdc, settings, "StdVideoH264LevelIdc", "maxLevelIdc", indents + 1, dump_html_StdVideoH264LevelIdc);
    dump_html_value<const VkOffset2D>(object.fieldOffsetGranularity, settings, "VkOffset2D", "fieldOffsetGranularity", indents + 1, dump_html_VkOffset2D);
}
void dump_html_VkVideoDecodeH264SessionParametersAddInfoKHR(const VkVideoDecodeH264SessionParametersAddInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stdSPSCount, settings, "uint32_t", "stdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH264SequenceParameterSet>(object.pStdSPSs, object.stdSPSCount, settings, "const StdVideoH264SequenceParameterSet*", "const StdVideoH264SequenceParameterSet", "pStdSPSs", indents + 1, dump_html_StdVideoH264SequenceParameterSet); // ZRT
    dump_html_value<const uint32_t>(object.stdPPSCount, settings, "uint32_t", "stdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH264PictureParameterSet>(object.pStdPPSs, object.stdPPSCount, settings, "const StdVideoH264PictureParameterSet*", "const StdVideoH264PictureParameterSet", "pStdPPSs", indents + 1, dump_html_StdVideoH264PictureParameterSet); // ZRT
}
void dump_html_VkVideoDecodeH264SessionParametersCreateInfoKHR(const VkVideoDecodeH264SessionParametersCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxStdSPSCount, settings, "uint32_t", "maxStdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStdPPSCount, settings, "uint32_t", "maxStdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkVideoDecodeH264SessionParametersAddInfoKHR>(object.pParametersAddInfo, settings, "const VkVideoDecodeH264SessionParametersAddInfoKHR*", "pParametersAddInfo", indents + 1, dump_html_VkVideoDecodeH264SessionParametersAddInfoKHR);
}
void dump_html_VkVideoDecodeH264PictureInfoKHR(const VkVideoDecodeH264PictureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoDecodeH264PictureInfo>(object.pStdPictureInfo, settings, "const StdVideoDecodeH264PictureInfo*", "pStdPictureInfo", indents + 1, dump_html_StdVideoDecodeH264PictureInfo);
    dump_html_value<const uint32_t>(object.sliceCount, settings, "uint32_t", "sliceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pSliceOffsets, object.sliceCount, settings, "const uint32_t*", "const uint32_t", "pSliceOffsets", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkVideoDecodeH264DpbSlotInfoKHR(const VkVideoDecodeH264DpbSlotInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoDecodeH264ReferenceInfo>(object.pStdReferenceInfo, settings, "const StdVideoDecodeH264ReferenceInfo*", "pStdReferenceInfo", indents + 1, dump_html_StdVideoDecodeH264ReferenceInfo);
}
void dump_html_VkTextureLODGatherFormatPropertiesAMD(const VkTextureLODGatherFormatPropertiesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.supportsTextureGatherLODBiasAMD, settings, "VkBool32", "supportsTextureGatherLODBiasAMD", indents + 1, dump_html_VkBool32);
}
void dump_html_VkShaderResourceUsageAMD(const VkShaderResourceUsageAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.numUsedVgprs, settings, "uint32_t", "numUsedVgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numUsedSgprs, settings, "uint32_t", "numUsedSgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.ldsSizePerLocalWorkGroup, settings, "uint32_t", "ldsSizePerLocalWorkGroup", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.ldsUsageSizeInBytes, settings, "size_t", "ldsUsageSizeInBytes", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.scratchMemUsageInBytes, settings, "size_t", "scratchMemUsageInBytes", indents + 1, dump_html_size_t);
}
void dump_html_VkShaderStatisticsInfoAMD(const VkShaderStatisticsInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkShaderStageFlags>(object.shaderStageMask, settings, "VkShaderStageFlags", "shaderStageMask", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkShaderResourceUsageAMD>(object.resourceUsage, settings, "VkShaderResourceUsageAMD", "resourceUsage", indents + 1, dump_html_VkShaderResourceUsageAMD);
    dump_html_value<const uint32_t>(object.numPhysicalVgprs, settings, "uint32_t", "numPhysicalVgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numPhysicalSgprs, settings, "uint32_t", "numPhysicalSgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numAvailableVgprs, settings, "uint32_t", "numAvailableVgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numAvailableSgprs, settings, "uint32_t", "numAvailableSgprs", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.computeWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "computeWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
}
void dump_html_VkRenderingFragmentShadingRateAttachmentInfoKHR(const VkRenderingFragmentShadingRateAttachmentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkImageLayout>(object.imageLayout, settings, "VkImageLayout", "imageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkExtent2D>(object.shadingRateAttachmentTexelSize, settings, "VkExtent2D", "shadingRateAttachmentTexelSize", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkRenderingFragmentDensityMapAttachmentInfoEXT(const VkRenderingFragmentDensityMapAttachmentInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkImageLayout>(object.imageLayout, settings, "VkImageLayout", "imageLayout", indents + 1, dump_html_VkImageLayout);
}
void dump_html_VkAttachmentSampleCountInfoAMD(const VkAttachmentSampleCountInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSampleCountFlagBits>(object.pColorAttachmentSamples, object.colorAttachmentCount, settings, "const VkSampleCountFlagBits*", "const VkSampleCountFlagBits", "pColorAttachmentSamples", indents + 1, dump_html_VkSampleCountFlagBits); // ZRT
    dump_html_value<const VkSampleCountFlagBits>(object.depthStencilAttachmentSamples, settings, "VkSampleCountFlagBits", "depthStencilAttachmentSamples", indents + 1, dump_html_VkSampleCountFlagBits);
}
void dump_html_VkMultiviewPerViewAttributesInfoNVX(const VkMultiviewPerViewAttributesInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.perViewAttributes, settings, "VkBool32", "perViewAttributes", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.perViewAttributesPositionXOnly, settings, "VkBool32", "perViewAttributesPositionXOnly", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_GGP)
void dump_html_VkStreamDescriptorSurfaceCreateInfoGGP(const VkStreamDescriptorSurfaceCreateInfoGGP& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkStreamDescriptorSurfaceCreateFlagsGGP>(object.flags, settings, "VkStreamDescriptorSurfaceCreateFlagsGGP", "flags", indents + 1, dump_html_VkStreamDescriptorSurfaceCreateFlagsGGP);
    dump_html_value<const GgpStreamDescriptor>(object.streamDescriptor, settings, "GgpStreamDescriptor", "streamDescriptor", indents + 1, dump_html_GgpStreamDescriptor);
}
#endif // VK_USE_PLATFORM_GGP
void dump_html_VkPhysicalDeviceCornerSampledImageFeaturesNV(const VkPhysicalDeviceCornerSampledImageFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cornerSampledImage, settings, "VkBool32", "cornerSampledImage", indents + 1, dump_html_VkBool32);
}
void dump_html_VkExternalImageFormatPropertiesNV(const VkExternalImageFormatPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageFormatProperties>(object.imageFormatProperties, settings, "VkImageFormatProperties", "imageFormatProperties", indents + 1, dump_html_VkImageFormatProperties);
    dump_html_value<const VkExternalMemoryFeatureFlagsNV>(object.externalMemoryFeatures, settings, "VkExternalMemoryFeatureFlagsNV", "externalMemoryFeatures", indents + 1, dump_html_VkExternalMemoryFeatureFlagsNV);
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.exportFromImportedHandleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.compatibleHandleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "compatibleHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
}
void dump_html_VkExternalMemoryImageCreateInfoNV(const VkExternalMemoryImageCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
}
void dump_html_VkExportMemoryAllocateInfoNV(const VkExportMemoryAllocateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkImportMemoryWin32HandleInfoNV(const VkImportMemoryWin32HandleInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkExportMemoryWin32HandleInfoNV(const VkExportMemoryWin32HandleInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkWin32KeyedMutexAcquireReleaseInfoNV(const VkWin32KeyedMutexAcquireReleaseInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.acquireCount, settings, "uint32_t", "acquireCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pAcquireSyncs, object.acquireCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pAcquireSyncs", indents + 1, dump_html_VkDeviceMemory); // ZRT
    dump_html_array<const uint64_t>(object.pAcquireKeys, object.acquireCount, settings, "const uint64_t*", "const uint64_t", "pAcquireKeys", indents + 1, dump_html_uint64_t); // ZRT
    dump_html_array<const uint32_t>(object.pAcquireTimeoutMilliseconds, object.acquireCount, settings, "const uint32_t*", "const uint32_t", "pAcquireTimeoutMilliseconds", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const uint32_t>(object.releaseCount, settings, "uint32_t", "releaseCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pReleaseSyncs, object.releaseCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pReleaseSyncs", indents + 1, dump_html_VkDeviceMemory); // ZRT
    dump_html_array<const uint64_t>(object.pReleaseKeys, object.releaseCount, settings, "const uint64_t*", "const uint64_t", "pReleaseKeys", indents + 1, dump_html_uint64_t); // ZRT
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkValidationFlagsEXT(const VkValidationFlagsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.disabledValidationCheckCount, settings, "uint32_t", "disabledValidationCheckCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkValidationCheckEXT>(object.pDisabledValidationChecks, object.disabledValidationCheckCount, settings, "const VkValidationCheckEXT*", "const VkValidationCheckEXT", "pDisabledValidationChecks", indents + 1, dump_html_VkValidationCheckEXT); // ZRT
}
#if defined(VK_USE_PLATFORM_VI_NN)
void dump_html_VkViSurfaceCreateInfoNN(const VkViSurfaceCreateInfoNN& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkViSurfaceCreateFlagsNN>(object.flags, settings, "VkViSurfaceCreateFlagsNN", "flags", indents + 1, dump_html_VkViSurfaceCreateFlagsNN);
    dump_html_value<const void*>(object.window, settings, "void*", "window", indents + 1, dump_html_void);
}
#endif // VK_USE_PLATFORM_VI_NN
void dump_html_VkImageViewASTCDecodeModeEXT(const VkImageViewASTCDecodeModeEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.decodeMode, settings, "VkFormat", "decodeMode", indents + 1, dump_html_VkFormat);
}
void dump_html_VkPhysicalDeviceASTCDecodeFeaturesEXT(const VkPhysicalDeviceASTCDecodeFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.decodeModeSharedExponent, settings, "VkBool32", "decodeModeSharedExponent", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePipelineRobustnessFeaturesEXT(const VkPhysicalDevicePipelineRobustnessFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineRobustness, settings, "VkBool32", "pipelineRobustness", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePipelineRobustnessPropertiesEXT(const VkPhysicalDevicePipelineRobustnessPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRobustnessBufferBehaviorEXT>(object.defaultRobustnessStorageBuffers, settings, "VkPipelineRobustnessBufferBehaviorEXT", "defaultRobustnessStorageBuffers", indents + 1, dump_html_VkPipelineRobustnessBufferBehaviorEXT);
    dump_html_value<const VkPipelineRobustnessBufferBehaviorEXT>(object.defaultRobustnessUniformBuffers, settings, "VkPipelineRobustnessBufferBehaviorEXT", "defaultRobustnessUniformBuffers", indents + 1, dump_html_VkPipelineRobustnessBufferBehaviorEXT);
    dump_html_value<const VkPipelineRobustnessBufferBehaviorEXT>(object.defaultRobustnessVertexInputs, settings, "VkPipelineRobustnessBufferBehaviorEXT", "defaultRobustnessVertexInputs", indents + 1, dump_html_VkPipelineRobustnessBufferBehaviorEXT);
    dump_html_value<const VkPipelineRobustnessImageBehaviorEXT>(object.defaultRobustnessImages, settings, "VkPipelineRobustnessImageBehaviorEXT", "defaultRobustnessImages", indents + 1, dump_html_VkPipelineRobustnessImageBehaviorEXT);
}
void dump_html_VkPipelineRobustnessCreateInfoEXT(const VkPipelineRobustnessCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRobustnessBufferBehaviorEXT>(object.storageBuffers, settings, "VkPipelineRobustnessBufferBehaviorEXT", "storageBuffers", indents + 1, dump_html_VkPipelineRobustnessBufferBehaviorEXT);
    dump_html_value<const VkPipelineRobustnessBufferBehaviorEXT>(object.uniformBuffers, settings, "VkPipelineRobustnessBufferBehaviorEXT", "uniformBuffers", indents + 1, dump_html_VkPipelineRobustnessBufferBehaviorEXT);
    dump_html_value<const VkPipelineRobustnessBufferBehaviorEXT>(object.vertexInputs, settings, "VkPipelineRobustnessBufferBehaviorEXT", "vertexInputs", indents + 1, dump_html_VkPipelineRobustnessBufferBehaviorEXT);
    dump_html_value<const VkPipelineRobustnessImageBehaviorEXT>(object.images, settings, "VkPipelineRobustnessImageBehaviorEXT", "images", indents + 1, dump_html_VkPipelineRobustnessImageBehaviorEXT);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkImportMemoryWin32HandleInfoKHR(const VkImportMemoryWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkExportMemoryWin32HandleInfoKHR(const VkExportMemoryWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkMemoryWin32HandlePropertiesKHR(const VkMemoryWin32HandlePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkMemoryGetWin32HandleInfoKHR(const VkMemoryGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkImportMemoryFdInfoKHR(const VkImportMemoryFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const int>(object.fd, settings, "int", "fd", indents + 1, dump_html_int);
}
void dump_html_VkMemoryFdPropertiesKHR(const VkMemoryFdPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
void dump_html_VkMemoryGetFdInfoKHR(const VkMemoryGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkWin32KeyedMutexAcquireReleaseInfoKHR(const VkWin32KeyedMutexAcquireReleaseInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.acquireCount, settings, "uint32_t", "acquireCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pAcquireSyncs, object.acquireCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pAcquireSyncs", indents + 1, dump_html_VkDeviceMemory); // ZRT
    dump_html_array<const uint64_t>(object.pAcquireKeys, object.acquireCount, settings, "const uint64_t*", "const uint64_t", "pAcquireKeys", indents + 1, dump_html_uint64_t); // ZRT
    dump_html_array<const uint32_t>(object.pAcquireTimeouts, object.acquireCount, settings, "const uint32_t*", "const uint32_t", "pAcquireTimeouts", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_value<const uint32_t>(object.releaseCount, settings, "uint32_t", "releaseCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pReleaseSyncs, object.releaseCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pReleaseSyncs", indents + 1, dump_html_VkDeviceMemory); // ZRT
    dump_html_array<const uint64_t>(object.pReleaseKeys, object.releaseCount, settings, "const uint64_t*", "const uint64_t", "pReleaseKeys", indents + 1, dump_html_uint64_t); // ZRT
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkImportSemaphoreWin32HandleInfoKHR(const VkImportSemaphoreWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkSemaphoreImportFlags>(object.flags, settings, "VkSemaphoreImportFlags", "flags", indents + 1, dump_html_VkSemaphoreImportFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkExportSemaphoreWin32HandleInfoKHR(const VkExportSemaphoreWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkD3D12FenceSubmitInfoKHR(const VkD3D12FenceSubmitInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreValuesCount, settings, "uint32_t", "waitSemaphoreValuesCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pWaitSemaphoreValues, object.waitSemaphoreValuesCount, settings, "const uint64_t*", "const uint64_t", "pWaitSemaphoreValues", indents + 1, dump_html_uint64_t); // ZRT
    dump_html_value<const uint32_t>(object.signalSemaphoreValuesCount, settings, "uint32_t", "signalSemaphoreValuesCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pSignalSemaphoreValues, object.signalSemaphoreValuesCount, settings, "const uint64_t*", "const uint64_t", "pSignalSemaphoreValues", indents + 1, dump_html_uint64_t); // ZRT
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkSemaphoreGetWin32HandleInfoKHR(const VkSemaphoreGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkImportSemaphoreFdInfoKHR(const VkImportSemaphoreFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkSemaphoreImportFlags>(object.flags, settings, "VkSemaphoreImportFlags", "flags", indents + 1, dump_html_VkSemaphoreImportFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    dump_html_value<const int>(object.fd, settings, "int", "fd", indents + 1, dump_html_int);
}
void dump_html_VkSemaphoreGetFdInfoKHR(const VkSemaphoreGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
}
void dump_html_VkPhysicalDevicePushDescriptorPropertiesKHR(const VkPhysicalDevicePushDescriptorPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxPushDescriptors, settings, "uint32_t", "maxPushDescriptors", indents + 1, dump_html_uint32_t);
}
void dump_html_VkConditionalRenderingBeginInfoEXT(const VkConditionalRenderingBeginInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkConditionalRenderingFlagsEXT>(object.flags, settings, "VkConditionalRenderingFlagsEXT", "flags", indents + 1, dump_html_VkConditionalRenderingFlagsEXT);
}
void dump_html_VkPhysicalDeviceConditionalRenderingFeaturesEXT(const VkPhysicalDeviceConditionalRenderingFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.conditionalRendering, settings, "VkBool32", "conditionalRendering", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.inheritedConditionalRendering, settings, "VkBool32", "inheritedConditionalRendering", indents + 1, dump_html_VkBool32);
}
void dump_html_VkCommandBufferInheritanceConditionalRenderingInfoEXT(const VkCommandBufferInheritanceConditionalRenderingInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.conditionalRenderingEnable, settings, "VkBool32", "conditionalRenderingEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRectLayerKHR(const VkRectLayerKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkOffset2D>(object.offset, settings, "VkOffset2D", "offset", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.extent, settings, "VkExtent2D", "extent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.layer, settings, "uint32_t", "layer", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPresentRegionKHR(const VkPresentRegionKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.rectangleCount, settings, "uint32_t", "rectangleCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRectLayerKHR>(object.pRectangles, object.rectangleCount, settings, "const VkRectLayerKHR*", "const VkRectLayerKHR", "pRectangles", indents + 1, dump_html_VkRectLayerKHR); // ZRT
}
void dump_html_VkPresentRegionsKHR(const VkPresentRegionsKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentRegionKHR>(object.pRegions, object.swapchainCount, settings, "const VkPresentRegionKHR*", "const VkPresentRegionKHR", "pRegions", indents + 1, dump_html_VkPresentRegionKHR); // ZRT
}
void dump_html_VkViewportWScalingNV(const VkViewportWScalingNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.xcoeff, settings, "float", "xcoeff", indents + 1, dump_html_float);
    dump_html_value<const float>(object.ycoeff, settings, "float", "ycoeff", indents + 1, dump_html_float);
}
void dump_html_VkPipelineViewportWScalingStateCreateInfoNV(const VkPipelineViewportWScalingStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.viewportWScalingEnable, settings, "VkBool32", "viewportWScalingEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkViewportWScalingNV>(object.pViewportWScalings, object.viewportCount, settings, "const VkViewportWScalingNV*", "const VkViewportWScalingNV", "pViewportWScalings", indents + 1, dump_html_VkViewportWScalingNV); // ZRT
}
void dump_html_VkSurfaceCapabilities2EXT(const VkSurfaceCapabilities2EXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minImageCount, settings, "uint32_t", "minImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageCount, settings, "uint32_t", "maxImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.currentExtent, settings, "VkExtent2D", "currentExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.minImageExtent, settings, "VkExtent2D", "minImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxImageExtent, settings, "VkExtent2D", "maxImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxImageArrayLayers, settings, "uint32_t", "maxImageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSurfaceTransformFlagsKHR>(object.supportedTransforms, settings, "VkSurfaceTransformFlagsKHR", "supportedTransforms", indents + 1, dump_html_VkSurfaceTransformFlagsKHR);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.currentTransform, settings, "VkSurfaceTransformFlagBitsKHR", "currentTransform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkCompositeAlphaFlagsKHR>(object.supportedCompositeAlpha, settings, "VkCompositeAlphaFlagsKHR", "supportedCompositeAlpha", indents + 1, dump_html_VkCompositeAlphaFlagsKHR);
    dump_html_value<const VkImageUsageFlags>(object.supportedUsageFlags, settings, "VkImageUsageFlags", "supportedUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkSurfaceCounterFlagsEXT>(object.supportedSurfaceCounters, settings, "VkSurfaceCounterFlagsEXT", "supportedSurfaceCounters", indents + 1, dump_html_VkSurfaceCounterFlagsEXT);
}
void dump_html_VkDisplayPowerInfoEXT(const VkDisplayPowerInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPowerStateEXT>(object.powerState, settings, "VkDisplayPowerStateEXT", "powerState", indents + 1, dump_html_VkDisplayPowerStateEXT);
}
void dump_html_VkDeviceEventInfoEXT(const VkDeviceEventInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceEventTypeEXT>(object.deviceEvent, settings, "VkDeviceEventTypeEXT", "deviceEvent", indents + 1, dump_html_VkDeviceEventTypeEXT);
}
void dump_html_VkDisplayEventInfoEXT(const VkDisplayEventInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayEventTypeEXT>(object.displayEvent, settings, "VkDisplayEventTypeEXT", "displayEvent", indents + 1, dump_html_VkDisplayEventTypeEXT);
}
void dump_html_VkSwapchainCounterCreateInfoEXT(const VkSwapchainCounterCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceCounterFlagsEXT>(object.surfaceCounters, settings, "VkSurfaceCounterFlagsEXT", "surfaceCounters", indents + 1, dump_html_VkSurfaceCounterFlagsEXT);
}
void dump_html_VkRefreshCycleDurationGOOGLE(const VkRefreshCycleDurationGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint64_t>(object.refreshDuration, settings, "uint64_t", "refreshDuration", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPastPresentationTimingGOOGLE(const VkPastPresentationTimingGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.presentID, settings, "uint32_t", "presentID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.desiredPresentTime, settings, "uint64_t", "desiredPresentTime", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.actualPresentTime, settings, "uint64_t", "actualPresentTime", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.earliestPresentTime, settings, "uint64_t", "earliestPresentTime", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.presentMargin, settings, "uint64_t", "presentMargin", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPresentTimeGOOGLE(const VkPresentTimeGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.presentID, settings, "uint32_t", "presentID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.desiredPresentTime, settings, "uint64_t", "desiredPresentTime", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPresentTimesInfoGOOGLE(const VkPresentTimesInfoGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentTimeGOOGLE>(object.pTimes, object.swapchainCount, settings, "const VkPresentTimeGOOGLE*", "const VkPresentTimeGOOGLE", "pTimes", indents + 1, dump_html_VkPresentTimeGOOGLE); // ZRT
}
void dump_html_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.perViewPositionAllComponents, settings, "VkBool32", "perViewPositionAllComponents", indents + 1, dump_html_VkBool32);
}
void dump_html_VkViewportSwizzleNV(const VkViewportSwizzleNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.x, settings, "VkViewportCoordinateSwizzleNV", "x", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.y, settings, "VkViewportCoordinateSwizzleNV", "y", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.z, settings, "VkViewportCoordinateSwizzleNV", "z", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.w, settings, "VkViewportCoordinateSwizzleNV", "w", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
}
void dump_html_VkPipelineViewportSwizzleStateCreateInfoNV(const VkPipelineViewportSwizzleStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineViewportSwizzleStateCreateFlagsNV>(object.flags, settings, "VkPipelineViewportSwizzleStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineViewportSwizzleStateCreateFlagsNV);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkViewportSwizzleNV>(object.pViewportSwizzles, object.viewportCount, settings, "const VkViewportSwizzleNV*", "const VkViewportSwizzleNV", "pViewportSwizzles", indents + 1, dump_html_VkViewportSwizzleNV); // ZRT
}
void dump_html_VkPhysicalDeviceDiscardRectanglePropertiesEXT(const VkPhysicalDeviceDiscardRectanglePropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxDiscardRectangles, settings, "uint32_t", "maxDiscardRectangles", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineDiscardRectangleStateCreateInfoEXT(const VkPipelineDiscardRectangleStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineDiscardRectangleStateCreateFlagsEXT>(object.flags, settings, "VkPipelineDiscardRectangleStateCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineDiscardRectangleStateCreateFlagsEXT);
    dump_html_value<const VkDiscardRectangleModeEXT>(object.discardRectangleMode, settings, "VkDiscardRectangleModeEXT", "discardRectangleMode", indents + 1, dump_html_VkDiscardRectangleModeEXT);
    dump_html_value<const uint32_t>(object.discardRectangleCount, settings, "uint32_t", "discardRectangleCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pDiscardRectangles, object.discardRectangleCount, settings, "const VkRect2D*", "const VkRect2D", "pDiscardRectangles", indents + 1, dump_html_VkRect2D); // ZRT
}
void dump_html_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(const VkPhysicalDeviceConservativeRasterizationPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const float>(object.primitiveOverestimationSize, settings, "float", "primitiveOverestimationSize", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxExtraPrimitiveOverestimationSize, settings, "float", "maxExtraPrimitiveOverestimationSize", indents + 1, dump_html_float);
    dump_html_value<const float>(object.extraPrimitiveOverestimationSizeGranularity, settings, "float", "extraPrimitiveOverestimationSizeGranularity", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.primitiveUnderestimation, settings, "VkBool32", "primitiveUnderestimation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.conservativePointAndLineRasterization, settings, "VkBool32", "conservativePointAndLineRasterization", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.degenerateTrianglesRasterized, settings, "VkBool32", "degenerateTrianglesRasterized", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.degenerateLinesRasterized, settings, "VkBool32", "degenerateLinesRasterized", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fullyCoveredFragmentShaderInputVariable, settings, "VkBool32", "fullyCoveredFragmentShaderInputVariable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.conservativeRasterizationPostDepthCoverage, settings, "VkBool32", "conservativeRasterizationPostDepthCoverage", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineRasterizationConservativeStateCreateInfoEXT(const VkPipelineRasterizationConservativeStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationConservativeStateCreateFlagsEXT>(object.flags, settings, "VkPipelineRasterizationConservativeStateCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    dump_html_value<const VkConservativeRasterizationModeEXT>(object.conservativeRasterizationMode, settings, "VkConservativeRasterizationModeEXT", "conservativeRasterizationMode", indents + 1, dump_html_VkConservativeRasterizationModeEXT);
    dump_html_value<const float>(object.extraPrimitiveOverestimationSize, settings, "float", "extraPrimitiveOverestimationSize", indents + 1, dump_html_float);
}
void dump_html_VkPhysicalDeviceDepthClipEnableFeaturesEXT(const VkPhysicalDeviceDepthClipEnableFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.depthClipEnable, settings, "VkBool32", "depthClipEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineRasterizationDepthClipStateCreateInfoEXT(const VkPipelineRasterizationDepthClipStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationDepthClipStateCreateFlagsEXT>(object.flags, settings, "VkPipelineRasterizationDepthClipStateCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineRasterizationDepthClipStateCreateFlagsEXT);
    dump_html_value<const VkBool32>(object.depthClipEnable, settings, "VkBool32", "depthClipEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkXYColorEXT(const VkXYColorEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.x, settings, "float", "x", indents + 1, dump_html_float);
    dump_html_value<const float>(object.y, settings, "float", "y", indents + 1, dump_html_float);
}
void dump_html_VkHdrMetadataEXT(const VkHdrMetadataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkXYColorEXT>(object.displayPrimaryRed, settings, "VkXYColorEXT", "displayPrimaryRed", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const VkXYColorEXT>(object.displayPrimaryGreen, settings, "VkXYColorEXT", "displayPrimaryGreen", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const VkXYColorEXT>(object.displayPrimaryBlue, settings, "VkXYColorEXT", "displayPrimaryBlue", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const VkXYColorEXT>(object.whitePoint, settings, "VkXYColorEXT", "whitePoint", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const float>(object.maxLuminance, settings, "float", "maxLuminance", indents + 1, dump_html_float);
    dump_html_value<const float>(object.minLuminance, settings, "float", "minLuminance", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxContentLightLevel, settings, "float", "maxContentLightLevel", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxFrameAverageLightLevel, settings, "float", "maxFrameAverageLightLevel", indents + 1, dump_html_float);
}
void dump_html_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.relaxedLineRasterization, settings, "VkBool32", "relaxedLineRasterization", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSharedPresentSurfaceCapabilitiesKHR(const VkSharedPresentSurfaceCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.sharedPresentSupportedUsageFlags, settings, "VkImageUsageFlags", "sharedPresentSupportedUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkImportFenceWin32HandleInfoKHR(const VkImportFenceWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkFenceImportFlags>(object.flags, settings, "VkFenceImportFlags", "flags", indents + 1, dump_html_VkFenceImportFlags);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkExportFenceWin32HandleInfoKHR(const VkExportFenceWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkFenceGetWin32HandleInfoKHR(const VkFenceGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkImportFenceFdInfoKHR(const VkImportFenceFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkFenceImportFlags>(object.flags, settings, "VkFenceImportFlags", "flags", indents + 1, dump_html_VkFenceImportFlags);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    dump_html_value<const int>(object.fd, settings, "int", "fd", indents + 1, dump_html_int);
}
void dump_html_VkFenceGetFdInfoKHR(const VkFenceGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
}
void dump_html_VkPhysicalDevicePerformanceQueryFeaturesKHR(const VkPhysicalDevicePerformanceQueryFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.performanceCounterQueryPools, settings, "VkBool32", "performanceCounterQueryPools", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.performanceCounterMultipleQueryPools, settings, "VkBool32", "performanceCounterMultipleQueryPools", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePerformanceQueryPropertiesKHR(const VkPhysicalDevicePerformanceQueryPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.allowCommandBufferQueryCopies, settings, "VkBool32", "allowCommandBufferQueryCopies", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPerformanceCounterKHR(const VkPerformanceCounterKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPerformanceCounterUnitKHR>(object.unit, settings, "VkPerformanceCounterUnitKHR", "unit", indents + 1, dump_html_VkPerformanceCounterUnitKHR);
    dump_html_value<const VkPerformanceCounterScopeKHR>(object.scope, settings, "VkPerformanceCounterScopeKHR", "scope", indents + 1, dump_html_VkPerformanceCounterScopeKHR);
    dump_html_value<const VkPerformanceCounterStorageKHR>(object.storage, settings, "VkPerformanceCounterStorageKHR", "storage", indents + 1, dump_html_VkPerformanceCounterStorageKHR);
    dump_html_array<const uint8_t>(object.uuid, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "uuid", indents + 1, dump_html_uint8_t); // ZRR
}
void dump_html_VkPerformanceCounterDescriptionKHR(const VkPerformanceCounterDescriptionKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPerformanceCounterDescriptionFlagsKHR>(object.flags, settings, "VkPerformanceCounterDescriptionFlagsKHR", "flags", indents + 1, dump_html_VkPerformanceCounterDescriptionFlagsKHR);
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.category, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "category", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
}
void dump_html_VkQueryPoolPerformanceCreateInfoKHR(const VkQueryPoolPerformanceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.counterIndexCount, settings, "uint32_t", "counterIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCounterIndices, object.counterIndexCount, settings, "const uint32_t*", "const uint32_t", "pCounterIndices", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkAcquireProfilingLockInfoKHR(const VkAcquireProfilingLockInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAcquireProfilingLockFlagsKHR>(object.flags, settings, "VkAcquireProfilingLockFlagsKHR", "flags", indents + 1, dump_html_VkAcquireProfilingLockFlagsKHR);
    dump_html_value<const uint64_t>(object.timeout, settings, "uint64_t", "timeout", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPerformanceQuerySubmitInfoKHR(const VkPerformanceQuerySubmitInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.counterPassIndex, settings, "uint32_t", "counterPassIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceSurfaceInfo2KHR(const VkPhysicalDeviceSurfaceInfo2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceKHR>(object.surface, settings, "VkSurfaceKHR", "surface", indents + 1, dump_html_VkSurfaceKHR);
}
void dump_html_VkSurfaceCapabilities2KHR(const VkSurfaceCapabilities2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceCapabilitiesKHR>(object.surfaceCapabilities, settings, "VkSurfaceCapabilitiesKHR", "surfaceCapabilities", indents + 1, dump_html_VkSurfaceCapabilitiesKHR);
}
void dump_html_VkSurfaceFormat2KHR(const VkSurfaceFormat2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceFormatKHR>(object.surfaceFormat, settings, "VkSurfaceFormatKHR", "surfaceFormat", indents + 1, dump_html_VkSurfaceFormatKHR);
}
void dump_html_VkDisplayProperties2KHR(const VkDisplayProperties2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPropertiesKHR>(object.displayProperties, settings, "VkDisplayPropertiesKHR", "displayProperties", indents + 1, dump_html_VkDisplayPropertiesKHR);
}
void dump_html_VkDisplayPlaneProperties2KHR(const VkDisplayPlaneProperties2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPlanePropertiesKHR>(object.displayPlaneProperties, settings, "VkDisplayPlanePropertiesKHR", "displayPlaneProperties", indents + 1, dump_html_VkDisplayPlanePropertiesKHR);
}
void dump_html_VkDisplayModeProperties2KHR(const VkDisplayModeProperties2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayModePropertiesKHR>(object.displayModeProperties, settings, "VkDisplayModePropertiesKHR", "displayModeProperties", indents + 1, dump_html_VkDisplayModePropertiesKHR);
}
void dump_html_VkDisplayPlaneInfo2KHR(const VkDisplayPlaneInfo2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayModeKHR>(object.mode, settings, "VkDisplayModeKHR", "mode", indents + 1, dump_html_VkDisplayModeKHR);
    dump_html_value<const uint32_t>(object.planeIndex, settings, "uint32_t", "planeIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDisplayPlaneCapabilities2KHR(const VkDisplayPlaneCapabilities2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPlaneCapabilitiesKHR>(object.capabilities, settings, "VkDisplayPlaneCapabilitiesKHR", "capabilities", indents + 1, dump_html_VkDisplayPlaneCapabilitiesKHR);
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
void dump_html_VkIOSSurfaceCreateInfoMVK(const VkIOSSurfaceCreateInfoMVK& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkIOSSurfaceCreateFlagsMVK>(object.flags, settings, "VkIOSSurfaceCreateFlagsMVK", "flags", indents + 1, dump_html_VkIOSSurfaceCreateFlagsMVK);
    dump_html_value<const void*>(object.pView, settings, "const void*", "pView", indents + 1, dump_html_void);
}
#endif // VK_USE_PLATFORM_IOS_MVK
#if defined(VK_USE_PLATFORM_MACOS_MVK)
void dump_html_VkMacOSSurfaceCreateInfoMVK(const VkMacOSSurfaceCreateInfoMVK& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMacOSSurfaceCreateFlagsMVK>(object.flags, settings, "VkMacOSSurfaceCreateFlagsMVK", "flags", indents + 1, dump_html_VkMacOSSurfaceCreateFlagsMVK);
    dump_html_value<const void*>(object.pView, settings, "const void*", "pView", indents + 1, dump_html_void);
}
#endif // VK_USE_PLATFORM_MACOS_MVK
void dump_html_VkDebugUtilsLabelEXT(const VkDebugUtilsLabelEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pLabelName, settings, "const char*", "pLabelName", indents + 1, dump_html_cstring);
    dump_html_array<const float>(object.color, 4, settings, "float[4]", "float", "color", indents + 1, dump_html_float); // ZRR
}
void dump_html_VkDebugUtilsObjectNameInfoEXT(const VkDebugUtilsObjectNameInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkObjectType>(object.objectType, settings, "VkObjectType", "objectType", indents + 1, dump_html_VkObjectType);
    dump_html_value<const uint64_t>(object.objectHandle, settings, "uint64_t", "objectHandle", indents + 1, dump_html_uint64_t);
    dump_html_value<const char*>(object.pObjectName, settings, "const char*", "pObjectName", indents + 1, dump_html_cstring);
}
void dump_html_VkDebugUtilsMessengerCallbackDataEXT(const VkDebugUtilsMessengerCallbackDataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugUtilsMessengerCallbackDataFlagsEXT>(object.flags, settings, "VkDebugUtilsMessengerCallbackDataFlagsEXT", "flags", indents + 1, dump_html_VkDebugUtilsMessengerCallbackDataFlagsEXT);
    dump_html_value<const char*>(object.pMessageIdName, settings, "const char*", "pMessageIdName", indents + 1, dump_html_cstring);
    dump_html_value<const int32_t>(object.messageIdNumber, settings, "int32_t", "messageIdNumber", indents + 1, dump_html_int32_t);
    dump_html_value<const char*>(object.pMessage, settings, "const char*", "pMessage", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.queueLabelCount, settings, "uint32_t", "queueLabelCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDebugUtilsLabelEXT>(object.pQueueLabels, object.queueLabelCount, settings, "const VkDebugUtilsLabelEXT*", "const VkDebugUtilsLabelEXT", "pQueueLabels", indents + 1, dump_html_VkDebugUtilsLabelEXT); // ZRT
    dump_html_value<const uint32_t>(object.cmdBufLabelCount, settings, "uint32_t", "cmdBufLabelCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDebugUtilsLabelEXT>(object.pCmdBufLabels, object.cmdBufLabelCount, settings, "const VkDebugUtilsLabelEXT*", "const VkDebugUtilsLabelEXT", "pCmdBufLabels", indents + 1, dump_html_VkDebugUtilsLabelEXT); // ZRT
    dump_html_value<const uint32_t>(object.objectCount, settings, "uint32_t", "objectCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDebugUtilsObjectNameInfoEXT>(object.pObjects, object.objectCount, settings, "const VkDebugUtilsObjectNameInfoEXT*", "const VkDebugUtilsObjectNameInfoEXT", "pObjects", indents + 1, dump_html_VkDebugUtilsObjectNameInfoEXT); // ZRT
}
void dump_html_VkDebugUtilsMessengerCreateInfoEXT(const VkDebugUtilsMessengerCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugUtilsMessengerCreateFlagsEXT>(object.flags, settings, "VkDebugUtilsMessengerCreateFlagsEXT", "flags", indents + 1, dump_html_VkDebugUtilsMessengerCreateFlagsEXT);
    dump_html_value<const VkDebugUtilsMessageSeverityFlagsEXT>(object.messageSeverity, settings, "VkDebugUtilsMessageSeverityFlagsEXT", "messageSeverity", indents + 1, dump_html_VkDebugUtilsMessageSeverityFlagsEXT);
    dump_html_value<const VkDebugUtilsMessageTypeFlagsEXT>(object.messageType, settings, "VkDebugUtilsMessageTypeFlagsEXT", "messageType", indents + 1, dump_html_VkDebugUtilsMessageTypeFlagsEXT);
    dump_html_value<const PFN_vkDebugUtilsMessengerCallbackEXT>(object.pfnUserCallback, settings, "PFN_vkDebugUtilsMessengerCallbackEXT", "pfnUserCallback", indents + 1, dump_html_PFN_vkDebugUtilsMessengerCallbackEXT);
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
}
void dump_html_VkDebugUtilsObjectTagInfoEXT(const VkDebugUtilsObjectTagInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkObjectType>(object.objectType, settings, "VkObjectType", "objectType", indents + 1, dump_html_VkObjectType);
    dump_html_value<const uint64_t>(object.objectHandle, settings, "uint64_t", "objectHandle", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.tagName, settings, "uint64_t", "tagName", indents + 1, dump_html_uint64_t);
    dump_html_value<const size_t>(object.tagSize, settings, "size_t", "tagSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pTag, settings, "const void*", "pTag", indents + 1, dump_html_void);
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidHardwareBufferUsageANDROID(const VkAndroidHardwareBufferUsageANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.androidHardwareBufferUsage, settings, "uint64_t", "androidHardwareBufferUsage", indents + 1, dump_html_uint64_t);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidHardwareBufferPropertiesANDROID(const VkAndroidHardwareBufferPropertiesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.allocationSize, settings, "VkDeviceSize", "allocationSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidHardwareBufferFormatPropertiesANDROID(const VkAndroidHardwareBufferFormatPropertiesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkFormatFeatureFlags>(object.formatFeatures, settings, "VkFormatFeatureFlags", "formatFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkComponentMapping>(object.samplerYcbcrConversionComponents, settings, "VkComponentMapping", "samplerYcbcrConversionComponents", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.suggestedYcbcrModel, settings, "VkSamplerYcbcrModelConversion", "suggestedYcbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.suggestedYcbcrRange, settings, "VkSamplerYcbcrRange", "suggestedYcbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkChromaLocation>(object.suggestedXChromaOffset, settings, "VkChromaLocation", "suggestedXChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.suggestedYChromaOffset, settings, "VkChromaLocation", "suggestedYChromaOffset", indents + 1, dump_html_VkChromaLocation);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkImportAndroidHardwareBufferInfoANDROID(const VkImportAndroidHardwareBufferInfoANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const AHardwareBuffer*>(object.buffer, settings, "struct AHardwareBuffer*", "buffer", indents + 1, dump_html_AHardwareBuffer);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkMemoryGetAndroidHardwareBufferInfoANDROID(const VkMemoryGetAndroidHardwareBufferInfoANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkExternalFormatANDROID(const VkExternalFormatANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidHardwareBufferFormatProperties2ANDROID(const VkAndroidHardwareBufferFormatProperties2ANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkFormatFeatureFlags2>(object.formatFeatures, settings, "VkFormatFeatureFlags2", "formatFeatures", indents + 1, dump_html_VkFormatFeatureFlags2);
    dump_html_value<const VkComponentMapping>(object.samplerYcbcrConversionComponents, settings, "VkComponentMapping", "samplerYcbcrConversionComponents", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.suggestedYcbcrModel, settings, "VkSamplerYcbcrModelConversion", "suggestedYcbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.suggestedYcbcrRange, settings, "VkSamplerYcbcrRange", "suggestedYcbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkChromaLocation>(object.suggestedXChromaOffset, settings, "VkChromaLocation", "suggestedXChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.suggestedYChromaOffset, settings, "VkChromaLocation", "suggestedYChromaOffset", indents + 1, dump_html_VkChromaLocation);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPhysicalDeviceShaderEnqueueFeaturesAMDX(const VkPhysicalDeviceShaderEnqueueFeaturesAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderEnqueue, settings, "VkBool32", "shaderEnqueue", indents + 1, dump_html_VkBool32);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPhysicalDeviceShaderEnqueuePropertiesAMDX(const VkPhysicalDeviceShaderEnqueuePropertiesAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxExecutionGraphDepth, settings, "uint32_t", "maxExecutionGraphDepth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxExecutionGraphShaderOutputNodes, settings, "uint32_t", "maxExecutionGraphShaderOutputNodes", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxExecutionGraphShaderPayloadSize, settings, "uint32_t", "maxExecutionGraphShaderPayloadSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxExecutionGraphShaderPayloadCount, settings, "uint32_t", "maxExecutionGraphShaderPayloadCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.executionGraphDispatchAddressAlignment, settings, "uint32_t", "executionGraphDispatchAddressAlignment", indents + 1, dump_html_uint32_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkExecutionGraphPipelineScratchSizeAMDX(const VkExecutionGraphPipelineScratchSizeAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkPipelineLibraryCreateInfoKHR(const VkPipelineLibraryCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.libraryCount, settings, "uint32_t", "libraryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipeline>(object.pLibraries, object.libraryCount, settings, "const VkPipeline*", "const VkPipeline", "pLibraries", indents + 1, dump_html_VkPipeline); // ZRT
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkExecutionGraphPipelineCreateInfoAMDX(const VkExecutionGraphPipelineCreateInfoAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo); // ZRT
    dump_html_pointer<const VkPipelineLibraryCreateInfoKHR>(object.pLibraryInfo, settings, "const VkPipelineLibraryCreateInfoKHR*", "pLibraryInfo", indents + 1, dump_html_VkPipelineLibraryCreateInfoKHR);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkDispatchGraphInfoAMDX(const VkDispatchGraphInfoAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.nodeIndex, settings, "uint32_t", "nodeIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.payloadCount, settings, "uint32_t", "payloadCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceOrHostAddressConstAMDX>(object.payloads, settings, "VkDeviceOrHostAddressConstAMDX", "payloads", indents + 1, dump_html_VkDeviceOrHostAddressConstAMDX);
    dump_html_value<const uint64_t>(object.payloadStride, settings, "uint64_t", "payloadStride", indents + 1, dump_html_uint64_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkDispatchGraphCountInfoAMDX(const VkDispatchGraphCountInfoAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.count, settings, "uint32_t", "count", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceOrHostAddressConstAMDX>(object.infos, settings, "VkDeviceOrHostAddressConstAMDX", "infos", indents + 1, dump_html_VkDeviceOrHostAddressConstAMDX);
    dump_html_value<const uint64_t>(object.stride, settings, "uint64_t", "stride", indents + 1, dump_html_uint64_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPipelineShaderStageNodeCreateInfoAMDX(const VkPipelineShaderStageNodeCreateInfoAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pName, settings, "const char*", "pName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.index, settings, "uint32_t", "index", indents + 1, dump_html_uint32_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkSampleLocationEXT(const VkSampleLocationEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.x, settings, "float", "x", indents + 1, dump_html_float);
    dump_html_value<const float>(object.y, settings, "float", "y", indents + 1, dump_html_float);
}
void dump_html_VkSampleLocationsInfoEXT(const VkSampleLocationsInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampleCountFlagBits>(object.sampleLocationsPerPixel, settings, "VkSampleCountFlagBits", "sampleLocationsPerPixel", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkExtent2D>(object.sampleLocationGridSize, settings, "VkExtent2D", "sampleLocationGridSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.sampleLocationsCount, settings, "uint32_t", "sampleLocationsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSampleLocationEXT>(object.pSampleLocations, object.sampleLocationsCount, settings, "const VkSampleLocationEXT*", "const VkSampleLocationEXT", "pSampleLocations", indents + 1, dump_html_VkSampleLocationEXT); // ZRT
}
void dump_html_VkAttachmentSampleLocationsEXT(const VkAttachmentSampleLocationsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.attachmentIndex, settings, "uint32_t", "attachmentIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleLocationsInfoEXT>(object.sampleLocationsInfo, settings, "VkSampleLocationsInfoEXT", "sampleLocationsInfo", indents + 1, dump_html_VkSampleLocationsInfoEXT);
}
void dump_html_VkSubpassSampleLocationsEXT(const VkSubpassSampleLocationsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.subpassIndex, settings, "uint32_t", "subpassIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleLocationsInfoEXT>(object.sampleLocationsInfo, settings, "VkSampleLocationsInfoEXT", "sampleLocationsInfo", indents + 1, dump_html_VkSampleLocationsInfoEXT);
}
void dump_html_VkRenderPassSampleLocationsBeginInfoEXT(const VkRenderPassSampleLocationsBeginInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentInitialSampleLocationsCount, settings, "uint32_t", "attachmentInitialSampleLocationsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentSampleLocationsEXT>(object.pAttachmentInitialSampleLocations, object.attachmentInitialSampleLocationsCount, settings, "const VkAttachmentSampleLocationsEXT*", "const VkAttachmentSampleLocationsEXT", "pAttachmentInitialSampleLocations", indents + 1, dump_html_VkAttachmentSampleLocationsEXT); // ZRT
    dump_html_value<const uint32_t>(object.postSubpassSampleLocationsCount, settings, "uint32_t", "postSubpassSampleLocationsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassSampleLocationsEXT>(object.pPostSubpassSampleLocations, object.postSubpassSampleLocationsCount, settings, "const VkSubpassSampleLocationsEXT*", "const VkSubpassSampleLocationsEXT", "pPostSubpassSampleLocations", indents + 1, dump_html_VkSubpassSampleLocationsEXT); // ZRT
}
void dump_html_VkPipelineSampleLocationsStateCreateInfoEXT(const VkPipelineSampleLocationsStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.sampleLocationsEnable, settings, "VkBool32", "sampleLocationsEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkSampleLocationsInfoEXT>(object.sampleLocationsInfo, settings, "VkSampleLocationsInfoEXT", "sampleLocationsInfo", indents + 1, dump_html_VkSampleLocationsInfoEXT);
}
void dump_html_VkPhysicalDeviceSampleLocationsPropertiesEXT(const VkPhysicalDeviceSampleLocationsPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampleCountFlags>(object.sampleLocationSampleCounts, settings, "VkSampleCountFlags", "sampleLocationSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkExtent2D>(object.maxSampleLocationGridSize, settings, "VkExtent2D", "maxSampleLocationGridSize", indents + 1, dump_html_VkExtent2D);
    dump_html_array<const float>(object.sampleLocationCoordinateRange, 2, settings, "float[2]", "float", "sampleLocationCoordinateRange", indents + 1, dump_html_float); // ZRR
    dump_html_value<const uint32_t>(object.sampleLocationSubPixelBits, settings, "uint32_t", "sampleLocationSubPixelBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.variableSampleLocations, settings, "VkBool32", "variableSampleLocations", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMultisamplePropertiesEXT(const VkMultisamplePropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.maxSampleLocationGridSize, settings, "VkExtent2D", "maxSampleLocationGridSize", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.advancedBlendCoherentOperations, settings, "VkBool32", "advancedBlendCoherentOperations", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.advancedBlendMaxColorAttachments, settings, "uint32_t", "advancedBlendMaxColorAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.advancedBlendIndependentBlend, settings, "VkBool32", "advancedBlendIndependentBlend", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendNonPremultipliedSrcColor, settings, "VkBool32", "advancedBlendNonPremultipliedSrcColor", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendNonPremultipliedDstColor, settings, "VkBool32", "advancedBlendNonPremultipliedDstColor", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendCorrelatedOverlap, settings, "VkBool32", "advancedBlendCorrelatedOverlap", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendAllOperations, settings, "VkBool32", "advancedBlendAllOperations", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineColorBlendAdvancedStateCreateInfoEXT(const VkPipelineColorBlendAdvancedStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.srcPremultiplied, settings, "VkBool32", "srcPremultiplied", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dstPremultiplied, settings, "VkBool32", "dstPremultiplied", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBlendOverlapEXT>(object.blendOverlap, settings, "VkBlendOverlapEXT", "blendOverlap", indents + 1, dump_html_VkBlendOverlapEXT);
}
void dump_html_VkPipelineCoverageToColorStateCreateInfoNV(const VkPipelineCoverageToColorStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCoverageToColorStateCreateFlagsNV>(object.flags, settings, "VkPipelineCoverageToColorStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineCoverageToColorStateCreateFlagsNV);
    dump_html_value<const VkBool32>(object.coverageToColorEnable, settings, "VkBool32", "coverageToColorEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.coverageToColorLocation, settings, "uint32_t", "coverageToColorLocation", indents + 1, dump_html_uint32_t);
}
void dump_html_VkAccelerationStructureBuildRangeInfoKHR(const VkAccelerationStructureBuildRangeInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.primitiveCount, settings, "uint32_t", "primitiveCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.primitiveOffset, settings, "uint32_t", "primitiveOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstVertex, settings, "uint32_t", "firstVertex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.transformOffset, settings, "uint32_t", "transformOffset", indents + 1, dump_html_uint32_t);
}
void dump_html_VkAabbPositionsKHR(const VkAabbPositionsKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.minX, settings, "float", "minX", indents + 1, dump_html_float);
    dump_html_value<const float>(object.minY, settings, "float", "minY", indents + 1, dump_html_float);
    dump_html_value<const float>(object.minZ, settings, "float", "minZ", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxX, settings, "float", "maxX", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxY, settings, "float", "maxY", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxZ, settings, "float", "maxZ", indents + 1, dump_html_float);
}
void dump_html_VkAccelerationStructureGeometryTrianglesDataKHR(const VkAccelerationStructureGeometryTrianglesDataKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.vertexFormat, settings, "VkFormat", "vertexFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.vertexData, settings, "VkDeviceOrHostAddressConstKHR", "vertexData", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.vertexStride, settings, "VkDeviceSize", "vertexStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.maxVertex, settings, "uint32_t", "maxVertex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.indexData, settings, "VkDeviceOrHostAddressConstKHR", "indexData", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.transformData, settings, "VkDeviceOrHostAddressConstKHR", "transformData", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
}
void dump_html_VkTransformMatrixKHR(const VkTransformMatrixKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
}
void dump_html_VkAccelerationStructureGeometryAabbsDataKHR(const VkAccelerationStructureGeometryAabbsDataKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.data, settings, "VkDeviceOrHostAddressConstKHR", "data", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.stride, settings, "VkDeviceSize", "stride", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkAccelerationStructureGeometryInstancesDataKHR(const VkAccelerationStructureGeometryInstancesDataKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.arrayOfPointers, settings, "VkBool32", "arrayOfPointers", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.data, settings, "VkDeviceOrHostAddressConstKHR", "data", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
}
void dump_html_VkAccelerationStructureGeometryKHR(const VkAccelerationStructureGeometryKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkGeometryTypeKHR>(object.geometryType, settings, "VkGeometryTypeKHR", "geometryType", indents + 1, dump_html_VkGeometryTypeKHR);
    dump_html_value<const VkAccelerationStructureGeometryDataKHR>(object.geometry, settings, "VkAccelerationStructureGeometryDataKHR", "geometry", indents + 1, dump_html_VkAccelerationStructureGeometryDataKHR);
    dump_html_value<const VkGeometryFlagsKHR>(object.flags, settings, "VkGeometryFlagsKHR", "flags", indents + 1, dump_html_VkGeometryFlagsKHR);
}
void dump_html_VkAccelerationStructureBuildGeometryInfoKHR(const VkAccelerationStructureBuildGeometryInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureTypeKHR>(object.type, settings, "VkAccelerationStructureTypeKHR", "type", indents + 1, dump_html_VkAccelerationStructureTypeKHR);
    dump_html_value<const VkBuildAccelerationStructureFlagsKHR>(object.flags, settings, "VkBuildAccelerationStructureFlagsKHR", "flags", indents + 1, dump_html_VkBuildAccelerationStructureFlagsKHR);
    dump_html_value<const VkBuildAccelerationStructureModeKHR>(object.mode, settings, "VkBuildAccelerationStructureModeKHR", "mode", indents + 1, dump_html_VkBuildAccelerationStructureModeKHR);
    dump_html_value<const VkAccelerationStructureKHR>(object.srcAccelerationStructure, settings, "VkAccelerationStructureKHR", "srcAccelerationStructure", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const VkAccelerationStructureKHR>(object.dstAccelerationStructure, settings, "VkAccelerationStructureKHR", "dstAccelerationStructure", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const uint32_t>(object.geometryCount, settings, "uint32_t", "geometryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAccelerationStructureGeometryKHR>(object.pGeometries, object.geometryCount, settings, "const VkAccelerationStructureGeometryKHR*", "const VkAccelerationStructureGeometryKHR", "pGeometries", indents + 1, dump_html_VkAccelerationStructureGeometryKHR); // ZRT
    dump_html_value<const VkDeviceOrHostAddressKHR>(object.scratchData, settings, "VkDeviceOrHostAddressKHR", "scratchData", indents + 1, dump_html_VkDeviceOrHostAddressKHR);
}
void dump_html_VkAccelerationStructureInstanceKHR(const VkAccelerationStructureInstanceKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkTransformMatrixKHR>(object.transform, settings, "VkTransformMatrixKHR", "transform", indents + 1, dump_html_VkTransformMatrixKHR);
    dump_html_value<const uint32_t>(object.instanceCustomIndex, settings, "uint32_t instanceCustomIndex:24", "instanceCustomIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.mask, settings, "uint32_t mask:8", "mask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceShaderBindingTableRecordOffset, settings, "uint32_t instanceShaderBindingTableRecordOffset:24", "instanceShaderBindingTableRecordOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkGeometryInstanceFlagsKHR>(object.flags, settings, "VkGeometryInstanceFlagsKHR flags:8", "flags", indents + 1, dump_html_VkGeometryInstanceFlagsKHR);
    dump_html_value<const uint64_t>(object.accelerationStructureReference, settings, "uint64_t", "accelerationStructureReference", indents + 1, dump_html_uint64_t);
}
void dump_html_VkAccelerationStructureCreateInfoKHR(const VkAccelerationStructureCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureCreateFlagsKHR>(object.createFlags, settings, "VkAccelerationStructureCreateFlagsKHR", "createFlags", indents + 1, dump_html_VkAccelerationStructureCreateFlagsKHR);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkAccelerationStructureTypeKHR>(object.type, settings, "VkAccelerationStructureTypeKHR", "type", indents + 1, dump_html_VkAccelerationStructureTypeKHR);
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
}
void dump_html_VkWriteDescriptorSetAccelerationStructureKHR(const VkWriteDescriptorSetAccelerationStructureKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAccelerationStructureKHR>(object.pAccelerationStructures, object.accelerationStructureCount, settings, "const VkAccelerationStructureKHR*", "const VkAccelerationStructureKHR", "pAccelerationStructures", indents + 1, dump_html_VkAccelerationStructureKHR); // ZRT
}
void dump_html_VkPhysicalDeviceAccelerationStructureFeaturesKHR(const VkPhysicalDeviceAccelerationStructureFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.accelerationStructure, settings, "VkBool32", "accelerationStructure", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.accelerationStructureCaptureReplay, settings, "VkBool32", "accelerationStructureCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.accelerationStructureIndirectBuild, settings, "VkBool32", "accelerationStructureIndirectBuild", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.accelerationStructureHostCommands, settings, "VkBool32", "accelerationStructureHostCommands", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingAccelerationStructureUpdateAfterBind, settings, "VkBool32", "descriptorBindingAccelerationStructureUpdateAfterBind", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceAccelerationStructurePropertiesKHR(const VkPhysicalDeviceAccelerationStructurePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.maxGeometryCount, settings, "uint64_t", "maxGeometryCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxInstanceCount, settings, "uint64_t", "maxInstanceCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxPrimitiveCount, settings, "uint64_t", "maxPrimitiveCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorAccelerationStructures, settings, "uint32_t", "maxPerStageDescriptorAccelerationStructures", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindAccelerationStructures, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindAccelerationStructures", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetAccelerationStructures, settings, "uint32_t", "maxDescriptorSetAccelerationStructures", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindAccelerationStructures, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindAccelerationStructures", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minAccelerationStructureScratchOffsetAlignment, settings, "uint32_t", "minAccelerationStructureScratchOffsetAlignment", indents + 1, dump_html_uint32_t);
}
void dump_html_VkAccelerationStructureDeviceAddressInfoKHR(const VkAccelerationStructureDeviceAddressInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureKHR>(object.accelerationStructure, settings, "VkAccelerationStructureKHR", "accelerationStructure", indents + 1, dump_html_VkAccelerationStructureKHR);
}
void dump_html_VkAccelerationStructureVersionInfoKHR(const VkAccelerationStructureVersionInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.pVersionData, 2*VK_UUID_SIZE, settings, "const uint8_t*", "const uint8_t", "pVersionData", indents + 1, dump_html_uint8_t); // ZRS
}
void dump_html_VkCopyAccelerationStructureToMemoryInfoKHR(const VkCopyAccelerationStructureToMemoryInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureKHR>(object.src, settings, "VkAccelerationStructureKHR", "src", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const VkDeviceOrHostAddressKHR>(object.dst, settings, "VkDeviceOrHostAddressKHR", "dst", indents + 1, dump_html_VkDeviceOrHostAddressKHR);
    dump_html_value<const VkCopyAccelerationStructureModeKHR>(object.mode, settings, "VkCopyAccelerationStructureModeKHR", "mode", indents + 1, dump_html_VkCopyAccelerationStructureModeKHR);
}
void dump_html_VkCopyMemoryToAccelerationStructureInfoKHR(const VkCopyMemoryToAccelerationStructureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.src, settings, "VkDeviceOrHostAddressConstKHR", "src", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkAccelerationStructureKHR>(object.dst, settings, "VkAccelerationStructureKHR", "dst", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const VkCopyAccelerationStructureModeKHR>(object.mode, settings, "VkCopyAccelerationStructureModeKHR", "mode", indents + 1, dump_html_VkCopyAccelerationStructureModeKHR);
}
void dump_html_VkCopyAccelerationStructureInfoKHR(const VkCopyAccelerationStructureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureKHR>(object.src, settings, "VkAccelerationStructureKHR", "src", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const VkAccelerationStructureKHR>(object.dst, settings, "VkAccelerationStructureKHR", "dst", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const VkCopyAccelerationStructureModeKHR>(object.mode, settings, "VkCopyAccelerationStructureModeKHR", "mode", indents + 1, dump_html_VkCopyAccelerationStructureModeKHR);
}
void dump_html_VkAccelerationStructureBuildSizesInfoKHR(const VkAccelerationStructureBuildSizesInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.accelerationStructureSize, settings, "VkDeviceSize", "accelerationStructureSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.updateScratchSize, settings, "VkDeviceSize", "updateScratchSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.buildScratchSize, settings, "VkDeviceSize", "buildScratchSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPipelineCoverageModulationStateCreateInfoNV(const VkPipelineCoverageModulationStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCoverageModulationStateCreateFlagsNV>(object.flags, settings, "VkPipelineCoverageModulationStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineCoverageModulationStateCreateFlagsNV);
    dump_html_value<const VkCoverageModulationModeNV>(object.coverageModulationMode, settings, "VkCoverageModulationModeNV", "coverageModulationMode", indents + 1, dump_html_VkCoverageModulationModeNV);
    dump_html_value<const VkBool32>(object.coverageModulationTableEnable, settings, "VkBool32", "coverageModulationTableEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.coverageModulationTableCount, settings, "uint32_t", "coverageModulationTableCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.pCoverageModulationTable, object.coverageModulationTableCount, settings, "const float*", "const float", "pCoverageModulationTable", indents + 1, dump_html_float); // ZRT
}
void dump_html_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderSMCount, settings, "uint32_t", "shaderSMCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderWarpsPerSM, settings, "uint32_t", "shaderWarpsPerSM", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSMBuiltins, settings, "VkBool32", "shaderSMBuiltins", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDrmFormatModifierPropertiesEXT(const VkDrmFormatModifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.drmFormatModifierPlaneCount, settings, "uint32_t", "drmFormatModifierPlaneCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormatFeatureFlags>(object.drmFormatModifierTilingFeatures, settings, "VkFormatFeatureFlags", "drmFormatModifierTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
}
void dump_html_VkDrmFormatModifierPropertiesListEXT(const VkDrmFormatModifierPropertiesListEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.drmFormatModifierCount, settings, "uint32_t", "drmFormatModifierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDrmFormatModifierPropertiesEXT>(object.pDrmFormatModifierProperties, object.drmFormatModifierCount, settings, "VkDrmFormatModifierPropertiesEXT*", "VkDrmFormatModifierPropertiesEXT", "pDrmFormatModifierProperties", indents + 1, dump_html_VkDrmFormatModifierPropertiesEXT); // ZRT
}
void dump_html_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(const VkPhysicalDeviceImageDrmFormatModifierInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkSharingMode>(object.sharingMode, settings, "VkSharingMode", "sharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkImageDrmFormatModifierListCreateInfoEXT(const VkImageDrmFormatModifierListCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.drmFormatModifierCount, settings, "uint32_t", "drmFormatModifierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pDrmFormatModifiers, object.drmFormatModifierCount, settings, "const uint64_t*", "const uint64_t", "pDrmFormatModifiers", indents + 1, dump_html_uint64_t); // ZRT
}
void dump_html_VkImageDrmFormatModifierExplicitCreateInfoEXT(const VkImageDrmFormatModifierExplicitCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.drmFormatModifierPlaneCount, settings, "uint32_t", "drmFormatModifierPlaneCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubresourceLayout>(object.pPlaneLayouts, object.drmFormatModifierPlaneCount, settings, "const VkSubresourceLayout*", "const VkSubresourceLayout", "pPlaneLayouts", indents + 1, dump_html_VkSubresourceLayout); // ZRT
}
void dump_html_VkImageDrmFormatModifierPropertiesEXT(const VkImageDrmFormatModifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
}
void dump_html_VkDrmFormatModifierProperties2EXT(const VkDrmFormatModifierProperties2EXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.drmFormatModifierPlaneCount, settings, "uint32_t", "drmFormatModifierPlaneCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormatFeatureFlags2>(object.drmFormatModifierTilingFeatures, settings, "VkFormatFeatureFlags2", "drmFormatModifierTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags2);
}
void dump_html_VkDrmFormatModifierPropertiesList2EXT(const VkDrmFormatModifierPropertiesList2EXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.drmFormatModifierCount, settings, "uint32_t", "drmFormatModifierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDrmFormatModifierProperties2EXT>(object.pDrmFormatModifierProperties, object.drmFormatModifierCount, settings, "VkDrmFormatModifierProperties2EXT*", "VkDrmFormatModifierProperties2EXT", "pDrmFormatModifierProperties", indents + 1, dump_html_VkDrmFormatModifierProperties2EXT); // ZRT
}
void dump_html_VkValidationCacheCreateInfoEXT(const VkValidationCacheCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkValidationCacheCreateFlagsEXT>(object.flags, settings, "VkValidationCacheCreateFlagsEXT", "flags", indents + 1, dump_html_VkValidationCacheCreateFlagsEXT);
    dump_html_value<const size_t>(object.initialDataSize, settings, "size_t", "initialDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pInitialData, settings, "const void*", "pInitialData", indents + 1, dump_html_void);
}
void dump_html_VkShaderModuleValidationCacheCreateInfoEXT(const VkShaderModuleValidationCacheCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkValidationCacheEXT>(object.validationCache, settings, "VkValidationCacheEXT", "validationCache", indents + 1, dump_html_VkValidationCacheEXT);
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPhysicalDevicePortabilitySubsetFeaturesKHR(const VkPhysicalDevicePortabilitySubsetFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.constantAlphaColorBlendFactors, settings, "VkBool32", "constantAlphaColorBlendFactors", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.events, settings, "VkBool32", "events", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.imageViewFormatReinterpretation, settings, "VkBool32", "imageViewFormatReinterpretation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.imageViewFormatSwizzle, settings, "VkBool32", "imageViewFormatSwizzle", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.imageView2DOn3DImage, settings, "VkBool32", "imageView2DOn3DImage", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multisampleArrayImage, settings, "VkBool32", "multisampleArrayImage", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.mutableComparisonSamplers, settings, "VkBool32", "mutableComparisonSamplers", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.pointPolygons, settings, "VkBool32", "pointPolygons", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.samplerMipLodBias, settings, "VkBool32", "samplerMipLodBias", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.separateStencilMaskRef, settings, "VkBool32", "separateStencilMaskRef", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampleRateInterpolationFunctions, settings, "VkBool32", "shaderSampleRateInterpolationFunctions", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.tessellationIsolines, settings, "VkBool32", "tessellationIsolines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.tessellationPointMode, settings, "VkBool32", "tessellationPointMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.triangleFans, settings, "VkBool32", "triangleFans", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vertexAttributeAccessBeyondStride, settings, "VkBool32", "vertexAttributeAccessBeyondStride", indents + 1, dump_html_VkBool32);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPhysicalDevicePortabilitySubsetPropertiesKHR(const VkPhysicalDevicePortabilitySubsetPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minVertexInputBindingStrideAlignment, settings, "uint32_t", "minVertexInputBindingStrideAlignment", indents + 1, dump_html_uint32_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkShadingRatePaletteNV(const VkShadingRatePaletteNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.shadingRatePaletteEntryCount, settings, "uint32_t", "shadingRatePaletteEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkShadingRatePaletteEntryNV>(object.pShadingRatePaletteEntries, object.shadingRatePaletteEntryCount, settings, "const VkShadingRatePaletteEntryNV*", "const VkShadingRatePaletteEntryNV", "pShadingRatePaletteEntries", indents + 1, dump_html_VkShadingRatePaletteEntryNV); // ZRT
}
void dump_html_VkPipelineViewportShadingRateImageStateCreateInfoNV(const VkPipelineViewportShadingRateImageStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shadingRateImageEnable, settings, "VkBool32", "shadingRateImageEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkShadingRatePaletteNV>(object.pShadingRatePalettes, object.viewportCount, settings, "const VkShadingRatePaletteNV*", "const VkShadingRatePaletteNV", "pShadingRatePalettes", indents + 1, dump_html_VkShadingRatePaletteNV); // ZRT
}
void dump_html_VkPhysicalDeviceShadingRateImageFeaturesNV(const VkPhysicalDeviceShadingRateImageFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shadingRateImage, settings, "VkBool32", "shadingRateImage", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shadingRateCoarseSampleOrder, settings, "VkBool32", "shadingRateCoarseSampleOrder", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShadingRateImagePropertiesNV(const VkPhysicalDeviceShadingRateImagePropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.shadingRateTexelSize, settings, "VkExtent2D", "shadingRateTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.shadingRatePaletteSize, settings, "uint32_t", "shadingRatePaletteSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shadingRateMaxCoarseSamples, settings, "uint32_t", "shadingRateMaxCoarseSamples", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCoarseSampleLocationNV(const VkCoarseSampleLocationNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.pixelX, settings, "uint32_t", "pixelX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pixelY, settings, "uint32_t", "pixelY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sample, settings, "uint32_t", "sample", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCoarseSampleOrderCustomNV(const VkCoarseSampleOrderCustomNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkShadingRatePaletteEntryNV>(object.shadingRate, settings, "VkShadingRatePaletteEntryNV", "shadingRate", indents + 1, dump_html_VkShadingRatePaletteEntryNV);
    dump_html_value<const uint32_t>(object.sampleCount, settings, "uint32_t", "sampleCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sampleLocationCount, settings, "uint32_t", "sampleLocationCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCoarseSampleLocationNV>(object.pSampleLocations, object.sampleLocationCount, settings, "const VkCoarseSampleLocationNV*", "const VkCoarseSampleLocationNV", "pSampleLocations", indents + 1, dump_html_VkCoarseSampleLocationNV); // ZRT
}
void dump_html_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCoarseSampleOrderTypeNV>(object.sampleOrderType, settings, "VkCoarseSampleOrderTypeNV", "sampleOrderType", indents + 1, dump_html_VkCoarseSampleOrderTypeNV);
    dump_html_value<const uint32_t>(object.customSampleOrderCount, settings, "uint32_t", "customSampleOrderCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCoarseSampleOrderCustomNV>(object.pCustomSampleOrders, object.customSampleOrderCount, settings, "const VkCoarseSampleOrderCustomNV*", "const VkCoarseSampleOrderCustomNV", "pCustomSampleOrders", indents + 1, dump_html_VkCoarseSampleOrderCustomNV); // ZRT
}
void dump_html_VkRayTracingShaderGroupCreateInfoNV(const VkRayTracingShaderGroupCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRayTracingShaderGroupTypeKHR>(object.type, settings, "VkRayTracingShaderGroupTypeKHR", "type", indents + 1, dump_html_VkRayTracingShaderGroupTypeKHR);
    dump_html_value<const uint32_t>(object.generalShader, settings, "uint32_t", "generalShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.closestHitShader, settings, "uint32_t", "closestHitShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.anyHitShader, settings, "uint32_t", "anyHitShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.intersectionShader, settings, "uint32_t", "intersectionShader", indents + 1, dump_html_uint32_t);
}
void dump_html_VkRayTracingPipelineCreateInfoNV(const VkRayTracingPipelineCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo); // ZRT
    dump_html_value<const uint32_t>(object.groupCount, settings, "uint32_t", "groupCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRayTracingShaderGroupCreateInfoNV>(object.pGroups, object.groupCount, settings, "const VkRayTracingShaderGroupCreateInfoNV*", "const VkRayTracingShaderGroupCreateInfoNV", "pGroups", indents + 1, dump_html_VkRayTracingShaderGroupCreateInfoNV); // ZRT
    dump_html_value<const uint32_t>(object.maxRecursionDepth, settings, "uint32_t", "maxRecursionDepth", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
}
void dump_html_VkGeometryTrianglesNV(const VkGeometryTrianglesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.vertexData, settings, "VkBuffer", "vertexData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.vertexOffset, settings, "VkDeviceSize", "vertexOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.vertexCount, settings, "uint32_t", "vertexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.vertexStride, settings, "VkDeviceSize", "vertexStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkFormat>(object.vertexFormat, settings, "VkFormat", "vertexFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkBuffer>(object.indexData, settings, "VkBuffer", "indexData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.indexOffset, settings, "VkDeviceSize", "indexOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.indexCount, settings, "uint32_t", "indexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
    dump_html_value<const VkBuffer>(object.transformData, settings, "VkBuffer", "transformData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.transformOffset, settings, "VkDeviceSize", "transformOffset", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkGeometryAABBNV(const VkGeometryAABBNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.aabbData, settings, "VkBuffer", "aabbData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const uint32_t>(object.numAABBs, settings, "uint32_t", "numAABBs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stride, settings, "uint32_t", "stride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkGeometryDataNV(const VkGeometryDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkGeometryTrianglesNV>(object.triangles, settings, "VkGeometryTrianglesNV", "triangles", indents + 1, dump_html_VkGeometryTrianglesNV);
    dump_html_value<const VkGeometryAABBNV>(object.aabbs, settings, "VkGeometryAABBNV", "aabbs", indents + 1, dump_html_VkGeometryAABBNV);
}
void dump_html_VkGeometryNV(const VkGeometryNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkGeometryTypeKHR>(object.geometryType, settings, "VkGeometryTypeKHR", "geometryType", indents + 1, dump_html_VkGeometryTypeKHR);
    dump_html_value<const VkGeometryDataNV>(object.geometry, settings, "VkGeometryDataNV", "geometry", indents + 1, dump_html_VkGeometryDataNV);
    dump_html_value<const VkGeometryFlagsKHR>(object.flags, settings, "VkGeometryFlagsKHR", "flags", indents + 1, dump_html_VkGeometryFlagsKHR);
}
void dump_html_VkAccelerationStructureInfoNV(const VkAccelerationStructureInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureTypeNV>(object.type, settings, "VkAccelerationStructureTypeNV", "type", indents + 1, dump_html_VkAccelerationStructureTypeKHR);
    dump_html_value<const VkBuildAccelerationStructureFlagsNV>(object.flags, settings, "VkBuildAccelerationStructureFlagsNV", "flags", indents + 1, dump_html_VkBuildAccelerationStructureFlagsKHR);
    dump_html_value<const uint32_t>(object.instanceCount, settings, "uint32_t", "instanceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.geometryCount, settings, "uint32_t", "geometryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkGeometryNV>(object.pGeometries, object.geometryCount, settings, "const VkGeometryNV*", "const VkGeometryNV", "pGeometries", indents + 1, dump_html_VkGeometryNV); // ZRT
}
void dump_html_VkAccelerationStructureCreateInfoNV(const VkAccelerationStructureCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.compactedSize, settings, "VkDeviceSize", "compactedSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkAccelerationStructureInfoNV>(object.info, settings, "VkAccelerationStructureInfoNV", "info", indents + 1, dump_html_VkAccelerationStructureInfoNV);
}
void dump_html_VkBindAccelerationStructureMemoryInfoNV(const VkBindAccelerationStructureMemoryInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureNV>(object.accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", indents + 1, dump_html_VkAccelerationStructureNV);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.deviceIndexCount, settings, "uint32_t", "deviceIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceIndices, object.deviceIndexCount, settings, "const uint32_t*", "const uint32_t", "pDeviceIndices", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkWriteDescriptorSetAccelerationStructureNV(const VkWriteDescriptorSetAccelerationStructureNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAccelerationStructureNV>(object.pAccelerationStructures, object.accelerationStructureCount, settings, "const VkAccelerationStructureNV*", "const VkAccelerationStructureNV", "pAccelerationStructures", indents + 1, dump_html_VkAccelerationStructureNV); // ZRT
}
void dump_html_VkAccelerationStructureMemoryRequirementsInfoNV(const VkAccelerationStructureMemoryRequirementsInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureMemoryRequirementsTypeNV>(object.type, settings, "VkAccelerationStructureMemoryRequirementsTypeNV", "type", indents + 1, dump_html_VkAccelerationStructureMemoryRequirementsTypeNV);
    dump_html_value<const VkAccelerationStructureNV>(object.accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", indents + 1, dump_html_VkAccelerationStructureNV);
}
void dump_html_VkPhysicalDeviceRayTracingPropertiesNV(const VkPhysicalDeviceRayTracingPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderGroupHandleSize, settings, "uint32_t", "shaderGroupHandleSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxRecursionDepth, settings, "uint32_t", "maxRecursionDepth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxShaderGroupStride, settings, "uint32_t", "maxShaderGroupStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderGroupBaseAlignment, settings, "uint32_t", "shaderGroupBaseAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.maxGeometryCount, settings, "uint64_t", "maxGeometryCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxInstanceCount, settings, "uint64_t", "maxInstanceCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxTriangleCount, settings, "uint64_t", "maxTriangleCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetAccelerationStructures, settings, "uint32_t", "maxDescriptorSetAccelerationStructures", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.representativeFragmentTest, settings, "VkBool32", "representativeFragmentTest", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(const VkPipelineRepresentativeFragmentTestStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.representativeFragmentTestEnable, settings, "VkBool32", "representativeFragmentTestEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageViewImageFormatInfoEXT(const VkPhysicalDeviceImageViewImageFormatInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageViewType>(object.imageViewType, settings, "VkImageViewType", "imageViewType", indents + 1, dump_html_VkImageViewType);
}
void dump_html_VkFilterCubicImageViewImageFormatPropertiesEXT(const VkFilterCubicImageViewImageFormatPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.filterCubic, settings, "VkBool32", "filterCubic", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.filterCubicMinmax, settings, "VkBool32", "filterCubicMinmax", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceQueueGlobalPriorityCreateInfoKHR(const VkDeviceQueueGlobalPriorityCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueueGlobalPriorityKHR>(object.globalPriority, settings, "VkQueueGlobalPriorityKHR", "globalPriority", indents + 1, dump_html_VkQueueGlobalPriorityKHR);
}
void dump_html_VkImportMemoryHostPointerInfoEXT(const VkImportMemoryHostPointerInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const void*>(object.pHostPointer, settings, "void*", "pHostPointer", indents + 1, dump_html_void);
}
void dump_html_VkMemoryHostPointerPropertiesEXT(const VkMemoryHostPointerPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(const VkPhysicalDeviceExternalMemoryHostPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.minImportedHostPointerAlignment, settings, "VkDeviceSize", "minImportedHostPointerAlignment", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPhysicalDeviceShaderClockFeaturesKHR(const VkPhysicalDeviceShaderClockFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSubgroupClock, settings, "VkBool32", "shaderSubgroupClock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDeviceClock, settings, "VkBool32", "shaderDeviceClock", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineCompilerControlCreateInfoAMD(const VkPipelineCompilerControlCreateInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCompilerControlFlagsAMD>(object.compilerControlFlags, settings, "VkPipelineCompilerControlFlagsAMD", "compilerControlFlags", indents + 1, dump_html_VkPipelineCompilerControlFlagsAMD);
}
void dump_html_VkCalibratedTimestampInfoKHR(const VkCalibratedTimestampInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkTimeDomainKHR>(object.timeDomain, settings, "VkTimeDomainKHR", "timeDomain", indents + 1, dump_html_VkTimeDomainKHR);
}
void dump_html_VkPhysicalDeviceShaderCorePropertiesAMD(const VkPhysicalDeviceShaderCorePropertiesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderEngineCount, settings, "uint32_t", "shaderEngineCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderArraysPerEngineCount, settings, "uint32_t", "shaderArraysPerEngineCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.computeUnitsPerShaderArray, settings, "uint32_t", "computeUnitsPerShaderArray", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.simdPerComputeUnit, settings, "uint32_t", "simdPerComputeUnit", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.wavefrontsPerSimd, settings, "uint32_t", "wavefrontsPerSimd", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.wavefrontSize, settings, "uint32_t", "wavefrontSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sgprsPerSimd, settings, "uint32_t", "sgprsPerSimd", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minSgprAllocation, settings, "uint32_t", "minSgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSgprAllocation, settings, "uint32_t", "maxSgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sgprAllocationGranularity, settings, "uint32_t", "sgprAllocationGranularity", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vgprsPerSimd, settings, "uint32_t", "vgprsPerSimd", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minVgprAllocation, settings, "uint32_t", "minVgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVgprAllocation, settings, "uint32_t", "maxVgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vgprAllocationGranularity, settings, "uint32_t", "vgprAllocationGranularity", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoDecodeH265ProfileInfoKHR(const VkVideoDecodeH265ProfileInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoH265ProfileIdc>(object.stdProfileIdc, settings, "StdVideoH265ProfileIdc", "stdProfileIdc", indents + 1, dump_html_StdVideoH265ProfileIdc);
}
void dump_html_VkVideoDecodeH265CapabilitiesKHR(const VkVideoDecodeH265CapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoH265LevelIdc>(object.maxLevelIdc, settings, "StdVideoH265LevelIdc", "maxLevelIdc", indents + 1, dump_html_StdVideoH265LevelIdc);
}
void dump_html_VkVideoDecodeH265SessionParametersAddInfoKHR(const VkVideoDecodeH265SessionParametersAddInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stdVPSCount, settings, "uint32_t", "stdVPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH265VideoParameterSet>(object.pStdVPSs, object.stdVPSCount, settings, "const StdVideoH265VideoParameterSet*", "const StdVideoH265VideoParameterSet", "pStdVPSs", indents + 1, dump_html_StdVideoH265VideoParameterSet); // ZRT
    dump_html_value<const uint32_t>(object.stdSPSCount, settings, "uint32_t", "stdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH265SequenceParameterSet>(object.pStdSPSs, object.stdSPSCount, settings, "const StdVideoH265SequenceParameterSet*", "const StdVideoH265SequenceParameterSet", "pStdSPSs", indents + 1, dump_html_StdVideoH265SequenceParameterSet); // ZRT
    dump_html_value<const uint32_t>(object.stdPPSCount, settings, "uint32_t", "stdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const StdVideoH265PictureParameterSet>(object.pStdPPSs, object.stdPPSCount, settings, "const StdVideoH265PictureParameterSet*", "const StdVideoH265PictureParameterSet", "pStdPPSs", indents + 1, dump_html_StdVideoH265PictureParameterSet); // ZRT
}
void dump_html_VkVideoDecodeH265SessionParametersCreateInfoKHR(const VkVideoDecodeH265SessionParametersCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxStdVPSCount, settings, "uint32_t", "maxStdVPSCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStdSPSCount, settings, "uint32_t", "maxStdSPSCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStdPPSCount, settings, "uint32_t", "maxStdPPSCount", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkVideoDecodeH265SessionParametersAddInfoKHR>(object.pParametersAddInfo, settings, "const VkVideoDecodeH265SessionParametersAddInfoKHR*", "pParametersAddInfo", indents + 1, dump_html_VkVideoDecodeH265SessionParametersAddInfoKHR);
}
void dump_html_VkVideoDecodeH265PictureInfoKHR(const VkVideoDecodeH265PictureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoDecodeH265PictureInfo>(object.pStdPictureInfo, settings, "const StdVideoDecodeH265PictureInfo*", "pStdPictureInfo", indents + 1, dump_html_StdVideoDecodeH265PictureInfo);
    dump_html_value<const uint32_t>(object.sliceSegmentCount, settings, "uint32_t", "sliceSegmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pSliceSegmentOffsets, object.sliceSegmentCount, settings, "const uint32_t*", "const uint32_t", "pSliceSegmentOffsets", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkVideoDecodeH265DpbSlotInfoKHR(const VkVideoDecodeH265DpbSlotInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoDecodeH265ReferenceInfo>(object.pStdReferenceInfo, settings, "const StdVideoDecodeH265ReferenceInfo*", "pStdReferenceInfo", indents + 1, dump_html_StdVideoDecodeH265ReferenceInfo);
}
void dump_html_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.globalPriorityQuery, settings, "VkBool32", "globalPriorityQuery", indents + 1, dump_html_VkBool32);
}
void dump_html_VkQueueFamilyGlobalPriorityPropertiesKHR(const VkQueueFamilyGlobalPriorityPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.priorityCount, settings, "uint32_t", "priorityCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkQueueGlobalPriorityKHR>(object.priorities, object.priorityCount, settings, "VkQueueGlobalPriorityKHR[VK_MAX_GLOBAL_PRIORITY_SIZE_KHR]", "VkQueueGlobalPriorityKHR", "priorities", indents + 1, dump_html_VkQueueGlobalPriorityKHR); // ZRT
}
void dump_html_VkDeviceMemoryOverallocationCreateInfoAMD(const VkDeviceMemoryOverallocationCreateInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryOverallocationBehaviorAMD>(object.overallocationBehavior, settings, "VkMemoryOverallocationBehaviorAMD", "overallocationBehavior", indents + 1, dump_html_VkMemoryOverallocationBehaviorAMD);
}
void dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxVertexAttribDivisor, settings, "uint32_t", "maxVertexAttribDivisor", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVertexInputBindingDivisorDescriptionKHR(const VkVertexInputBindingDivisorDescriptionKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.divisor, settings, "uint32_t", "divisor", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineVertexInputDivisorStateCreateInfoKHR(const VkPipelineVertexInputDivisorStateCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.vertexBindingDivisorCount, settings, "uint32_t", "vertexBindingDivisorCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVertexInputBindingDivisorDescriptionKHR>(object.pVertexBindingDivisors, object.vertexBindingDivisorCount, settings, "const VkVertexInputBindingDivisorDescriptionKHR*", "const VkVertexInputBindingDivisorDescriptionKHR", "pVertexBindingDivisors", indents + 1, dump_html_VkVertexInputBindingDivisorDescriptionKHR); // ZRT
}
void dump_html_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR(const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.vertexAttributeInstanceRateDivisor, settings, "VkBool32", "vertexAttributeInstanceRateDivisor", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vertexAttributeInstanceRateZeroDivisor, settings, "VkBool32", "vertexAttributeInstanceRateZeroDivisor", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_GGP)
void dump_html_VkPresentFrameTokenGGP(const VkPresentFrameTokenGGP& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const GgpFrameToken>(object.frameToken, settings, "GgpFrameToken", "frameToken", indents + 1, dump_html_GgpFrameToken);
}
#endif // VK_USE_PLATFORM_GGP
void dump_html_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.computeDerivativeGroupQuads, settings, "VkBool32", "computeDerivativeGroupQuads", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.computeDerivativeGroupLinear, settings, "VkBool32", "computeDerivativeGroupLinear", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMeshShaderFeaturesNV(const VkPhysicalDeviceMeshShaderFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.taskShader, settings, "VkBool32", "taskShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.meshShader, settings, "VkBool32", "meshShader", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMeshShaderPropertiesNV(const VkPhysicalDeviceMeshShaderPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxDrawMeshTasksCount, settings, "uint32_t", "maxDrawMeshTasksCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskWorkGroupInvocations, settings, "uint32_t", "maxTaskWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxTaskWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxTaskWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxTaskTotalMemorySize, settings, "uint32_t", "maxTaskTotalMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskOutputCount, settings, "uint32_t", "maxTaskOutputCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshWorkGroupInvocations, settings, "uint32_t", "maxMeshWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxMeshWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxMeshWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxMeshTotalMemorySize, settings, "uint32_t", "maxMeshTotalMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputVertices, settings, "uint32_t", "maxMeshOutputVertices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputPrimitives, settings, "uint32_t", "maxMeshOutputPrimitives", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshMultiviewViewCount, settings, "uint32_t", "maxMeshMultiviewViewCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.meshOutputPerVertexGranularity, settings, "uint32_t", "meshOutputPerVertexGranularity", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.meshOutputPerPrimitiveGranularity, settings, "uint32_t", "meshOutputPerPrimitiveGranularity", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDrawMeshTasksIndirectCommandNV(const VkDrawMeshTasksIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.taskCount, settings, "uint32_t", "taskCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstTask, settings, "uint32_t", "firstTask", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentShaderBarycentric, settings, "VkBool32", "fragmentShaderBarycentric", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderImageFootprintFeaturesNV(const VkPhysicalDeviceShaderImageFootprintFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imageFootprint, settings, "VkBool32", "imageFootprint", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineViewportExclusiveScissorStateCreateInfoNV(const VkPipelineViewportExclusiveScissorStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.exclusiveScissorCount, settings, "uint32_t", "exclusiveScissorCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pExclusiveScissors, object.exclusiveScissorCount, settings, "const VkRect2D*", "const VkRect2D", "pExclusiveScissors", indents + 1, dump_html_VkRect2D); // ZRT
}
void dump_html_VkPhysicalDeviceExclusiveScissorFeaturesNV(const VkPhysicalDeviceExclusiveScissorFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.exclusiveScissor, settings, "VkBool32", "exclusiveScissor", indents + 1, dump_html_VkBool32);
}
void dump_html_VkQueueFamilyCheckpointPropertiesNV(const VkQueueFamilyCheckpointPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags>(object.checkpointExecutionStageMask, settings, "VkPipelineStageFlags", "checkpointExecutionStageMask", indents + 1, dump_html_VkPipelineStageFlags);
}
void dump_html_VkCheckpointDataNV(const VkCheckpointDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlagBits>(object.stage, settings, "VkPipelineStageFlagBits", "stage", indents + 1, dump_html_VkPipelineStageFlagBits);
    dump_html_value<const void*>(object.pCheckpointMarker, settings, "void*", "pCheckpointMarker", indents + 1, dump_html_void);
}
void dump_html_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderIntegerFunctions2, settings, "VkBool32", "shaderIntegerFunctions2", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPerformanceValueINTEL(const VkPerformanceValueINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkPerformanceValueTypeINTEL>(object.type, settings, "VkPerformanceValueTypeINTEL", "type", indents + 1, dump_html_VkPerformanceValueTypeINTEL);
    dump_html_value<const VkPerformanceValueDataINTEL>(object.data, settings, "VkPerformanceValueDataINTEL", "data", indents + 1, dump_html_VkPerformanceValueDataINTEL);
}
void dump_html_VkInitializePerformanceApiInfoINTEL(const VkInitializePerformanceApiInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
}
void dump_html_VkQueryPoolPerformanceQueryCreateInfoINTEL(const VkQueryPoolPerformanceQueryCreateInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueryPoolSamplingModeINTEL>(object.performanceCountersSampling, settings, "VkQueryPoolSamplingModeINTEL", "performanceCountersSampling", indents + 1, dump_html_VkQueryPoolSamplingModeINTEL);
}
void dump_html_VkPerformanceMarkerInfoINTEL(const VkPerformanceMarkerInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.marker, settings, "uint64_t", "marker", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPerformanceStreamMarkerInfoINTEL(const VkPerformanceStreamMarkerInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.marker, settings, "uint32_t", "marker", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPerformanceOverrideInfoINTEL(const VkPerformanceOverrideInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPerformanceOverrideTypeINTEL>(object.type, settings, "VkPerformanceOverrideTypeINTEL", "type", indents + 1, dump_html_VkPerformanceOverrideTypeINTEL);
    dump_html_value<const VkBool32>(object.enable, settings, "VkBool32", "enable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint64_t>(object.parameter, settings, "uint64_t", "parameter", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPerformanceConfigurationAcquireInfoINTEL(const VkPerformanceConfigurationAcquireInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPerformanceConfigurationTypeINTEL>(object.type, settings, "VkPerformanceConfigurationTypeINTEL", "type", indents + 1, dump_html_VkPerformanceConfigurationTypeINTEL);
}
void dump_html_VkPhysicalDevicePCIBusInfoPropertiesEXT(const VkPhysicalDevicePCIBusInfoPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.pciDomain, settings, "uint32_t", "pciDomain", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pciBus, settings, "uint32_t", "pciBus", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pciDevice, settings, "uint32_t", "pciDevice", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pciFunction, settings, "uint32_t", "pciFunction", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDisplayNativeHdrSurfaceCapabilitiesAMD(const VkDisplayNativeHdrSurfaceCapabilitiesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.localDimmingSupport, settings, "VkBool32", "localDimmingSupport", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSwapchainDisplayNativeHdrCreateInfoAMD(const VkSwapchainDisplayNativeHdrCreateInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.localDimmingEnable, settings, "VkBool32", "localDimmingEnable", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImagePipeSurfaceCreateInfoFUCHSIA(const VkImagePipeSurfaceCreateInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImagePipeSurfaceCreateFlagsFUCHSIA>(object.flags, settings, "VkImagePipeSurfaceCreateFlagsFUCHSIA", "flags", indents + 1, dump_html_VkImagePipeSurfaceCreateFlagsFUCHSIA);
    dump_html_value<const zx_handle_t>(object.imagePipeHandle, settings, "zx_handle_t", "imagePipeHandle", indents + 1, dump_html_zx_handle_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkMetalSurfaceCreateInfoEXT(const VkMetalSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMetalSurfaceCreateFlagsEXT>(object.flags, settings, "VkMetalSurfaceCreateFlagsEXT", "flags", indents + 1, dump_html_VkMetalSurfaceCreateFlagsEXT);
    dump_html_pointer<const CAMetalLayer>(object.pLayer, settings, "const CAMetalLayer*", "pLayer", indents + 1, dump_html_CAMetalLayer);
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(const VkPhysicalDeviceFragmentDensityMapFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentDensityMap, settings, "VkBool32", "fragmentDensityMap", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentDensityMapDynamic, settings, "VkBool32", "fragmentDensityMapDynamic", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentDensityMapNonSubsampledImages, settings, "VkBool32", "fragmentDensityMapNonSubsampledImages", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(const VkPhysicalDeviceFragmentDensityMapPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.minFragmentDensityTexelSize, settings, "VkExtent2D", "minFragmentDensityTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxFragmentDensityTexelSize, settings, "VkExtent2D", "maxFragmentDensityTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkBool32>(object.fragmentDensityInvocations, settings, "VkBool32", "fragmentDensityInvocations", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderPassFragmentDensityMapCreateInfoEXT(const VkRenderPassFragmentDensityMapCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAttachmentReference>(object.fragmentDensityMapAttachment, settings, "VkAttachmentReference", "fragmentDensityMapAttachment", indents + 1, dump_html_VkAttachmentReference);
}
void dump_html_VkFragmentShadingRateAttachmentInfoKHR(const VkFragmentShadingRateAttachmentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkAttachmentReference2>(object.pFragmentShadingRateAttachment, settings, "const VkAttachmentReference2*", "pFragmentShadingRateAttachment", indents + 1, dump_html_VkAttachmentReference2);
    dump_html_value<const VkExtent2D>(object.shadingRateAttachmentTexelSize, settings, "VkExtent2D", "shadingRateAttachmentTexelSize", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkPipelineFragmentShadingRateStateCreateInfoKHR(const VkPipelineFragmentShadingRateStateCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.fragmentSize, settings, "VkExtent2D", "fragmentSize", indents + 1, dump_html_VkExtent2D);
    dump_html_array<const VkFragmentShadingRateCombinerOpKHR>(object.combinerOps, 2, settings, "VkFragmentShadingRateCombinerOpKHR[2]", "VkFragmentShadingRateCombinerOpKHR", "combinerOps", indents + 1, dump_html_VkFragmentShadingRateCombinerOpKHR); // ZRR
}
void dump_html_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(const VkPhysicalDeviceFragmentShadingRateFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineFragmentShadingRate, settings, "VkBool32", "pipelineFragmentShadingRate", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.primitiveFragmentShadingRate, settings, "VkBool32", "primitiveFragmentShadingRate", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.attachmentFragmentShadingRate, settings, "VkBool32", "attachmentFragmentShadingRate", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(const VkPhysicalDeviceFragmentShadingRatePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.minFragmentShadingRateAttachmentTexelSize, settings, "VkExtent2D", "minFragmentShadingRateAttachmentTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxFragmentShadingRateAttachmentTexelSize, settings, "VkExtent2D", "maxFragmentShadingRateAttachmentTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxFragmentShadingRateAttachmentTexelSizeAspectRatio, settings, "uint32_t", "maxFragmentShadingRateAttachmentTexelSizeAspectRatio", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.primitiveFragmentShadingRateWithMultipleViewports, settings, "VkBool32", "primitiveFragmentShadingRateWithMultipleViewports", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.layeredShadingRateAttachments, settings, "VkBool32", "layeredShadingRateAttachments", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateNonTrivialCombinerOps, settings, "VkBool32", "fragmentShadingRateNonTrivialCombinerOps", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkExtent2D>(object.maxFragmentSize, settings, "VkExtent2D", "maxFragmentSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxFragmentSizeAspectRatio, settings, "uint32_t", "maxFragmentSizeAspectRatio", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentShadingRateCoverageSamples, settings, "uint32_t", "maxFragmentShadingRateCoverageSamples", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlagBits>(object.maxFragmentShadingRateRasterizationSamples, settings, "VkSampleCountFlagBits", "maxFragmentShadingRateRasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkBool32>(object.fragmentShadingRateWithShaderDepthStencilWrites, settings, "VkBool32", "fragmentShadingRateWithShaderDepthStencilWrites", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateWithSampleMask, settings, "VkBool32", "fragmentShadingRateWithSampleMask", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateWithShaderSampleMask, settings, "VkBool32", "fragmentShadingRateWithShaderSampleMask", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateWithConservativeRasterization, settings, "VkBool32", "fragmentShadingRateWithConservativeRasterization", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateWithFragmentShaderInterlock, settings, "VkBool32", "fragmentShadingRateWithFragmentShaderInterlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateWithCustomSampleLocations, settings, "VkBool32", "fragmentShadingRateWithCustomSampleLocations", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShadingRateStrictMultiplyCombiner, settings, "VkBool32", "fragmentShadingRateStrictMultiplyCombiner", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentShadingRateKHR(const VkPhysicalDeviceFragmentShadingRateKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampleCountFlags>(object.sampleCounts, settings, "VkSampleCountFlags", "sampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkExtent2D>(object.fragmentSize, settings, "VkExtent2D", "fragmentSize", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkPhysicalDeviceShaderCoreProperties2AMD(const VkPhysicalDeviceShaderCoreProperties2AMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderCorePropertiesFlagsAMD>(object.shaderCoreFeatures, settings, "VkShaderCorePropertiesFlagsAMD", "shaderCoreFeatures", indents + 1, dump_html_VkShaderCorePropertiesFlagsAMD);
    dump_html_value<const uint32_t>(object.activeComputeUnitCount, settings, "uint32_t", "activeComputeUnitCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceCoherentMemoryFeaturesAMD(const VkPhysicalDeviceCoherentMemoryFeaturesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.deviceCoherentMemory, settings, "VkBool32", "deviceCoherentMemory", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR(const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dynamicRenderingLocalRead, settings, "VkBool32", "dynamicRenderingLocalRead", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderingAttachmentLocationInfoKHR(const VkRenderingAttachmentLocationInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pColorAttachmentLocations, object.colorAttachmentCount, settings, "const uint32_t*", "const uint32_t", "pColorAttachmentLocations", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkRenderingInputAttachmentIndexInfoKHR(const VkRenderingInputAttachmentIndexInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pColorAttachmentInputIndices, object.colorAttachmentCount, settings, "const uint32_t*", "const uint32_t", "pColorAttachmentInputIndices", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_pointer<const uint32_t>(object.pDepthInputAttachmentIndex, settings, "const uint32_t*", "pDepthInputAttachmentIndex", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const uint32_t>(object.pStencilInputAttachmentIndex, settings, "const uint32_t*", "pStencilInputAttachmentIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderImageInt64Atomics, settings, "VkBool32", "shaderImageInt64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseImageInt64Atomics, settings, "VkBool32", "sparseImageInt64Atomics", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderQuadControlFeaturesKHR(const VkPhysicalDeviceShaderQuadControlFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderQuadControl, settings, "VkBool32", "shaderQuadControl", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMemoryBudgetPropertiesEXT(const VkPhysicalDeviceMemoryBudgetPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const VkDeviceSize>(object.heapBudget, ApiDumpInstance::current().getMemoryHeapCount(), settings, "VkDeviceSize[VK_MAX_MEMORY_HEAPS]", "VkDeviceSize", "heapBudget", indents + 1, dump_html_VkDeviceSize); // ZRS
    dump_html_array<const VkDeviceSize>(object.heapUsage, ApiDumpInstance::current().getMemoryHeapCount(), settings, "VkDeviceSize[VK_MAX_MEMORY_HEAPS]", "VkDeviceSize", "heapUsage", indents + 1, dump_html_VkDeviceSize); // ZRS
}
void dump_html_VkPhysicalDeviceMemoryPriorityFeaturesEXT(const VkPhysicalDeviceMemoryPriorityFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.memoryPriority, settings, "VkBool32", "memoryPriority", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMemoryPriorityAllocateInfoEXT(const VkMemoryPriorityAllocateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const float>(object.priority, settings, "float", "priority", indents + 1, dump_html_float);
}
void dump_html_VkSurfaceProtectedCapabilitiesKHR(const VkSurfaceProtectedCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.supportsProtected, settings, "VkBool32", "supportsProtected", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dedicatedAllocationImageAliasing, settings, "VkBool32", "dedicatedAllocationImageAliasing", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.bufferDeviceAddress, settings, "VkBool32", "bufferDeviceAddress", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressCaptureReplay, settings, "VkBool32", "bufferDeviceAddressCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressMultiDevice, settings, "VkBool32", "bufferDeviceAddressMultiDevice", indents + 1, dump_html_VkBool32);
}
void dump_html_VkBufferDeviceAddressCreateInfoEXT(const VkBufferDeviceAddressCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
}
void dump_html_VkValidationFeaturesEXT(const VkValidationFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.enabledValidationFeatureCount, settings, "uint32_t", "enabledValidationFeatureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkValidationFeatureEnableEXT>(object.pEnabledValidationFeatures, object.enabledValidationFeatureCount, settings, "const VkValidationFeatureEnableEXT*", "const VkValidationFeatureEnableEXT", "pEnabledValidationFeatures", indents + 1, dump_html_VkValidationFeatureEnableEXT); // ZRT
    dump_html_value<const uint32_t>(object.disabledValidationFeatureCount, settings, "uint32_t", "disabledValidationFeatureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkValidationFeatureDisableEXT>(object.pDisabledValidationFeatures, object.disabledValidationFeatureCount, settings, "const VkValidationFeatureDisableEXT*", "const VkValidationFeatureDisableEXT", "pDisabledValidationFeatures", indents + 1, dump_html_VkValidationFeatureDisableEXT); // ZRT
}
void dump_html_VkPhysicalDevicePresentWaitFeaturesKHR(const VkPhysicalDevicePresentWaitFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.presentWait, settings, "VkBool32", "presentWait", indents + 1, dump_html_VkBool32);
}
void dump_html_VkCooperativeMatrixPropertiesNV(const VkCooperativeMatrixPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.MSize, settings, "uint32_t", "MSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.NSize, settings, "uint32_t", "NSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.KSize, settings, "uint32_t", "KSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkComponentTypeNV>(object.AType, settings, "VkComponentTypeNV", "AType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkComponentTypeNV>(object.BType, settings, "VkComponentTypeNV", "BType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkComponentTypeNV>(object.CType, settings, "VkComponentTypeNV", "CType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkComponentTypeNV>(object.DType, settings, "VkComponentTypeNV", "DType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkScopeNV>(object.scope, settings, "VkScopeNV", "scope", indents + 1, dump_html_VkScopeKHR);
}
void dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesNV(const VkPhysicalDeviceCooperativeMatrixFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cooperativeMatrix, settings, "VkBool32", "cooperativeMatrix", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.cooperativeMatrixRobustBufferAccess, settings, "VkBool32", "cooperativeMatrixRobustBufferAccess", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesNV(const VkPhysicalDeviceCooperativeMatrixPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.cooperativeMatrixSupportedStages, settings, "VkShaderStageFlags", "cooperativeMatrixSupportedStages", indents + 1, dump_html_VkShaderStageFlags);
}
void dump_html_VkPhysicalDeviceCoverageReductionModeFeaturesNV(const VkPhysicalDeviceCoverageReductionModeFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.coverageReductionMode, settings, "VkBool32", "coverageReductionMode", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineCoverageReductionStateCreateInfoNV(const VkPipelineCoverageReductionStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCoverageReductionStateCreateFlagsNV>(object.flags, settings, "VkPipelineCoverageReductionStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineCoverageReductionStateCreateFlagsNV);
    dump_html_value<const VkCoverageReductionModeNV>(object.coverageReductionMode, settings, "VkCoverageReductionModeNV", "coverageReductionMode", indents + 1, dump_html_VkCoverageReductionModeNV);
}
void dump_html_VkFramebufferMixedSamplesCombinationNV(const VkFramebufferMixedSamplesCombinationNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCoverageReductionModeNV>(object.coverageReductionMode, settings, "VkCoverageReductionModeNV", "coverageReductionMode", indents + 1, dump_html_VkCoverageReductionModeNV);
    dump_html_value<const VkSampleCountFlagBits>(object.rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkSampleCountFlags>(object.depthStencilSamples, settings, "VkSampleCountFlags", "depthStencilSamples", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.colorSamples, settings, "VkSampleCountFlags", "colorSamples", indents + 1, dump_html_VkSampleCountFlags);
}
void dump_html_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentShaderSampleInterlock, settings, "VkBool32", "fragmentShaderSampleInterlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShaderPixelInterlock, settings, "VkBool32", "fragmentShaderPixelInterlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShaderShadingRateInterlock, settings, "VkBool32", "fragmentShaderShadingRateInterlock", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.ycbcrImageArrays, settings, "VkBool32", "ycbcrImageArrays", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceProvokingVertexFeaturesEXT(const VkPhysicalDeviceProvokingVertexFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.provokingVertexLast, settings, "VkBool32", "provokingVertexLast", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackPreservesProvokingVertex, settings, "VkBool32", "transformFeedbackPreservesProvokingVertex", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceProvokingVertexPropertiesEXT(const VkPhysicalDeviceProvokingVertexPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.provokingVertexModePerPipeline, settings, "VkBool32", "provokingVertexModePerPipeline", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackPreservesTriangleFanProvokingVertex, settings, "VkBool32", "transformFeedbackPreservesTriangleFanProvokingVertex", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkProvokingVertexModeEXT>(object.provokingVertexMode, settings, "VkProvokingVertexModeEXT", "provokingVertexMode", indents + 1, dump_html_VkProvokingVertexModeEXT);
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkSurfaceFullScreenExclusiveInfoEXT(const VkSurfaceFullScreenExclusiveInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFullScreenExclusiveEXT>(object.fullScreenExclusive, settings, "VkFullScreenExclusiveEXT", "fullScreenExclusive", indents + 1, dump_html_VkFullScreenExclusiveEXT);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkSurfaceCapabilitiesFullScreenExclusiveEXT(const VkSurfaceCapabilitiesFullScreenExclusiveEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fullScreenExclusiveSupported, settings, "VkBool32", "fullScreenExclusiveSupported", indents + 1, dump_html_VkBool32);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_VkSurfaceFullScreenExclusiveWin32InfoEXT(const VkSurfaceFullScreenExclusiveWin32InfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const HMONITOR>(object.hmonitor, settings, "HMONITOR", "hmonitor", indents + 1, dump_html_HMONITOR);
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_VkHeadlessSurfaceCreateInfoEXT(const VkHeadlessSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkHeadlessSurfaceCreateFlagsEXT>(object.flags, settings, "VkHeadlessSurfaceCreateFlagsEXT", "flags", indents + 1, dump_html_VkHeadlessSurfaceCreateFlagsEXT);
}
void dump_html_VkPhysicalDeviceLineRasterizationFeaturesKHR(const VkPhysicalDeviceLineRasterizationFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rectangularLines, settings, "VkBool32", "rectangularLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bresenhamLines, settings, "VkBool32", "bresenhamLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.smoothLines, settings, "VkBool32", "smoothLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stippledRectangularLines, settings, "VkBool32", "stippledRectangularLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stippledBresenhamLines, settings, "VkBool32", "stippledBresenhamLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stippledSmoothLines, settings, "VkBool32", "stippledSmoothLines", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceLineRasterizationPropertiesKHR(const VkPhysicalDeviceLineRasterizationPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.lineSubPixelPrecisionBits, settings, "uint32_t", "lineSubPixelPrecisionBits", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineRasterizationLineStateCreateInfoKHR(const VkPipelineRasterizationLineStateCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkLineRasterizationModeKHR>(object.lineRasterizationMode, settings, "VkLineRasterizationModeKHR", "lineRasterizationMode", indents + 1, dump_html_VkLineRasterizationModeKHR);
    dump_html_value<const VkBool32>(object.stippledLineEnable, settings, "VkBool32", "stippledLineEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.lineStippleFactor, settings, "uint32_t", "lineStippleFactor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint16_t>(object.lineStipplePattern, settings, "uint16_t", "lineStipplePattern", indents + 1, dump_html_uint16_t);
}
void dump_html_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderBufferFloat32Atomics, settings, "VkBool32", "shaderBufferFloat32Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat32AtomicAdd, settings, "VkBool32", "shaderBufferFloat32AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat64Atomics, settings, "VkBool32", "shaderBufferFloat64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat64AtomicAdd, settings, "VkBool32", "shaderBufferFloat64AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat32Atomics, settings, "VkBool32", "shaderSharedFloat32Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat32AtomicAdd, settings, "VkBool32", "shaderSharedFloat32AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat64Atomics, settings, "VkBool32", "shaderSharedFloat64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat64AtomicAdd, settings, "VkBool32", "shaderSharedFloat64AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderImageFloat32Atomics, settings, "VkBool32", "shaderImageFloat32Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderImageFloat32AtomicAdd, settings, "VkBool32", "shaderImageFloat32AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseImageFloat32Atomics, settings, "VkBool32", "sparseImageFloat32Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseImageFloat32AtomicAdd, settings, "VkBool32", "sparseImageFloat32AtomicAdd", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceIndexTypeUint8FeaturesKHR(const VkPhysicalDeviceIndexTypeUint8FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.indexTypeUint8, settings, "VkBool32", "indexTypeUint8", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.extendedDynamicState, settings, "VkBool32", "extendedDynamicState", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineExecutableInfo, settings, "VkBool32", "pipelineExecutableInfo", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineInfoKHR(const VkPipelineInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
}
void dump_html_VkPipelineExecutablePropertiesKHR(const VkPipelineExecutablePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.stages, settings, "VkShaderStageFlags", "stages", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.subgroupSize, settings, "uint32_t", "subgroupSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineExecutableInfoKHR(const VkPipelineExecutableInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
    dump_html_value<const uint32_t>(object.executableIndex, settings, "uint32_t", "executableIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPipelineExecutableStatisticKHR(const VkPipelineExecutableStatisticKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const VkPipelineExecutableStatisticFormatKHR>(object.format, settings, "VkPipelineExecutableStatisticFormatKHR", "format", indents + 1, dump_html_VkPipelineExecutableStatisticFormatKHR);
    dump_html_value<const VkPipelineExecutableStatisticValueKHR>(object.value, settings, "VkPipelineExecutableStatisticValueKHR", "value", indents + 1, dump_html_VkPipelineExecutableStatisticValueKHR);
}
void dump_html_VkPipelineExecutableInternalRepresentationKHR(const VkPipelineExecutableInternalRepresentationKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const VkBool32>(object.isText, settings, "VkBool32", "isText", indents + 1, dump_html_VkBool32);
    dump_html_value<const size_t>(object.dataSize, settings, "size_t", "dataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pData, settings, "void*", "pData", indents + 1, dump_html_void);
}
void dump_html_VkPhysicalDeviceHostImageCopyFeaturesEXT(const VkPhysicalDeviceHostImageCopyFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hostImageCopy, settings, "VkBool32", "hostImageCopy", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceHostImageCopyPropertiesEXT(const VkPhysicalDeviceHostImageCopyPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.copySrcLayoutCount, settings, "uint32_t", "copySrcLayoutCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageLayout>(object.pCopySrcLayouts, object.copySrcLayoutCount, settings, "VkImageLayout*", "VkImageLayout", "pCopySrcLayouts", indents + 1, dump_html_VkImageLayout); // ZRT
    dump_html_value<const uint32_t>(object.copyDstLayoutCount, settings, "uint32_t", "copyDstLayoutCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageLayout>(object.pCopyDstLayouts, object.copyDstLayoutCount, settings, "VkImageLayout*", "VkImageLayout", "pCopyDstLayouts", indents + 1, dump_html_VkImageLayout); // ZRT
    dump_html_array<const uint8_t>(object.optimalTilingLayoutUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "optimalTilingLayoutUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_value<const VkBool32>(object.identicalMemoryTypeRequirements, settings, "VkBool32", "identicalMemoryTypeRequirements", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMemoryToImageCopyEXT(const VkMemoryToImageCopyEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.pHostPointer, settings, "const void*", "pHostPointer", indents + 1, dump_html_void);
    dump_html_value<const uint32_t>(object.memoryRowLength, settings, "uint32_t", "memoryRowLength", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.memoryImageHeight, settings, "uint32_t", "memoryImageHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageSubresourceLayers>(object.imageSubresource, settings, "VkImageSubresourceLayers", "imageSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.imageOffset, settings, "VkOffset3D", "imageOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.imageExtent, settings, "VkExtent3D", "imageExtent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkImageToMemoryCopyEXT(const VkImageToMemoryCopyEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.pHostPointer, settings, "void*", "pHostPointer", indents + 1, dump_html_void);
    dump_html_value<const uint32_t>(object.memoryRowLength, settings, "uint32_t", "memoryRowLength", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.memoryImageHeight, settings, "uint32_t", "memoryImageHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageSubresourceLayers>(object.imageSubresource, settings, "VkImageSubresourceLayers", "imageSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.imageOffset, settings, "VkOffset3D", "imageOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.imageExtent, settings, "VkExtent3D", "imageExtent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkCopyMemoryToImageInfoEXT(const VkCopyMemoryToImageInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkHostImageCopyFlagsEXT>(object.flags, settings, "VkHostImageCopyFlagsEXT", "flags", indents + 1, dump_html_VkHostImageCopyFlagsEXT);
    dump_html_value<const VkImage>(object.dstImage, settings, "VkImage", "dstImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.dstImageLayout, settings, "VkImageLayout", "dstImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMemoryToImageCopyEXT>(object.pRegions, object.regionCount, settings, "const VkMemoryToImageCopyEXT*", "const VkMemoryToImageCopyEXT", "pRegions", indents + 1, dump_html_VkMemoryToImageCopyEXT); // ZRT
}
void dump_html_VkCopyImageToMemoryInfoEXT(const VkCopyImageToMemoryInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkHostImageCopyFlagsEXT>(object.flags, settings, "VkHostImageCopyFlagsEXT", "flags", indents + 1, dump_html_VkHostImageCopyFlagsEXT);
    dump_html_value<const VkImage>(object.srcImage, settings, "VkImage", "srcImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.srcImageLayout, settings, "VkImageLayout", "srcImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageToMemoryCopyEXT>(object.pRegions, object.regionCount, settings, "const VkImageToMemoryCopyEXT*", "const VkImageToMemoryCopyEXT", "pRegions", indents + 1, dump_html_VkImageToMemoryCopyEXT); // ZRT
}
void dump_html_VkCopyImageToImageInfoEXT(const VkCopyImageToImageInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkHostImageCopyFlagsEXT>(object.flags, settings, "VkHostImageCopyFlagsEXT", "flags", indents + 1, dump_html_VkHostImageCopyFlagsEXT);
    dump_html_value<const VkImage>(object.srcImage, settings, "VkImage", "srcImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.srcImageLayout, settings, "VkImageLayout", "srcImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImage>(object.dstImage, settings, "VkImage", "dstImage", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.dstImageLayout, settings, "VkImageLayout", "dstImageLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageCopy2>(object.pRegions, object.regionCount, settings, "const VkImageCopy2*", "const VkImageCopy2", "pRegions", indents + 1, dump_html_VkImageCopy2); // ZRT
}
void dump_html_VkHostImageLayoutTransitionInfoEXT(const VkHostImageLayoutTransitionInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageLayout>(object.oldLayout, settings, "VkImageLayout", "oldLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.newLayout, settings, "VkImageLayout", "newLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageSubresourceRange>(object.subresourceRange, settings, "VkImageSubresourceRange", "subresourceRange", indents + 1, dump_html_VkImageSubresourceRange);
}
void dump_html_VkSubresourceHostMemcpySizeEXT(const VkSubresourceHostMemcpySizeEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkHostImageCopyDevicePerformanceQueryEXT(const VkHostImageCopyDevicePerformanceQueryEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.optimalDeviceAccess, settings, "VkBool32", "optimalDeviceAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.identicalMemoryLayout, settings, "VkBool32", "identicalMemoryLayout", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSubresourceLayout2KHR(const VkSubresourceLayout2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSubresourceLayout>(object.subresourceLayout, settings, "VkSubresourceLayout", "subresourceLayout", indents + 1, dump_html_VkSubresourceLayout);
}
void dump_html_VkImageSubresource2KHR(const VkImageSubresource2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageSubresource>(object.imageSubresource, settings, "VkImageSubresource", "imageSubresource", indents + 1, dump_html_VkImageSubresource);
}
void dump_html_VkMemoryMapInfoKHR(const VkMemoryMapInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryMapFlags>(object.flags, settings, "VkMemoryMapFlags", "flags", indents + 1, dump_html_VkMemoryMapFlags);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkMemoryUnmapInfoKHR(const VkMemoryUnmapInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryUnmapFlagsKHR>(object.flags, settings, "VkMemoryUnmapFlagsKHR", "flags", indents + 1, dump_html_VkMemoryUnmapFlagsKHR);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
}
void dump_html_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.memoryMapPlaced, settings, "VkBool32", "memoryMapPlaced", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.memoryMapRangePlaced, settings, "VkBool32", "memoryMapRangePlaced", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.memoryUnmapReserve, settings, "VkBool32", "memoryUnmapReserve", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.minPlacedMemoryMapAlignment, settings, "VkDeviceSize", "minPlacedMemoryMapAlignment", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkMemoryMapPlacedInfoEXT(const VkMemoryMapPlacedInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.pPlacedAddress, settings, "void*", "pPlacedAddress", indents + 1, dump_html_void);
}
void dump_html_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderBufferFloat16Atomics, settings, "VkBool32", "shaderBufferFloat16Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat16AtomicAdd, settings, "VkBool32", "shaderBufferFloat16AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat16AtomicMinMax, settings, "VkBool32", "shaderBufferFloat16AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat32AtomicMinMax, settings, "VkBool32", "shaderBufferFloat32AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderBufferFloat64AtomicMinMax, settings, "VkBool32", "shaderBufferFloat64AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat16Atomics, settings, "VkBool32", "shaderSharedFloat16Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat16AtomicAdd, settings, "VkBool32", "shaderSharedFloat16AtomicAdd", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat16AtomicMinMax, settings, "VkBool32", "shaderSharedFloat16AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat32AtomicMinMax, settings, "VkBool32", "shaderSharedFloat32AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedFloat64AtomicMinMax, settings, "VkBool32", "shaderSharedFloat64AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderImageFloat32AtomicMinMax, settings, "VkBool32", "shaderImageFloat32AtomicMinMax", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseImageFloat32AtomicMinMax, settings, "VkBool32", "sparseImageFloat32AtomicMinMax", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSurfacePresentModeEXT(const VkSurfacePresentModeEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPresentModeKHR>(object.presentMode, settings, "VkPresentModeKHR", "presentMode", indents + 1, dump_html_VkPresentModeKHR);
}
void dump_html_VkSurfacePresentScalingCapabilitiesEXT(const VkSurfacePresentScalingCapabilitiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPresentScalingFlagsEXT>(object.supportedPresentScaling, settings, "VkPresentScalingFlagsEXT", "supportedPresentScaling", indents + 1, dump_html_VkPresentScalingFlagsEXT);
    dump_html_value<const VkPresentGravityFlagsEXT>(object.supportedPresentGravityX, settings, "VkPresentGravityFlagsEXT", "supportedPresentGravityX", indents + 1, dump_html_VkPresentGravityFlagsEXT);
    dump_html_value<const VkPresentGravityFlagsEXT>(object.supportedPresentGravityY, settings, "VkPresentGravityFlagsEXT", "supportedPresentGravityY", indents + 1, dump_html_VkPresentGravityFlagsEXT);
    dump_html_value<const VkExtent2D>(object.minScaledImageExtent, settings, "VkExtent2D", "minScaledImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxScaledImageExtent, settings, "VkExtent2D", "maxScaledImageExtent", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkSurfacePresentModeCompatibilityEXT(const VkSurfacePresentModeCompatibilityEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.presentModeCount, settings, "uint32_t", "presentModeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentModeKHR>(object.pPresentModes, object.presentModeCount, settings, "VkPresentModeKHR*", "VkPresentModeKHR", "pPresentModes", indents + 1, dump_html_VkPresentModeKHR); // ZRT
}
void dump_html_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.swapchainMaintenance1, settings, "VkBool32", "swapchainMaintenance1", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSwapchainPresentFenceInfoEXT(const VkSwapchainPresentFenceInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFence>(object.pFences, object.swapchainCount, settings, "const VkFence*", "const VkFence", "pFences", indents + 1, dump_html_VkFence); // ZRT
}
void dump_html_VkSwapchainPresentModesCreateInfoEXT(const VkSwapchainPresentModesCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.presentModeCount, settings, "uint32_t", "presentModeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentModeKHR>(object.pPresentModes, object.presentModeCount, settings, "const VkPresentModeKHR*", "const VkPresentModeKHR", "pPresentModes", indents + 1, dump_html_VkPresentModeKHR); // ZRT
}
void dump_html_VkSwapchainPresentModeInfoEXT(const VkSwapchainPresentModeInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentModeKHR>(object.pPresentModes, object.swapchainCount, settings, "const VkPresentModeKHR*", "const VkPresentModeKHR", "pPresentModes", indents + 1, dump_html_VkPresentModeKHR); // ZRT
}
void dump_html_VkSwapchainPresentScalingCreateInfoEXT(const VkSwapchainPresentScalingCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPresentScalingFlagsEXT>(object.scalingBehavior, settings, "VkPresentScalingFlagsEXT", "scalingBehavior", indents + 1, dump_html_VkPresentScalingFlagsEXT);
    dump_html_value<const VkPresentGravityFlagsEXT>(object.presentGravityX, settings, "VkPresentGravityFlagsEXT", "presentGravityX", indents + 1, dump_html_VkPresentGravityFlagsEXT);
    dump_html_value<const VkPresentGravityFlagsEXT>(object.presentGravityY, settings, "VkPresentGravityFlagsEXT", "presentGravityY", indents + 1, dump_html_VkPresentGravityFlagsEXT);
}
void dump_html_VkReleaseSwapchainImagesInfoEXT(const VkReleaseSwapchainImagesInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
    dump_html_value<const uint32_t>(object.imageIndexCount, settings, "uint32_t", "imageIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pImageIndices, object.imageIndexCount, settings, "const uint32_t*", "const uint32_t", "pImageIndices", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxGraphicsShaderGroupCount, settings, "uint32_t", "maxGraphicsShaderGroupCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxIndirectSequenceCount, settings, "uint32_t", "maxIndirectSequenceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxIndirectCommandsTokenCount, settings, "uint32_t", "maxIndirectCommandsTokenCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxIndirectCommandsStreamCount, settings, "uint32_t", "maxIndirectCommandsStreamCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxIndirectCommandsTokenOffset, settings, "uint32_t", "maxIndirectCommandsTokenOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxIndirectCommandsStreamStride, settings, "uint32_t", "maxIndirectCommandsStreamStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minSequencesCountBufferOffsetAlignment, settings, "uint32_t", "minSequencesCountBufferOffsetAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minSequencesIndexBufferOffsetAlignment, settings, "uint32_t", "minSequencesIndexBufferOffsetAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minIndirectCommandsBufferOffsetAlignment, settings, "uint32_t", "minIndirectCommandsBufferOffsetAlignment", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.deviceGeneratedCommands, settings, "VkBool32", "deviceGeneratedCommands", indents + 1, dump_html_VkBool32);
}
void dump_html_VkGraphicsShaderGroupCreateInfoNV(const VkGraphicsShaderGroupCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo); // ZRT
    dump_html_pointer<const VkPipelineVertexInputStateCreateInfo>(object.pVertexInputState, settings, "const VkPipelineVertexInputStateCreateInfo*", "pVertexInputState", indents + 1, dump_html_VkPipelineVertexInputStateCreateInfo);
    dump_html_pointer<const VkPipelineTessellationStateCreateInfo>(object.pTessellationState, settings, "const VkPipelineTessellationStateCreateInfo*", "pTessellationState", indents + 1, dump_html_VkPipelineTessellationStateCreateInfo);
}
void dump_html_VkGraphicsPipelineShaderGroupsCreateInfoNV(const VkGraphicsPipelineShaderGroupsCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.groupCount, settings, "uint32_t", "groupCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkGraphicsShaderGroupCreateInfoNV>(object.pGroups, object.groupCount, settings, "const VkGraphicsShaderGroupCreateInfoNV*", "const VkGraphicsShaderGroupCreateInfoNV", "pGroups", indents + 1, dump_html_VkGraphicsShaderGroupCreateInfoNV); // ZRT
    dump_html_value<const uint32_t>(object.pipelineCount, settings, "uint32_t", "pipelineCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipeline>(object.pPipelines, object.pipelineCount, settings, "const VkPipeline*", "const VkPipeline", "pPipelines", indents + 1, dump_html_VkPipeline); // ZRT
}
void dump_html_VkBindShaderGroupIndirectCommandNV(const VkBindShaderGroupIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.groupIndex, settings, "uint32_t", "groupIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkBindIndexBufferIndirectCommandNV(const VkBindIndexBufferIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.bufferAddress, settings, "VkDeviceAddress", "bufferAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const uint32_t>(object.size, settings, "uint32_t", "size", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
}
void dump_html_VkBindVertexBufferIndirectCommandNV(const VkBindVertexBufferIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.bufferAddress, settings, "VkDeviceAddress", "bufferAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const uint32_t>(object.size, settings, "uint32_t", "size", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stride, settings, "uint32_t", "stride", indents + 1, dump_html_uint32_t);
}
void dump_html_VkSetStateFlagsIndirectCommandNV(const VkSetStateFlagsIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.data, settings, "uint32_t", "data", indents + 1, dump_html_uint32_t);
}
void dump_html_VkIndirectCommandsStreamNV(const VkIndirectCommandsStreamNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkIndirectCommandsLayoutTokenNV(const VkIndirectCommandsLayoutTokenNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkIndirectCommandsTokenTypeNV>(object.tokenType, settings, "VkIndirectCommandsTokenTypeNV", "tokenType", indents + 1, dump_html_VkIndirectCommandsTokenTypeNV);
    dump_html_value<const uint32_t>(object.stream, settings, "uint32_t", "stream", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vertexBindingUnit, settings, "uint32_t", "vertexBindingUnit", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.vertexDynamicStride, settings, "VkBool32", "vertexDynamicStride", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkPipelineLayout>(object.pushconstantPipelineLayout, settings, "VkPipelineLayout", "pushconstantPipelineLayout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkShaderStageFlags>(object.pushconstantShaderStageFlags, settings, "VkShaderStageFlags", "pushconstantShaderStageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const uint32_t>(object.pushconstantOffset, settings, "uint32_t", "pushconstantOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pushconstantSize, settings, "uint32_t", "pushconstantSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkIndirectStateFlagsNV>(object.indirectStateFlags, settings, "VkIndirectStateFlagsNV", "indirectStateFlags", indents + 1, dump_html_VkIndirectStateFlagsNV);
    dump_html_value<const uint32_t>(object.indexTypeCount, settings, "uint32_t", "indexTypeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkIndexType>(object.pIndexTypes, object.indexTypeCount, settings, "const VkIndexType*", "const VkIndexType", "pIndexTypes", indents + 1, dump_html_VkIndexType); // ZRT
    dump_html_array<const uint32_t>(object.pIndexTypeValues, object.indexTypeCount, settings, "const uint32_t*", "const uint32_t", "pIndexTypeValues", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkIndirectCommandsLayoutCreateInfoNV(const VkIndirectCommandsLayoutCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkIndirectCommandsLayoutUsageFlagsNV>(object.flags, settings, "VkIndirectCommandsLayoutUsageFlagsNV", "flags", indents + 1, dump_html_VkIndirectCommandsLayoutUsageFlagsNV);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const uint32_t>(object.tokenCount, settings, "uint32_t", "tokenCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkIndirectCommandsLayoutTokenNV>(object.pTokens, object.tokenCount, settings, "const VkIndirectCommandsLayoutTokenNV*", "const VkIndirectCommandsLayoutTokenNV", "pTokens", indents + 1, dump_html_VkIndirectCommandsLayoutTokenNV); // ZRT
    dump_html_value<const uint32_t>(object.streamCount, settings, "uint32_t", "streamCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pStreamStrides, object.streamCount, settings, "const uint32_t*", "const uint32_t", "pStreamStrides", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkGeneratedCommandsInfoNV(const VkGeneratedCommandsInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
    dump_html_value<const VkIndirectCommandsLayoutNV>(object.indirectCommandsLayout, settings, "VkIndirectCommandsLayoutNV", "indirectCommandsLayout", indents + 1, dump_html_VkIndirectCommandsLayoutNV);
    dump_html_value<const uint32_t>(object.streamCount, settings, "uint32_t", "streamCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkIndirectCommandsStreamNV>(object.pStreams, object.streamCount, settings, "const VkIndirectCommandsStreamNV*", "const VkIndirectCommandsStreamNV", "pStreams", indents + 1, dump_html_VkIndirectCommandsStreamNV); // ZRT
    dump_html_value<const uint32_t>(object.sequencesCount, settings, "uint32_t", "sequencesCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBuffer>(object.preprocessBuffer, settings, "VkBuffer", "preprocessBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.preprocessOffset, settings, "VkDeviceSize", "preprocessOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.preprocessSize, settings, "VkDeviceSize", "preprocessSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBuffer>(object.sequencesCountBuffer, settings, "VkBuffer", "sequencesCountBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.sequencesCountOffset, settings, "VkDeviceSize", "sequencesCountOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBuffer>(object.sequencesIndexBuffer, settings, "VkBuffer", "sequencesIndexBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.sequencesIndexOffset, settings, "VkDeviceSize", "sequencesIndexOffset", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkGeneratedCommandsMemoryRequirementsInfoNV(const VkGeneratedCommandsMemoryRequirementsInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
    dump_html_value<const VkIndirectCommandsLayoutNV>(object.indirectCommandsLayout, settings, "VkIndirectCommandsLayoutNV", "indirectCommandsLayout", indents + 1, dump_html_VkIndirectCommandsLayoutNV);
    dump_html_value<const uint32_t>(object.maxSequencesCount, settings, "uint32_t", "maxSequencesCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(const VkPhysicalDeviceInheritedViewportScissorFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.inheritedViewportScissor2D, settings, "VkBool32", "inheritedViewportScissor2D", indents + 1, dump_html_VkBool32);
}
void dump_html_VkCommandBufferInheritanceViewportScissorInfoNV(const VkCommandBufferInheritanceViewportScissorInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.viewportScissor2D, settings, "VkBool32", "viewportScissor2D", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.viewportDepthCount, settings, "uint32_t", "viewportDepthCount", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkViewport>(object.pViewportDepths, settings, "const VkViewport*", "pViewportDepths", indents + 1, dump_html_VkViewport);
}
void dump_html_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.texelBufferAlignment, settings, "VkBool32", "texelBufferAlignment", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderPassTransformBeginInfoQCOM(const VkRenderPassTransformBeginInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.transform, settings, "VkSurfaceTransformFlagBitsKHR", "transform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
}
void dump_html_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(const VkCommandBufferInheritanceRenderPassTransformInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.transform, settings, "VkSurfaceTransformFlagBitsKHR", "transform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkRect2D>(object.renderArea, settings, "VkRect2D", "renderArea", indents + 1, dump_html_VkRect2D);
}
void dump_html_VkPhysicalDeviceDepthBiasControlFeaturesEXT(const VkPhysicalDeviceDepthBiasControlFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.depthBiasControl, settings, "VkBool32", "depthBiasControl", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.leastRepresentableValueForceUnormRepresentation, settings, "VkBool32", "leastRepresentableValueForceUnormRepresentation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.floatRepresentation, settings, "VkBool32", "floatRepresentation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthBiasExact, settings, "VkBool32", "depthBiasExact", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDepthBiasInfoEXT(const VkDepthBiasInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const float>(object.depthBiasConstantFactor, settings, "float", "depthBiasConstantFactor", indents + 1, dump_html_float);
    dump_html_value<const float>(object.depthBiasClamp, settings, "float", "depthBiasClamp", indents + 1, dump_html_float);
    dump_html_value<const float>(object.depthBiasSlopeFactor, settings, "float", "depthBiasSlopeFactor", indents + 1, dump_html_float);
}
void dump_html_VkDepthBiasRepresentationInfoEXT(const VkDepthBiasRepresentationInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDepthBiasRepresentationEXT>(object.depthBiasRepresentation, settings, "VkDepthBiasRepresentationEXT", "depthBiasRepresentation", indents + 1, dump_html_VkDepthBiasRepresentationEXT);
    dump_html_value<const VkBool32>(object.depthBiasExact, settings, "VkBool32", "depthBiasExact", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.deviceMemoryReport, settings, "VkBool32", "deviceMemoryReport", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceMemoryReportCallbackDataEXT(const VkDeviceMemoryReportCallbackDataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemoryReportFlagsEXT>(object.flags, settings, "VkDeviceMemoryReportFlagsEXT", "flags", indents + 1, dump_html_VkDeviceMemoryReportFlagsEXT);
    dump_html_value<const VkDeviceMemoryReportEventTypeEXT>(object.type, settings, "VkDeviceMemoryReportEventTypeEXT", "type", indents + 1, dump_html_VkDeviceMemoryReportEventTypeEXT);
    dump_html_value<const uint64_t>(object.memoryObjectId, settings, "uint64_t", "memoryObjectId", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkObjectType>(object.objectType, settings, "VkObjectType", "objectType", indents + 1, dump_html_VkObjectType);
    dump_html_value<const uint64_t>(object.objectHandle, settings, "uint64_t", "objectHandle", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.heapIndex, settings, "uint32_t", "heapIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDeviceDeviceMemoryReportCreateInfoEXT(const VkDeviceDeviceMemoryReportCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemoryReportFlagsEXT>(object.flags, settings, "VkDeviceMemoryReportFlagsEXT", "flags", indents + 1, dump_html_VkDeviceMemoryReportFlagsEXT);
    dump_html_value<const PFN_vkDeviceMemoryReportCallbackEXT>(object.pfnUserCallback, settings, "PFN_vkDeviceMemoryReportCallbackEXT", "pfnUserCallback", indents + 1, dump_html_PFN_vkDeviceMemoryReportCallbackEXT);
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
}
void dump_html_VkPhysicalDeviceRobustness2FeaturesEXT(const VkPhysicalDeviceRobustness2FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.robustBufferAccess2, settings, "VkBool32", "robustBufferAccess2", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.robustImageAccess2, settings, "VkBool32", "robustImageAccess2", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.nullDescriptor, settings, "VkBool32", "nullDescriptor", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRobustness2PropertiesEXT(const VkPhysicalDeviceRobustness2PropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.robustStorageBufferAccessSizeAlignment, settings, "VkDeviceSize", "robustStorageBufferAccessSizeAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.robustUniformBufferAccessSizeAlignment, settings, "VkDeviceSize", "robustUniformBufferAccessSizeAlignment", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkSamplerCustomBorderColorCreateInfoEXT(const VkSamplerCustomBorderColorCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkClearColorValue>(object.customBorderColor, settings, "VkClearColorValue", "customBorderColor", indents + 1, dump_html_VkClearColorValue);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
}
void dump_html_VkPhysicalDeviceCustomBorderColorPropertiesEXT(const VkPhysicalDeviceCustomBorderColorPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxCustomBorderColorSamplers, settings, "uint32_t", "maxCustomBorderColorSamplers", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceCustomBorderColorFeaturesEXT(const VkPhysicalDeviceCustomBorderColorFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.customBorderColors, settings, "VkBool32", "customBorderColors", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.customBorderColorWithoutFormat, settings, "VkBool32", "customBorderColorWithoutFormat", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePresentBarrierFeaturesNV(const VkPhysicalDevicePresentBarrierFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.presentBarrier, settings, "VkBool32", "presentBarrier", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSurfaceCapabilitiesPresentBarrierNV(const VkSurfaceCapabilitiesPresentBarrierNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.presentBarrierSupported, settings, "VkBool32", "presentBarrierSupported", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSwapchainPresentBarrierCreateInfoNV(const VkSwapchainPresentBarrierCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.presentBarrierEnable, settings, "VkBool32", "presentBarrierEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPresentIdKHR(const VkPresentIdKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pPresentIds, object.swapchainCount, settings, "const uint64_t*", "const uint64_t", "pPresentIds", indents + 1, dump_html_uint64_t); // ZRT
}
void dump_html_VkPhysicalDevicePresentIdFeaturesKHR(const VkPhysicalDevicePresentIdFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.presentId, settings, "VkBool32", "presentId", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoEncodeInfoKHR(const VkVideoEncodeInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeFlagsKHR>(object.flags, settings, "VkVideoEncodeFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeFlagsKHR);
    dump_html_value<const VkBuffer>(object.dstBuffer, settings, "VkBuffer", "dstBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.dstBufferOffset, settings, "VkDeviceSize", "dstBufferOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.dstBufferRange, settings, "VkDeviceSize", "dstBufferRange", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkVideoPictureResourceInfoKHR>(object.srcPictureResource, settings, "VkVideoPictureResourceInfoKHR", "srcPictureResource", indents + 1, dump_html_VkVideoPictureResourceInfoKHR);
    dump_html_pointer<const VkVideoReferenceSlotInfoKHR>(object.pSetupReferenceSlot, settings, "const VkVideoReferenceSlotInfoKHR*", "pSetupReferenceSlot", indents + 1, dump_html_VkVideoReferenceSlotInfoKHR);
    dump_html_value<const uint32_t>(object.referenceSlotCount, settings, "uint32_t", "referenceSlotCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoReferenceSlotInfoKHR>(object.pReferenceSlots, object.referenceSlotCount, settings, "const VkVideoReferenceSlotInfoKHR*", "const VkVideoReferenceSlotInfoKHR", "pReferenceSlots", indents + 1, dump_html_VkVideoReferenceSlotInfoKHR); // ZRT
    dump_html_value<const uint32_t>(object.precedingExternallyEncodedBytes, settings, "uint32_t", "precedingExternallyEncodedBytes", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeCapabilitiesKHR(const VkVideoEncodeCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeCapabilityFlagsKHR>(object.flags, settings, "VkVideoEncodeCapabilityFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeCapabilityFlagsKHR);
    dump_html_value<const VkVideoEncodeRateControlModeFlagsKHR>(object.rateControlModes, settings, "VkVideoEncodeRateControlModeFlagsKHR", "rateControlModes", indents + 1, dump_html_VkVideoEncodeRateControlModeFlagsKHR);
    dump_html_value<const uint32_t>(object.maxRateControlLayers, settings, "uint32_t", "maxRateControlLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.maxBitrate, settings, "uint64_t", "maxBitrate", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.maxQualityLevels, settings, "uint32_t", "maxQualityLevels", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.encodeInputPictureGranularity, settings, "VkExtent2D", "encodeInputPictureGranularity", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkVideoEncodeFeedbackFlagsKHR>(object.supportedEncodeFeedbackFlags, settings, "VkVideoEncodeFeedbackFlagsKHR", "supportedEncodeFeedbackFlags", indents + 1, dump_html_VkVideoEncodeFeedbackFlagsKHR);
}
void dump_html_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeFeedbackFlagsKHR>(object.encodeFeedbackFlags, settings, "VkVideoEncodeFeedbackFlagsKHR", "encodeFeedbackFlags", indents + 1, dump_html_VkVideoEncodeFeedbackFlagsKHR);
}
void dump_html_VkVideoEncodeUsageInfoKHR(const VkVideoEncodeUsageInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeUsageFlagsKHR>(object.videoUsageHints, settings, "VkVideoEncodeUsageFlagsKHR", "videoUsageHints", indents + 1, dump_html_VkVideoEncodeUsageFlagsKHR);
    dump_html_value<const VkVideoEncodeContentFlagsKHR>(object.videoContentHints, settings, "VkVideoEncodeContentFlagsKHR", "videoContentHints", indents + 1, dump_html_VkVideoEncodeContentFlagsKHR);
    dump_html_value<const VkVideoEncodeTuningModeKHR>(object.tuningMode, settings, "VkVideoEncodeTuningModeKHR", "tuningMode", indents + 1, dump_html_VkVideoEncodeTuningModeKHR);
}
void dump_html_VkVideoEncodeRateControlLayerInfoKHR(const VkVideoEncodeRateControlLayerInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.averageBitrate, settings, "uint64_t", "averageBitrate", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxBitrate, settings, "uint64_t", "maxBitrate", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.frameRateNumerator, settings, "uint32_t", "frameRateNumerator", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.frameRateDenominator, settings, "uint32_t", "frameRateDenominator", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeRateControlInfoKHR(const VkVideoEncodeRateControlInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeRateControlFlagsKHR>(object.flags, settings, "VkVideoEncodeRateControlFlagsKHR", "flags", indents + 1, dump_html_VkVideoEncodeRateControlFlagsKHR);
    dump_html_value<const VkVideoEncodeRateControlModeFlagBitsKHR>(object.rateControlMode, settings, "VkVideoEncodeRateControlModeFlagBitsKHR", "rateControlMode", indents + 1, dump_html_VkVideoEncodeRateControlModeFlagBitsKHR);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVideoEncodeRateControlLayerInfoKHR>(object.pLayers, object.layerCount, settings, "const VkVideoEncodeRateControlLayerInfoKHR*", "const VkVideoEncodeRateControlLayerInfoKHR", "pLayers", indents + 1, dump_html_VkVideoEncodeRateControlLayerInfoKHR); // ZRT
    dump_html_value<const uint32_t>(object.virtualBufferSizeInMs, settings, "uint32_t", "virtualBufferSizeInMs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.initialVirtualBufferSizeInMs, settings, "uint32_t", "initialVirtualBufferSizeInMs", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkVideoProfileInfoKHR>(object.pVideoProfile, settings, "const VkVideoProfileInfoKHR*", "pVideoProfile", indents + 1, dump_html_VkVideoProfileInfoKHR);
    dump_html_value<const uint32_t>(object.qualityLevel, settings, "uint32_t", "qualityLevel", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeQualityLevelPropertiesKHR(const VkVideoEncodeQualityLevelPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoEncodeRateControlModeFlagBitsKHR>(object.preferredRateControlMode, settings, "VkVideoEncodeRateControlModeFlagBitsKHR", "preferredRateControlMode", indents + 1, dump_html_VkVideoEncodeRateControlModeFlagBitsKHR);
    dump_html_value<const uint32_t>(object.preferredRateControlLayerCount, settings, "uint32_t", "preferredRateControlLayerCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeQualityLevelInfoKHR(const VkVideoEncodeQualityLevelInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.qualityLevel, settings, "uint32_t", "qualityLevel", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVideoEncodeSessionParametersGetInfoKHR(const VkVideoEncodeSessionParametersGetInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkVideoSessionParametersKHR>(object.videoSessionParameters, settings, "VkVideoSessionParametersKHR", "videoSessionParameters", indents + 1, dump_html_VkVideoSessionParametersKHR);
}
void dump_html_VkVideoEncodeSessionParametersFeedbackInfoKHR(const VkVideoEncodeSessionParametersFeedbackInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hasOverrides, settings, "VkBool32", "hasOverrides", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(const VkPhysicalDeviceDiagnosticsConfigFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.diagnosticsConfig, settings, "VkBool32", "diagnosticsConfig", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceDiagnosticsConfigCreateInfoNV(const VkDeviceDiagnosticsConfigCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceDiagnosticsConfigFlagsNV>(object.flags, settings, "VkDeviceDiagnosticsConfigFlagsNV", "flags", indents + 1, dump_html_VkDeviceDiagnosticsConfigFlagsNV);
}
void dump_html_VkCudaModuleCreateInfoNV(const VkCudaModuleCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const size_t>(object.dataSize, settings, "size_t", "dataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
}
void dump_html_VkCudaFunctionCreateInfoNV(const VkCudaFunctionCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCudaModuleNV>(object.module, settings, "VkCudaModuleNV", "module", indents + 1, dump_html_VkCudaModuleNV);
    dump_html_value<const char*>(object.pName, settings, "const char*", "pName", indents + 1, dump_html_cstring);
}
void dump_html_VkCudaLaunchInfoNV(const VkCudaLaunchInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCudaFunctionNV>(object.function, settings, "VkCudaFunctionNV", "function", indents + 1, dump_html_VkCudaFunctionNV);
    dump_html_value<const uint32_t>(object.gridDimX, settings, "uint32_t", "gridDimX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gridDimY, settings, "uint32_t", "gridDimY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.gridDimZ, settings, "uint32_t", "gridDimZ", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.blockDimX, settings, "uint32_t", "blockDimX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.blockDimY, settings, "uint32_t", "blockDimY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.blockDimZ, settings, "uint32_t", "blockDimZ", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sharedMemBytes, settings, "uint32_t", "sharedMemBytes", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.paramCount, settings, "size_t", "paramCount", indents + 1, dump_html_size_t);
    dump_html_array<const void*>(object.pParams, object.paramCount, settings, "const void* const *", "const void* const ", "pParams", indents + 1, dump_html_void); // ZRT
    dump_html_value<const size_t>(object.extraCount, settings, "size_t", "extraCount", indents + 1, dump_html_size_t);
    dump_html_array<const void*>(object.pExtras, object.extraCount, settings, "const void* const *", "const void* const ", "pExtras", indents + 1, dump_html_void); // ZRT
}
void dump_html_VkPhysicalDeviceCudaKernelLaunchFeaturesNV(const VkPhysicalDeviceCudaKernelLaunchFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cudaKernelLaunchFeatures, settings, "VkBool32", "cudaKernelLaunchFeatures", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceCudaKernelLaunchPropertiesNV(const VkPhysicalDeviceCudaKernelLaunchPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.computeCapabilityMinor, settings, "uint32_t", "computeCapabilityMinor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.computeCapabilityMajor, settings, "uint32_t", "computeCapabilityMajor", indents + 1, dump_html_uint32_t);
}
void dump_html_VkQueryLowLatencySupportNV(const VkQueryLowLatencySupportNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.pQueriedLowLatencyData, settings, "void*", "pQueriedLowLatencyData", indents + 1, dump_html_void);
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalObjectCreateInfoEXT(const VkExportMetalObjectCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExportMetalObjectTypeFlagBitsEXT>(object.exportObjectType, settings, "VkExportMetalObjectTypeFlagBitsEXT", "exportObjectType", indents + 1, dump_html_VkExportMetalObjectTypeFlagBitsEXT);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalObjectsInfoEXT(const VkExportMetalObjectsInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalDeviceInfoEXT(const VkExportMetalDeviceInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const MTLDevice_id>(object.mtlDevice, settings, "MTLDevice_id", "mtlDevice", indents + 1, dump_html_MTLDevice_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalCommandQueueInfoEXT(const VkExportMetalCommandQueueInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueue>(object.queue, settings, "VkQueue", "queue", indents + 1, dump_html_VkQueue);
    dump_html_value<const MTLCommandQueue_id>(object.mtlCommandQueue, settings, "MTLCommandQueue_id", "mtlCommandQueue", indents + 1, dump_html_MTLCommandQueue_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalBufferInfoEXT(const VkExportMetalBufferInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const MTLBuffer_id>(object.mtlBuffer, settings, "MTLBuffer_id", "mtlBuffer", indents + 1, dump_html_MTLBuffer_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkImportMetalBufferInfoEXT(const VkImportMetalBufferInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const MTLBuffer_id>(object.mtlBuffer, settings, "MTLBuffer_id", "mtlBuffer", indents + 1, dump_html_MTLBuffer_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalTextureInfoEXT(const VkExportMetalTextureInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkBufferView>(object.bufferView, settings, "VkBufferView", "bufferView", indents + 1, dump_html_VkBufferView);
    dump_html_value<const VkImageAspectFlagBits>(object.plane, settings, "VkImageAspectFlagBits", "plane", indents + 1, dump_html_VkImageAspectFlagBits);
    dump_html_value<const MTLTexture_id>(object.mtlTexture, settings, "MTLTexture_id", "mtlTexture", indents + 1, dump_html_MTLTexture_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkImportMetalTextureInfoEXT(const VkImportMetalTextureInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageAspectFlagBits>(object.plane, settings, "VkImageAspectFlagBits", "plane", indents + 1, dump_html_VkImageAspectFlagBits);
    dump_html_value<const MTLTexture_id>(object.mtlTexture, settings, "MTLTexture_id", "mtlTexture", indents + 1, dump_html_MTLTexture_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalIOSurfaceInfoEXT(const VkExportMetalIOSurfaceInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const IOSurfaceRef>(object.ioSurface, settings, "IOSurfaceRef", "ioSurface", indents + 1, dump_html_IOSurfaceRef);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkImportMetalIOSurfaceInfoEXT(const VkImportMetalIOSurfaceInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const IOSurfaceRef>(object.ioSurface, settings, "IOSurfaceRef", "ioSurface", indents + 1, dump_html_IOSurfaceRef);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkExportMetalSharedEventInfoEXT(const VkExportMetalSharedEventInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkEvent>(object.event, settings, "VkEvent", "event", indents + 1, dump_html_VkEvent);
    dump_html_value<const MTLSharedEvent_id>(object.mtlSharedEvent, settings, "MTLSharedEvent_id", "mtlSharedEvent", indents + 1, dump_html_MTLSharedEvent_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_VkImportMetalSharedEventInfoEXT(const VkImportMetalSharedEventInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const MTLSharedEvent_id>(object.mtlSharedEvent, settings, "MTLSharedEvent_id", "mtlSharedEvent", indents + 1, dump_html_MTLSharedEvent_id);
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_VkQueueFamilyCheckpointProperties2NV(const VkQueueFamilyCheckpointProperties2NV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags2>(object.checkpointExecutionStageMask, settings, "VkPipelineStageFlags2", "checkpointExecutionStageMask", indents + 1, dump_html_VkPipelineStageFlags2);
}
void dump_html_VkCheckpointData2NV(const VkCheckpointData2NV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags2>(object.stage, settings, "VkPipelineStageFlags2", "stage", indents + 1, dump_html_VkPipelineStageFlags2);
    dump_html_value<const void*>(object.pCheckpointMarker, settings, "void*", "pCheckpointMarker", indents + 1, dump_html_void);
}
void dump_html_VkPhysicalDeviceDescriptorBufferPropertiesEXT(const VkPhysicalDeviceDescriptorBufferPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.combinedImageSamplerDescriptorSingleArray, settings, "VkBool32", "combinedImageSamplerDescriptorSingleArray", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferlessPushDescriptors, settings, "VkBool32", "bufferlessPushDescriptors", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.allowSamplerImageViewPostSubmitCreation, settings, "VkBool32", "allowSamplerImageViewPostSubmitCreation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.descriptorBufferOffsetAlignment, settings, "VkDeviceSize", "descriptorBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.maxDescriptorBufferBindings, settings, "uint32_t", "maxDescriptorBufferBindings", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxResourceDescriptorBufferBindings, settings, "uint32_t", "maxResourceDescriptorBufferBindings", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSamplerDescriptorBufferBindings, settings, "uint32_t", "maxSamplerDescriptorBufferBindings", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxEmbeddedImmutableSamplerBindings, settings, "uint32_t", "maxEmbeddedImmutableSamplerBindings", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxEmbeddedImmutableSamplers, settings, "uint32_t", "maxEmbeddedImmutableSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.bufferCaptureReplayDescriptorDataSize, settings, "size_t", "bufferCaptureReplayDescriptorDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.imageCaptureReplayDescriptorDataSize, settings, "size_t", "imageCaptureReplayDescriptorDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.imageViewCaptureReplayDescriptorDataSize, settings, "size_t", "imageViewCaptureReplayDescriptorDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.samplerCaptureReplayDescriptorDataSize, settings, "size_t", "samplerCaptureReplayDescriptorDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.accelerationStructureCaptureReplayDescriptorDataSize, settings, "size_t", "accelerationStructureCaptureReplayDescriptorDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.samplerDescriptorSize, settings, "size_t", "samplerDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.combinedImageSamplerDescriptorSize, settings, "size_t", "combinedImageSamplerDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.sampledImageDescriptorSize, settings, "size_t", "sampledImageDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.storageImageDescriptorSize, settings, "size_t", "storageImageDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.uniformTexelBufferDescriptorSize, settings, "size_t", "uniformTexelBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.robustUniformTexelBufferDescriptorSize, settings, "size_t", "robustUniformTexelBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.storageTexelBufferDescriptorSize, settings, "size_t", "storageTexelBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.robustStorageTexelBufferDescriptorSize, settings, "size_t", "robustStorageTexelBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.uniformBufferDescriptorSize, settings, "size_t", "uniformBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.robustUniformBufferDescriptorSize, settings, "size_t", "robustUniformBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.storageBufferDescriptorSize, settings, "size_t", "storageBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.robustStorageBufferDescriptorSize, settings, "size_t", "robustStorageBufferDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.inputAttachmentDescriptorSize, settings, "size_t", "inputAttachmentDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.accelerationStructureDescriptorSize, settings, "size_t", "accelerationStructureDescriptorSize", indents + 1, dump_html_size_t);
    dump_html_value<const VkDeviceSize>(object.maxSamplerDescriptorBufferRange, settings, "VkDeviceSize", "maxSamplerDescriptorBufferRange", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.maxResourceDescriptorBufferRange, settings, "VkDeviceSize", "maxResourceDescriptorBufferRange", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.samplerDescriptorBufferAddressSpaceSize, settings, "VkDeviceSize", "samplerDescriptorBufferAddressSpaceSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.resourceDescriptorBufferAddressSpaceSize, settings, "VkDeviceSize", "resourceDescriptorBufferAddressSpaceSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.descriptorBufferAddressSpaceSize, settings, "VkDeviceSize", "descriptorBufferAddressSpaceSize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const size_t>(object.combinedImageSamplerDensityMapDescriptorSize, settings, "size_t", "combinedImageSamplerDensityMapDescriptorSize", indents + 1, dump_html_size_t);
}
void dump_html_VkPhysicalDeviceDescriptorBufferFeaturesEXT(const VkPhysicalDeviceDescriptorBufferFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.descriptorBuffer, settings, "VkBool32", "descriptorBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBufferCaptureReplay, settings, "VkBool32", "descriptorBufferCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBufferImageLayoutIgnored, settings, "VkBool32", "descriptorBufferImageLayoutIgnored", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBufferPushDescriptors, settings, "VkBool32", "descriptorBufferPushDescriptors", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDescriptorAddressInfoEXT(const VkDescriptorAddressInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddress>(object.address, settings, "VkDeviceAddress", "address", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.range, settings, "VkDeviceSize", "range", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
}
void dump_html_VkDescriptorBufferBindingInfoEXT(const VkDescriptorBufferBindingInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddress>(object.address, settings, "VkDeviceAddress", "address", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkBufferUsageFlags>(object.usage, settings, "VkBufferUsageFlags", "usage", indents + 1, dump_html_VkBufferUsageFlags);
}
void dump_html_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
}
void dump_html_VkDescriptorGetInfoEXT(const VkDescriptorGetInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    ApiDumpInstance::current().setDescriptorType(object.type);
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorType>(object.type, settings, "VkDescriptorType", "type", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const VkDescriptorDataEXT>(object.data, settings, "VkDescriptorDataEXT", "data", indents + 1, dump_html_VkDescriptorDataEXT);
}
void dump_html_VkBufferCaptureDescriptorDataInfoEXT(const VkBufferCaptureDescriptorDataInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
}
void dump_html_VkImageCaptureDescriptorDataInfoEXT(const VkImageCaptureDescriptorDataInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
}
void dump_html_VkImageViewCaptureDescriptorDataInfoEXT(const VkImageViewCaptureDescriptorDataInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
}
void dump_html_VkSamplerCaptureDescriptorDataInfoEXT(const VkSamplerCaptureDescriptorDataInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampler>(object.sampler, settings, "VkSampler", "sampler", indents + 1, dump_html_VkSampler);
}
void dump_html_VkOpaqueCaptureDescriptorDataCreateInfoEXT(const VkOpaqueCaptureDescriptorDataCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.opaqueCaptureDescriptorData, settings, "const void*", "opaqueCaptureDescriptorData", indents + 1, dump_html_void);
}
void dump_html_VkAccelerationStructureCaptureDescriptorDataInfoEXT(const VkAccelerationStructureCaptureDescriptorDataInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureKHR>(object.accelerationStructure, settings, "VkAccelerationStructureKHR", "accelerationStructure", indents + 1, dump_html_VkAccelerationStructureKHR);
    dump_html_value<const VkAccelerationStructureNV>(object.accelerationStructureNV, settings, "VkAccelerationStructureNV", "accelerationStructureNV", indents + 1, dump_html_VkAccelerationStructureNV);
}
void dump_html_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.graphicsPipelineLibrary, settings, "VkBool32", "graphicsPipelineLibrary", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.graphicsPipelineLibraryFastLinking, settings, "VkBool32", "graphicsPipelineLibraryFastLinking", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.graphicsPipelineLibraryIndependentInterpolationDecoration, settings, "VkBool32", "graphicsPipelineLibraryIndependentInterpolationDecoration", indents + 1, dump_html_VkBool32);
}
void dump_html_VkGraphicsPipelineLibraryCreateInfoEXT(const VkGraphicsPipelineLibraryCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkGraphicsPipelineLibraryFlagsEXT>(object.flags, settings, "VkGraphicsPipelineLibraryFlagsEXT", "flags", indents + 1, dump_html_VkGraphicsPipelineLibraryFlagsEXT);
}
void dump_html_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderEarlyAndLateFragmentTests, settings, "VkBool32", "shaderEarlyAndLateFragmentTests", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.triStripVertexOrderIndependentOfProvokingVertex, settings, "VkBool32", "triStripVertexOrderIndependentOfProvokingVertex", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSubgroupUniformControlFlow, settings, "VkBool32", "shaderSubgroupUniformControlFlow", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentShadingRateEnums, settings, "VkBool32", "fragmentShadingRateEnums", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.supersampleFragmentShadingRates, settings, "VkBool32", "supersampleFragmentShadingRates", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.noInvocationFragmentShadingRates, settings, "VkBool32", "noInvocationFragmentShadingRates", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampleCountFlagBits>(object.maxFragmentShadingRateInvocationCount, settings, "VkSampleCountFlagBits", "maxFragmentShadingRateInvocationCount", indents + 1, dump_html_VkSampleCountFlagBits);
}
void dump_html_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(const VkPipelineFragmentShadingRateEnumStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFragmentShadingRateTypeNV>(object.shadingRateType, settings, "VkFragmentShadingRateTypeNV", "shadingRateType", indents + 1, dump_html_VkFragmentShadingRateTypeNV);
    dump_html_value<const VkFragmentShadingRateNV>(object.shadingRate, settings, "VkFragmentShadingRateNV", "shadingRate", indents + 1, dump_html_VkFragmentShadingRateNV);
    dump_html_array<const VkFragmentShadingRateCombinerOpKHR>(object.combinerOps, 2, settings, "VkFragmentShadingRateCombinerOpKHR[2]", "VkFragmentShadingRateCombinerOpKHR", "combinerOps", indents + 1, dump_html_VkFragmentShadingRateCombinerOpKHR); // ZRR
}
void dump_html_VkAccelerationStructureGeometryMotionTrianglesDataNV(const VkAccelerationStructureGeometryMotionTrianglesDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.vertexData, settings, "VkDeviceOrHostAddressConstKHR", "vertexData", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
}
void dump_html_VkAccelerationStructureMotionInfoNV(const VkAccelerationStructureMotionInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxInstances, settings, "uint32_t", "maxInstances", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkAccelerationStructureMotionInfoFlagsNV>(object.flags, settings, "VkAccelerationStructureMotionInfoFlagsNV", "flags", indents + 1, dump_html_VkAccelerationStructureMotionInfoFlagsNV);
}
void dump_html_VkAccelerationStructureMatrixMotionInstanceNV(const VkAccelerationStructureMatrixMotionInstanceNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkTransformMatrixKHR>(object.transformT0, settings, "VkTransformMatrixKHR", "transformT0", indents + 1, dump_html_VkTransformMatrixKHR);
    dump_html_value<const VkTransformMatrixKHR>(object.transformT1, settings, "VkTransformMatrixKHR", "transformT1", indents + 1, dump_html_VkTransformMatrixKHR);
    dump_html_value<const uint32_t>(object.instanceCustomIndex, settings, "uint32_t instanceCustomIndex:24", "instanceCustomIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.mask, settings, "uint32_t mask:8", "mask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceShaderBindingTableRecordOffset, settings, "uint32_t instanceShaderBindingTableRecordOffset:24", "instanceShaderBindingTableRecordOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkGeometryInstanceFlagsKHR>(object.flags, settings, "VkGeometryInstanceFlagsKHR flags:8", "flags", indents + 1, dump_html_VkGeometryInstanceFlagsKHR);
    dump_html_value<const uint64_t>(object.accelerationStructureReference, settings, "uint64_t", "accelerationStructureReference", indents + 1, dump_html_uint64_t);
}
void dump_html_VkSRTDataNV(const VkSRTDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.sx, settings, "float", "sx", indents + 1, dump_html_float);
    dump_html_value<const float>(object.a, settings, "float", "a", indents + 1, dump_html_float);
    dump_html_value<const float>(object.b, settings, "float", "b", indents + 1, dump_html_float);
    dump_html_value<const float>(object.pvx, settings, "float", "pvx", indents + 1, dump_html_float);
    dump_html_value<const float>(object.sy, settings, "float", "sy", indents + 1, dump_html_float);
    dump_html_value<const float>(object.c, settings, "float", "c", indents + 1, dump_html_float);
    dump_html_value<const float>(object.pvy, settings, "float", "pvy", indents + 1, dump_html_float);
    dump_html_value<const float>(object.sz, settings, "float", "sz", indents + 1, dump_html_float);
    dump_html_value<const float>(object.pvz, settings, "float", "pvz", indents + 1, dump_html_float);
    dump_html_value<const float>(object.qx, settings, "float", "qx", indents + 1, dump_html_float);
    dump_html_value<const float>(object.qy, settings, "float", "qy", indents + 1, dump_html_float);
    dump_html_value<const float>(object.qz, settings, "float", "qz", indents + 1, dump_html_float);
    dump_html_value<const float>(object.qw, settings, "float", "qw", indents + 1, dump_html_float);
    dump_html_value<const float>(object.tx, settings, "float", "tx", indents + 1, dump_html_float);
    dump_html_value<const float>(object.ty, settings, "float", "ty", indents + 1, dump_html_float);
    dump_html_value<const float>(object.tz, settings, "float", "tz", indents + 1, dump_html_float);
}
void dump_html_VkAccelerationStructureSRTMotionInstanceNV(const VkAccelerationStructureSRTMotionInstanceNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSRTDataNV>(object.transformT0, settings, "VkSRTDataNV", "transformT0", indents + 1, dump_html_VkSRTDataNV);
    dump_html_value<const VkSRTDataNV>(object.transformT1, settings, "VkSRTDataNV", "transformT1", indents + 1, dump_html_VkSRTDataNV);
    dump_html_value<const uint32_t>(object.instanceCustomIndex, settings, "uint32_t instanceCustomIndex:24", "instanceCustomIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.mask, settings, "uint32_t mask:8", "mask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceShaderBindingTableRecordOffset, settings, "uint32_t instanceShaderBindingTableRecordOffset:24", "instanceShaderBindingTableRecordOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkGeometryInstanceFlagsKHR>(object.flags, settings, "VkGeometryInstanceFlagsKHR flags:8", "flags", indents + 1, dump_html_VkGeometryInstanceFlagsKHR);
    dump_html_value<const uint64_t>(object.accelerationStructureReference, settings, "uint64_t", "accelerationStructureReference", indents + 1, dump_html_uint64_t);
}
void dump_html_VkAccelerationStructureMotionInstanceNV(const VkAccelerationStructureMotionInstanceNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkAccelerationStructureMotionInstanceTypeNV>(object.type, settings, "VkAccelerationStructureMotionInstanceTypeNV", "type", indents + 1, dump_html_VkAccelerationStructureMotionInstanceTypeNV);
    dump_html_value<const VkAccelerationStructureMotionInstanceFlagsNV>(object.flags, settings, "VkAccelerationStructureMotionInstanceFlagsNV", "flags", indents + 1, dump_html_VkAccelerationStructureMotionInstanceFlagsNV);
    dump_html_value<const VkAccelerationStructureMotionInstanceDataNV>(object.data, settings, "VkAccelerationStructureMotionInstanceDataNV", "data", indents + 1, dump_html_VkAccelerationStructureMotionInstanceDataNV);
}
void dump_html_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayTracingMotionBlur, settings, "VkBool32", "rayTracingMotionBlur", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rayTracingMotionBlurPipelineTraceRaysIndirect, settings, "VkBool32", "rayTracingMotionBlurPipelineTraceRaysIndirect", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMeshShaderFeaturesEXT(const VkPhysicalDeviceMeshShaderFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.taskShader, settings, "VkBool32", "taskShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.meshShader, settings, "VkBool32", "meshShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewMeshShader, settings, "VkBool32", "multiviewMeshShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.primitiveFragmentShadingRateMeshShader, settings, "VkBool32", "primitiveFragmentShadingRateMeshShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.meshShaderQueries, settings, "VkBool32", "meshShaderQueries", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMeshShaderPropertiesEXT(const VkPhysicalDeviceMeshShaderPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxTaskWorkGroupTotalCount, settings, "uint32_t", "maxTaskWorkGroupTotalCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxTaskWorkGroupCount, 3, settings, "uint32_t[3]", "uint32_t", "maxTaskWorkGroupCount", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxTaskWorkGroupInvocations, settings, "uint32_t", "maxTaskWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxTaskWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxTaskWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxTaskPayloadSize, settings, "uint32_t", "maxTaskPayloadSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskSharedMemorySize, settings, "uint32_t", "maxTaskSharedMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskPayloadAndSharedMemorySize, settings, "uint32_t", "maxTaskPayloadAndSharedMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshWorkGroupTotalCount, settings, "uint32_t", "maxMeshWorkGroupTotalCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxMeshWorkGroupCount, 3, settings, "uint32_t[3]", "uint32_t", "maxMeshWorkGroupCount", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxMeshWorkGroupInvocations, settings, "uint32_t", "maxMeshWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxMeshWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxMeshWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxMeshSharedMemorySize, settings, "uint32_t", "maxMeshSharedMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshPayloadAndSharedMemorySize, settings, "uint32_t", "maxMeshPayloadAndSharedMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputMemorySize, settings, "uint32_t", "maxMeshOutputMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshPayloadAndOutputMemorySize, settings, "uint32_t", "maxMeshPayloadAndOutputMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputComponents, settings, "uint32_t", "maxMeshOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputVertices, settings, "uint32_t", "maxMeshOutputVertices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputPrimitives, settings, "uint32_t", "maxMeshOutputPrimitives", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputLayers, settings, "uint32_t", "maxMeshOutputLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshMultiviewViewCount, settings, "uint32_t", "maxMeshMultiviewViewCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.meshOutputPerVertexGranularity, settings, "uint32_t", "meshOutputPerVertexGranularity", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.meshOutputPerPrimitiveGranularity, settings, "uint32_t", "meshOutputPerPrimitiveGranularity", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPreferredTaskWorkGroupInvocations, settings, "uint32_t", "maxPreferredTaskWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPreferredMeshWorkGroupInvocations, settings, "uint32_t", "maxPreferredMeshWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.prefersLocalInvocationVertexOutput, settings, "VkBool32", "prefersLocalInvocationVertexOutput", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.prefersLocalInvocationPrimitiveOutput, settings, "VkBool32", "prefersLocalInvocationPrimitiveOutput", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.prefersCompactVertexOutput, settings, "VkBool32", "prefersCompactVertexOutput", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.prefersCompactPrimitiveOutput, settings, "VkBool32", "prefersCompactPrimitiveOutput", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDrawMeshTasksIndirectCommandEXT(const VkDrawMeshTasksIndirectCommandEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.groupCountX, settings, "uint32_t", "groupCountX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.groupCountY, settings, "uint32_t", "groupCountY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.groupCountZ, settings, "uint32_t", "groupCountZ", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.ycbcr2plane444Formats, settings, "VkBool32", "ycbcr2plane444Formats", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentDensityMapDeferred, settings, "VkBool32", "fragmentDensityMapDeferred", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.subsampledLoads, settings, "VkBool32", "subsampledLoads", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.subsampledCoarseReconstructionEarlyAccess, settings, "VkBool32", "subsampledCoarseReconstructionEarlyAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxSubsampledArrayLayers, settings, "uint32_t", "maxSubsampledArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetSubsampledSamplers, settings, "uint32_t", "maxDescriptorSetSubsampledSamplers", indents + 1, dump_html_uint32_t);
}
void dump_html_VkCopyCommandTransformInfoQCOM(const VkCopyCommandTransformInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.transform, settings, "VkSurfaceTransformFlagBitsKHR", "transform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
}
void dump_html_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.workgroupMemoryExplicitLayout, settings, "VkBool32", "workgroupMemoryExplicitLayout", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.workgroupMemoryExplicitLayoutScalarBlockLayout, settings, "VkBool32", "workgroupMemoryExplicitLayoutScalarBlockLayout", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.workgroupMemoryExplicitLayout8BitAccess, settings, "VkBool32", "workgroupMemoryExplicitLayout8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.workgroupMemoryExplicitLayout16BitAccess, settings, "VkBool32", "workgroupMemoryExplicitLayout16BitAccess", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageCompressionControlFeaturesEXT(const VkPhysicalDeviceImageCompressionControlFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imageCompressionControl, settings, "VkBool32", "imageCompressionControl", indents + 1, dump_html_VkBool32);
}
void dump_html_VkImageCompressionControlEXT(const VkImageCompressionControlEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCompressionFlagsEXT>(object.flags, settings, "VkImageCompressionFlagsEXT", "flags", indents + 1, dump_html_VkImageCompressionFlagsEXT);
    dump_html_value<const uint32_t>(object.compressionControlPlaneCount, settings, "uint32_t", "compressionControlPlaneCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageCompressionFixedRateFlagsEXT>(object.pFixedRateFlags, object.compressionControlPlaneCount, settings, "VkImageCompressionFixedRateFlagsEXT*", "VkImageCompressionFixedRateFlagsEXT", "pFixedRateFlags", indents + 1, dump_html_VkImageCompressionFixedRateFlagsEXT); // ZRT
}
void dump_html_VkImageCompressionPropertiesEXT(const VkImageCompressionPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCompressionFlagsEXT>(object.imageCompressionFlags, settings, "VkImageCompressionFlagsEXT", "imageCompressionFlags", indents + 1, dump_html_VkImageCompressionFlagsEXT);
    dump_html_value<const VkImageCompressionFixedRateFlagsEXT>(object.imageCompressionFixedRateFlags, settings, "VkImageCompressionFixedRateFlagsEXT", "imageCompressionFixedRateFlags", indents + 1, dump_html_VkImageCompressionFixedRateFlagsEXT);
}
void dump_html_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.attachmentFeedbackLoopLayout, settings, "VkBool32", "attachmentFeedbackLoopLayout", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevice4444FormatsFeaturesEXT(const VkPhysicalDevice4444FormatsFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.formatA4R4G4B4, settings, "VkBool32", "formatA4R4G4B4", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.formatA4B4G4R4, settings, "VkBool32", "formatA4B4G4R4", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFaultFeaturesEXT(const VkPhysicalDeviceFaultFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.deviceFault, settings, "VkBool32", "deviceFault", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.deviceFaultVendorBinary, settings, "VkBool32", "deviceFaultVendorBinary", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceFaultCountsEXT(const VkDeviceFaultCountsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.addressInfoCount, settings, "uint32_t", "addressInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vendorInfoCount, settings, "uint32_t", "vendorInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.vendorBinarySize, settings, "VkDeviceSize", "vendorBinarySize", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkDeviceFaultAddressInfoEXT(const VkDeviceFaultAddressInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceFaultAddressTypeEXT>(object.addressType, settings, "VkDeviceFaultAddressTypeEXT", "addressType", indents + 1, dump_html_VkDeviceFaultAddressTypeEXT);
    dump_html_value<const VkDeviceAddress>(object.reportedAddress, settings, "VkDeviceAddress", "reportedAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.addressPrecision, settings, "VkDeviceSize", "addressPrecision", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkDeviceFaultVendorInfoEXT(const VkDeviceFaultVendorInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const uint64_t>(object.vendorFaultCode, settings, "uint64_t", "vendorFaultCode", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.vendorFaultData, settings, "uint64_t", "vendorFaultData", indents + 1, dump_html_uint64_t);
}
void dump_html_VkDeviceFaultInfoEXT(const VkDeviceFaultInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_pointer<const VkDeviceFaultAddressInfoEXT>(object.pAddressInfos, settings, "VkDeviceFaultAddressInfoEXT*", "pAddressInfos", indents + 1, dump_html_VkDeviceFaultAddressInfoEXT);
    dump_html_pointer<const VkDeviceFaultVendorInfoEXT>(object.pVendorInfos, settings, "VkDeviceFaultVendorInfoEXT*", "pVendorInfos", indents + 1, dump_html_VkDeviceFaultVendorInfoEXT);
    dump_html_value<const void*>(object.pVendorBinaryData, settings, "void*", "pVendorBinaryData", indents + 1, dump_html_void);
}
void dump_html_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(const VkDeviceFaultVendorBinaryHeaderVersionOneEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.headerSize, settings, "uint32_t", "headerSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceFaultVendorBinaryHeaderVersionEXT>(object.headerVersion, settings, "VkDeviceFaultVendorBinaryHeaderVersionEXT", "headerVersion", indents + 1, dump_html_VkDeviceFaultVendorBinaryHeaderVersionEXT);
    dump_html_value<const uint32_t>(object.vendorID, settings, "uint32_t", "vendorID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.deviceID, settings, "uint32_t", "deviceID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.driverVersion, settings, "uint32_t", "driverVersion", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint8_t>(object.pipelineCacheUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "pipelineCacheUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_value<const uint32_t>(object.applicationNameOffset, settings, "uint32_t", "applicationNameOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.applicationVersion, settings, "uint32_t", "applicationVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.engineNameOffset, settings, "uint32_t", "engineNameOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.engineVersion, settings, "uint32_t", "engineVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.apiVersion, settings, "uint32_t", "apiVersion", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rasterizationOrderColorAttachmentAccess, settings, "VkBool32", "rasterizationOrderColorAttachmentAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rasterizationOrderDepthAttachmentAccess, settings, "VkBool32", "rasterizationOrderDepthAttachmentAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rasterizationOrderStencilAttachmentAccess, settings, "VkBool32", "rasterizationOrderStencilAttachmentAccess", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.formatRgba10x6WithoutYCbCrSampler, settings, "VkBool32", "formatRgba10x6WithoutYCbCrSampler", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
void dump_html_VkDirectFBSurfaceCreateInfoEXT(const VkDirectFBSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDirectFBSurfaceCreateFlagsEXT>(object.flags, settings, "VkDirectFBSurfaceCreateFlagsEXT", "flags", indents + 1, dump_html_VkDirectFBSurfaceCreateFlagsEXT);
    dump_html_pointer<const IDirectFB>(object.dfb, settings, "IDirectFB*", "dfb", indents + 1, dump_html_IDirectFB);
    dump_html_pointer<const IDirectFBSurface>(object.surface, settings, "IDirectFBSurface*", "surface", indents + 1, dump_html_IDirectFBSurface);
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
void dump_html_VkRayTracingShaderGroupCreateInfoKHR(const VkRayTracingShaderGroupCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRayTracingShaderGroupTypeKHR>(object.type, settings, "VkRayTracingShaderGroupTypeKHR", "type", indents + 1, dump_html_VkRayTracingShaderGroupTypeKHR);
    dump_html_value<const uint32_t>(object.generalShader, settings, "uint32_t", "generalShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.closestHitShader, settings, "uint32_t", "closestHitShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.anyHitShader, settings, "uint32_t", "anyHitShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.intersectionShader, settings, "uint32_t", "intersectionShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pShaderGroupCaptureReplayHandle, settings, "const void*", "pShaderGroupCaptureReplayHandle", indents + 1, dump_html_void);
}
void dump_html_VkRayTracingPipelineInterfaceCreateInfoKHR(const VkRayTracingPipelineInterfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxPipelineRayPayloadSize, settings, "uint32_t", "maxPipelineRayPayloadSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPipelineRayHitAttributeSize, settings, "uint32_t", "maxPipelineRayHitAttributeSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkRayTracingPipelineCreateInfoKHR(const VkRayTracingPipelineCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo); // ZRT
    dump_html_value<const uint32_t>(object.groupCount, settings, "uint32_t", "groupCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRayTracingShaderGroupCreateInfoKHR>(object.pGroups, object.groupCount, settings, "const VkRayTracingShaderGroupCreateInfoKHR*", "const VkRayTracingShaderGroupCreateInfoKHR", "pGroups", indents + 1, dump_html_VkRayTracingShaderGroupCreateInfoKHR); // ZRT
    dump_html_value<const uint32_t>(object.maxPipelineRayRecursionDepth, settings, "uint32_t", "maxPipelineRayRecursionDepth", indents + 1, dump_html_uint32_t);
    dump_html_pointer<const VkPipelineLibraryCreateInfoKHR>(object.pLibraryInfo, settings, "const VkPipelineLibraryCreateInfoKHR*", "pLibraryInfo", indents + 1, dump_html_VkPipelineLibraryCreateInfoKHR);
    dump_html_pointer<const VkRayTracingPipelineInterfaceCreateInfoKHR>(object.pLibraryInterface, settings, "const VkRayTracingPipelineInterfaceCreateInfoKHR*", "pLibraryInterface", indents + 1, dump_html_VkRayTracingPipelineInterfaceCreateInfoKHR);
    dump_html_pointer<const VkPipelineDynamicStateCreateInfo>(object.pDynamicState, settings, "const VkPipelineDynamicStateCreateInfo*", "pDynamicState", indents + 1, dump_html_VkPipelineDynamicStateCreateInfo);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
}
void dump_html_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(const VkPhysicalDeviceRayTracingPipelineFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayTracingPipeline, settings, "VkBool32", "rayTracingPipeline", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rayTracingPipelineShaderGroupHandleCaptureReplay, settings, "VkBool32", "rayTracingPipelineShaderGroupHandleCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rayTracingPipelineShaderGroupHandleCaptureReplayMixed, settings, "VkBool32", "rayTracingPipelineShaderGroupHandleCaptureReplayMixed", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rayTracingPipelineTraceRaysIndirect, settings, "VkBool32", "rayTracingPipelineTraceRaysIndirect", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rayTraversalPrimitiveCulling, settings, "VkBool32", "rayTraversalPrimitiveCulling", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(const VkPhysicalDeviceRayTracingPipelinePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderGroupHandleSize, settings, "uint32_t", "shaderGroupHandleSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxRayRecursionDepth, settings, "uint32_t", "maxRayRecursionDepth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxShaderGroupStride, settings, "uint32_t", "maxShaderGroupStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderGroupBaseAlignment, settings, "uint32_t", "shaderGroupBaseAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderGroupHandleCaptureReplaySize, settings, "uint32_t", "shaderGroupHandleCaptureReplaySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxRayDispatchInvocationCount, settings, "uint32_t", "maxRayDispatchInvocationCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderGroupHandleAlignment, settings, "uint32_t", "shaderGroupHandleAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxRayHitAttributeSize, settings, "uint32_t", "maxRayHitAttributeSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkStridedDeviceAddressRegionKHR(const VkStridedDeviceAddressRegionKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.stride, settings, "VkDeviceSize", "stride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkTraceRaysIndirectCommandKHR(const VkTraceRaysIndirectCommandKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.depth, settings, "uint32_t", "depth", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceRayQueryFeaturesKHR(const VkPhysicalDeviceRayQueryFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayQuery, settings, "VkBool32", "rayQuery", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.mutableDescriptorType, settings, "VkBool32", "mutableDescriptorType", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMutableDescriptorTypeListEXT(const VkMutableDescriptorTypeListEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.descriptorTypeCount, settings, "uint32_t", "descriptorTypeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorType>(object.pDescriptorTypes, object.descriptorTypeCount, settings, "const VkDescriptorType*", "const VkDescriptorType", "pDescriptorTypes", indents + 1, dump_html_VkDescriptorType); // ZRT
}
void dump_html_VkMutableDescriptorTypeCreateInfoEXT(const VkMutableDescriptorTypeCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.mutableDescriptorTypeListCount, settings, "uint32_t", "mutableDescriptorTypeListCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMutableDescriptorTypeListEXT>(object.pMutableDescriptorTypeLists, object.mutableDescriptorTypeListCount, settings, "const VkMutableDescriptorTypeListEXT*", "const VkMutableDescriptorTypeListEXT", "pMutableDescriptorTypeLists", indents + 1, dump_html_VkMutableDescriptorTypeListEXT); // ZRT
}
void dump_html_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.vertexInputDynamicState, settings, "VkBool32", "vertexInputDynamicState", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVertexInputBindingDescription2EXT(const VkVertexInputBindingDescription2EXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stride, settings, "uint32_t", "stride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkVertexInputRate>(object.inputRate, settings, "VkVertexInputRate", "inputRate", indents + 1, dump_html_VkVertexInputRate);
    dump_html_value<const uint32_t>(object.divisor, settings, "uint32_t", "divisor", indents + 1, dump_html_uint32_t);
}
void dump_html_VkVertexInputAttributeDescription2EXT(const VkVertexInputAttributeDescription2EXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.location, settings, "uint32_t", "location", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceDrmPropertiesEXT(const VkPhysicalDeviceDrmPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hasPrimary, settings, "VkBool32", "hasPrimary", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.hasRender, settings, "VkBool32", "hasRender", indents + 1, dump_html_VkBool32);
    dump_html_value<const int64_t>(object.primaryMajor, settings, "int64_t", "primaryMajor", indents + 1, dump_html_int64_t);
    dump_html_value<const int64_t>(object.primaryMinor, settings, "int64_t", "primaryMinor", indents + 1, dump_html_int64_t);
    dump_html_value<const int64_t>(object.renderMajor, settings, "int64_t", "renderMajor", indents + 1, dump_html_int64_t);
    dump_html_value<const int64_t>(object.renderMinor, settings, "int64_t", "renderMinor", indents + 1, dump_html_int64_t);
}
void dump_html_VkPhysicalDeviceAddressBindingReportFeaturesEXT(const VkPhysicalDeviceAddressBindingReportFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.reportAddressBinding, settings, "VkBool32", "reportAddressBinding", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceAddressBindingCallbackDataEXT(const VkDeviceAddressBindingCallbackDataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddressBindingFlagsEXT>(object.flags, settings, "VkDeviceAddressBindingFlagsEXT", "flags", indents + 1, dump_html_VkDeviceAddressBindingFlagsEXT);
    dump_html_value<const VkDeviceAddress>(object.baseAddress, settings, "VkDeviceAddress", "baseAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceAddressBindingTypeEXT>(object.bindingType, settings, "VkDeviceAddressBindingTypeEXT", "bindingType", indents + 1, dump_html_VkDeviceAddressBindingTypeEXT);
}
void dump_html_VkPhysicalDeviceDepthClipControlFeaturesEXT(const VkPhysicalDeviceDepthClipControlFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.depthClipControl, settings, "VkBool32", "depthClipControl", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineViewportDepthClipControlCreateInfoEXT(const VkPipelineViewportDepthClipControlCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.negativeOneToOne, settings, "VkBool32", "negativeOneToOne", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.primitiveTopologyListRestart, settings, "VkBool32", "primitiveTopologyListRestart", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.primitiveTopologyPatchListRestart, settings, "VkBool32", "primitiveTopologyPatchListRestart", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImportMemoryZirconHandleInfoFUCHSIA(const VkImportMemoryZirconHandleInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const zx_handle_t>(object.handle, settings, "zx_handle_t", "handle", indents + 1, dump_html_zx_handle_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkMemoryZirconHandlePropertiesFUCHSIA(const VkMemoryZirconHandlePropertiesFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkMemoryGetZirconHandleInfoFUCHSIA(const VkMemoryGetZirconHandleInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImportSemaphoreZirconHandleInfoFUCHSIA(const VkImportSemaphoreZirconHandleInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkSemaphoreImportFlags>(object.flags, settings, "VkSemaphoreImportFlags", "flags", indents + 1, dump_html_VkSemaphoreImportFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    dump_html_value<const zx_handle_t>(object.zirconHandle, settings, "zx_handle_t", "zirconHandle", indents + 1, dump_html_zx_handle_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkSemaphoreGetZirconHandleInfoFUCHSIA(const VkSemaphoreGetZirconHandleInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferCollectionCreateInfoFUCHSIA(const VkBufferCollectionCreateInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const zx_handle_t>(object.collectionToken, settings, "zx_handle_t", "collectionToken", indents + 1, dump_html_zx_handle_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImportMemoryBufferCollectionFUCHSIA(const VkImportMemoryBufferCollectionFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCollectionFUCHSIA>(object.collection, settings, "VkBufferCollectionFUCHSIA", "collection", indents + 1, dump_html_VkBufferCollectionFUCHSIA);
    dump_html_value<const uint32_t>(object.index, settings, "uint32_t", "index", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferCollectionImageCreateInfoFUCHSIA(const VkBufferCollectionImageCreateInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCollectionFUCHSIA>(object.collection, settings, "VkBufferCollectionFUCHSIA", "collection", indents + 1, dump_html_VkBufferCollectionFUCHSIA);
    dump_html_value<const uint32_t>(object.index, settings, "uint32_t", "index", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferCollectionConstraintsInfoFUCHSIA(const VkBufferCollectionConstraintsInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minBufferCount, settings, "uint32_t", "minBufferCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxBufferCount, settings, "uint32_t", "maxBufferCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minBufferCountForCamping, settings, "uint32_t", "minBufferCountForCamping", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minBufferCountForDedicatedSlack, settings, "uint32_t", "minBufferCountForDedicatedSlack", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minBufferCountForSharedSlack, settings, "uint32_t", "minBufferCountForSharedSlack", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferConstraintsInfoFUCHSIA(const VkBufferConstraintsInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCreateInfo>(object.createInfo, settings, "VkBufferCreateInfo", "createInfo", indents + 1, dump_html_VkBufferCreateInfo);
    dump_html_value<const VkFormatFeatureFlags>(object.requiredFormatFeatures, settings, "VkFormatFeatureFlags", "requiredFormatFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkBufferCollectionConstraintsInfoFUCHSIA>(object.bufferCollectionConstraints, settings, "VkBufferCollectionConstraintsInfoFUCHSIA", "bufferCollectionConstraints", indents + 1, dump_html_VkBufferCollectionConstraintsInfoFUCHSIA);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferCollectionBufferCreateInfoFUCHSIA(const VkBufferCollectionBufferCreateInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCollectionFUCHSIA>(object.collection, settings, "VkBufferCollectionFUCHSIA", "collection", indents + 1, dump_html_VkBufferCollectionFUCHSIA);
    dump_html_value<const uint32_t>(object.index, settings, "uint32_t", "index", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkSysmemColorSpaceFUCHSIA(const VkSysmemColorSpaceFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.colorSpace, settings, "uint32_t", "colorSpace", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkBufferCollectionPropertiesFUCHSIA(const VkBufferCollectionPropertiesFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.bufferCount, settings, "uint32_t", "bufferCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.createInfoIndex, settings, "uint32_t", "createInfoIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.sysmemPixelFormat, settings, "uint64_t", "sysmemPixelFormat", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkFormatFeatureFlags>(object.formatFeatures, settings, "VkFormatFeatureFlags", "formatFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkSysmemColorSpaceFUCHSIA>(object.sysmemColorSpaceIndex, settings, "VkSysmemColorSpaceFUCHSIA", "sysmemColorSpaceIndex", indents + 1, dump_html_VkSysmemColorSpaceFUCHSIA);
    dump_html_value<const VkComponentMapping>(object.samplerYcbcrConversionComponents, settings, "VkComponentMapping", "samplerYcbcrConversionComponents", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.suggestedYcbcrModel, settings, "VkSamplerYcbcrModelConversion", "suggestedYcbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.suggestedYcbcrRange, settings, "VkSamplerYcbcrRange", "suggestedYcbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkChromaLocation>(object.suggestedXChromaOffset, settings, "VkChromaLocation", "suggestedXChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.suggestedYChromaOffset, settings, "VkChromaLocation", "suggestedYChromaOffset", indents + 1, dump_html_VkChromaLocation);
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImageFormatConstraintsInfoFUCHSIA(const VkImageFormatConstraintsInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCreateInfo>(object.imageCreateInfo, settings, "VkImageCreateInfo", "imageCreateInfo", indents + 1, dump_html_VkImageCreateInfo);
    dump_html_value<const VkFormatFeatureFlags>(object.requiredFormatFeatures, settings, "VkFormatFeatureFlags", "requiredFormatFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkImageFormatConstraintsFlagsFUCHSIA>(object.flags, settings, "VkImageFormatConstraintsFlagsFUCHSIA", "flags", indents + 1, dump_html_VkImageFormatConstraintsFlagsFUCHSIA);
    dump_html_value<const uint64_t>(object.sysmemPixelFormat, settings, "uint64_t", "sysmemPixelFormat", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.colorSpaceCount, settings, "uint32_t", "colorSpaceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSysmemColorSpaceFUCHSIA>(object.pColorSpaces, object.colorSpaceCount, settings, "const VkSysmemColorSpaceFUCHSIA*", "const VkSysmemColorSpaceFUCHSIA", "pColorSpaces", indents + 1, dump_html_VkSysmemColorSpaceFUCHSIA); // ZRT
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_VkImageConstraintsInfoFUCHSIA(const VkImageConstraintsInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.formatConstraintsCount, settings, "uint32_t", "formatConstraintsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageFormatConstraintsInfoFUCHSIA>(object.pFormatConstraints, object.formatConstraintsCount, settings, "const VkImageFormatConstraintsInfoFUCHSIA*", "const VkImageFormatConstraintsInfoFUCHSIA", "pFormatConstraints", indents + 1, dump_html_VkImageFormatConstraintsInfoFUCHSIA); // ZRT
    dump_html_value<const VkBufferCollectionConstraintsInfoFUCHSIA>(object.bufferCollectionConstraints, settings, "VkBufferCollectionConstraintsInfoFUCHSIA", "bufferCollectionConstraints", indents + 1, dump_html_VkBufferCollectionConstraintsInfoFUCHSIA);
    dump_html_value<const VkImageConstraintsInfoFlagsFUCHSIA>(object.flags, settings, "VkImageConstraintsInfoFlagsFUCHSIA", "flags", indents + 1, dump_html_VkImageConstraintsInfoFlagsFUCHSIA);
}
#endif // VK_USE_PLATFORM_FUCHSIA
void dump_html_VkSubpassShadingPipelineCreateInfoHUAWEI(const VkSubpassShadingPipelineCreateInfoHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.subpassShading, settings, "VkBool32", "subpassShading", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxSubpassShadingWorkgroupSizeAspectRatio, settings, "uint32_t", "maxSubpassShadingWorkgroupSizeAspectRatio", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.invocationMask, settings, "VkBool32", "invocationMask", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMemoryGetRemoteAddressInfoNV(const VkMemoryGetRemoteAddressInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
}
void dump_html_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.externalMemoryRDMA, settings, "VkBool32", "externalMemoryRDMA", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelinePropertiesIdentifierEXT(const VkPipelinePropertiesIdentifierEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.pipelineIdentifier, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "pipelineIdentifier", indents + 1, dump_html_uint8_t); // ZRR
}
void dump_html_VkPhysicalDevicePipelinePropertiesFeaturesEXT(const VkPhysicalDevicePipelinePropertiesFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelinePropertiesIdentifier, settings, "VkBool32", "pipelinePropertiesIdentifier", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFrameBoundaryFeaturesEXT(const VkPhysicalDeviceFrameBoundaryFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.frameBoundary, settings, "VkBool32", "frameBoundary", indents + 1, dump_html_VkBool32);
}
void dump_html_VkFrameBoundaryEXT(const VkFrameBoundaryEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFrameBoundaryFlagsEXT>(object.flags, settings, "VkFrameBoundaryFlagsEXT", "flags", indents + 1, dump_html_VkFrameBoundaryFlagsEXT);
    dump_html_value<const uint64_t>(object.frameID, settings, "uint64_t", "frameID", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.imageCount, settings, "uint32_t", "imageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImage>(object.pImages, object.imageCount, settings, "const VkImage*", "const VkImage", "pImages", indents + 1, dump_html_VkImage); // ZRT
    dump_html_value<const uint32_t>(object.bufferCount, settings, "uint32_t", "bufferCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkBuffer>(object.pBuffers, object.bufferCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", indents + 1, dump_html_VkBuffer); // ZRT
    dump_html_value<const uint64_t>(object.tagName, settings, "uint64_t", "tagName", indents + 1, dump_html_uint64_t);
    dump_html_value<const size_t>(object.tagSize, settings, "size_t", "tagSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pTag, settings, "const void*", "pTag", indents + 1, dump_html_void);
}
void dump_html_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multisampledRenderToSingleSampled, settings, "VkBool32", "multisampledRenderToSingleSampled", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSubpassResolvePerformanceQueryEXT(const VkSubpassResolvePerformanceQueryEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.optimal, settings, "VkBool32", "optimal", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMultisampledRenderToSingleSampledInfoEXT(const VkMultisampledRenderToSingleSampledInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multisampledRenderToSingleSampledEnable, settings, "VkBool32", "multisampledRenderToSingleSampledEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkSampleCountFlagBits>(object.rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
}
void dump_html_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.extendedDynamicState2, settings, "VkBool32", "extendedDynamicState2", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState2LogicOp, settings, "VkBool32", "extendedDynamicState2LogicOp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState2PatchControlPoints, settings, "VkBool32", "extendedDynamicState2PatchControlPoints", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkScreenSurfaceCreateInfoQNX(const VkScreenSurfaceCreateInfoQNX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkScreenSurfaceCreateFlagsQNX>(object.flags, settings, "VkScreenSurfaceCreateFlagsQNX", "flags", indents + 1, dump_html_VkScreenSurfaceCreateFlagsQNX);
    dump_html_value<const _screen_context*>(object.context, settings, "struct _screen_context*", "context", indents + 1, dump_html__screen_context);
    dump_html_value<const _screen_window*>(object.window, settings, "struct _screen_window*", "window", indents + 1, dump_html__screen_window);
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
void dump_html_VkPhysicalDeviceColorWriteEnableFeaturesEXT(const VkPhysicalDeviceColorWriteEnableFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.colorWriteEnable, settings, "VkBool32", "colorWriteEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPipelineColorWriteCreateInfoEXT(const VkPipelineColorWriteCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkBool32>(object.pColorWriteEnables, object.attachmentCount, settings, "const VkBool32*", "const VkBool32", "pColorWriteEnables", indents + 1, dump_html_VkBool32); // ZRT
}
void dump_html_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.primitivesGeneratedQuery, settings, "VkBool32", "primitivesGeneratedQuery", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.primitivesGeneratedQueryWithRasterizerDiscard, settings, "VkBool32", "primitivesGeneratedQueryWithRasterizerDiscard", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.primitivesGeneratedQueryWithNonZeroStreams, settings, "VkBool32", "primitivesGeneratedQueryWithNonZeroStreams", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayTracingMaintenance1, settings, "VkBool32", "rayTracingMaintenance1", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rayTracingPipelineTraceRaysIndirect2, settings, "VkBool32", "rayTracingPipelineTraceRaysIndirect2", indents + 1, dump_html_VkBool32);
}
void dump_html_VkTraceRaysIndirectCommand2KHR(const VkTraceRaysIndirectCommand2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.raygenShaderRecordAddress, settings, "VkDeviceAddress", "raygenShaderRecordAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.raygenShaderRecordSize, settings, "VkDeviceSize", "raygenShaderRecordSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceAddress>(object.missShaderBindingTableAddress, settings, "VkDeviceAddress", "missShaderBindingTableAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.missShaderBindingTableSize, settings, "VkDeviceSize", "missShaderBindingTableSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.missShaderBindingTableStride, settings, "VkDeviceSize", "missShaderBindingTableStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceAddress>(object.hitShaderBindingTableAddress, settings, "VkDeviceAddress", "hitShaderBindingTableAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.hitShaderBindingTableSize, settings, "VkDeviceSize", "hitShaderBindingTableSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.hitShaderBindingTableStride, settings, "VkDeviceSize", "hitShaderBindingTableStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceAddress>(object.callableShaderBindingTableAddress, settings, "VkDeviceAddress", "callableShaderBindingTableAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.callableShaderBindingTableSize, settings, "VkDeviceSize", "callableShaderBindingTableSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.callableShaderBindingTableStride, settings, "VkDeviceSize", "callableShaderBindingTableStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.depth, settings, "uint32_t", "depth", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceImageViewMinLodFeaturesEXT(const VkPhysicalDeviceImageViewMinLodFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.minLod, settings, "VkBool32", "minLod", indents + 1, dump_html_VkBool32);
}
void dump_html_VkImageViewMinLodCreateInfoEXT(const VkImageViewMinLodCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const float>(object.minLod, settings, "float", "minLod", indents + 1, dump_html_float);
}
void dump_html_VkPhysicalDeviceMultiDrawFeaturesEXT(const VkPhysicalDeviceMultiDrawFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multiDraw, settings, "VkBool32", "multiDraw", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMultiDrawPropertiesEXT(const VkPhysicalDeviceMultiDrawPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxMultiDrawCount, settings, "uint32_t", "maxMultiDrawCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkMultiDrawInfoEXT(const VkMultiDrawInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.firstVertex, settings, "uint32_t", "firstVertex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vertexCount, settings, "uint32_t", "vertexCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkMultiDrawIndexedInfoEXT(const VkMultiDrawIndexedInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.firstIndex, settings, "uint32_t", "firstIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.indexCount, settings, "uint32_t", "indexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const int32_t>(object.vertexOffset, settings, "int32_t", "vertexOffset", indents + 1, dump_html_int32_t);
}
void dump_html_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.image2DViewOf3D, settings, "VkBool32", "image2DViewOf3D", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sampler2DViewOf3D, settings, "VkBool32", "sampler2DViewOf3D", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderTileImageFeaturesEXT(const VkPhysicalDeviceShaderTileImageFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderTileImageColorReadAccess, settings, "VkBool32", "shaderTileImageColorReadAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTileImageDepthReadAccess, settings, "VkBool32", "shaderTileImageDepthReadAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTileImageStencilReadAccess, settings, "VkBool32", "shaderTileImageStencilReadAccess", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderTileImagePropertiesEXT(const VkPhysicalDeviceShaderTileImagePropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderTileImageCoherentReadAccelerated, settings, "VkBool32", "shaderTileImageCoherentReadAccelerated", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTileImageReadSampleFromPixelRateInvocation, settings, "VkBool32", "shaderTileImageReadSampleFromPixelRateInvocation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTileImageReadFromHelperInvocation, settings, "VkBool32", "shaderTileImageReadFromHelperInvocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMicromapUsageEXT(const VkMicromapUsageEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.count, settings, "uint32_t", "count", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.subdivisionLevel, settings, "uint32_t", "subdivisionLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.format, settings, "uint32_t", "format", indents + 1, dump_html_uint32_t);
}
void dump_html_VkMicromapBuildInfoEXT(const VkMicromapBuildInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMicromapTypeEXT>(object.type, settings, "VkMicromapTypeEXT", "type", indents + 1, dump_html_VkMicromapTypeEXT);
    dump_html_value<const VkBuildMicromapFlagsEXT>(object.flags, settings, "VkBuildMicromapFlagsEXT", "flags", indents + 1, dump_html_VkBuildMicromapFlagsEXT);
    dump_html_value<const VkBuildMicromapModeEXT>(object.mode, settings, "VkBuildMicromapModeEXT", "mode", indents + 1, dump_html_VkBuildMicromapModeEXT);
    dump_html_value<const VkMicromapEXT>(object.dstMicromap, settings, "VkMicromapEXT", "dstMicromap", indents + 1, dump_html_VkMicromapEXT);
    dump_html_value<const uint32_t>(object.usageCountsCount, settings, "uint32_t", "usageCountsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMicromapUsageEXT>(object.pUsageCounts, object.usageCountsCount, settings, "const VkMicromapUsageEXT*", "const VkMicromapUsageEXT", "pUsageCounts", indents + 1, dump_html_VkMicromapUsageEXT); // ZRT
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.data, settings, "VkDeviceOrHostAddressConstKHR", "data", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceOrHostAddressKHR>(object.scratchData, settings, "VkDeviceOrHostAddressKHR", "scratchData", indents + 1, dump_html_VkDeviceOrHostAddressKHR);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.triangleArray, settings, "VkDeviceOrHostAddressConstKHR", "triangleArray", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.triangleArrayStride, settings, "VkDeviceSize", "triangleArrayStride", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkMicromapCreateInfoEXT(const VkMicromapCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMicromapCreateFlagsEXT>(object.createFlags, settings, "VkMicromapCreateFlagsEXT", "createFlags", indents + 1, dump_html_VkMicromapCreateFlagsEXT);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkMicromapTypeEXT>(object.type, settings, "VkMicromapTypeEXT", "type", indents + 1, dump_html_VkMicromapTypeEXT);
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
}
void dump_html_VkPhysicalDeviceOpacityMicromapFeaturesEXT(const VkPhysicalDeviceOpacityMicromapFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.micromap, settings, "VkBool32", "micromap", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.micromapCaptureReplay, settings, "VkBool32", "micromapCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.micromapHostCommands, settings, "VkBool32", "micromapHostCommands", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceOpacityMicromapPropertiesEXT(const VkPhysicalDeviceOpacityMicromapPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxOpacity2StateSubdivisionLevel, settings, "uint32_t", "maxOpacity2StateSubdivisionLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxOpacity4StateSubdivisionLevel, settings, "uint32_t", "maxOpacity4StateSubdivisionLevel", indents + 1, dump_html_uint32_t);
}
void dump_html_VkMicromapVersionInfoEXT(const VkMicromapVersionInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.pVersionData, 2*VK_UUID_SIZE, settings, "const uint8_t*", "const uint8_t", "pVersionData", indents + 1, dump_html_uint8_t); // ZRS
}
void dump_html_VkCopyMicromapToMemoryInfoEXT(const VkCopyMicromapToMemoryInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMicromapEXT>(object.src, settings, "VkMicromapEXT", "src", indents + 1, dump_html_VkMicromapEXT);
    dump_html_value<const VkDeviceOrHostAddressKHR>(object.dst, settings, "VkDeviceOrHostAddressKHR", "dst", indents + 1, dump_html_VkDeviceOrHostAddressKHR);
    dump_html_value<const VkCopyMicromapModeEXT>(object.mode, settings, "VkCopyMicromapModeEXT", "mode", indents + 1, dump_html_VkCopyMicromapModeEXT);
}
void dump_html_VkCopyMemoryToMicromapInfoEXT(const VkCopyMemoryToMicromapInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.src, settings, "VkDeviceOrHostAddressConstKHR", "src", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkMicromapEXT>(object.dst, settings, "VkMicromapEXT", "dst", indents + 1, dump_html_VkMicromapEXT);
    dump_html_value<const VkCopyMicromapModeEXT>(object.mode, settings, "VkCopyMicromapModeEXT", "mode", indents + 1, dump_html_VkCopyMicromapModeEXT);
}
void dump_html_VkCopyMicromapInfoEXT(const VkCopyMicromapInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMicromapEXT>(object.src, settings, "VkMicromapEXT", "src", indents + 1, dump_html_VkMicromapEXT);
    dump_html_value<const VkMicromapEXT>(object.dst, settings, "VkMicromapEXT", "dst", indents + 1, dump_html_VkMicromapEXT);
    dump_html_value<const VkCopyMicromapModeEXT>(object.mode, settings, "VkCopyMicromapModeEXT", "mode", indents + 1, dump_html_VkCopyMicromapModeEXT);
}
void dump_html_VkMicromapBuildSizesInfoEXT(const VkMicromapBuildSizesInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.micromapSize, settings, "VkDeviceSize", "micromapSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.buildScratchSize, settings, "VkDeviceSize", "buildScratchSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.discardable, settings, "VkBool32", "discardable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkAccelerationStructureTrianglesOpacityMicromapEXT(const VkAccelerationStructureTrianglesOpacityMicromapEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.indexBuffer, settings, "VkDeviceOrHostAddressConstKHR", "indexBuffer", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.indexStride, settings, "VkDeviceSize", "indexStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.baseTriangle, settings, "uint32_t", "baseTriangle", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.usageCountsCount, settings, "uint32_t", "usageCountsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMicromapUsageEXT>(object.pUsageCounts, object.usageCountsCount, settings, "const VkMicromapUsageEXT*", "const VkMicromapUsageEXT", "pUsageCounts", indents + 1, dump_html_VkMicromapUsageEXT); // ZRT
    dump_html_value<const VkMicromapEXT>(object.micromap, settings, "VkMicromapEXT", "micromap", indents + 1, dump_html_VkMicromapEXT);
}
void dump_html_VkMicromapTriangleEXT(const VkMicromapTriangleEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.dataOffset, settings, "uint32_t", "dataOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint16_t>(object.subdivisionLevel, settings, "uint16_t", "subdivisionLevel", indents + 1, dump_html_uint16_t);
    dump_html_value<const uint16_t>(object.format, settings, "uint16_t", "format", indents + 1, dump_html_uint16_t);
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPhysicalDeviceDisplacementMicromapFeaturesNV(const VkPhysicalDeviceDisplacementMicromapFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.displacementMicromap, settings, "VkBool32", "displacementMicromap", indents + 1, dump_html_VkBool32);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkPhysicalDeviceDisplacementMicromapPropertiesNV(const VkPhysicalDeviceDisplacementMicromapPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxDisplacementMicromapSubdivisionLevel, settings, "uint32_t", "maxDisplacementMicromapSubdivisionLevel", indents + 1, dump_html_uint32_t);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkAccelerationStructureTrianglesDisplacementMicromapNV(const VkAccelerationStructureTrianglesDisplacementMicromapNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.displacementBiasAndScaleFormat, settings, "VkFormat", "displacementBiasAndScaleFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkFormat>(object.displacementVectorFormat, settings, "VkFormat", "displacementVectorFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.displacementBiasAndScaleBuffer, settings, "VkDeviceOrHostAddressConstKHR", "displacementBiasAndScaleBuffer", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.displacementBiasAndScaleStride, settings, "VkDeviceSize", "displacementBiasAndScaleStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.displacementVectorBuffer, settings, "VkDeviceOrHostAddressConstKHR", "displacementVectorBuffer", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.displacementVectorStride, settings, "VkDeviceSize", "displacementVectorStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.displacedMicromapPrimitiveFlags, settings, "VkDeviceOrHostAddressConstKHR", "displacedMicromapPrimitiveFlags", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.displacedMicromapPrimitiveFlagsStride, settings, "VkDeviceSize", "displacedMicromapPrimitiveFlagsStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
    dump_html_value<const VkDeviceOrHostAddressConstKHR>(object.indexBuffer, settings, "VkDeviceOrHostAddressConstKHR", "indexBuffer", indents + 1, dump_html_VkDeviceOrHostAddressConstKHR);
    dump_html_value<const VkDeviceSize>(object.indexStride, settings, "VkDeviceSize", "indexStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.baseTriangle, settings, "uint32_t", "baseTriangle", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.usageCountsCount, settings, "uint32_t", "usageCountsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMicromapUsageEXT>(object.pUsageCounts, object.usageCountsCount, settings, "const VkMicromapUsageEXT*", "const VkMicromapUsageEXT", "pUsageCounts", indents + 1, dump_html_VkMicromapUsageEXT); // ZRT
    dump_html_value<const VkMicromapEXT>(object.micromap, settings, "VkMicromapEXT", "micromap", indents + 1, dump_html_VkMicromapEXT);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*pNext", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.clustercullingShader, settings, "VkBool32", "clustercullingShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewClusterCullingShader, settings, "VkBool32", "multiviewClusterCullingShader", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint32_t>(object.maxWorkGroupCount, 3, settings, "uint32_t[3]", "uint32_t", "maxWorkGroupCount", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_array<const uint32_t>(object.maxWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxWorkGroupSize", indents + 1, dump_html_uint32_t); // ZRR
    dump_html_value<const uint32_t>(object.maxOutputClusterCount, settings, "uint32_t", "maxOutputClusterCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.indirectBufferOffsetAlignment, settings, "VkDeviceSize", "indirectBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*pNext", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.clusterShadingRate, settings, "VkBool32", "clusterShadingRate", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.borderColorSwizzle, settings, "VkBool32", "borderColorSwizzle", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.borderColorSwizzleFromImage, settings, "VkBool32", "borderColorSwizzleFromImage", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSamplerBorderColorComponentMappingCreateInfoEXT(const VkSamplerBorderColorComponentMappingCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkComponentMapping>(object.components, settings, "VkComponentMapping", "components", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkBool32>(object.srgb, settings, "VkBool32", "srgb", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pageableDeviceLocalMemory, settings, "VkBool32", "pageableDeviceLocalMemory", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderCorePropertiesARM(const VkPhysicalDeviceShaderCorePropertiesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.pixelRate, settings, "uint32_t", "pixelRate", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.texelRate, settings, "uint32_t", "texelRate", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.fmaRate, settings, "uint32_t", "fmaRate", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR(const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSubgroupRotate, settings, "VkBool32", "shaderSubgroupRotate", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSubgroupRotateClustered, settings, "VkBool32", "shaderSubgroupRotateClustered", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDeviceQueueShaderCoreControlCreateInfoARM(const VkDeviceQueueShaderCoreControlCreateInfoARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderCoreCount, settings, "uint32_t", "shaderCoreCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceSchedulingControlsFeaturesARM(const VkPhysicalDeviceSchedulingControlsFeaturesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.schedulingControls, settings, "VkBool32", "schedulingControls", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceSchedulingControlsPropertiesARM(const VkPhysicalDeviceSchedulingControlsPropertiesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceSchedulingControlsFlagsARM>(object.schedulingControlsFlags, settings, "VkPhysicalDeviceSchedulingControlsFlagsARM", "schedulingControlsFlags", indents + 1, dump_html_VkPhysicalDeviceSchedulingControlsFlagsARM);
}
void dump_html_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imageSlicedViewOf3D, settings, "VkBool32", "imageSlicedViewOf3D", indents + 1, dump_html_VkBool32);
}
void dump_html_VkImageViewSlicedCreateInfoEXT(const VkImageViewSlicedCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.sliceOffset, settings, "uint32_t", "sliceOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sliceCount, settings, "uint32_t", "sliceCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.descriptorSetHostMapping, settings, "VkBool32", "descriptorSetHostMapping", indents + 1, dump_html_VkBool32);
}
void dump_html_VkDescriptorSetBindingReferenceVALVE(const VkDescriptorSetBindingReferenceVALVE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSetLayout>(object.descriptorSetLayout, settings, "VkDescriptorSetLayout", "descriptorSetLayout", indents + 1, dump_html_VkDescriptorSetLayout);
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
}
void dump_html_VkDescriptorSetLayoutHostMappingInfoVALVE(const VkDescriptorSetLayoutHostMappingInfoVALVE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const size_t>(object.descriptorOffset, settings, "size_t", "descriptorOffset", indents + 1, dump_html_size_t);
    dump_html_value<const uint32_t>(object.descriptorSize, settings, "uint32_t", "descriptorSize", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.depthClampZeroOne, settings, "VkBool32", "depthClampZeroOne", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.nonSeamlessCubeMap, settings, "VkBool32", "nonSeamlessCubeMap", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRenderPassStripedFeaturesARM(const VkPhysicalDeviceRenderPassStripedFeaturesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.renderPassStriped, settings, "VkBool32", "renderPassStriped", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRenderPassStripedPropertiesARM(const VkPhysicalDeviceRenderPassStripedPropertiesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.renderPassStripeGranularity, settings, "VkExtent2D", "renderPassStripeGranularity", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxRenderPassStripes, settings, "uint32_t", "maxRenderPassStripes", indents + 1, dump_html_uint32_t);
}
void dump_html_VkRenderPassStripeInfoARM(const VkRenderPassStripeInfoARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRect2D>(object.stripeArea, settings, "VkRect2D", "stripeArea", indents + 1, dump_html_VkRect2D);
}
void dump_html_VkRenderPassStripeBeginInfoARM(const VkRenderPassStripeBeginInfoARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stripeInfoCount, settings, "uint32_t", "stripeInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRenderPassStripeInfoARM>(object.pStripeInfos, object.stripeInfoCount, settings, "const VkRenderPassStripeInfoARM*", "const VkRenderPassStripeInfoARM", "pStripeInfos", indents + 1, dump_html_VkRenderPassStripeInfoARM); // ZRT
}
void dump_html_VkRenderPassStripeSubmitInfoARM(const VkRenderPassStripeSubmitInfoARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.stripeSemaphoreInfoCount, settings, "uint32_t", "stripeSemaphoreInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphoreSubmitInfo>(object.pStripeSemaphoreInfos, object.stripeSemaphoreInfoCount, settings, "const VkSemaphoreSubmitInfo*", "const VkSemaphoreSubmitInfo", "pStripeSemaphoreInfos", indents + 1, dump_html_VkSemaphoreSubmitInfo); // ZRT
}
void dump_html_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentDensityMapOffset, settings, "VkBool32", "fragmentDensityMapOffset", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.fragmentDensityOffsetGranularity, settings, "VkExtent2D", "fragmentDensityOffsetGranularity", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(const VkSubpassFragmentDensityMapOffsetEndInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.fragmentDensityOffsetCount, settings, "uint32_t", "fragmentDensityOffsetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkOffset2D>(object.pFragmentDensityOffsets, object.fragmentDensityOffsetCount, settings, "const VkOffset2D*", "const VkOffset2D", "pFragmentDensityOffsets", indents + 1, dump_html_VkOffset2D); // ZRT
}
void dump_html_VkCopyMemoryIndirectCommandNV(const VkCopyMemoryIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.srcAddress, settings, "VkDeviceAddress", "srcAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceAddress>(object.dstAddress, settings, "VkDeviceAddress", "dstAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
}
void dump_html_VkCopyMemoryToImageIndirectCommandNV(const VkCopyMemoryToImageIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.srcAddress, settings, "VkDeviceAddress", "srcAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const uint32_t>(object.bufferRowLength, settings, "uint32_t", "bufferRowLength", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.bufferImageHeight, settings, "uint32_t", "bufferImageHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageSubresourceLayers>(object.imageSubresource, settings, "VkImageSubresourceLayers", "imageSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.imageOffset, settings, "VkOffset3D", "imageOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.imageExtent, settings, "VkExtent3D", "imageExtent", indents + 1, dump_html_VkExtent3D);
}
void dump_html_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.indirectCopy, settings, "VkBool32", "indirectCopy", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueueFlags>(object.supportedQueues, settings, "VkQueueFlags", "supportedQueues", indents + 1, dump_html_VkQueueFlags);
}
void dump_html_VkDecompressMemoryRegionNV(const VkDecompressMemoryRegionNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.srcAddress, settings, "VkDeviceAddress", "srcAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceAddress>(object.dstAddress, settings, "VkDeviceAddress", "dstAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.compressedSize, settings, "VkDeviceSize", "compressedSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.decompressedSize, settings, "VkDeviceSize", "decompressedSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkMemoryDecompressionMethodFlagsNV>(object.decompressionMethod, settings, "VkMemoryDecompressionMethodFlagsNV", "decompressionMethod", indents + 1, dump_html_VkMemoryDecompressionMethodFlagsNV);
}
void dump_html_VkPhysicalDeviceMemoryDecompressionFeaturesNV(const VkPhysicalDeviceMemoryDecompressionFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.memoryDecompression, settings, "VkBool32", "memoryDecompression", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMemoryDecompressionPropertiesNV(const VkPhysicalDeviceMemoryDecompressionPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryDecompressionMethodFlagsNV>(object.decompressionMethods, settings, "VkMemoryDecompressionMethodFlagsNV", "decompressionMethods", indents + 1, dump_html_VkMemoryDecompressionMethodFlagsNV);
    dump_html_value<const uint64_t>(object.maxDecompressionIndirectCount, settings, "uint64_t", "maxDecompressionIndirectCount", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.deviceGeneratedCompute, settings, "VkBool32", "deviceGeneratedCompute", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.deviceGeneratedComputePipelines, settings, "VkBool32", "deviceGeneratedComputePipelines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.deviceGeneratedComputeCaptureReplay, settings, "VkBool32", "deviceGeneratedComputeCaptureReplay", indents + 1, dump_html_VkBool32);
}
void dump_html_VkComputePipelineIndirectBufferInfoNV(const VkComputePipelineIndirectBufferInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceAddress>(object.pipelineDeviceAddressCaptureReplay, settings, "VkDeviceAddress", "pipelineDeviceAddressCaptureReplay", indents + 1, dump_html_VkDeviceAddress);
}
void dump_html_VkPipelineIndirectDeviceAddressInfoNV(const VkPipelineIndirectDeviceAddressInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
}
void dump_html_VkBindPipelineIndirectCommandNV(const VkBindPipelineIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.pipelineAddress, settings, "VkDeviceAddress", "pipelineAddress", indents + 1, dump_html_VkDeviceAddress);
}
void dump_html_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(const VkPhysicalDeviceLinearColorAttachmentFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.linearColorAttachment, settings, "VkBool32", "linearColorAttachment", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderMaximalReconvergence, settings, "VkBool32", "shaderMaximalReconvergence", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imageCompressionControlSwapchain, settings, "VkBool32", "imageCompressionControlSwapchain", indents + 1, dump_html_VkBool32);
}
void dump_html_VkImageViewSampleWeightCreateInfoQCOM(const VkImageViewSampleWeightCreateInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkOffset2D>(object.filterCenter, settings, "VkOffset2D", "filterCenter", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.filterSize, settings, "VkExtent2D", "filterSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.numPhases, settings, "uint32_t", "numPhases", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceImageProcessingFeaturesQCOM(const VkPhysicalDeviceImageProcessingFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.textureSampleWeighted, settings, "VkBool32", "textureSampleWeighted", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureBoxFilter, settings, "VkBool32", "textureBoxFilter", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureBlockMatch, settings, "VkBool32", "textureBlockMatch", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageProcessingPropertiesQCOM(const VkPhysicalDeviceImageProcessingPropertiesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxWeightFilterPhases, settings, "uint32_t", "maxWeightFilterPhases", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.maxWeightFilterDimension, settings, "VkExtent2D", "maxWeightFilterDimension", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxBlockMatchRegion, settings, "VkExtent2D", "maxBlockMatchRegion", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxBoxFilterBlockSize, settings, "VkExtent2D", "maxBoxFilterBlockSize", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(const VkPhysicalDeviceNestedCommandBufferFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.nestedCommandBuffer, settings, "VkBool32", "nestedCommandBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.nestedCommandBufferRendering, settings, "VkBool32", "nestedCommandBufferRendering", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.nestedCommandBufferSimultaneousUse, settings, "VkBool32", "nestedCommandBufferSimultaneousUse", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(const VkPhysicalDeviceNestedCommandBufferPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxCommandBufferNestingLevel, settings, "uint32_t", "maxCommandBufferNestingLevel", indents + 1, dump_html_uint32_t);
}
void dump_html_VkExternalMemoryAcquireUnmodifiedEXT(const VkExternalMemoryAcquireUnmodifiedEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.acquireUnmodifiedMemory, settings, "VkBool32", "acquireUnmodifiedMemory", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.extendedDynamicState3TessellationDomainOrigin, settings, "VkBool32", "extendedDynamicState3TessellationDomainOrigin", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3DepthClampEnable, settings, "VkBool32", "extendedDynamicState3DepthClampEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3PolygonMode, settings, "VkBool32", "extendedDynamicState3PolygonMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3RasterizationSamples, settings, "VkBool32", "extendedDynamicState3RasterizationSamples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3SampleMask, settings, "VkBool32", "extendedDynamicState3SampleMask", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3AlphaToCoverageEnable, settings, "VkBool32", "extendedDynamicState3AlphaToCoverageEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3AlphaToOneEnable, settings, "VkBool32", "extendedDynamicState3AlphaToOneEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3LogicOpEnable, settings, "VkBool32", "extendedDynamicState3LogicOpEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ColorBlendEnable, settings, "VkBool32", "extendedDynamicState3ColorBlendEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ColorBlendEquation, settings, "VkBool32", "extendedDynamicState3ColorBlendEquation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ColorWriteMask, settings, "VkBool32", "extendedDynamicState3ColorWriteMask", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3RasterizationStream, settings, "VkBool32", "extendedDynamicState3RasterizationStream", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ConservativeRasterizationMode, settings, "VkBool32", "extendedDynamicState3ConservativeRasterizationMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ExtraPrimitiveOverestimationSize, settings, "VkBool32", "extendedDynamicState3ExtraPrimitiveOverestimationSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3DepthClipEnable, settings, "VkBool32", "extendedDynamicState3DepthClipEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3SampleLocationsEnable, settings, "VkBool32", "extendedDynamicState3SampleLocationsEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ColorBlendAdvanced, settings, "VkBool32", "extendedDynamicState3ColorBlendAdvanced", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ProvokingVertexMode, settings, "VkBool32", "extendedDynamicState3ProvokingVertexMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3LineRasterizationMode, settings, "VkBool32", "extendedDynamicState3LineRasterizationMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3LineStippleEnable, settings, "VkBool32", "extendedDynamicState3LineStippleEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3DepthClipNegativeOneToOne, settings, "VkBool32", "extendedDynamicState3DepthClipNegativeOneToOne", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ViewportWScalingEnable, settings, "VkBool32", "extendedDynamicState3ViewportWScalingEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ViewportSwizzle, settings, "VkBool32", "extendedDynamicState3ViewportSwizzle", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3CoverageToColorEnable, settings, "VkBool32", "extendedDynamicState3CoverageToColorEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3CoverageToColorLocation, settings, "VkBool32", "extendedDynamicState3CoverageToColorLocation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3CoverageModulationMode, settings, "VkBool32", "extendedDynamicState3CoverageModulationMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3CoverageModulationTableEnable, settings, "VkBool32", "extendedDynamicState3CoverageModulationTableEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3CoverageModulationTable, settings, "VkBool32", "extendedDynamicState3CoverageModulationTable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3CoverageReductionMode, settings, "VkBool32", "extendedDynamicState3CoverageReductionMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3RepresentativeFragmentTestEnable, settings, "VkBool32", "extendedDynamicState3RepresentativeFragmentTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.extendedDynamicState3ShadingRateImageEnable, settings, "VkBool32", "extendedDynamicState3ShadingRateImageEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dynamicPrimitiveTopologyUnrestricted, settings, "VkBool32", "dynamicPrimitiveTopologyUnrestricted", indents + 1, dump_html_VkBool32);
}
void dump_html_VkColorBlendEquationEXT(const VkColorBlendEquationEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBlendFactor>(object.srcColorBlendFactor, settings, "VkBlendFactor", "srcColorBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendFactor>(object.dstColorBlendFactor, settings, "VkBlendFactor", "dstColorBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendOp>(object.colorBlendOp, settings, "VkBlendOp", "colorBlendOp", indents + 1, dump_html_VkBlendOp);
    dump_html_value<const VkBlendFactor>(object.srcAlphaBlendFactor, settings, "VkBlendFactor", "srcAlphaBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendFactor>(object.dstAlphaBlendFactor, settings, "VkBlendFactor", "dstAlphaBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendOp>(object.alphaBlendOp, settings, "VkBlendOp", "alphaBlendOp", indents + 1, dump_html_VkBlendOp);
}
void dump_html_VkColorBlendAdvancedEXT(const VkColorBlendAdvancedEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBlendOp>(object.advancedBlendOp, settings, "VkBlendOp", "advancedBlendOp", indents + 1, dump_html_VkBlendOp);
    dump_html_value<const VkBool32>(object.srcPremultiplied, settings, "VkBool32", "srcPremultiplied", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dstPremultiplied, settings, "VkBool32", "dstPremultiplied", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBlendOverlapEXT>(object.blendOverlap, settings, "VkBlendOverlapEXT", "blendOverlap", indents + 1, dump_html_VkBlendOverlapEXT);
    dump_html_value<const VkBool32>(object.clampResults, settings, "VkBool32", "clampResults", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.subpassMergeFeedback, settings, "VkBool32", "subpassMergeFeedback", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderPassCreationControlEXT(const VkRenderPassCreationControlEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.disallowMerging, settings, "VkBool32", "disallowMerging", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderPassCreationFeedbackInfoEXT(const VkRenderPassCreationFeedbackInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.postMergeSubpassCount, settings, "uint32_t", "postMergeSubpassCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkRenderPassCreationFeedbackCreateInfoEXT(const VkRenderPassCreationFeedbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkRenderPassCreationFeedbackInfoEXT>(object.pRenderPassFeedback, settings, "VkRenderPassCreationFeedbackInfoEXT*", "pRenderPassFeedback", indents + 1, dump_html_VkRenderPassCreationFeedbackInfoEXT);
}
void dump_html_VkRenderPassSubpassFeedbackInfoEXT(const VkRenderPassSubpassFeedbackInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSubpassMergeStatusEXT>(object.subpassMergeStatus, settings, "VkSubpassMergeStatusEXT", "subpassMergeStatus", indents + 1, dump_html_VkSubpassMergeStatusEXT);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.postMergeIndex, settings, "uint32_t", "postMergeIndex", indents + 1, dump_html_uint32_t);
}
void dump_html_VkRenderPassSubpassFeedbackCreateInfoEXT(const VkRenderPassSubpassFeedbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkRenderPassSubpassFeedbackInfoEXT>(object.pSubpassFeedback, settings, "VkRenderPassSubpassFeedbackInfoEXT*", "pSubpassFeedback", indents + 1, dump_html_VkRenderPassSubpassFeedbackInfoEXT);
}
void dump_html_VkDirectDriverLoadingInfoLUNARG(const VkDirectDriverLoadingInfoLUNARG& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDirectDriverLoadingFlagsLUNARG>(object.flags, settings, "VkDirectDriverLoadingFlagsLUNARG", "flags", indents + 1, dump_html_VkDirectDriverLoadingFlagsLUNARG);
    dump_html_value<const PFN_vkGetInstanceProcAddrLUNARG>(object.pfnGetInstanceProcAddr, settings, "PFN_vkGetInstanceProcAddrLUNARG", "pfnGetInstanceProcAddr", indents + 1, dump_html_PFN_vkGetInstanceProcAddrLUNARG);
}
void dump_html_VkDirectDriverLoadingListLUNARG(const VkDirectDriverLoadingListLUNARG& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDirectDriverLoadingModeLUNARG>(object.mode, settings, "VkDirectDriverLoadingModeLUNARG", "mode", indents + 1, dump_html_VkDirectDriverLoadingModeLUNARG);
    dump_html_value<const uint32_t>(object.driverCount, settings, "uint32_t", "driverCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDirectDriverLoadingInfoLUNARG>(object.pDrivers, object.driverCount, settings, "const VkDirectDriverLoadingInfoLUNARG*", "const VkDirectDriverLoadingInfoLUNARG", "pDrivers", indents + 1, dump_html_VkDirectDriverLoadingInfoLUNARG); // ZRT
}
void dump_html_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderModuleIdentifier, settings, "VkBool32", "shaderModuleIdentifier", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.shaderModuleIdentifierAlgorithmUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "shaderModuleIdentifierAlgorithmUUID", indents + 1, dump_html_uint8_t); // ZRR
}
void dump_html_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(const VkPipelineShaderStageModuleIdentifierCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.identifierSize, settings, "uint32_t", "identifierSize", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint8_t>(object.pIdentifier, object.identifierSize, settings, "const uint8_t*", "const uint8_t", "pIdentifier", indents + 1, dump_html_uint8_t); // ZRT
}
void dump_html_VkShaderModuleIdentifierEXT(const VkShaderModuleIdentifierEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.identifierSize, settings, "uint32_t", "identifierSize", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint8_t>(object.identifier, 32, settings, "uint8_t[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]", "uint8_t", "identifier", indents + 1, dump_html_uint8_t); // ZRR
}
void dump_html_VkPhysicalDeviceOpticalFlowFeaturesNV(const VkPhysicalDeviceOpticalFlowFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.opticalFlow, settings, "VkBool32", "opticalFlow", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceOpticalFlowPropertiesNV(const VkPhysicalDeviceOpticalFlowPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkOpticalFlowGridSizeFlagsNV>(object.supportedOutputGridSizes, settings, "VkOpticalFlowGridSizeFlagsNV", "supportedOutputGridSizes", indents + 1, dump_html_VkOpticalFlowGridSizeFlagsNV);
    dump_html_value<const VkOpticalFlowGridSizeFlagsNV>(object.supportedHintGridSizes, settings, "VkOpticalFlowGridSizeFlagsNV", "supportedHintGridSizes", indents + 1, dump_html_VkOpticalFlowGridSizeFlagsNV);
    dump_html_value<const VkBool32>(object.hintSupported, settings, "VkBool32", "hintSupported", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.costSupported, settings, "VkBool32", "costSupported", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bidirectionalFlowSupported, settings, "VkBool32", "bidirectionalFlowSupported", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.globalFlowSupported, settings, "VkBool32", "globalFlowSupported", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.minWidth, settings, "uint32_t", "minWidth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minHeight, settings, "uint32_t", "minHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxWidth, settings, "uint32_t", "maxWidth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxHeight, settings, "uint32_t", "maxHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxNumRegionsOfInterest, settings, "uint32_t", "maxNumRegionsOfInterest", indents + 1, dump_html_uint32_t);
}
void dump_html_VkOpticalFlowImageFormatInfoNV(const VkOpticalFlowImageFormatInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkOpticalFlowUsageFlagsNV>(object.usage, settings, "VkOpticalFlowUsageFlagsNV", "usage", indents + 1, dump_html_VkOpticalFlowUsageFlagsNV);
}
void dump_html_VkOpticalFlowImageFormatPropertiesNV(const VkOpticalFlowImageFormatPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
}
void dump_html_VkOpticalFlowSessionCreateInfoNV(const VkOpticalFlowSessionCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormat>(object.imageFormat, settings, "VkFormat", "imageFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkFormat>(object.flowVectorFormat, settings, "VkFormat", "flowVectorFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkFormat>(object.costFormat, settings, "VkFormat", "costFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkOpticalFlowGridSizeFlagsNV>(object.outputGridSize, settings, "VkOpticalFlowGridSizeFlagsNV", "outputGridSize", indents + 1, dump_html_VkOpticalFlowGridSizeFlagsNV);
    dump_html_value<const VkOpticalFlowGridSizeFlagsNV>(object.hintGridSize, settings, "VkOpticalFlowGridSizeFlagsNV", "hintGridSize", indents + 1, dump_html_VkOpticalFlowGridSizeFlagsNV);
    dump_html_value<const VkOpticalFlowPerformanceLevelNV>(object.performanceLevel, settings, "VkOpticalFlowPerformanceLevelNV", "performanceLevel", indents + 1, dump_html_VkOpticalFlowPerformanceLevelNV);
    dump_html_value<const VkOpticalFlowSessionCreateFlagsNV>(object.flags, settings, "VkOpticalFlowSessionCreateFlagsNV", "flags", indents + 1, dump_html_VkOpticalFlowSessionCreateFlagsNV);
}
void dump_html_VkOpticalFlowSessionCreatePrivateDataInfoNV(const VkOpticalFlowSessionCreatePrivateDataInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.id, settings, "uint32_t", "id", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.size, settings, "uint32_t", "size", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pPrivateData, settings, "const void*", "pPrivateData", indents + 1, dump_html_void);
}
void dump_html_VkOpticalFlowExecuteInfoNV(const VkOpticalFlowExecuteInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkOpticalFlowExecuteFlagsNV>(object.flags, settings, "VkOpticalFlowExecuteFlagsNV", "flags", indents + 1, dump_html_VkOpticalFlowExecuteFlagsNV);
    dump_html_value<const uint32_t>(object.regionCount, settings, "uint32_t", "regionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pRegions, object.regionCount, settings, "const VkRect2D*", "const VkRect2D", "pRegions", indents + 1, dump_html_VkRect2D); // ZRT
}
void dump_html_VkPhysicalDeviceLegacyDitheringFeaturesEXT(const VkPhysicalDeviceLegacyDitheringFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.legacyDithering, settings, "VkBool32", "legacyDithering", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineProtectedAccess, settings, "VkBool32", "pipelineProtectedAccess", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.externalFormatResolve, settings, "VkBool32", "externalFormatResolve", indents + 1, dump_html_VkBool32);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.nullColorAttachmentWithExternalFormatResolve, settings, "VkBool32", "nullColorAttachmentWithExternalFormatResolve", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkChromaLocation>(object.externalFormatResolveChromaOffsetX, settings, "VkChromaLocation", "externalFormatResolveChromaOffsetX", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.externalFormatResolveChromaOffsetY, settings, "VkChromaLocation", "externalFormatResolveChromaOffsetY", indents + 1, dump_html_VkChromaLocation);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(const VkAndroidHardwareBufferFormatResolvePropertiesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.colorAttachmentFormat, settings, "VkFormat", "colorAttachmentFormat", indents + 1, dump_html_VkFormat);
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
void dump_html_VkPhysicalDeviceMaintenance5FeaturesKHR(const VkPhysicalDeviceMaintenance5FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.maintenance5, settings, "VkBool32", "maintenance5", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMaintenance5PropertiesKHR(const VkPhysicalDeviceMaintenance5PropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.earlyFragmentMultisampleCoverageAfterSampleCounting, settings, "VkBool32", "earlyFragmentMultisampleCoverageAfterSampleCounting", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.earlyFragmentSampleMaskTestBeforeSampleCounting, settings, "VkBool32", "earlyFragmentSampleMaskTestBeforeSampleCounting", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthStencilSwizzleOneSupport, settings, "VkBool32", "depthStencilSwizzleOneSupport", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.polygonModePointSize, settings, "VkBool32", "polygonModePointSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.nonStrictSinglePixelWideLinesUseParallelogram, settings, "VkBool32", "nonStrictSinglePixelWideLinesUseParallelogram", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.nonStrictWideLinesUseParallelogram, settings, "VkBool32", "nonStrictWideLinesUseParallelogram", indents + 1, dump_html_VkBool32);
}
void dump_html_VkRenderingAreaInfoKHR(const VkRenderingAreaInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.viewMask, settings, "uint32_t", "viewMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFormat>(object.pColorAttachmentFormats, object.colorAttachmentCount, settings, "const VkFormat*", "const VkFormat", "pColorAttachmentFormats", indents + 1, dump_html_VkFormat); // ZRT
    dump_html_value<const VkFormat>(object.depthAttachmentFormat, settings, "VkFormat", "depthAttachmentFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkFormat>(object.stencilAttachmentFormat, settings, "VkFormat", "stencilAttachmentFormat", indents + 1, dump_html_VkFormat);
}
void dump_html_VkDeviceImageSubresourceInfoKHR(const VkDeviceImageSubresourceInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkImageCreateInfo>(object.pCreateInfo, settings, "const VkImageCreateInfo*", "pCreateInfo", indents + 1, dump_html_VkImageCreateInfo);
    dump_html_pointer<const VkImageSubresource2KHR>(object.pSubresource, settings, "const VkImageSubresource2KHR*", "pSubresource", indents + 1, dump_html_VkImageSubresource2KHR);
}
void dump_html_VkPipelineCreateFlags2CreateInfoKHR(const VkPipelineCreateFlags2CreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags2KHR>(object.flags, settings, "VkPipelineCreateFlags2KHR", "flags", indents + 1, dump_html_VkPipelineCreateFlags2KHR);
}
void dump_html_VkBufferUsageFlags2CreateInfoKHR(const VkBufferUsageFlags2CreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferUsageFlags2KHR>(object.usage, settings, "VkBufferUsageFlags2KHR", "usage", indents + 1, dump_html_VkBufferUsageFlags2KHR);
}
void dump_html_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayTracingPositionFetch, settings, "VkBool32", "rayTracingPositionFetch", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderObjectFeaturesEXT(const VkPhysicalDeviceShaderObjectFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderObject, settings, "VkBool32", "shaderObject", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderObjectPropertiesEXT(const VkPhysicalDeviceShaderObjectPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.shaderBinaryUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "shaderBinaryUUID", indents + 1, dump_html_uint8_t); // ZRR
    dump_html_value<const uint32_t>(object.shaderBinaryVersion, settings, "uint32_t", "shaderBinaryVersion", indents + 1, dump_html_uint32_t);
}
void dump_html_VkShaderCreateInfoEXT(const VkShaderCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderCreateFlagsEXT>(object.flags, settings, "VkShaderCreateFlagsEXT", "flags", indents + 1, dump_html_VkShaderCreateFlagsEXT);
    dump_html_value<const VkShaderStageFlagBits>(object.stage, settings, "VkShaderStageFlagBits", "stage", indents + 1, dump_html_VkShaderStageFlagBits);
    dump_html_value<const VkShaderStageFlags>(object.nextStage, settings, "VkShaderStageFlags", "nextStage", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkShaderCodeTypeEXT>(object.codeType, settings, "VkShaderCodeTypeEXT", "codeType", indents + 1, dump_html_VkShaderCodeTypeEXT);
    dump_html_value<const size_t>(object.codeSize, settings, "size_t", "codeSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pCode, settings, "const void*", "pCode", indents + 1, dump_html_void);
    dump_html_value<const char*>(object.pName, settings, "const char*", "pName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.setLayoutCount, settings, "uint32_t", "setLayoutCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayout>(object.pSetLayouts, object.setLayoutCount, settings, "const VkDescriptorSetLayout*", "const VkDescriptorSetLayout", "pSetLayouts", indents + 1, dump_html_VkDescriptorSetLayout); // ZRT
    dump_html_value<const uint32_t>(object.pushConstantRangeCount, settings, "uint32_t", "pushConstantRangeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPushConstantRange>(object.pPushConstantRanges, object.pushConstantRangeCount, settings, "const VkPushConstantRange*", "const VkPushConstantRange", "pPushConstantRanges", indents + 1, dump_html_VkPushConstantRange); // ZRT
    dump_html_pointer<const VkSpecializationInfo>(object.pSpecializationInfo, settings, "const VkSpecializationInfo*", "pSpecializationInfo", indents + 1, dump_html_VkSpecializationInfo);
}
void dump_html_VkPhysicalDeviceTilePropertiesFeaturesQCOM(const VkPhysicalDeviceTilePropertiesFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.tileProperties, settings, "VkBool32", "tileProperties", indents + 1, dump_html_VkBool32);
}
void dump_html_VkTilePropertiesQCOM(const VkTilePropertiesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent3D>(object.tileSize, settings, "VkExtent3D", "tileSize", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const VkExtent2D>(object.apronSize, settings, "VkExtent2D", "apronSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkOffset2D>(object.origin, settings, "VkOffset2D", "origin", indents + 1, dump_html_VkOffset2D);
}
void dump_html_VkPhysicalDeviceAmigoProfilingFeaturesSEC(const VkPhysicalDeviceAmigoProfilingFeaturesSEC& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.amigoProfiling, settings, "VkBool32", "amigoProfiling", indents + 1, dump_html_VkBool32);
}
void dump_html_VkAmigoProfilingSubmitInfoSEC(const VkAmigoProfilingSubmitInfoSEC& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.firstDrawTimestamp, settings, "uint64_t", "firstDrawTimestamp", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.swapBufferTimestamp, settings, "uint64_t", "swapBufferTimestamp", indents + 1, dump_html_uint64_t);
}
void dump_html_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multiviewPerViewViewports, settings, "VkBool32", "multiviewPerViewViewports", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRayTracingInvocationReorderModeNV>(object.rayTracingInvocationReorderReorderingHint, settings, "VkRayTracingInvocationReorderModeNV", "rayTracingInvocationReorderReorderingHint", indents + 1, dump_html_VkRayTracingInvocationReorderModeNV);
}
void dump_html_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayTracingInvocationReorder, settings, "VkBool32", "rayTracingInvocationReorder", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.extendedSparseAddressSpace, settings, "VkBool32", "extendedSparseAddressSpace", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.extendedSparseAddressSpaceSize, settings, "VkDeviceSize", "extendedSparseAddressSpaceSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkImageUsageFlags>(object.extendedSparseImageUsageFlags, settings, "VkImageUsageFlags", "extendedSparseImageUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkBufferUsageFlags>(object.extendedSparseBufferUsageFlags, settings, "VkBufferUsageFlags", "extendedSparseBufferUsageFlags", indents + 1, dump_html_VkBufferUsageFlags);
}
void dump_html_VkLayerSettingEXT(const VkLayerSettingEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const char*>(object.pLayerName, settings, "const char*", "pLayerName", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.pSettingName, settings, "const char*", "pSettingName", indents + 1, dump_html_cstring);
    dump_html_value<const VkLayerSettingTypeEXT>(object.type, settings, "VkLayerSettingTypeEXT", "type", indents + 1, dump_html_VkLayerSettingTypeEXT);
    dump_html_value<const uint32_t>(object.valueCount, settings, "uint32_t", "valueCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pValues, settings, "const void*", "pValues", indents + 1, dump_html_void);
}
void dump_html_VkLayerSettingsCreateInfoEXT(const VkLayerSettingsCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.settingCount, settings, "uint32_t", "settingCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkLayerSettingEXT>(object.pSettings, object.settingCount, settings, "const VkLayerSettingEXT*", "const VkLayerSettingEXT", "pSettings", indents + 1, dump_html_VkLayerSettingEXT); // ZRT
}
void dump_html_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderCoreBuiltins, settings, "VkBool32", "shaderCoreBuiltins", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.shaderCoreMask, settings, "uint64_t", "shaderCoreMask", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.shaderCoreCount, settings, "uint32_t", "shaderCoreCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderWarpsPerCore, settings, "uint32_t", "shaderWarpsPerCore", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineLibraryGroupHandles, settings, "VkBool32", "pipelineLibraryGroupHandles", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dynamicRenderingUnusedAttachments, settings, "VkBool32", "dynamicRenderingUnusedAttachments", indents + 1, dump_html_VkBool32);
}
void dump_html_VkLatencySleepModeInfoNV(const VkLatencySleepModeInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.lowLatencyMode, settings, "VkBool32", "lowLatencyMode", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.lowLatencyBoost, settings, "VkBool32", "lowLatencyBoost", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.minimumIntervalUs, settings, "uint32_t", "minimumIntervalUs", indents + 1, dump_html_uint32_t);
}
void dump_html_VkLatencySleepInfoNV(const VkLatencySleepInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.signalSemaphore, settings, "VkSemaphore", "signalSemaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const uint64_t>(object.value, settings, "uint64_t", "value", indents + 1, dump_html_uint64_t);
}
void dump_html_VkSetLatencyMarkerInfoNV(const VkSetLatencyMarkerInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.presentID, settings, "uint64_t", "presentID", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkLatencyMarkerNV>(object.marker, settings, "VkLatencyMarkerNV", "marker", indents + 1, dump_html_VkLatencyMarkerNV);
}
void dump_html_VkLatencyTimingsFrameReportNV(const VkLatencyTimingsFrameReportNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.presentID, settings, "uint64_t", "presentID", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.inputSampleTimeUs, settings, "uint64_t", "inputSampleTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.simStartTimeUs, settings, "uint64_t", "simStartTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.simEndTimeUs, settings, "uint64_t", "simEndTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.renderSubmitStartTimeUs, settings, "uint64_t", "renderSubmitStartTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.renderSubmitEndTimeUs, settings, "uint64_t", "renderSubmitEndTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.presentStartTimeUs, settings, "uint64_t", "presentStartTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.presentEndTimeUs, settings, "uint64_t", "presentEndTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.driverStartTimeUs, settings, "uint64_t", "driverStartTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.driverEndTimeUs, settings, "uint64_t", "driverEndTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.osRenderQueueStartTimeUs, settings, "uint64_t", "osRenderQueueStartTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.osRenderQueueEndTimeUs, settings, "uint64_t", "osRenderQueueEndTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.gpuRenderStartTimeUs, settings, "uint64_t", "gpuRenderStartTimeUs", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.gpuRenderEndTimeUs, settings, "uint64_t", "gpuRenderEndTimeUs", indents + 1, dump_html_uint64_t);
}
void dump_html_VkGetLatencyMarkerInfoNV(const VkGetLatencyMarkerInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.timingCount, settings, "uint32_t", "timingCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkLatencyTimingsFrameReportNV>(object.pTimings, object.timingCount, settings, "VkLatencyTimingsFrameReportNV*", "VkLatencyTimingsFrameReportNV", "pTimings", indents + 1, dump_html_VkLatencyTimingsFrameReportNV); // ZRT
}
void dump_html_VkLatencySubmissionPresentIdNV(const VkLatencySubmissionPresentIdNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.presentID, settings, "uint64_t", "presentID", indents + 1, dump_html_uint64_t);
}
void dump_html_VkSwapchainLatencyCreateInfoNV(const VkSwapchainLatencyCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.latencyModeEnable, settings, "VkBool32", "latencyModeEnable", indents + 1, dump_html_VkBool32);
}
void dump_html_VkOutOfBandQueueTypeInfoNV(const VkOutOfBandQueueTypeInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkOutOfBandQueueTypeNV>(object.queueType, settings, "VkOutOfBandQueueTypeNV", "queueType", indents + 1, dump_html_VkOutOfBandQueueTypeNV);
}
void dump_html_VkLatencySurfaceCapabilitiesNV(const VkLatencySurfaceCapabilitiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.presentModeCount, settings, "uint32_t", "presentModeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentModeKHR>(object.pPresentModes, object.presentModeCount, settings, "VkPresentModeKHR*", "VkPresentModeKHR", "pPresentModes", indents + 1, dump_html_VkPresentModeKHR); // ZRT
}
void dump_html_VkCooperativeMatrixPropertiesKHR(const VkCooperativeMatrixPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.MSize, settings, "uint32_t", "MSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.NSize, settings, "uint32_t", "NSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.KSize, settings, "uint32_t", "KSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkComponentTypeKHR>(object.AType, settings, "VkComponentTypeKHR", "AType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkComponentTypeKHR>(object.BType, settings, "VkComponentTypeKHR", "BType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkComponentTypeKHR>(object.CType, settings, "VkComponentTypeKHR", "CType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkComponentTypeKHR>(object.ResultType, settings, "VkComponentTypeKHR", "ResultType", indents + 1, dump_html_VkComponentTypeKHR);
    dump_html_value<const VkBool32>(object.saturatingAccumulation, settings, "VkBool32", "saturatingAccumulation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkScopeKHR>(object.scope, settings, "VkScopeKHR", "scope", indents + 1, dump_html_VkScopeKHR);
}
void dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(const VkPhysicalDeviceCooperativeMatrixFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cooperativeMatrix, settings, "VkBool32", "cooperativeMatrix", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.cooperativeMatrixRobustBufferAccess, settings, "VkBool32", "cooperativeMatrixRobustBufferAccess", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(const VkPhysicalDeviceCooperativeMatrixPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.cooperativeMatrixSupportedStages, settings, "VkShaderStageFlags", "cooperativeMatrixSupportedStages", indents + 1, dump_html_VkShaderStageFlags);
}
void dump_html_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multiviewPerViewRenderAreas, settings, "VkBool32", "multiviewPerViewRenderAreas", indents + 1, dump_html_VkBool32);
}
void dump_html_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.perViewRenderAreaCount, settings, "uint32_t", "perViewRenderAreaCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pPerViewRenderAreas, object.perViewRenderAreaCount, settings, "const VkRect2D*", "const VkRect2D", "pPerViewRenderAreas", indents + 1, dump_html_VkRect2D); // ZRT
}
void dump_html_VkVideoDecodeAV1ProfileInfoKHR(const VkVideoDecodeAV1ProfileInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoAV1Profile>(object.stdProfile, settings, "StdVideoAV1Profile", "stdProfile", indents + 1, dump_html_StdVideoAV1Profile);
    dump_html_value<const VkBool32>(object.filmGrainSupport, settings, "VkBool32", "filmGrainSupport", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoDecodeAV1CapabilitiesKHR(const VkVideoDecodeAV1CapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const StdVideoAV1Level>(object.maxLevel, settings, "StdVideoAV1Level", "maxLevel", indents + 1, dump_html_StdVideoAV1Level);
}
void dump_html_VkVideoDecodeAV1SessionParametersCreateInfoKHR(const VkVideoDecodeAV1SessionParametersCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoAV1SequenceHeader>(object.pStdSequenceHeader, settings, "const StdVideoAV1SequenceHeader*", "pStdSequenceHeader", indents + 1, dump_html_StdVideoAV1SequenceHeader);
}
void dump_html_VkVideoDecodeAV1PictureInfoKHR(const VkVideoDecodeAV1PictureInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoDecodeAV1PictureInfo>(object.pStdPictureInfo, settings, "const StdVideoDecodeAV1PictureInfo*", "pStdPictureInfo", indents + 1, dump_html_StdVideoDecodeAV1PictureInfo);
    dump_html_array<const int32_t>(object.referenceNameSlotIndices, 7, settings, "int32_t[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]", "int32_t", "referenceNameSlotIndices", indents + 1, dump_html_int32_t); // ZRR
    dump_html_value<const uint32_t>(object.frameHeaderOffset, settings, "uint32_t", "frameHeaderOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.tileCount, settings, "uint32_t", "tileCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pTileOffsets, object.tileCount, settings, "const uint32_t*", "const uint32_t", "pTileOffsets", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_array<const uint32_t>(object.pTileSizes, object.tileCount, settings, "const uint32_t*", "const uint32_t", "pTileSizes", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkVideoDecodeAV1DpbSlotInfoKHR(const VkVideoDecodeAV1DpbSlotInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const StdVideoDecodeAV1ReferenceInfo>(object.pStdReferenceInfo, settings, "const StdVideoDecodeAV1ReferenceInfo*", "pStdReferenceInfo", indents + 1, dump_html_StdVideoDecodeAV1ReferenceInfo);
}
void dump_html_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(const VkPhysicalDeviceVideoMaintenance1FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.videoMaintenance1, settings, "VkBool32", "videoMaintenance1", indents + 1, dump_html_VkBool32);
}
void dump_html_VkVideoInlineQueryInfoKHR(const VkVideoInlineQueryInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueryPool>(object.queryPool, settings, "VkQueryPool", "queryPool", indents + 1, dump_html_VkQueryPool);
    dump_html_value<const uint32_t>(object.firstQuery, settings, "uint32_t", "firstQuery", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.queryCount, settings, "uint32_t", "queryCount", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(const VkPhysicalDevicePerStageDescriptorSetFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.perStageDescriptorSet, settings, "VkBool32", "perStageDescriptorSet", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dynamicPipelineLayout, settings, "VkBool32", "dynamicPipelineLayout", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageProcessing2FeaturesQCOM(const VkPhysicalDeviceImageProcessing2FeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.textureBlockMatch2, settings, "VkBool32", "textureBlockMatch2", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceImageProcessing2PropertiesQCOM(const VkPhysicalDeviceImageProcessing2PropertiesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.maxBlockMatchWindow, settings, "VkExtent2D", "maxBlockMatchWindow", indents + 1, dump_html_VkExtent2D);
}
void dump_html_VkSamplerBlockMatchWindowCreateInfoQCOM(const VkSamplerBlockMatchWindowCreateInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.windowExtent, settings, "VkExtent2D", "windowExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkBlockMatchWindowCompareModeQCOM>(object.windowCompareMode, settings, "VkBlockMatchWindowCompareModeQCOM", "windowCompareMode", indents + 1, dump_html_VkBlockMatchWindowCompareModeQCOM);
}
void dump_html_VkPhysicalDeviceCubicWeightsFeaturesQCOM(const VkPhysicalDeviceCubicWeightsFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.selectableCubicWeights, settings, "VkBool32", "selectableCubicWeights", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSamplerCubicWeightsCreateInfoQCOM(const VkSamplerCubicWeightsCreateInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCubicFilterWeightsQCOM>(object.cubicWeights, settings, "VkCubicFilterWeightsQCOM", "cubicWeights", indents + 1, dump_html_VkCubicFilterWeightsQCOM);
}
void dump_html_VkBlitImageCubicWeightsInfoQCOM(const VkBlitImageCubicWeightsInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCubicFilterWeightsQCOM>(object.cubicWeights, settings, "VkCubicFilterWeightsQCOM", "cubicWeights", indents + 1, dump_html_VkCubicFilterWeightsQCOM);
}
void dump_html_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.ycbcrDegamma, settings, "VkBool32", "ycbcrDegamma", indents + 1, dump_html_VkBool32);
}
void dump_html_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.enableYDegamma, settings, "VkBool32", "enableYDegamma", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.enableCbCrDegamma, settings, "VkBool32", "enableCbCrDegamma", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceCubicClampFeaturesQCOM(const VkPhysicalDeviceCubicClampFeaturesQCOM& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cubicRangeClamp, settings, "VkBool32", "cubicRangeClamp", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.attachmentFeedbackLoopDynamicState, settings, "VkBool32", "attachmentFeedbackLoopDynamicState", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR(const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxVertexAttribDivisor, settings, "uint32_t", "maxVertexAttribDivisor", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.supportsNonZeroFirstInstance, settings, "VkBool32", "supportsNonZeroFirstInstance", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderFloatControls2FeaturesKHR(const VkPhysicalDeviceShaderFloatControls2FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderFloatControls2, settings, "VkBool32", "shaderFloatControls2", indents + 1, dump_html_VkBool32);
}
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkScreenBufferPropertiesQNX(const VkScreenBufferPropertiesQNX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.allocationSize, settings, "VkDeviceSize", "allocationSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkScreenBufferFormatPropertiesQNX(const VkScreenBufferFormatPropertiesQNX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.screenUsage, settings, "uint64_t", "screenUsage", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkFormatFeatureFlags>(object.formatFeatures, settings, "VkFormatFeatureFlags", "formatFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkComponentMapping>(object.samplerYcbcrConversionComponents, settings, "VkComponentMapping", "samplerYcbcrConversionComponents", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.suggestedYcbcrModel, settings, "VkSamplerYcbcrModelConversion", "suggestedYcbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.suggestedYcbcrRange, settings, "VkSamplerYcbcrRange", "suggestedYcbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkChromaLocation>(object.suggestedXChromaOffset, settings, "VkChromaLocation", "suggestedXChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.suggestedYChromaOffset, settings, "VkChromaLocation", "suggestedYChromaOffset", indents + 1, dump_html_VkChromaLocation);
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkImportScreenBufferInfoQNX(const VkImportScreenBufferInfoQNX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const _screen_buffer*>(object.buffer, settings, "struct _screen_buffer*", "buffer", indents + 1, dump_html__screen_buffer);
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkExternalFormatQNX(const VkExternalFormatQNX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.screenBufferImport, settings, "VkBool32", "screenBufferImport", indents + 1, dump_html_VkBool32);
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
void dump_html_VkPhysicalDeviceLayeredDriverPropertiesMSFT(const VkPhysicalDeviceLayeredDriverPropertiesMSFT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkLayeredDriverUnderlyingApiMSFT>(object.underlyingAPI, settings, "VkLayeredDriverUnderlyingApiMSFT", "underlyingAPI", indents + 1, dump_html_VkLayeredDriverUnderlyingApiMSFT);
}
void dump_html_VkPhysicalDeviceShaderExpectAssumeFeaturesKHR(const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderExpectAssume, settings, "VkBool32", "shaderExpectAssume", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMaintenance6FeaturesKHR(const VkPhysicalDeviceMaintenance6FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.maintenance6, settings, "VkBool32", "maintenance6", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceMaintenance6PropertiesKHR(const VkPhysicalDeviceMaintenance6PropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.blockTexelViewCompatibleMultipleLayers, settings, "VkBool32", "blockTexelViewCompatibleMultipleLayers", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxCombinedImageSamplerDescriptorCount, settings, "uint32_t", "maxCombinedImageSamplerDescriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.fragmentShadingRateClampCombinerInputs, settings, "VkBool32", "fragmentShadingRateClampCombinerInputs", indents + 1, dump_html_VkBool32);
}
void dump_html_VkBindMemoryStatusKHR(const VkBindMemoryStatusKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkResult>(object.pResult, settings, "VkResult*", "pResult", indents + 1, dump_html_VkResult);
}
void dump_html_VkBindDescriptorSetsInfoKHR(const VkBindDescriptorSetsInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.firstSet, settings, "uint32_t", "firstSet", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorSetCount, settings, "uint32_t", "descriptorSetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSet>(object.pDescriptorSets, object.descriptorSetCount, settings, "const VkDescriptorSet*", "const VkDescriptorSet", "pDescriptorSets", indents + 1, dump_html_VkDescriptorSet); // ZRT
    dump_html_value<const uint32_t>(object.dynamicOffsetCount, settings, "uint32_t", "dynamicOffsetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDynamicOffsets, object.dynamicOffsetCount, settings, "const uint32_t*", "const uint32_t", "pDynamicOffsets", indents + 1, dump_html_uint32_t); // ZRT
}
void dump_html_VkPushConstantsInfoKHR(const VkPushConstantsInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.size, settings, "uint32_t", "size", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pValues, settings, "const void*", "pValues", indents + 1, dump_html_void);
}
void dump_html_VkPushDescriptorSetInfoKHR(const VkPushDescriptorSetInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.set, settings, "uint32_t", "set", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorWriteCount, settings, "uint32_t", "descriptorWriteCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkWriteDescriptorSet>(object.pDescriptorWrites, object.descriptorWriteCount, settings, "const VkWriteDescriptorSet*", "const VkWriteDescriptorSet", "pDescriptorWrites", indents + 1, dump_html_VkWriteDescriptorSet); // ZRT
}
void dump_html_VkPushDescriptorSetWithTemplateInfoKHR(const VkPushDescriptorSetWithTemplateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorUpdateTemplate>(object.descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", indents + 1, dump_html_VkDescriptorUpdateTemplate);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.set, settings, "uint32_t", "set", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
}
void dump_html_VkSetDescriptorBufferOffsetsInfoEXT(const VkSetDescriptorBufferOffsetsInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.firstSet, settings, "uint32_t", "firstSet", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.setCount, settings, "uint32_t", "setCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pBufferIndices, object.setCount, settings, "const uint32_t*", "const uint32_t", "pBufferIndices", indents + 1, dump_html_uint32_t); // ZRT
    dump_html_array<const VkDeviceSize>(object.pOffsets, object.setCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", indents + 1, dump_html_VkDeviceSize); // ZRT
}
void dump_html_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(const VkBindDescriptorBufferEmbeddedSamplersInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.set, settings, "uint32_t", "set", indents + 1, dump_html_uint32_t);
}
void dump_html_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.descriptorPoolOverallocation, settings, "VkBool32", "descriptorPoolOverallocation", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRawAccessChainsFeaturesNV(const VkPhysicalDeviceRawAccessChainsFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderRawAccessChains, settings, "VkBool32", "shaderRawAccessChains", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderFloat16VectorAtomics, settings, "VkBool32", "shaderFloat16VectorAtomics", indents + 1, dump_html_VkBool32);
}
void dump_html_VkPhysicalDeviceRayTracingValidationFeaturesNV(const VkPhysicalDeviceRayTracingValidationFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rayTracingValidation, settings, "VkBool32", "rayTracingValidation", indents + 1, dump_html_VkBool32);
}

//========================== Union Implementations ==========================//

void dump_html_VkClearColorValue(const VkClearColorValue& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_array<const float>(object.float32, 4, settings, "float[4]", "float", "float32", indents + 1, dump_html_float); // ZRY
    dump_html_array<const int32_t>(object.int32, 4, settings, "int32_t[4]", "int32_t", "int32", indents + 1, dump_html_int32_t); // ZRY
    dump_html_array<const uint32_t>(object.uint32, 4, settings, "uint32_t[4]", "uint32_t", "uint32", indents + 1, dump_html_uint32_t); // ZRY
}
void dump_html_VkClearValue(const VkClearValue& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkClearColorValue>(object.color, settings, "VkClearColorValue", "color", indents + 1, dump_html_VkClearColorValue);
    dump_html_value<const VkClearDepthStencilValue>(object.depthStencil, settings, "VkClearDepthStencilValue", "depthStencil", indents + 1, dump_html_VkClearDepthStencilValue);
}
void dump_html_VkPerformanceCounterResultKHR(const VkPerformanceCounterResultKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.int32, settings, "int32_t", "int32", indents + 1, dump_html_int32_t);
    dump_html_value<const int64_t>(object.int64, settings, "int64_t", "int64", indents + 1, dump_html_int64_t);
    dump_html_value<const uint32_t>(object.uint32, settings, "uint32_t", "uint32", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.uint64, settings, "uint64_t", "uint64", indents + 1, dump_html_uint64_t);
    dump_html_value<const float>(object.float32, settings, "float", "float32", indents + 1, dump_html_float);
    dump_html_value<const double>(object.float64, settings, "double", "float64", indents + 1, dump_html_double);
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_VkDeviceOrHostAddressConstAMDX(const VkDeviceOrHostAddressConstAMDX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const void*>(object.hostAddress, settings, "const void*", "hostAddress", indents + 1, dump_html_void);
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_VkDeviceOrHostAddressKHR(const VkDeviceOrHostAddressKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const void*>(object.hostAddress, settings, "void*", "hostAddress", indents + 1, dump_html_void);
}
void dump_html_VkDeviceOrHostAddressConstKHR(const VkDeviceOrHostAddressConstKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    dump_html_value<const void*>(object.hostAddress, settings, "const void*", "hostAddress", indents + 1, dump_html_void);
}
void dump_html_VkAccelerationStructureGeometryDataKHR(const VkAccelerationStructureGeometryDataKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkAccelerationStructureGeometryTrianglesDataKHR>(object.triangles, settings, "VkAccelerationStructureGeometryTrianglesDataKHR", "triangles", indents + 1, dump_html_VkAccelerationStructureGeometryTrianglesDataKHR);
    dump_html_value<const VkAccelerationStructureGeometryAabbsDataKHR>(object.aabbs, settings, "VkAccelerationStructureGeometryAabbsDataKHR", "aabbs", indents + 1, dump_html_VkAccelerationStructureGeometryAabbsDataKHR);
    dump_html_value<const VkAccelerationStructureGeometryInstancesDataKHR>(object.instances, settings, "VkAccelerationStructureGeometryInstancesDataKHR", "instances", indents + 1, dump_html_VkAccelerationStructureGeometryInstancesDataKHR);
}
void dump_html_VkPerformanceValueDataINTEL(const VkPerformanceValueDataINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.value32, settings, "uint32_t", "value32", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.value64, settings, "uint64_t", "value64", indents + 1, dump_html_uint64_t);
    dump_html_value<const float>(object.valueFloat, settings, "float", "valueFloat", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.valueBool, settings, "VkBool32", "valueBool", indents + 1, dump_html_VkBool32);
    dump_html_value<const char*>(object.valueString, settings, "const char*", "valueString", indents + 1, dump_html_cstring);
}
void dump_html_VkPipelineExecutableStatisticValueKHR(const VkPipelineExecutableStatisticValueKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.b32, settings, "VkBool32", "b32", indents + 1, dump_html_VkBool32);
    dump_html_value<const int64_t>(object.i64, settings, "int64_t", "i64", indents + 1, dump_html_int64_t);
    dump_html_value<const uint64_t>(object.u64, settings, "uint64_t", "u64", indents + 1, dump_html_uint64_t);
    dump_html_value<const double>(object.f64, settings, "double", "f64", indents + 1, dump_html_double);
}
void dump_html_VkDescriptorDataEXT(const VkDescriptorDataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_SAMPLER)
    dump_html_pointer<const VkSampler>(object.pSampler, settings, "const VkSampler*", "pSampler", indents + 1, dump_html_VkSampler);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER)
    dump_html_pointer<const VkDescriptorImageInfo>(object.pCombinedImageSampler, settings, "const VkDescriptorImageInfo*", "pCombinedImageSampler", indents + 1, dump_html_VkDescriptorImageInfo);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT)
    dump_html_pointer<const VkDescriptorImageInfo>(object.pInputAttachmentImage, settings, "const VkDescriptorImageInfo*", "pInputAttachmentImage", indents + 1, dump_html_VkDescriptorImageInfo);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE)
    dump_html_pointer<const VkDescriptorImageInfo>(object.pSampledImage, settings, "const VkDescriptorImageInfo*", "pSampledImage", indents + 1, dump_html_VkDescriptorImageInfo);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE)
    dump_html_pointer<const VkDescriptorImageInfo>(object.pStorageImage, settings, "const VkDescriptorImageInfo*", "pStorageImage", indents + 1, dump_html_VkDescriptorImageInfo);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER)
    dump_html_pointer<const VkDescriptorAddressInfoEXT>(object.pUniformTexelBuffer, settings, "const VkDescriptorAddressInfoEXT*", "pUniformTexelBuffer", indents + 1, dump_html_VkDescriptorAddressInfoEXT);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
    dump_html_pointer<const VkDescriptorAddressInfoEXT>(object.pStorageTexelBuffer, settings, "const VkDescriptorAddressInfoEXT*", "pStorageTexelBuffer", indents + 1, dump_html_VkDescriptorAddressInfoEXT);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER)
    dump_html_pointer<const VkDescriptorAddressInfoEXT>(object.pUniformBuffer, settings, "const VkDescriptorAddressInfoEXT*", "pUniformBuffer", indents + 1, dump_html_VkDescriptorAddressInfoEXT);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER)
    dump_html_pointer<const VkDescriptorAddressInfoEXT>(object.pStorageBuffer, settings, "const VkDescriptorAddressInfoEXT*", "pStorageBuffer", indents + 1, dump_html_VkDescriptorAddressInfoEXT);
    if(ApiDumpInstance::current().getDescriptorType() == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR)
    dump_html_value<const VkDeviceAddress>(object.accelerationStructure, settings, "VkDeviceAddress", "accelerationStructure", indents + 1, dump_html_VkDeviceAddress);
}
void dump_html_VkAccelerationStructureMotionInstanceDataNV(const VkAccelerationStructureMotionInstanceDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkAccelerationStructureInstanceKHR>(object.staticInstance, settings, "VkAccelerationStructureInstanceKHR", "staticInstance", indents + 1, dump_html_VkAccelerationStructureInstanceKHR);
    dump_html_value<const VkAccelerationStructureMatrixMotionInstanceNV>(object.matrixMotionInstance, settings, "VkAccelerationStructureMatrixMotionInstanceNV", "matrixMotionInstance", indents + 1, dump_html_VkAccelerationStructureMatrixMotionInstanceNV);
    dump_html_value<const VkAccelerationStructureSRTMotionInstanceNV>(object.srtMotionInstance, settings, "VkAccelerationStructureSRTMotionInstanceNV", "srtMotionInstance", indents + 1, dump_html_VkAccelerationStructureSRTMotionInstanceNV);
}

//======================== pNext Chain Implementation =======================//

void dump_html_pNext_trampoline(const void* object, const ApiDumpSettings& settings, int indents)
{
    switch((int64_t) (static_cast<const VkBaseInStructure*>(object)->sType)) {
    case 44:
        dump_html_pNext<const VkBufferMemoryBarrier>(static_cast<const VkBufferMemoryBarrier*>(object), settings, "VkBufferMemoryBarrier", indents, dump_html_VkBufferMemoryBarrier);
        break;
    case 45:
        dump_html_pNext<const VkImageMemoryBarrier>(static_cast<const VkImageMemoryBarrier*>(object), settings, "VkImageMemoryBarrier", indents, dump_html_VkImageMemoryBarrier);
        break;
    case 46:
        dump_html_pNext<const VkMemoryBarrier>(static_cast<const VkMemoryBarrier*>(object), settings, "VkMemoryBarrier", indents, dump_html_VkMemoryBarrier);
        break;
    case 0:
        dump_html_pNext<const VkApplicationInfo>(static_cast<const VkApplicationInfo*>(object), settings, "VkApplicationInfo", indents, dump_html_VkApplicationInfo);
        break;
    case 1:
        dump_html_pNext<const VkInstanceCreateInfo>(static_cast<const VkInstanceCreateInfo*>(object), settings, "VkInstanceCreateInfo", indents, dump_html_VkInstanceCreateInfo);
        break;
    case 2:
        dump_html_pNext<const VkDeviceQueueCreateInfo>(static_cast<const VkDeviceQueueCreateInfo*>(object), settings, "VkDeviceQueueCreateInfo", indents, dump_html_VkDeviceQueueCreateInfo);
        break;
    case 3:
        dump_html_pNext<const VkDeviceCreateInfo>(static_cast<const VkDeviceCreateInfo*>(object), settings, "VkDeviceCreateInfo", indents, dump_html_VkDeviceCreateInfo);
        break;
    case 4:
        dump_html_pNext<const VkSubmitInfo>(static_cast<const VkSubmitInfo*>(object), settings, "VkSubmitInfo", indents, dump_html_VkSubmitInfo);
        break;
    case 6:
        dump_html_pNext<const VkMappedMemoryRange>(static_cast<const VkMappedMemoryRange*>(object), settings, "VkMappedMemoryRange", indents, dump_html_VkMappedMemoryRange);
        break;
    case 5:
        dump_html_pNext<const VkMemoryAllocateInfo>(static_cast<const VkMemoryAllocateInfo*>(object), settings, "VkMemoryAllocateInfo", indents, dump_html_VkMemoryAllocateInfo);
        break;
    case 7:
        dump_html_pNext<const VkBindSparseInfo>(static_cast<const VkBindSparseInfo*>(object), settings, "VkBindSparseInfo", indents, dump_html_VkBindSparseInfo);
        break;
    case 8:
        dump_html_pNext<const VkFenceCreateInfo>(static_cast<const VkFenceCreateInfo*>(object), settings, "VkFenceCreateInfo", indents, dump_html_VkFenceCreateInfo);
        break;
    case 9:
        dump_html_pNext<const VkSemaphoreCreateInfo>(static_cast<const VkSemaphoreCreateInfo*>(object), settings, "VkSemaphoreCreateInfo", indents, dump_html_VkSemaphoreCreateInfo);
        break;
    case 10:
        dump_html_pNext<const VkEventCreateInfo>(static_cast<const VkEventCreateInfo*>(object), settings, "VkEventCreateInfo", indents, dump_html_VkEventCreateInfo);
        break;
    case 11:
        dump_html_pNext<const VkQueryPoolCreateInfo>(static_cast<const VkQueryPoolCreateInfo*>(object), settings, "VkQueryPoolCreateInfo", indents, dump_html_VkQueryPoolCreateInfo);
        break;
    case 12:
        dump_html_pNext<const VkBufferCreateInfo>(static_cast<const VkBufferCreateInfo*>(object), settings, "VkBufferCreateInfo", indents, dump_html_VkBufferCreateInfo);
        break;
    case 13:
        dump_html_pNext<const VkBufferViewCreateInfo>(static_cast<const VkBufferViewCreateInfo*>(object), settings, "VkBufferViewCreateInfo", indents, dump_html_VkBufferViewCreateInfo);
        break;
    case 14:
        dump_html_pNext<const VkImageCreateInfo>(static_cast<const VkImageCreateInfo*>(object), settings, "VkImageCreateInfo", indents, dump_html_VkImageCreateInfo);
        break;
    case 15:
        dump_html_pNext<const VkImageViewCreateInfo>(static_cast<const VkImageViewCreateInfo*>(object), settings, "VkImageViewCreateInfo", indents, dump_html_VkImageViewCreateInfo);
        break;
    case 16:
        dump_html_pNext<const VkShaderModuleCreateInfo>(static_cast<const VkShaderModuleCreateInfo*>(object), settings, "VkShaderModuleCreateInfo", indents, dump_html_VkShaderModuleCreateInfo);
        break;
    case 17:
        dump_html_pNext<const VkPipelineCacheCreateInfo>(static_cast<const VkPipelineCacheCreateInfo*>(object), settings, "VkPipelineCacheCreateInfo", indents, dump_html_VkPipelineCacheCreateInfo);
        break;
    case 18:
        dump_html_pNext<const VkPipelineShaderStageCreateInfo>(static_cast<const VkPipelineShaderStageCreateInfo*>(object), settings, "VkPipelineShaderStageCreateInfo", indents, dump_html_VkPipelineShaderStageCreateInfo);
        break;
    case 29:
        dump_html_pNext<const VkComputePipelineCreateInfo>(static_cast<const VkComputePipelineCreateInfo*>(object), settings, "VkComputePipelineCreateInfo", indents, dump_html_VkComputePipelineCreateInfo);
        break;
    case 19:
        dump_html_pNext<const VkPipelineVertexInputStateCreateInfo>(static_cast<const VkPipelineVertexInputStateCreateInfo*>(object), settings, "VkPipelineVertexInputStateCreateInfo", indents, dump_html_VkPipelineVertexInputStateCreateInfo);
        break;
    case 20:
        dump_html_pNext<const VkPipelineInputAssemblyStateCreateInfo>(static_cast<const VkPipelineInputAssemblyStateCreateInfo*>(object), settings, "VkPipelineInputAssemblyStateCreateInfo", indents, dump_html_VkPipelineInputAssemblyStateCreateInfo);
        break;
    case 21:
        dump_html_pNext<const VkPipelineTessellationStateCreateInfo>(static_cast<const VkPipelineTessellationStateCreateInfo*>(object), settings, "VkPipelineTessellationStateCreateInfo", indents, dump_html_VkPipelineTessellationStateCreateInfo);
        break;
    case 22:
        dump_html_pNext<const VkPipelineViewportStateCreateInfo>(static_cast<const VkPipelineViewportStateCreateInfo*>(object), settings, "VkPipelineViewportStateCreateInfo", indents, dump_html_VkPipelineViewportStateCreateInfo);
        break;
    case 23:
        dump_html_pNext<const VkPipelineRasterizationStateCreateInfo>(static_cast<const VkPipelineRasterizationStateCreateInfo*>(object), settings, "VkPipelineRasterizationStateCreateInfo", indents, dump_html_VkPipelineRasterizationStateCreateInfo);
        break;
    case 24:
        dump_html_pNext<const VkPipelineMultisampleStateCreateInfo>(static_cast<const VkPipelineMultisampleStateCreateInfo*>(object), settings, "VkPipelineMultisampleStateCreateInfo", indents, dump_html_VkPipelineMultisampleStateCreateInfo);
        break;
    case 25:
        dump_html_pNext<const VkPipelineDepthStencilStateCreateInfo>(static_cast<const VkPipelineDepthStencilStateCreateInfo*>(object), settings, "VkPipelineDepthStencilStateCreateInfo", indents, dump_html_VkPipelineDepthStencilStateCreateInfo);
        break;
    case 26:
        dump_html_pNext<const VkPipelineColorBlendStateCreateInfo>(static_cast<const VkPipelineColorBlendStateCreateInfo*>(object), settings, "VkPipelineColorBlendStateCreateInfo", indents, dump_html_VkPipelineColorBlendStateCreateInfo);
        break;
    case 27:
        dump_html_pNext<const VkPipelineDynamicStateCreateInfo>(static_cast<const VkPipelineDynamicStateCreateInfo*>(object), settings, "VkPipelineDynamicStateCreateInfo", indents, dump_html_VkPipelineDynamicStateCreateInfo);
        break;
    case 28:
        dump_html_pNext<const VkGraphicsPipelineCreateInfo>(static_cast<const VkGraphicsPipelineCreateInfo*>(object), settings, "VkGraphicsPipelineCreateInfo", indents, dump_html_VkGraphicsPipelineCreateInfo);
        break;
    case 30:
        dump_html_pNext<const VkPipelineLayoutCreateInfo>(static_cast<const VkPipelineLayoutCreateInfo*>(object), settings, "VkPipelineLayoutCreateInfo", indents, dump_html_VkPipelineLayoutCreateInfo);
        break;
    case 31:
        dump_html_pNext<const VkSamplerCreateInfo>(static_cast<const VkSamplerCreateInfo*>(object), settings, "VkSamplerCreateInfo", indents, dump_html_VkSamplerCreateInfo);
        break;
    case 36:
        dump_html_pNext<const VkCopyDescriptorSet>(static_cast<const VkCopyDescriptorSet*>(object), settings, "VkCopyDescriptorSet", indents, dump_html_VkCopyDescriptorSet);
        break;
    case 33:
        dump_html_pNext<const VkDescriptorPoolCreateInfo>(static_cast<const VkDescriptorPoolCreateInfo*>(object), settings, "VkDescriptorPoolCreateInfo", indents, dump_html_VkDescriptorPoolCreateInfo);
        break;
    case 34:
        dump_html_pNext<const VkDescriptorSetAllocateInfo>(static_cast<const VkDescriptorSetAllocateInfo*>(object), settings, "VkDescriptorSetAllocateInfo", indents, dump_html_VkDescriptorSetAllocateInfo);
        break;
    case 32:
        dump_html_pNext<const VkDescriptorSetLayoutCreateInfo>(static_cast<const VkDescriptorSetLayoutCreateInfo*>(object), settings, "VkDescriptorSetLayoutCreateInfo", indents, dump_html_VkDescriptorSetLayoutCreateInfo);
        break;
    case 35:
        dump_html_pNext<const VkWriteDescriptorSet>(static_cast<const VkWriteDescriptorSet*>(object), settings, "VkWriteDescriptorSet", indents, dump_html_VkWriteDescriptorSet);
        break;
    case 37:
        dump_html_pNext<const VkFramebufferCreateInfo>(static_cast<const VkFramebufferCreateInfo*>(object), settings, "VkFramebufferCreateInfo", indents, dump_html_VkFramebufferCreateInfo);
        break;
    case 38:
        dump_html_pNext<const VkRenderPassCreateInfo>(static_cast<const VkRenderPassCreateInfo*>(object), settings, "VkRenderPassCreateInfo", indents, dump_html_VkRenderPassCreateInfo);
        break;
    case 39:
        dump_html_pNext<const VkCommandPoolCreateInfo>(static_cast<const VkCommandPoolCreateInfo*>(object), settings, "VkCommandPoolCreateInfo", indents, dump_html_VkCommandPoolCreateInfo);
        break;
    case 40:
        dump_html_pNext<const VkCommandBufferAllocateInfo>(static_cast<const VkCommandBufferAllocateInfo*>(object), settings, "VkCommandBufferAllocateInfo", indents, dump_html_VkCommandBufferAllocateInfo);
        break;
    case 41:
        dump_html_pNext<const VkCommandBufferInheritanceInfo>(static_cast<const VkCommandBufferInheritanceInfo*>(object), settings, "VkCommandBufferInheritanceInfo", indents, dump_html_VkCommandBufferInheritanceInfo);
        break;
    case 42:
        dump_html_pNext<const VkCommandBufferBeginInfo>(static_cast<const VkCommandBufferBeginInfo*>(object), settings, "VkCommandBufferBeginInfo", indents, dump_html_VkCommandBufferBeginInfo);
        break;
    case 43:
        dump_html_pNext<const VkRenderPassBeginInfo>(static_cast<const VkRenderPassBeginInfo*>(object), settings, "VkRenderPassBeginInfo", indents, dump_html_VkRenderPassBeginInfo);
        break;
    case 1000094000:
        dump_html_pNext<const VkPhysicalDeviceSubgroupProperties>(static_cast<const VkPhysicalDeviceSubgroupProperties*>(object), settings, "VkPhysicalDeviceSubgroupProperties", indents, dump_html_VkPhysicalDeviceSubgroupProperties);
        break;
    case 1000157000:
        dump_html_pNext<const VkBindBufferMemoryInfo>(static_cast<const VkBindBufferMemoryInfo*>(object), settings, "VkBindBufferMemoryInfo", indents, dump_html_VkBindBufferMemoryInfo);
        break;
    case 1000157001:
        dump_html_pNext<const VkBindImageMemoryInfo>(static_cast<const VkBindImageMemoryInfo*>(object), settings, "VkBindImageMemoryInfo", indents, dump_html_VkBindImageMemoryInfo);
        break;
    case 1000083000:
        dump_html_pNext<const VkPhysicalDevice16BitStorageFeatures>(static_cast<const VkPhysicalDevice16BitStorageFeatures*>(object), settings, "VkPhysicalDevice16BitStorageFeatures", indents, dump_html_VkPhysicalDevice16BitStorageFeatures);
        break;
    case 1000127000:
        dump_html_pNext<const VkMemoryDedicatedRequirements>(static_cast<const VkMemoryDedicatedRequirements*>(object), settings, "VkMemoryDedicatedRequirements", indents, dump_html_VkMemoryDedicatedRequirements);
        break;
    case 1000127001:
        dump_html_pNext<const VkMemoryDedicatedAllocateInfo>(static_cast<const VkMemoryDedicatedAllocateInfo*>(object), settings, "VkMemoryDedicatedAllocateInfo", indents, dump_html_VkMemoryDedicatedAllocateInfo);
        break;
    case 1000060000:
        dump_html_pNext<const VkMemoryAllocateFlagsInfo>(static_cast<const VkMemoryAllocateFlagsInfo*>(object), settings, "VkMemoryAllocateFlagsInfo", indents, dump_html_VkMemoryAllocateFlagsInfo);
        break;
    case 1000060003:
        dump_html_pNext<const VkDeviceGroupRenderPassBeginInfo>(static_cast<const VkDeviceGroupRenderPassBeginInfo*>(object), settings, "VkDeviceGroupRenderPassBeginInfo", indents, dump_html_VkDeviceGroupRenderPassBeginInfo);
        break;
    case 1000060004:
        dump_html_pNext<const VkDeviceGroupCommandBufferBeginInfo>(static_cast<const VkDeviceGroupCommandBufferBeginInfo*>(object), settings, "VkDeviceGroupCommandBufferBeginInfo", indents, dump_html_VkDeviceGroupCommandBufferBeginInfo);
        break;
    case 1000060005:
        dump_html_pNext<const VkDeviceGroupSubmitInfo>(static_cast<const VkDeviceGroupSubmitInfo*>(object), settings, "VkDeviceGroupSubmitInfo", indents, dump_html_VkDeviceGroupSubmitInfo);
        break;
    case 1000060006:
        dump_html_pNext<const VkDeviceGroupBindSparseInfo>(static_cast<const VkDeviceGroupBindSparseInfo*>(object), settings, "VkDeviceGroupBindSparseInfo", indents, dump_html_VkDeviceGroupBindSparseInfo);
        break;
    case 1000060013:
        dump_html_pNext<const VkBindBufferMemoryDeviceGroupInfo>(static_cast<const VkBindBufferMemoryDeviceGroupInfo*>(object), settings, "VkBindBufferMemoryDeviceGroupInfo", indents, dump_html_VkBindBufferMemoryDeviceGroupInfo);
        break;
    case 1000060014:
        dump_html_pNext<const VkBindImageMemoryDeviceGroupInfo>(static_cast<const VkBindImageMemoryDeviceGroupInfo*>(object), settings, "VkBindImageMemoryDeviceGroupInfo", indents, dump_html_VkBindImageMemoryDeviceGroupInfo);
        break;
    case 1000070000:
        dump_html_pNext<const VkPhysicalDeviceGroupProperties>(static_cast<const VkPhysicalDeviceGroupProperties*>(object), settings, "VkPhysicalDeviceGroupProperties", indents, dump_html_VkPhysicalDeviceGroupProperties);
        break;
    case 1000070001:
        dump_html_pNext<const VkDeviceGroupDeviceCreateInfo>(static_cast<const VkDeviceGroupDeviceCreateInfo*>(object), settings, "VkDeviceGroupDeviceCreateInfo", indents, dump_html_VkDeviceGroupDeviceCreateInfo);
        break;
    case 1000146000:
        dump_html_pNext<const VkBufferMemoryRequirementsInfo2>(static_cast<const VkBufferMemoryRequirementsInfo2*>(object), settings, "VkBufferMemoryRequirementsInfo2", indents, dump_html_VkBufferMemoryRequirementsInfo2);
        break;
    case 1000146001:
        dump_html_pNext<const VkImageMemoryRequirementsInfo2>(static_cast<const VkImageMemoryRequirementsInfo2*>(object), settings, "VkImageMemoryRequirementsInfo2", indents, dump_html_VkImageMemoryRequirementsInfo2);
        break;
    case 1000146002:
        dump_html_pNext<const VkImageSparseMemoryRequirementsInfo2>(static_cast<const VkImageSparseMemoryRequirementsInfo2*>(object), settings, "VkImageSparseMemoryRequirementsInfo2", indents, dump_html_VkImageSparseMemoryRequirementsInfo2);
        break;
    case 1000146003:
        dump_html_pNext<const VkMemoryRequirements2>(static_cast<const VkMemoryRequirements2*>(object), settings, "VkMemoryRequirements2", indents, dump_html_VkMemoryRequirements2);
        break;
    case 1000146004:
        dump_html_pNext<const VkSparseImageMemoryRequirements2>(static_cast<const VkSparseImageMemoryRequirements2*>(object), settings, "VkSparseImageMemoryRequirements2", indents, dump_html_VkSparseImageMemoryRequirements2);
        break;
    case 1000059000:
        dump_html_pNext<const VkPhysicalDeviceFeatures2>(static_cast<const VkPhysicalDeviceFeatures2*>(object), settings, "VkPhysicalDeviceFeatures2", indents, dump_html_VkPhysicalDeviceFeatures2);
        break;
    case 1000059001:
        dump_html_pNext<const VkPhysicalDeviceProperties2>(static_cast<const VkPhysicalDeviceProperties2*>(object), settings, "VkPhysicalDeviceProperties2", indents, dump_html_VkPhysicalDeviceProperties2);
        break;
    case 1000059002:
        dump_html_pNext<const VkFormatProperties2>(static_cast<const VkFormatProperties2*>(object), settings, "VkFormatProperties2", indents, dump_html_VkFormatProperties2);
        break;
    case 1000059003:
        dump_html_pNext<const VkImageFormatProperties2>(static_cast<const VkImageFormatProperties2*>(object), settings, "VkImageFormatProperties2", indents, dump_html_VkImageFormatProperties2);
        break;
    case 1000059004:
        dump_html_pNext<const VkPhysicalDeviceImageFormatInfo2>(static_cast<const VkPhysicalDeviceImageFormatInfo2*>(object), settings, "VkPhysicalDeviceImageFormatInfo2", indents, dump_html_VkPhysicalDeviceImageFormatInfo2);
        break;
    case 1000059005:
        dump_html_pNext<const VkQueueFamilyProperties2>(static_cast<const VkQueueFamilyProperties2*>(object), settings, "VkQueueFamilyProperties2", indents, dump_html_VkQueueFamilyProperties2);
        break;
    case 1000059006:
        dump_html_pNext<const VkPhysicalDeviceMemoryProperties2>(static_cast<const VkPhysicalDeviceMemoryProperties2*>(object), settings, "VkPhysicalDeviceMemoryProperties2", indents, dump_html_VkPhysicalDeviceMemoryProperties2);
        break;
    case 1000059007:
        dump_html_pNext<const VkSparseImageFormatProperties2>(static_cast<const VkSparseImageFormatProperties2*>(object), settings, "VkSparseImageFormatProperties2", indents, dump_html_VkSparseImageFormatProperties2);
        break;
    case 1000059008:
        dump_html_pNext<const VkPhysicalDeviceSparseImageFormatInfo2>(static_cast<const VkPhysicalDeviceSparseImageFormatInfo2*>(object), settings, "VkPhysicalDeviceSparseImageFormatInfo2", indents, dump_html_VkPhysicalDeviceSparseImageFormatInfo2);
        break;
    case 1000117000:
        dump_html_pNext<const VkPhysicalDevicePointClippingProperties>(static_cast<const VkPhysicalDevicePointClippingProperties*>(object), settings, "VkPhysicalDevicePointClippingProperties", indents, dump_html_VkPhysicalDevicePointClippingProperties);
        break;
    case 1000117001:
        dump_html_pNext<const VkRenderPassInputAttachmentAspectCreateInfo>(static_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(object), settings, "VkRenderPassInputAttachmentAspectCreateInfo", indents, dump_html_VkRenderPassInputAttachmentAspectCreateInfo);
        break;
    case 1000117002:
        dump_html_pNext<const VkImageViewUsageCreateInfo>(static_cast<const VkImageViewUsageCreateInfo*>(object), settings, "VkImageViewUsageCreateInfo", indents, dump_html_VkImageViewUsageCreateInfo);
        break;
    case 1000117003:
        dump_html_pNext<const VkPipelineTessellationDomainOriginStateCreateInfo>(static_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(object), settings, "VkPipelineTessellationDomainOriginStateCreateInfo", indents, dump_html_VkPipelineTessellationDomainOriginStateCreateInfo);
        break;
    case 1000053000:
        dump_html_pNext<const VkRenderPassMultiviewCreateInfo>(static_cast<const VkRenderPassMultiviewCreateInfo*>(object), settings, "VkRenderPassMultiviewCreateInfo", indents, dump_html_VkRenderPassMultiviewCreateInfo);
        break;
    case 1000053001:
        dump_html_pNext<const VkPhysicalDeviceMultiviewFeatures>(static_cast<const VkPhysicalDeviceMultiviewFeatures*>(object), settings, "VkPhysicalDeviceMultiviewFeatures", indents, dump_html_VkPhysicalDeviceMultiviewFeatures);
        break;
    case 1000053002:
        dump_html_pNext<const VkPhysicalDeviceMultiviewProperties>(static_cast<const VkPhysicalDeviceMultiviewProperties*>(object), settings, "VkPhysicalDeviceMultiviewProperties", indents, dump_html_VkPhysicalDeviceMultiviewProperties);
        break;
    case 1000120000:
        dump_html_pNext<const VkPhysicalDeviceVariablePointersFeatures>(static_cast<const VkPhysicalDeviceVariablePointersFeatures*>(object), settings, "VkPhysicalDeviceVariablePointersFeatures", indents, dump_html_VkPhysicalDeviceVariablePointersFeatures);
        break;
    case 1000145001:
        dump_html_pNext<const VkPhysicalDeviceProtectedMemoryFeatures>(static_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(object), settings, "VkPhysicalDeviceProtectedMemoryFeatures", indents, dump_html_VkPhysicalDeviceProtectedMemoryFeatures);
        break;
    case 1000145002:
        dump_html_pNext<const VkPhysicalDeviceProtectedMemoryProperties>(static_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(object), settings, "VkPhysicalDeviceProtectedMemoryProperties", indents, dump_html_VkPhysicalDeviceProtectedMemoryProperties);
        break;
    case 1000145003:
        dump_html_pNext<const VkDeviceQueueInfo2>(static_cast<const VkDeviceQueueInfo2*>(object), settings, "VkDeviceQueueInfo2", indents, dump_html_VkDeviceQueueInfo2);
        break;
    case 1000145000:
        dump_html_pNext<const VkProtectedSubmitInfo>(static_cast<const VkProtectedSubmitInfo*>(object), settings, "VkProtectedSubmitInfo", indents, dump_html_VkProtectedSubmitInfo);
        break;
    case 1000156000:
        dump_html_pNext<const VkSamplerYcbcrConversionCreateInfo>(static_cast<const VkSamplerYcbcrConversionCreateInfo*>(object), settings, "VkSamplerYcbcrConversionCreateInfo", indents, dump_html_VkSamplerYcbcrConversionCreateInfo);
        break;
    case 1000156001:
        dump_html_pNext<const VkSamplerYcbcrConversionInfo>(static_cast<const VkSamplerYcbcrConversionInfo*>(object), settings, "VkSamplerYcbcrConversionInfo", indents, dump_html_VkSamplerYcbcrConversionInfo);
        break;
    case 1000156002:
        dump_html_pNext<const VkBindImagePlaneMemoryInfo>(static_cast<const VkBindImagePlaneMemoryInfo*>(object), settings, "VkBindImagePlaneMemoryInfo", indents, dump_html_VkBindImagePlaneMemoryInfo);
        break;
    case 1000156003:
        dump_html_pNext<const VkImagePlaneMemoryRequirementsInfo>(static_cast<const VkImagePlaneMemoryRequirementsInfo*>(object), settings, "VkImagePlaneMemoryRequirementsInfo", indents, dump_html_VkImagePlaneMemoryRequirementsInfo);
        break;
    case 1000156004:
        dump_html_pNext<const VkPhysicalDeviceSamplerYcbcrConversionFeatures>(static_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(object), settings, "VkPhysicalDeviceSamplerYcbcrConversionFeatures", indents, dump_html_VkPhysicalDeviceSamplerYcbcrConversionFeatures);
        break;
    case 1000156005:
        dump_html_pNext<const VkSamplerYcbcrConversionImageFormatProperties>(static_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(object), settings, "VkSamplerYcbcrConversionImageFormatProperties", indents, dump_html_VkSamplerYcbcrConversionImageFormatProperties);
        break;
    case 1000085000:
        dump_html_pNext<const VkDescriptorUpdateTemplateCreateInfo>(static_cast<const VkDescriptorUpdateTemplateCreateInfo*>(object), settings, "VkDescriptorUpdateTemplateCreateInfo", indents, dump_html_VkDescriptorUpdateTemplateCreateInfo);
        break;
    case 1000071000:
        dump_html_pNext<const VkPhysicalDeviceExternalImageFormatInfo>(static_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(object), settings, "VkPhysicalDeviceExternalImageFormatInfo", indents, dump_html_VkPhysicalDeviceExternalImageFormatInfo);
        break;
    case 1000071001:
        dump_html_pNext<const VkExternalImageFormatProperties>(static_cast<const VkExternalImageFormatProperties*>(object), settings, "VkExternalImageFormatProperties", indents, dump_html_VkExternalImageFormatProperties);
        break;
    case 1000071002:
        dump_html_pNext<const VkPhysicalDeviceExternalBufferInfo>(static_cast<const VkPhysicalDeviceExternalBufferInfo*>(object), settings, "VkPhysicalDeviceExternalBufferInfo", indents, dump_html_VkPhysicalDeviceExternalBufferInfo);
        break;
    case 1000071003:
        dump_html_pNext<const VkExternalBufferProperties>(static_cast<const VkExternalBufferProperties*>(object), settings, "VkExternalBufferProperties", indents, dump_html_VkExternalBufferProperties);
        break;
    case 1000071004:
        dump_html_pNext<const VkPhysicalDeviceIDProperties>(static_cast<const VkPhysicalDeviceIDProperties*>(object), settings, "VkPhysicalDeviceIDProperties", indents, dump_html_VkPhysicalDeviceIDProperties);
        break;
    case 1000072001:
        dump_html_pNext<const VkExternalMemoryImageCreateInfo>(static_cast<const VkExternalMemoryImageCreateInfo*>(object), settings, "VkExternalMemoryImageCreateInfo", indents, dump_html_VkExternalMemoryImageCreateInfo);
        break;
    case 1000072000:
        dump_html_pNext<const VkExternalMemoryBufferCreateInfo>(static_cast<const VkExternalMemoryBufferCreateInfo*>(object), settings, "VkExternalMemoryBufferCreateInfo", indents, dump_html_VkExternalMemoryBufferCreateInfo);
        break;
    case 1000072002:
        dump_html_pNext<const VkExportMemoryAllocateInfo>(static_cast<const VkExportMemoryAllocateInfo*>(object), settings, "VkExportMemoryAllocateInfo", indents, dump_html_VkExportMemoryAllocateInfo);
        break;
    case 1000112000:
        dump_html_pNext<const VkPhysicalDeviceExternalFenceInfo>(static_cast<const VkPhysicalDeviceExternalFenceInfo*>(object), settings, "VkPhysicalDeviceExternalFenceInfo", indents, dump_html_VkPhysicalDeviceExternalFenceInfo);
        break;
    case 1000112001:
        dump_html_pNext<const VkExternalFenceProperties>(static_cast<const VkExternalFenceProperties*>(object), settings, "VkExternalFenceProperties", indents, dump_html_VkExternalFenceProperties);
        break;
    case 1000113000:
        dump_html_pNext<const VkExportFenceCreateInfo>(static_cast<const VkExportFenceCreateInfo*>(object), settings, "VkExportFenceCreateInfo", indents, dump_html_VkExportFenceCreateInfo);
        break;
    case 1000077000:
        dump_html_pNext<const VkExportSemaphoreCreateInfo>(static_cast<const VkExportSemaphoreCreateInfo*>(object), settings, "VkExportSemaphoreCreateInfo", indents, dump_html_VkExportSemaphoreCreateInfo);
        break;
    case 1000076000:
        dump_html_pNext<const VkPhysicalDeviceExternalSemaphoreInfo>(static_cast<const VkPhysicalDeviceExternalSemaphoreInfo*>(object), settings, "VkPhysicalDeviceExternalSemaphoreInfo", indents, dump_html_VkPhysicalDeviceExternalSemaphoreInfo);
        break;
    case 1000076001:
        dump_html_pNext<const VkExternalSemaphoreProperties>(static_cast<const VkExternalSemaphoreProperties*>(object), settings, "VkExternalSemaphoreProperties", indents, dump_html_VkExternalSemaphoreProperties);
        break;
    case 1000168000:
        dump_html_pNext<const VkPhysicalDeviceMaintenance3Properties>(static_cast<const VkPhysicalDeviceMaintenance3Properties*>(object), settings, "VkPhysicalDeviceMaintenance3Properties", indents, dump_html_VkPhysicalDeviceMaintenance3Properties);
        break;
    case 1000168001:
        dump_html_pNext<const VkDescriptorSetLayoutSupport>(static_cast<const VkDescriptorSetLayoutSupport*>(object), settings, "VkDescriptorSetLayoutSupport", indents, dump_html_VkDescriptorSetLayoutSupport);
        break;
    case 1000063000:
        dump_html_pNext<const VkPhysicalDeviceShaderDrawParametersFeatures>(static_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(object), settings, "VkPhysicalDeviceShaderDrawParametersFeatures", indents, dump_html_VkPhysicalDeviceShaderDrawParametersFeatures);
        break;
    case 49:
        dump_html_pNext<const VkPhysicalDeviceVulkan11Features>(static_cast<const VkPhysicalDeviceVulkan11Features*>(object), settings, "VkPhysicalDeviceVulkan11Features", indents, dump_html_VkPhysicalDeviceVulkan11Features);
        break;
    case 50:
        dump_html_pNext<const VkPhysicalDeviceVulkan11Properties>(static_cast<const VkPhysicalDeviceVulkan11Properties*>(object), settings, "VkPhysicalDeviceVulkan11Properties", indents, dump_html_VkPhysicalDeviceVulkan11Properties);
        break;
    case 51:
        dump_html_pNext<const VkPhysicalDeviceVulkan12Features>(static_cast<const VkPhysicalDeviceVulkan12Features*>(object), settings, "VkPhysicalDeviceVulkan12Features", indents, dump_html_VkPhysicalDeviceVulkan12Features);
        break;
    case 52:
        dump_html_pNext<const VkPhysicalDeviceVulkan12Properties>(static_cast<const VkPhysicalDeviceVulkan12Properties*>(object), settings, "VkPhysicalDeviceVulkan12Properties", indents, dump_html_VkPhysicalDeviceVulkan12Properties);
        break;
    case 1000147000:
        dump_html_pNext<const VkImageFormatListCreateInfo>(static_cast<const VkImageFormatListCreateInfo*>(object), settings, "VkImageFormatListCreateInfo", indents, dump_html_VkImageFormatListCreateInfo);
        break;
    case 1000109000:
        dump_html_pNext<const VkAttachmentDescription2>(static_cast<const VkAttachmentDescription2*>(object), settings, "VkAttachmentDescription2", indents, dump_html_VkAttachmentDescription2);
        break;
    case 1000109001:
        dump_html_pNext<const VkAttachmentReference2>(static_cast<const VkAttachmentReference2*>(object), settings, "VkAttachmentReference2", indents, dump_html_VkAttachmentReference2);
        break;
    case 1000109002:
        dump_html_pNext<const VkSubpassDescription2>(static_cast<const VkSubpassDescription2*>(object), settings, "VkSubpassDescription2", indents, dump_html_VkSubpassDescription2);
        break;
    case 1000109003:
        dump_html_pNext<const VkSubpassDependency2>(static_cast<const VkSubpassDependency2*>(object), settings, "VkSubpassDependency2", indents, dump_html_VkSubpassDependency2);
        break;
    case 1000109004:
        dump_html_pNext<const VkRenderPassCreateInfo2>(static_cast<const VkRenderPassCreateInfo2*>(object), settings, "VkRenderPassCreateInfo2", indents, dump_html_VkRenderPassCreateInfo2);
        break;
    case 1000109005:
        dump_html_pNext<const VkSubpassBeginInfo>(static_cast<const VkSubpassBeginInfo*>(object), settings, "VkSubpassBeginInfo", indents, dump_html_VkSubpassBeginInfo);
        break;
    case 1000109006:
        dump_html_pNext<const VkSubpassEndInfo>(static_cast<const VkSubpassEndInfo*>(object), settings, "VkSubpassEndInfo", indents, dump_html_VkSubpassEndInfo);
        break;
    case 1000177000:
        dump_html_pNext<const VkPhysicalDevice8BitStorageFeatures>(static_cast<const VkPhysicalDevice8BitStorageFeatures*>(object), settings, "VkPhysicalDevice8BitStorageFeatures", indents, dump_html_VkPhysicalDevice8BitStorageFeatures);
        break;
    case 1000196000:
        dump_html_pNext<const VkPhysicalDeviceDriverProperties>(static_cast<const VkPhysicalDeviceDriverProperties*>(object), settings, "VkPhysicalDeviceDriverProperties", indents, dump_html_VkPhysicalDeviceDriverProperties);
        break;
    case 1000180000:
        dump_html_pNext<const VkPhysicalDeviceShaderAtomicInt64Features>(static_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(object), settings, "VkPhysicalDeviceShaderAtomicInt64Features", indents, dump_html_VkPhysicalDeviceShaderAtomicInt64Features);
        break;
    case 1000082000:
        dump_html_pNext<const VkPhysicalDeviceShaderFloat16Int8Features>(static_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(object), settings, "VkPhysicalDeviceShaderFloat16Int8Features", indents, dump_html_VkPhysicalDeviceShaderFloat16Int8Features);
        break;
    case 1000197000:
        dump_html_pNext<const VkPhysicalDeviceFloatControlsProperties>(static_cast<const VkPhysicalDeviceFloatControlsProperties*>(object), settings, "VkPhysicalDeviceFloatControlsProperties", indents, dump_html_VkPhysicalDeviceFloatControlsProperties);
        break;
    case 1000161000:
        dump_html_pNext<const VkDescriptorSetLayoutBindingFlagsCreateInfo>(static_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo*>(object), settings, "VkDescriptorSetLayoutBindingFlagsCreateInfo", indents, dump_html_VkDescriptorSetLayoutBindingFlagsCreateInfo);
        break;
    case 1000161001:
        dump_html_pNext<const VkPhysicalDeviceDescriptorIndexingFeatures>(static_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(object), settings, "VkPhysicalDeviceDescriptorIndexingFeatures", indents, dump_html_VkPhysicalDeviceDescriptorIndexingFeatures);
        break;
    case 1000161002:
        dump_html_pNext<const VkPhysicalDeviceDescriptorIndexingProperties>(static_cast<const VkPhysicalDeviceDescriptorIndexingProperties*>(object), settings, "VkPhysicalDeviceDescriptorIndexingProperties", indents, dump_html_VkPhysicalDeviceDescriptorIndexingProperties);
        break;
    case 1000161003:
        dump_html_pNext<const VkDescriptorSetVariableDescriptorCountAllocateInfo>(static_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo*>(object), settings, "VkDescriptorSetVariableDescriptorCountAllocateInfo", indents, dump_html_VkDescriptorSetVariableDescriptorCountAllocateInfo);
        break;
    case 1000161004:
        dump_html_pNext<const VkDescriptorSetVariableDescriptorCountLayoutSupport>(static_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport*>(object), settings, "VkDescriptorSetVariableDescriptorCountLayoutSupport", indents, dump_html_VkDescriptorSetVariableDescriptorCountLayoutSupport);
        break;
    case 1000199001:
        dump_html_pNext<const VkSubpassDescriptionDepthStencilResolve>(static_cast<const VkSubpassDescriptionDepthStencilResolve*>(object), settings, "VkSubpassDescriptionDepthStencilResolve", indents, dump_html_VkSubpassDescriptionDepthStencilResolve);
        break;
    case 1000199000:
        dump_html_pNext<const VkPhysicalDeviceDepthStencilResolveProperties>(static_cast<const VkPhysicalDeviceDepthStencilResolveProperties*>(object), settings, "VkPhysicalDeviceDepthStencilResolveProperties", indents, dump_html_VkPhysicalDeviceDepthStencilResolveProperties);
        break;
    case 1000221000:
        dump_html_pNext<const VkPhysicalDeviceScalarBlockLayoutFeatures>(static_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(object), settings, "VkPhysicalDeviceScalarBlockLayoutFeatures", indents, dump_html_VkPhysicalDeviceScalarBlockLayoutFeatures);
        break;
    case 1000246000:
        dump_html_pNext<const VkImageStencilUsageCreateInfo>(static_cast<const VkImageStencilUsageCreateInfo*>(object), settings, "VkImageStencilUsageCreateInfo", indents, dump_html_VkImageStencilUsageCreateInfo);
        break;
    case 1000130001:
        dump_html_pNext<const VkSamplerReductionModeCreateInfo>(static_cast<const VkSamplerReductionModeCreateInfo*>(object), settings, "VkSamplerReductionModeCreateInfo", indents, dump_html_VkSamplerReductionModeCreateInfo);
        break;
    case 1000130000:
        dump_html_pNext<const VkPhysicalDeviceSamplerFilterMinmaxProperties>(static_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties*>(object), settings, "VkPhysicalDeviceSamplerFilterMinmaxProperties", indents, dump_html_VkPhysicalDeviceSamplerFilterMinmaxProperties);
        break;
    case 1000211000:
        dump_html_pNext<const VkPhysicalDeviceVulkanMemoryModelFeatures>(static_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(object), settings, "VkPhysicalDeviceVulkanMemoryModelFeatures", indents, dump_html_VkPhysicalDeviceVulkanMemoryModelFeatures);
        break;
    case 1000108000:
        dump_html_pNext<const VkPhysicalDeviceImagelessFramebufferFeatures>(static_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(object), settings, "VkPhysicalDeviceImagelessFramebufferFeatures", indents, dump_html_VkPhysicalDeviceImagelessFramebufferFeatures);
        break;
    case 1000108002:
        dump_html_pNext<const VkFramebufferAttachmentImageInfo>(static_cast<const VkFramebufferAttachmentImageInfo*>(object), settings, "VkFramebufferAttachmentImageInfo", indents, dump_html_VkFramebufferAttachmentImageInfo);
        break;
    case 1000108001:
        dump_html_pNext<const VkFramebufferAttachmentsCreateInfo>(static_cast<const VkFramebufferAttachmentsCreateInfo*>(object), settings, "VkFramebufferAttachmentsCreateInfo", indents, dump_html_VkFramebufferAttachmentsCreateInfo);
        break;
    case 1000108003:
        dump_html_pNext<const VkRenderPassAttachmentBeginInfo>(static_cast<const VkRenderPassAttachmentBeginInfo*>(object), settings, "VkRenderPassAttachmentBeginInfo", indents, dump_html_VkRenderPassAttachmentBeginInfo);
        break;
    case 1000253000:
        dump_html_pNext<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(static_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(object), settings, "VkPhysicalDeviceUniformBufferStandardLayoutFeatures", indents, dump_html_VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
        break;
    case 1000175000:
        dump_html_pNext<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(static_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(object), settings, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", indents, dump_html_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
        break;
    case 1000241000:
        dump_html_pNext<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(static_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(object), settings, "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", indents, dump_html_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
        break;
    case 1000241001:
        dump_html_pNext<const VkAttachmentReferenceStencilLayout>(static_cast<const VkAttachmentReferenceStencilLayout*>(object), settings, "VkAttachmentReferenceStencilLayout", indents, dump_html_VkAttachmentReferenceStencilLayout);
        break;
    case 1000241002:
        dump_html_pNext<const VkAttachmentDescriptionStencilLayout>(static_cast<const VkAttachmentDescriptionStencilLayout*>(object), settings, "VkAttachmentDescriptionStencilLayout", indents, dump_html_VkAttachmentDescriptionStencilLayout);
        break;
    case 1000261000:
        dump_html_pNext<const VkPhysicalDeviceHostQueryResetFeatures>(static_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(object), settings, "VkPhysicalDeviceHostQueryResetFeatures", indents, dump_html_VkPhysicalDeviceHostQueryResetFeatures);
        break;
    case 1000207000:
        dump_html_pNext<const VkPhysicalDeviceTimelineSemaphoreFeatures>(static_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(object), settings, "VkPhysicalDeviceTimelineSemaphoreFeatures", indents, dump_html_VkPhysicalDeviceTimelineSemaphoreFeatures);
        break;
    case 1000207001:
        dump_html_pNext<const VkPhysicalDeviceTimelineSemaphoreProperties>(static_cast<const VkPhysicalDeviceTimelineSemaphoreProperties*>(object), settings, "VkPhysicalDeviceTimelineSemaphoreProperties", indents, dump_html_VkPhysicalDeviceTimelineSemaphoreProperties);
        break;
    case 1000207002:
        dump_html_pNext<const VkSemaphoreTypeCreateInfo>(static_cast<const VkSemaphoreTypeCreateInfo*>(object), settings, "VkSemaphoreTypeCreateInfo", indents, dump_html_VkSemaphoreTypeCreateInfo);
        break;
    case 1000207003:
        dump_html_pNext<const VkTimelineSemaphoreSubmitInfo>(static_cast<const VkTimelineSemaphoreSubmitInfo*>(object), settings, "VkTimelineSemaphoreSubmitInfo", indents, dump_html_VkTimelineSemaphoreSubmitInfo);
        break;
    case 1000207004:
        dump_html_pNext<const VkSemaphoreWaitInfo>(static_cast<const VkSemaphoreWaitInfo*>(object), settings, "VkSemaphoreWaitInfo", indents, dump_html_VkSemaphoreWaitInfo);
        break;
    case 1000207005:
        dump_html_pNext<const VkSemaphoreSignalInfo>(static_cast<const VkSemaphoreSignalInfo*>(object), settings, "VkSemaphoreSignalInfo", indents, dump_html_VkSemaphoreSignalInfo);
        break;
    case 1000257000:
        dump_html_pNext<const VkPhysicalDeviceBufferDeviceAddressFeatures>(static_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(object), settings, "VkPhysicalDeviceBufferDeviceAddressFeatures", indents, dump_html_VkPhysicalDeviceBufferDeviceAddressFeatures);
        break;
    case 1000244001:
        dump_html_pNext<const VkBufferDeviceAddressInfo>(static_cast<const VkBufferDeviceAddressInfo*>(object), settings, "VkBufferDeviceAddressInfo", indents, dump_html_VkBufferDeviceAddressInfo);
        break;
    case 1000257002:
        dump_html_pNext<const VkBufferOpaqueCaptureAddressCreateInfo>(static_cast<const VkBufferOpaqueCaptureAddressCreateInfo*>(object), settings, "VkBufferOpaqueCaptureAddressCreateInfo", indents, dump_html_VkBufferOpaqueCaptureAddressCreateInfo);
        break;
    case 1000257003:
        dump_html_pNext<const VkMemoryOpaqueCaptureAddressAllocateInfo>(static_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo*>(object), settings, "VkMemoryOpaqueCaptureAddressAllocateInfo", indents, dump_html_VkMemoryOpaqueCaptureAddressAllocateInfo);
        break;
    case 1000257004:
        dump_html_pNext<const VkDeviceMemoryOpaqueCaptureAddressInfo>(static_cast<const VkDeviceMemoryOpaqueCaptureAddressInfo*>(object), settings, "VkDeviceMemoryOpaqueCaptureAddressInfo", indents, dump_html_VkDeviceMemoryOpaqueCaptureAddressInfo);
        break;
    case 53:
        dump_html_pNext<const VkPhysicalDeviceVulkan13Features>(static_cast<const VkPhysicalDeviceVulkan13Features*>(object), settings, "VkPhysicalDeviceVulkan13Features", indents, dump_html_VkPhysicalDeviceVulkan13Features);
        break;
    case 54:
        dump_html_pNext<const VkPhysicalDeviceVulkan13Properties>(static_cast<const VkPhysicalDeviceVulkan13Properties*>(object), settings, "VkPhysicalDeviceVulkan13Properties", indents, dump_html_VkPhysicalDeviceVulkan13Properties);
        break;
    case 1000192000:
        dump_html_pNext<const VkPipelineCreationFeedbackCreateInfo>(static_cast<const VkPipelineCreationFeedbackCreateInfo*>(object), settings, "VkPipelineCreationFeedbackCreateInfo", indents, dump_html_VkPipelineCreationFeedbackCreateInfo);
        break;
    case 1000215000:
        dump_html_pNext<const VkPhysicalDeviceShaderTerminateInvocationFeatures>(static_cast<const VkPhysicalDeviceShaderTerminateInvocationFeatures*>(object), settings, "VkPhysicalDeviceShaderTerminateInvocationFeatures", indents, dump_html_VkPhysicalDeviceShaderTerminateInvocationFeatures);
        break;
    case 1000245000:
        dump_html_pNext<const VkPhysicalDeviceToolProperties>(static_cast<const VkPhysicalDeviceToolProperties*>(object), settings, "VkPhysicalDeviceToolProperties", indents, dump_html_VkPhysicalDeviceToolProperties);
        break;
    case 1000276000:
        dump_html_pNext<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>(static_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(object), settings, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures", indents, dump_html_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures);
        break;
    case 1000295000:
        dump_html_pNext<const VkPhysicalDevicePrivateDataFeatures>(static_cast<const VkPhysicalDevicePrivateDataFeatures*>(object), settings, "VkPhysicalDevicePrivateDataFeatures", indents, dump_html_VkPhysicalDevicePrivateDataFeatures);
        break;
    case 1000295001:
        dump_html_pNext<const VkDevicePrivateDataCreateInfo>(static_cast<const VkDevicePrivateDataCreateInfo*>(object), settings, "VkDevicePrivateDataCreateInfo", indents, dump_html_VkDevicePrivateDataCreateInfo);
        break;
    case 1000295002:
        dump_html_pNext<const VkPrivateDataSlotCreateInfo>(static_cast<const VkPrivateDataSlotCreateInfo*>(object), settings, "VkPrivateDataSlotCreateInfo", indents, dump_html_VkPrivateDataSlotCreateInfo);
        break;
    case 1000297000:
        dump_html_pNext<const VkPhysicalDevicePipelineCreationCacheControlFeatures>(static_cast<const VkPhysicalDevicePipelineCreationCacheControlFeatures*>(object), settings, "VkPhysicalDevicePipelineCreationCacheControlFeatures", indents, dump_html_VkPhysicalDevicePipelineCreationCacheControlFeatures);
        break;
    case 1000314000:
        dump_html_pNext<const VkMemoryBarrier2>(static_cast<const VkMemoryBarrier2*>(object), settings, "VkMemoryBarrier2", indents, dump_html_VkMemoryBarrier2);
        break;
    case 1000314001:
        dump_html_pNext<const VkBufferMemoryBarrier2>(static_cast<const VkBufferMemoryBarrier2*>(object), settings, "VkBufferMemoryBarrier2", indents, dump_html_VkBufferMemoryBarrier2);
        break;
    case 1000314002:
        dump_html_pNext<const VkImageMemoryBarrier2>(static_cast<const VkImageMemoryBarrier2*>(object), settings, "VkImageMemoryBarrier2", indents, dump_html_VkImageMemoryBarrier2);
        break;
    case 1000314003:
        dump_html_pNext<const VkDependencyInfo>(static_cast<const VkDependencyInfo*>(object), settings, "VkDependencyInfo", indents, dump_html_VkDependencyInfo);
        break;
    case 1000314005:
        dump_html_pNext<const VkSemaphoreSubmitInfo>(static_cast<const VkSemaphoreSubmitInfo*>(object), settings, "VkSemaphoreSubmitInfo", indents, dump_html_VkSemaphoreSubmitInfo);
        break;
    case 1000314006:
        dump_html_pNext<const VkCommandBufferSubmitInfo>(static_cast<const VkCommandBufferSubmitInfo*>(object), settings, "VkCommandBufferSubmitInfo", indents, dump_html_VkCommandBufferSubmitInfo);
        break;
    case 1000314004:
        dump_html_pNext<const VkSubmitInfo2>(static_cast<const VkSubmitInfo2*>(object), settings, "VkSubmitInfo2", indents, dump_html_VkSubmitInfo2);
        break;
    case 1000314007:
        dump_html_pNext<const VkPhysicalDeviceSynchronization2Features>(static_cast<const VkPhysicalDeviceSynchronization2Features*>(object), settings, "VkPhysicalDeviceSynchronization2Features", indents, dump_html_VkPhysicalDeviceSynchronization2Features);
        break;
    case 1000325000:
        dump_html_pNext<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>(static_cast<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(object), settings, "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures", indents, dump_html_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures);
        break;
    case 1000335000:
        dump_html_pNext<const VkPhysicalDeviceImageRobustnessFeatures>(static_cast<const VkPhysicalDeviceImageRobustnessFeatures*>(object), settings, "VkPhysicalDeviceImageRobustnessFeatures", indents, dump_html_VkPhysicalDeviceImageRobustnessFeatures);
        break;
    case 1000337006:
        dump_html_pNext<const VkBufferCopy2>(static_cast<const VkBufferCopy2*>(object), settings, "VkBufferCopy2", indents, dump_html_VkBufferCopy2);
        break;
    case 1000337000:
        dump_html_pNext<const VkCopyBufferInfo2>(static_cast<const VkCopyBufferInfo2*>(object), settings, "VkCopyBufferInfo2", indents, dump_html_VkCopyBufferInfo2);
        break;
    case 1000337007:
        dump_html_pNext<const VkImageCopy2>(static_cast<const VkImageCopy2*>(object), settings, "VkImageCopy2", indents, dump_html_VkImageCopy2);
        break;
    case 1000337001:
        dump_html_pNext<const VkCopyImageInfo2>(static_cast<const VkCopyImageInfo2*>(object), settings, "VkCopyImageInfo2", indents, dump_html_VkCopyImageInfo2);
        break;
    case 1000337009:
        dump_html_pNext<const VkBufferImageCopy2>(static_cast<const VkBufferImageCopy2*>(object), settings, "VkBufferImageCopy2", indents, dump_html_VkBufferImageCopy2);
        break;
    case 1000337002:
        dump_html_pNext<const VkCopyBufferToImageInfo2>(static_cast<const VkCopyBufferToImageInfo2*>(object), settings, "VkCopyBufferToImageInfo2", indents, dump_html_VkCopyBufferToImageInfo2);
        break;
    case 1000337003:
        dump_html_pNext<const VkCopyImageToBufferInfo2>(static_cast<const VkCopyImageToBufferInfo2*>(object), settings, "VkCopyImageToBufferInfo2", indents, dump_html_VkCopyImageToBufferInfo2);
        break;
    case 1000337008:
        dump_html_pNext<const VkImageBlit2>(static_cast<const VkImageBlit2*>(object), settings, "VkImageBlit2", indents, dump_html_VkImageBlit2);
        break;
    case 1000337004:
        dump_html_pNext<const VkBlitImageInfo2>(static_cast<const VkBlitImageInfo2*>(object), settings, "VkBlitImageInfo2", indents, dump_html_VkBlitImageInfo2);
        break;
    case 1000337010:
        dump_html_pNext<const VkImageResolve2>(static_cast<const VkImageResolve2*>(object), settings, "VkImageResolve2", indents, dump_html_VkImageResolve2);
        break;
    case 1000337005:
        dump_html_pNext<const VkResolveImageInfo2>(static_cast<const VkResolveImageInfo2*>(object), settings, "VkResolveImageInfo2", indents, dump_html_VkResolveImageInfo2);
        break;
    case 1000225002:
        dump_html_pNext<const VkPhysicalDeviceSubgroupSizeControlFeatures>(static_cast<const VkPhysicalDeviceSubgroupSizeControlFeatures*>(object), settings, "VkPhysicalDeviceSubgroupSizeControlFeatures", indents, dump_html_VkPhysicalDeviceSubgroupSizeControlFeatures);
        break;
    case 1000225000:
        dump_html_pNext<const VkPhysicalDeviceSubgroupSizeControlProperties>(static_cast<const VkPhysicalDeviceSubgroupSizeControlProperties*>(object), settings, "VkPhysicalDeviceSubgroupSizeControlProperties", indents, dump_html_VkPhysicalDeviceSubgroupSizeControlProperties);
        break;
    case 1000225001:
        dump_html_pNext<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>(static_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*>(object), settings, "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo", indents, dump_html_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo);
        break;
    case 1000138000:
        dump_html_pNext<const VkPhysicalDeviceInlineUniformBlockFeatures>(static_cast<const VkPhysicalDeviceInlineUniformBlockFeatures*>(object), settings, "VkPhysicalDeviceInlineUniformBlockFeatures", indents, dump_html_VkPhysicalDeviceInlineUniformBlockFeatures);
        break;
    case 1000138001:
        dump_html_pNext<const VkPhysicalDeviceInlineUniformBlockProperties>(static_cast<const VkPhysicalDeviceInlineUniformBlockProperties*>(object), settings, "VkPhysicalDeviceInlineUniformBlockProperties", indents, dump_html_VkPhysicalDeviceInlineUniformBlockProperties);
        break;
    case 1000138002:
        dump_html_pNext<const VkWriteDescriptorSetInlineUniformBlock>(static_cast<const VkWriteDescriptorSetInlineUniformBlock*>(object), settings, "VkWriteDescriptorSetInlineUniformBlock", indents, dump_html_VkWriteDescriptorSetInlineUniformBlock);
        break;
    case 1000138003:
        dump_html_pNext<const VkDescriptorPoolInlineUniformBlockCreateInfo>(static_cast<const VkDescriptorPoolInlineUniformBlockCreateInfo*>(object), settings, "VkDescriptorPoolInlineUniformBlockCreateInfo", indents, dump_html_VkDescriptorPoolInlineUniformBlockCreateInfo);
        break;
    case 1000066000:
        dump_html_pNext<const VkPhysicalDeviceTextureCompressionASTCHDRFeatures>(static_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(object), settings, "VkPhysicalDeviceTextureCompressionASTCHDRFeatures", indents, dump_html_VkPhysicalDeviceTextureCompressionASTCHDRFeatures);
        break;
    case 1000044001:
        dump_html_pNext<const VkRenderingAttachmentInfo>(static_cast<const VkRenderingAttachmentInfo*>(object), settings, "VkRenderingAttachmentInfo", indents, dump_html_VkRenderingAttachmentInfo);
        break;
    case 1000044000:
        dump_html_pNext<const VkRenderingInfo>(static_cast<const VkRenderingInfo*>(object), settings, "VkRenderingInfo", indents, dump_html_VkRenderingInfo);
        break;
    case 1000044002:
        dump_html_pNext<const VkPipelineRenderingCreateInfo>(static_cast<const VkPipelineRenderingCreateInfo*>(object), settings, "VkPipelineRenderingCreateInfo", indents, dump_html_VkPipelineRenderingCreateInfo);
        break;
    case 1000044003:
        dump_html_pNext<const VkPhysicalDeviceDynamicRenderingFeatures>(static_cast<const VkPhysicalDeviceDynamicRenderingFeatures*>(object), settings, "VkPhysicalDeviceDynamicRenderingFeatures", indents, dump_html_VkPhysicalDeviceDynamicRenderingFeatures);
        break;
    case 1000044004:
        dump_html_pNext<const VkCommandBufferInheritanceRenderingInfo>(static_cast<const VkCommandBufferInheritanceRenderingInfo*>(object), settings, "VkCommandBufferInheritanceRenderingInfo", indents, dump_html_VkCommandBufferInheritanceRenderingInfo);
        break;
    case 1000280000:
        dump_html_pNext<const VkPhysicalDeviceShaderIntegerDotProductFeatures>(static_cast<const VkPhysicalDeviceShaderIntegerDotProductFeatures*>(object), settings, "VkPhysicalDeviceShaderIntegerDotProductFeatures", indents, dump_html_VkPhysicalDeviceShaderIntegerDotProductFeatures);
        break;
    case 1000280001:
        dump_html_pNext<const VkPhysicalDeviceShaderIntegerDotProductProperties>(static_cast<const VkPhysicalDeviceShaderIntegerDotProductProperties*>(object), settings, "VkPhysicalDeviceShaderIntegerDotProductProperties", indents, dump_html_VkPhysicalDeviceShaderIntegerDotProductProperties);
        break;
    case 1000281001:
        dump_html_pNext<const VkPhysicalDeviceTexelBufferAlignmentProperties>(static_cast<const VkPhysicalDeviceTexelBufferAlignmentProperties*>(object), settings, "VkPhysicalDeviceTexelBufferAlignmentProperties", indents, dump_html_VkPhysicalDeviceTexelBufferAlignmentProperties);
        break;
    case 1000360000:
        dump_html_pNext<const VkFormatProperties3>(static_cast<const VkFormatProperties3*>(object), settings, "VkFormatProperties3", indents, dump_html_VkFormatProperties3);
        break;
    case 1000413000:
        dump_html_pNext<const VkPhysicalDeviceMaintenance4Features>(static_cast<const VkPhysicalDeviceMaintenance4Features*>(object), settings, "VkPhysicalDeviceMaintenance4Features", indents, dump_html_VkPhysicalDeviceMaintenance4Features);
        break;
    case 1000413001:
        dump_html_pNext<const VkPhysicalDeviceMaintenance4Properties>(static_cast<const VkPhysicalDeviceMaintenance4Properties*>(object), settings, "VkPhysicalDeviceMaintenance4Properties", indents, dump_html_VkPhysicalDeviceMaintenance4Properties);
        break;
    case 1000413002:
        dump_html_pNext<const VkDeviceBufferMemoryRequirements>(static_cast<const VkDeviceBufferMemoryRequirements*>(object), settings, "VkDeviceBufferMemoryRequirements", indents, dump_html_VkDeviceBufferMemoryRequirements);
        break;
    case 1000413003:
        dump_html_pNext<const VkDeviceImageMemoryRequirements>(static_cast<const VkDeviceImageMemoryRequirements*>(object), settings, "VkDeviceImageMemoryRequirements", indents, dump_html_VkDeviceImageMemoryRequirements);
        break;
    case 1000001000:
        dump_html_pNext<const VkSwapchainCreateInfoKHR>(static_cast<const VkSwapchainCreateInfoKHR*>(object), settings, "VkSwapchainCreateInfoKHR", indents, dump_html_VkSwapchainCreateInfoKHR);
        break;
    case 1000001001:
        dump_html_pNext<const VkPresentInfoKHR>(static_cast<const VkPresentInfoKHR*>(object), settings, "VkPresentInfoKHR", indents, dump_html_VkPresentInfoKHR);
        break;
    case 1000060008:
        dump_html_pNext<const VkImageSwapchainCreateInfoKHR>(static_cast<const VkImageSwapchainCreateInfoKHR*>(object), settings, "VkImageSwapchainCreateInfoKHR", indents, dump_html_VkImageSwapchainCreateInfoKHR);
        break;
    case 1000060009:
        dump_html_pNext<const VkBindImageMemorySwapchainInfoKHR>(static_cast<const VkBindImageMemorySwapchainInfoKHR*>(object), settings, "VkBindImageMemorySwapchainInfoKHR", indents, dump_html_VkBindImageMemorySwapchainInfoKHR);
        break;
    case 1000060010:
        dump_html_pNext<const VkAcquireNextImageInfoKHR>(static_cast<const VkAcquireNextImageInfoKHR*>(object), settings, "VkAcquireNextImageInfoKHR", indents, dump_html_VkAcquireNextImageInfoKHR);
        break;
    case 1000060007:
        dump_html_pNext<const VkDeviceGroupPresentCapabilitiesKHR>(static_cast<const VkDeviceGroupPresentCapabilitiesKHR*>(object), settings, "VkDeviceGroupPresentCapabilitiesKHR", indents, dump_html_VkDeviceGroupPresentCapabilitiesKHR);
        break;
    case 1000060011:
        dump_html_pNext<const VkDeviceGroupPresentInfoKHR>(static_cast<const VkDeviceGroupPresentInfoKHR*>(object), settings, "VkDeviceGroupPresentInfoKHR", indents, dump_html_VkDeviceGroupPresentInfoKHR);
        break;
    case 1000060012:
        dump_html_pNext<const VkDeviceGroupSwapchainCreateInfoKHR>(static_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(object), settings, "VkDeviceGroupSwapchainCreateInfoKHR", indents, dump_html_VkDeviceGroupSwapchainCreateInfoKHR);
        break;
    case 1000002000:
        dump_html_pNext<const VkDisplayModeCreateInfoKHR>(static_cast<const VkDisplayModeCreateInfoKHR*>(object), settings, "VkDisplayModeCreateInfoKHR", indents, dump_html_VkDisplayModeCreateInfoKHR);
        break;
    case 1000002001:
        dump_html_pNext<const VkDisplaySurfaceCreateInfoKHR>(static_cast<const VkDisplaySurfaceCreateInfoKHR*>(object), settings, "VkDisplaySurfaceCreateInfoKHR", indents, dump_html_VkDisplaySurfaceCreateInfoKHR);
        break;
    case 1000003000:
        dump_html_pNext<const VkDisplayPresentInfoKHR>(static_cast<const VkDisplayPresentInfoKHR*>(object), settings, "VkDisplayPresentInfoKHR", indents, dump_html_VkDisplayPresentInfoKHR);
        break;
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    case 1000004000:
        dump_html_pNext<const VkXlibSurfaceCreateInfoKHR>(static_cast<const VkXlibSurfaceCreateInfoKHR*>(object), settings, "VkXlibSurfaceCreateInfoKHR", indents, dump_html_VkXlibSurfaceCreateInfoKHR);
        break;
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
    case 1000005000:
        dump_html_pNext<const VkXcbSurfaceCreateInfoKHR>(static_cast<const VkXcbSurfaceCreateInfoKHR*>(object), settings, "VkXcbSurfaceCreateInfoKHR", indents, dump_html_VkXcbSurfaceCreateInfoKHR);
        break;
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    case 1000006000:
        dump_html_pNext<const VkWaylandSurfaceCreateInfoKHR>(static_cast<const VkWaylandSurfaceCreateInfoKHR*>(object), settings, "VkWaylandSurfaceCreateInfoKHR", indents, dump_html_VkWaylandSurfaceCreateInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000008000:
        dump_html_pNext<const VkAndroidSurfaceCreateInfoKHR>(static_cast<const VkAndroidSurfaceCreateInfoKHR*>(object), settings, "VkAndroidSurfaceCreateInfoKHR", indents, dump_html_VkAndroidSurfaceCreateInfoKHR);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000009000:
        dump_html_pNext<const VkWin32SurfaceCreateInfoKHR>(static_cast<const VkWin32SurfaceCreateInfoKHR*>(object), settings, "VkWin32SurfaceCreateInfoKHR", indents, dump_html_VkWin32SurfaceCreateInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000011000:
        dump_html_pNext<const VkDebugReportCallbackCreateInfoEXT>(static_cast<const VkDebugReportCallbackCreateInfoEXT*>(object), settings, "VkDebugReportCallbackCreateInfoEXT", indents, dump_html_VkDebugReportCallbackCreateInfoEXT);
        break;
    case 1000018000:
        dump_html_pNext<const VkPipelineRasterizationStateRasterizationOrderAMD>(static_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(object), settings, "VkPipelineRasterizationStateRasterizationOrderAMD", indents, dump_html_VkPipelineRasterizationStateRasterizationOrderAMD);
        break;
    case 1000022000:
        dump_html_pNext<const VkDebugMarkerObjectNameInfoEXT>(static_cast<const VkDebugMarkerObjectNameInfoEXT*>(object), settings, "VkDebugMarkerObjectNameInfoEXT", indents, dump_html_VkDebugMarkerObjectNameInfoEXT);
        break;
    case 1000022001:
        dump_html_pNext<const VkDebugMarkerObjectTagInfoEXT>(static_cast<const VkDebugMarkerObjectTagInfoEXT*>(object), settings, "VkDebugMarkerObjectTagInfoEXT", indents, dump_html_VkDebugMarkerObjectTagInfoEXT);
        break;
    case 1000022002:
        dump_html_pNext<const VkDebugMarkerMarkerInfoEXT>(static_cast<const VkDebugMarkerMarkerInfoEXT*>(object), settings, "VkDebugMarkerMarkerInfoEXT", indents, dump_html_VkDebugMarkerMarkerInfoEXT);
        break;
    case 1000023016:
        dump_html_pNext<const VkQueueFamilyQueryResultStatusPropertiesKHR>(static_cast<const VkQueueFamilyQueryResultStatusPropertiesKHR*>(object), settings, "VkQueueFamilyQueryResultStatusPropertiesKHR", indents, dump_html_VkQueueFamilyQueryResultStatusPropertiesKHR);
        break;
    case 1000023012:
        dump_html_pNext<const VkQueueFamilyVideoPropertiesKHR>(static_cast<const VkQueueFamilyVideoPropertiesKHR*>(object), settings, "VkQueueFamilyVideoPropertiesKHR", indents, dump_html_VkQueueFamilyVideoPropertiesKHR);
        break;
    case 1000023000:
        dump_html_pNext<const VkVideoProfileInfoKHR>(static_cast<const VkVideoProfileInfoKHR*>(object), settings, "VkVideoProfileInfoKHR", indents, dump_html_VkVideoProfileInfoKHR);
        break;
    case 1000023013:
        dump_html_pNext<const VkVideoProfileListInfoKHR>(static_cast<const VkVideoProfileListInfoKHR*>(object), settings, "VkVideoProfileListInfoKHR", indents, dump_html_VkVideoProfileListInfoKHR);
        break;
    case 1000023001:
        dump_html_pNext<const VkVideoCapabilitiesKHR>(static_cast<const VkVideoCapabilitiesKHR*>(object), settings, "VkVideoCapabilitiesKHR", indents, dump_html_VkVideoCapabilitiesKHR);
        break;
    case 1000023014:
        dump_html_pNext<const VkPhysicalDeviceVideoFormatInfoKHR>(static_cast<const VkPhysicalDeviceVideoFormatInfoKHR*>(object), settings, "VkPhysicalDeviceVideoFormatInfoKHR", indents, dump_html_VkPhysicalDeviceVideoFormatInfoKHR);
        break;
    case 1000023015:
        dump_html_pNext<const VkVideoFormatPropertiesKHR>(static_cast<const VkVideoFormatPropertiesKHR*>(object), settings, "VkVideoFormatPropertiesKHR", indents, dump_html_VkVideoFormatPropertiesKHR);
        break;
    case 1000023002:
        dump_html_pNext<const VkVideoPictureResourceInfoKHR>(static_cast<const VkVideoPictureResourceInfoKHR*>(object), settings, "VkVideoPictureResourceInfoKHR", indents, dump_html_VkVideoPictureResourceInfoKHR);
        break;
    case 1000023011:
        dump_html_pNext<const VkVideoReferenceSlotInfoKHR>(static_cast<const VkVideoReferenceSlotInfoKHR*>(object), settings, "VkVideoReferenceSlotInfoKHR", indents, dump_html_VkVideoReferenceSlotInfoKHR);
        break;
    case 1000023003:
        dump_html_pNext<const VkVideoSessionMemoryRequirementsKHR>(static_cast<const VkVideoSessionMemoryRequirementsKHR*>(object), settings, "VkVideoSessionMemoryRequirementsKHR", indents, dump_html_VkVideoSessionMemoryRequirementsKHR);
        break;
    case 1000023004:
        dump_html_pNext<const VkBindVideoSessionMemoryInfoKHR>(static_cast<const VkBindVideoSessionMemoryInfoKHR*>(object), settings, "VkBindVideoSessionMemoryInfoKHR", indents, dump_html_VkBindVideoSessionMemoryInfoKHR);
        break;
    case 1000023005:
        dump_html_pNext<const VkVideoSessionCreateInfoKHR>(static_cast<const VkVideoSessionCreateInfoKHR*>(object), settings, "VkVideoSessionCreateInfoKHR", indents, dump_html_VkVideoSessionCreateInfoKHR);
        break;
    case 1000023006:
        dump_html_pNext<const VkVideoSessionParametersCreateInfoKHR>(static_cast<const VkVideoSessionParametersCreateInfoKHR*>(object), settings, "VkVideoSessionParametersCreateInfoKHR", indents, dump_html_VkVideoSessionParametersCreateInfoKHR);
        break;
    case 1000023007:
        dump_html_pNext<const VkVideoSessionParametersUpdateInfoKHR>(static_cast<const VkVideoSessionParametersUpdateInfoKHR*>(object), settings, "VkVideoSessionParametersUpdateInfoKHR", indents, dump_html_VkVideoSessionParametersUpdateInfoKHR);
        break;
    case 1000023008:
        dump_html_pNext<const VkVideoBeginCodingInfoKHR>(static_cast<const VkVideoBeginCodingInfoKHR*>(object), settings, "VkVideoBeginCodingInfoKHR", indents, dump_html_VkVideoBeginCodingInfoKHR);
        break;
    case 1000023009:
        dump_html_pNext<const VkVideoEndCodingInfoKHR>(static_cast<const VkVideoEndCodingInfoKHR*>(object), settings, "VkVideoEndCodingInfoKHR", indents, dump_html_VkVideoEndCodingInfoKHR);
        break;
    case 1000023010:
        dump_html_pNext<const VkVideoCodingControlInfoKHR>(static_cast<const VkVideoCodingControlInfoKHR*>(object), settings, "VkVideoCodingControlInfoKHR", indents, dump_html_VkVideoCodingControlInfoKHR);
        break;
    case 1000024001:
        dump_html_pNext<const VkVideoDecodeCapabilitiesKHR>(static_cast<const VkVideoDecodeCapabilitiesKHR*>(object), settings, "VkVideoDecodeCapabilitiesKHR", indents, dump_html_VkVideoDecodeCapabilitiesKHR);
        break;
    case 1000024002:
        dump_html_pNext<const VkVideoDecodeUsageInfoKHR>(static_cast<const VkVideoDecodeUsageInfoKHR*>(object), settings, "VkVideoDecodeUsageInfoKHR", indents, dump_html_VkVideoDecodeUsageInfoKHR);
        break;
    case 1000024000:
        dump_html_pNext<const VkVideoDecodeInfoKHR>(static_cast<const VkVideoDecodeInfoKHR*>(object), settings, "VkVideoDecodeInfoKHR", indents, dump_html_VkVideoDecodeInfoKHR);
        break;
    case 1000026000:
        dump_html_pNext<const VkDedicatedAllocationImageCreateInfoNV>(static_cast<const VkDedicatedAllocationImageCreateInfoNV*>(object), settings, "VkDedicatedAllocationImageCreateInfoNV", indents, dump_html_VkDedicatedAllocationImageCreateInfoNV);
        break;
    case 1000026001:
        dump_html_pNext<const VkDedicatedAllocationBufferCreateInfoNV>(static_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(object), settings, "VkDedicatedAllocationBufferCreateInfoNV", indents, dump_html_VkDedicatedAllocationBufferCreateInfoNV);
        break;
    case 1000026002:
        dump_html_pNext<const VkDedicatedAllocationMemoryAllocateInfoNV>(static_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(object), settings, "VkDedicatedAllocationMemoryAllocateInfoNV", indents, dump_html_VkDedicatedAllocationMemoryAllocateInfoNV);
        break;
    case 1000028000:
        dump_html_pNext<const VkPhysicalDeviceTransformFeedbackFeaturesEXT>(static_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(object), settings, "VkPhysicalDeviceTransformFeedbackFeaturesEXT", indents, dump_html_VkPhysicalDeviceTransformFeedbackFeaturesEXT);
        break;
    case 1000028001:
        dump_html_pNext<const VkPhysicalDeviceTransformFeedbackPropertiesEXT>(static_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(object), settings, "VkPhysicalDeviceTransformFeedbackPropertiesEXT", indents, dump_html_VkPhysicalDeviceTransformFeedbackPropertiesEXT);
        break;
    case 1000028002:
        dump_html_pNext<const VkPipelineRasterizationStateStreamCreateInfoEXT>(static_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(object), settings, "VkPipelineRasterizationStateStreamCreateInfoEXT", indents, dump_html_VkPipelineRasterizationStateStreamCreateInfoEXT);
        break;
    case 1000029000:
        dump_html_pNext<const VkCuModuleCreateInfoNVX>(static_cast<const VkCuModuleCreateInfoNVX*>(object), settings, "VkCuModuleCreateInfoNVX", indents, dump_html_VkCuModuleCreateInfoNVX);
        break;
    case 1000029001:
        dump_html_pNext<const VkCuFunctionCreateInfoNVX>(static_cast<const VkCuFunctionCreateInfoNVX*>(object), settings, "VkCuFunctionCreateInfoNVX", indents, dump_html_VkCuFunctionCreateInfoNVX);
        break;
    case 1000029002:
        dump_html_pNext<const VkCuLaunchInfoNVX>(static_cast<const VkCuLaunchInfoNVX*>(object), settings, "VkCuLaunchInfoNVX", indents, dump_html_VkCuLaunchInfoNVX);
        break;
    case 1000030000:
        dump_html_pNext<const VkImageViewHandleInfoNVX>(static_cast<const VkImageViewHandleInfoNVX*>(object), settings, "VkImageViewHandleInfoNVX", indents, dump_html_VkImageViewHandleInfoNVX);
        break;
    case 1000030001:
        dump_html_pNext<const VkImageViewAddressPropertiesNVX>(static_cast<const VkImageViewAddressPropertiesNVX*>(object), settings, "VkImageViewAddressPropertiesNVX", indents, dump_html_VkImageViewAddressPropertiesNVX);
        break;
    case 1000038000:
        dump_html_pNext<const VkVideoEncodeH264CapabilitiesKHR>(static_cast<const VkVideoEncodeH264CapabilitiesKHR*>(object), settings, "VkVideoEncodeH264CapabilitiesKHR", indents, dump_html_VkVideoEncodeH264CapabilitiesKHR);
        break;
    case 1000038011:
        dump_html_pNext<const VkVideoEncodeH264QualityLevelPropertiesKHR>(static_cast<const VkVideoEncodeH264QualityLevelPropertiesKHR*>(object), settings, "VkVideoEncodeH264QualityLevelPropertiesKHR", indents, dump_html_VkVideoEncodeH264QualityLevelPropertiesKHR);
        break;
    case 1000038010:
        dump_html_pNext<const VkVideoEncodeH264SessionCreateInfoKHR>(static_cast<const VkVideoEncodeH264SessionCreateInfoKHR*>(object), settings, "VkVideoEncodeH264SessionCreateInfoKHR", indents, dump_html_VkVideoEncodeH264SessionCreateInfoKHR);
        break;
    case 1000038002:
        dump_html_pNext<const VkVideoEncodeH264SessionParametersAddInfoKHR>(static_cast<const VkVideoEncodeH264SessionParametersAddInfoKHR*>(object), settings, "VkVideoEncodeH264SessionParametersAddInfoKHR", indents, dump_html_VkVideoEncodeH264SessionParametersAddInfoKHR);
        break;
    case 1000038001:
        dump_html_pNext<const VkVideoEncodeH264SessionParametersCreateInfoKHR>(static_cast<const VkVideoEncodeH264SessionParametersCreateInfoKHR*>(object), settings, "VkVideoEncodeH264SessionParametersCreateInfoKHR", indents, dump_html_VkVideoEncodeH264SessionParametersCreateInfoKHR);
        break;
    case 1000038012:
        dump_html_pNext<const VkVideoEncodeH264SessionParametersGetInfoKHR>(static_cast<const VkVideoEncodeH264SessionParametersGetInfoKHR*>(object), settings, "VkVideoEncodeH264SessionParametersGetInfoKHR", indents, dump_html_VkVideoEncodeH264SessionParametersGetInfoKHR);
        break;
    case 1000038013:
        dump_html_pNext<const VkVideoEncodeH264SessionParametersFeedbackInfoKHR>(static_cast<const VkVideoEncodeH264SessionParametersFeedbackInfoKHR*>(object), settings, "VkVideoEncodeH264SessionParametersFeedbackInfoKHR", indents, dump_html_VkVideoEncodeH264SessionParametersFeedbackInfoKHR);
        break;
    case 1000038005:
        dump_html_pNext<const VkVideoEncodeH264NaluSliceInfoKHR>(static_cast<const VkVideoEncodeH264NaluSliceInfoKHR*>(object), settings, "VkVideoEncodeH264NaluSliceInfoKHR", indents, dump_html_VkVideoEncodeH264NaluSliceInfoKHR);
        break;
    case 1000038003:
        dump_html_pNext<const VkVideoEncodeH264PictureInfoKHR>(static_cast<const VkVideoEncodeH264PictureInfoKHR*>(object), settings, "VkVideoEncodeH264PictureInfoKHR", indents, dump_html_VkVideoEncodeH264PictureInfoKHR);
        break;
    case 1000038004:
        dump_html_pNext<const VkVideoEncodeH264DpbSlotInfoKHR>(static_cast<const VkVideoEncodeH264DpbSlotInfoKHR*>(object), settings, "VkVideoEncodeH264DpbSlotInfoKHR", indents, dump_html_VkVideoEncodeH264DpbSlotInfoKHR);
        break;
    case 1000038007:
        dump_html_pNext<const VkVideoEncodeH264ProfileInfoKHR>(static_cast<const VkVideoEncodeH264ProfileInfoKHR*>(object), settings, "VkVideoEncodeH264ProfileInfoKHR", indents, dump_html_VkVideoEncodeH264ProfileInfoKHR);
        break;
    case 1000038008:
        dump_html_pNext<const VkVideoEncodeH264RateControlInfoKHR>(static_cast<const VkVideoEncodeH264RateControlInfoKHR*>(object), settings, "VkVideoEncodeH264RateControlInfoKHR", indents, dump_html_VkVideoEncodeH264RateControlInfoKHR);
        break;
    case 1000038009:
        dump_html_pNext<const VkVideoEncodeH264RateControlLayerInfoKHR>(static_cast<const VkVideoEncodeH264RateControlLayerInfoKHR*>(object), settings, "VkVideoEncodeH264RateControlLayerInfoKHR", indents, dump_html_VkVideoEncodeH264RateControlLayerInfoKHR);
        break;
    case 1000038006:
        dump_html_pNext<const VkVideoEncodeH264GopRemainingFrameInfoKHR>(static_cast<const VkVideoEncodeH264GopRemainingFrameInfoKHR*>(object), settings, "VkVideoEncodeH264GopRemainingFrameInfoKHR", indents, dump_html_VkVideoEncodeH264GopRemainingFrameInfoKHR);
        break;
    case 1000039000:
        dump_html_pNext<const VkVideoEncodeH265CapabilitiesKHR>(static_cast<const VkVideoEncodeH265CapabilitiesKHR*>(object), settings, "VkVideoEncodeH265CapabilitiesKHR", indents, dump_html_VkVideoEncodeH265CapabilitiesKHR);
        break;
    case 1000039011:
        dump_html_pNext<const VkVideoEncodeH265SessionCreateInfoKHR>(static_cast<const VkVideoEncodeH265SessionCreateInfoKHR*>(object), settings, "VkVideoEncodeH265SessionCreateInfoKHR", indents, dump_html_VkVideoEncodeH265SessionCreateInfoKHR);
        break;
    case 1000039012:
        dump_html_pNext<const VkVideoEncodeH265QualityLevelPropertiesKHR>(static_cast<const VkVideoEncodeH265QualityLevelPropertiesKHR*>(object), settings, "VkVideoEncodeH265QualityLevelPropertiesKHR", indents, dump_html_VkVideoEncodeH265QualityLevelPropertiesKHR);
        break;
    case 1000039002:
        dump_html_pNext<const VkVideoEncodeH265SessionParametersAddInfoKHR>(static_cast<const VkVideoEncodeH265SessionParametersAddInfoKHR*>(object), settings, "VkVideoEncodeH265SessionParametersAddInfoKHR", indents, dump_html_VkVideoEncodeH265SessionParametersAddInfoKHR);
        break;
    case 1000039001:
        dump_html_pNext<const VkVideoEncodeH265SessionParametersCreateInfoKHR>(static_cast<const VkVideoEncodeH265SessionParametersCreateInfoKHR*>(object), settings, "VkVideoEncodeH265SessionParametersCreateInfoKHR", indents, dump_html_VkVideoEncodeH265SessionParametersCreateInfoKHR);
        break;
    case 1000039013:
        dump_html_pNext<const VkVideoEncodeH265SessionParametersGetInfoKHR>(static_cast<const VkVideoEncodeH265SessionParametersGetInfoKHR*>(object), settings, "VkVideoEncodeH265SessionParametersGetInfoKHR", indents, dump_html_VkVideoEncodeH265SessionParametersGetInfoKHR);
        break;
    case 1000039014:
        dump_html_pNext<const VkVideoEncodeH265SessionParametersFeedbackInfoKHR>(static_cast<const VkVideoEncodeH265SessionParametersFeedbackInfoKHR*>(object), settings, "VkVideoEncodeH265SessionParametersFeedbackInfoKHR", indents, dump_html_VkVideoEncodeH265SessionParametersFeedbackInfoKHR);
        break;
    case 1000039005:
        dump_html_pNext<const VkVideoEncodeH265NaluSliceSegmentInfoKHR>(static_cast<const VkVideoEncodeH265NaluSliceSegmentInfoKHR*>(object), settings, "VkVideoEncodeH265NaluSliceSegmentInfoKHR", indents, dump_html_VkVideoEncodeH265NaluSliceSegmentInfoKHR);
        break;
    case 1000039003:
        dump_html_pNext<const VkVideoEncodeH265PictureInfoKHR>(static_cast<const VkVideoEncodeH265PictureInfoKHR*>(object), settings, "VkVideoEncodeH265PictureInfoKHR", indents, dump_html_VkVideoEncodeH265PictureInfoKHR);
        break;
    case 1000039004:
        dump_html_pNext<const VkVideoEncodeH265DpbSlotInfoKHR>(static_cast<const VkVideoEncodeH265DpbSlotInfoKHR*>(object), settings, "VkVideoEncodeH265DpbSlotInfoKHR", indents, dump_html_VkVideoEncodeH265DpbSlotInfoKHR);
        break;
    case 1000039007:
        dump_html_pNext<const VkVideoEncodeH265ProfileInfoKHR>(static_cast<const VkVideoEncodeH265ProfileInfoKHR*>(object), settings, "VkVideoEncodeH265ProfileInfoKHR", indents, dump_html_VkVideoEncodeH265ProfileInfoKHR);
        break;
    case 1000039009:
        dump_html_pNext<const VkVideoEncodeH265RateControlInfoKHR>(static_cast<const VkVideoEncodeH265RateControlInfoKHR*>(object), settings, "VkVideoEncodeH265RateControlInfoKHR", indents, dump_html_VkVideoEncodeH265RateControlInfoKHR);
        break;
    case 1000039010:
        dump_html_pNext<const VkVideoEncodeH265RateControlLayerInfoKHR>(static_cast<const VkVideoEncodeH265RateControlLayerInfoKHR*>(object), settings, "VkVideoEncodeH265RateControlLayerInfoKHR", indents, dump_html_VkVideoEncodeH265RateControlLayerInfoKHR);
        break;
    case 1000039006:
        dump_html_pNext<const VkVideoEncodeH265GopRemainingFrameInfoKHR>(static_cast<const VkVideoEncodeH265GopRemainingFrameInfoKHR*>(object), settings, "VkVideoEncodeH265GopRemainingFrameInfoKHR", indents, dump_html_VkVideoEncodeH265GopRemainingFrameInfoKHR);
        break;
    case 1000040003:
        dump_html_pNext<const VkVideoDecodeH264ProfileInfoKHR>(static_cast<const VkVideoDecodeH264ProfileInfoKHR*>(object), settings, "VkVideoDecodeH264ProfileInfoKHR", indents, dump_html_VkVideoDecodeH264ProfileInfoKHR);
        break;
    case 1000040000:
        dump_html_pNext<const VkVideoDecodeH264CapabilitiesKHR>(static_cast<const VkVideoDecodeH264CapabilitiesKHR*>(object), settings, "VkVideoDecodeH264CapabilitiesKHR", indents, dump_html_VkVideoDecodeH264CapabilitiesKHR);
        break;
    case 1000040005:
        dump_html_pNext<const VkVideoDecodeH264SessionParametersAddInfoKHR>(static_cast<const VkVideoDecodeH264SessionParametersAddInfoKHR*>(object), settings, "VkVideoDecodeH264SessionParametersAddInfoKHR", indents, dump_html_VkVideoDecodeH264SessionParametersAddInfoKHR);
        break;
    case 1000040004:
        dump_html_pNext<const VkVideoDecodeH264SessionParametersCreateInfoKHR>(static_cast<const VkVideoDecodeH264SessionParametersCreateInfoKHR*>(object), settings, "VkVideoDecodeH264SessionParametersCreateInfoKHR", indents, dump_html_VkVideoDecodeH264SessionParametersCreateInfoKHR);
        break;
    case 1000040001:
        dump_html_pNext<const VkVideoDecodeH264PictureInfoKHR>(static_cast<const VkVideoDecodeH264PictureInfoKHR*>(object), settings, "VkVideoDecodeH264PictureInfoKHR", indents, dump_html_VkVideoDecodeH264PictureInfoKHR);
        break;
    case 1000040006:
        dump_html_pNext<const VkVideoDecodeH264DpbSlotInfoKHR>(static_cast<const VkVideoDecodeH264DpbSlotInfoKHR*>(object), settings, "VkVideoDecodeH264DpbSlotInfoKHR", indents, dump_html_VkVideoDecodeH264DpbSlotInfoKHR);
        break;
    case 1000041000:
        dump_html_pNext<const VkTextureLODGatherFormatPropertiesAMD>(static_cast<const VkTextureLODGatherFormatPropertiesAMD*>(object), settings, "VkTextureLODGatherFormatPropertiesAMD", indents, dump_html_VkTextureLODGatherFormatPropertiesAMD);
        break;
    case 1000044006:
        dump_html_pNext<const VkRenderingFragmentShadingRateAttachmentInfoKHR>(static_cast<const VkRenderingFragmentShadingRateAttachmentInfoKHR*>(object), settings, "VkRenderingFragmentShadingRateAttachmentInfoKHR", indents, dump_html_VkRenderingFragmentShadingRateAttachmentInfoKHR);
        break;
    case 1000044007:
        dump_html_pNext<const VkRenderingFragmentDensityMapAttachmentInfoEXT>(static_cast<const VkRenderingFragmentDensityMapAttachmentInfoEXT*>(object), settings, "VkRenderingFragmentDensityMapAttachmentInfoEXT", indents, dump_html_VkRenderingFragmentDensityMapAttachmentInfoEXT);
        break;
    case 1000044008:
        dump_html_pNext<const VkAttachmentSampleCountInfoAMD>(static_cast<const VkAttachmentSampleCountInfoAMD*>(object), settings, "VkAttachmentSampleCountInfoAMD", indents, dump_html_VkAttachmentSampleCountInfoAMD);
        break;
    case 1000044009:
        dump_html_pNext<const VkMultiviewPerViewAttributesInfoNVX>(static_cast<const VkMultiviewPerViewAttributesInfoNVX*>(object), settings, "VkMultiviewPerViewAttributesInfoNVX", indents, dump_html_VkMultiviewPerViewAttributesInfoNVX);
        break;
#if defined(VK_USE_PLATFORM_GGP)
    case 1000049000:
        dump_html_pNext<const VkStreamDescriptorSurfaceCreateInfoGGP>(static_cast<const VkStreamDescriptorSurfaceCreateInfoGGP*>(object), settings, "VkStreamDescriptorSurfaceCreateInfoGGP", indents, dump_html_VkStreamDescriptorSurfaceCreateInfoGGP);
        break;
#endif // VK_USE_PLATFORM_GGP
    case 1000050000:
        dump_html_pNext<const VkPhysicalDeviceCornerSampledImageFeaturesNV>(static_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(object), settings, "VkPhysicalDeviceCornerSampledImageFeaturesNV", indents, dump_html_VkPhysicalDeviceCornerSampledImageFeaturesNV);
        break;
    case 1000056000:
        dump_html_pNext<const VkExternalMemoryImageCreateInfoNV>(static_cast<const VkExternalMemoryImageCreateInfoNV*>(object), settings, "VkExternalMemoryImageCreateInfoNV", indents, dump_html_VkExternalMemoryImageCreateInfoNV);
        break;
    case 1000056001:
        dump_html_pNext<const VkExportMemoryAllocateInfoNV>(static_cast<const VkExportMemoryAllocateInfoNV*>(object), settings, "VkExportMemoryAllocateInfoNV", indents, dump_html_VkExportMemoryAllocateInfoNV);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000057000:
        dump_html_pNext<const VkImportMemoryWin32HandleInfoNV>(static_cast<const VkImportMemoryWin32HandleInfoNV*>(object), settings, "VkImportMemoryWin32HandleInfoNV", indents, dump_html_VkImportMemoryWin32HandleInfoNV);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000057001:
        dump_html_pNext<const VkExportMemoryWin32HandleInfoNV>(static_cast<const VkExportMemoryWin32HandleInfoNV*>(object), settings, "VkExportMemoryWin32HandleInfoNV", indents, dump_html_VkExportMemoryWin32HandleInfoNV);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000058000:
        dump_html_pNext<const VkWin32KeyedMutexAcquireReleaseInfoNV>(static_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(object), settings, "VkWin32KeyedMutexAcquireReleaseInfoNV", indents, dump_html_VkWin32KeyedMutexAcquireReleaseInfoNV);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000061000:
        dump_html_pNext<const VkValidationFlagsEXT>(static_cast<const VkValidationFlagsEXT*>(object), settings, "VkValidationFlagsEXT", indents, dump_html_VkValidationFlagsEXT);
        break;
#if defined(VK_USE_PLATFORM_VI_NN)
    case 1000062000:
        dump_html_pNext<const VkViSurfaceCreateInfoNN>(static_cast<const VkViSurfaceCreateInfoNN*>(object), settings, "VkViSurfaceCreateInfoNN", indents, dump_html_VkViSurfaceCreateInfoNN);
        break;
#endif // VK_USE_PLATFORM_VI_NN
    case 1000067000:
        dump_html_pNext<const VkImageViewASTCDecodeModeEXT>(static_cast<const VkImageViewASTCDecodeModeEXT*>(object), settings, "VkImageViewASTCDecodeModeEXT", indents, dump_html_VkImageViewASTCDecodeModeEXT);
        break;
    case 1000067001:
        dump_html_pNext<const VkPhysicalDeviceASTCDecodeFeaturesEXT>(static_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(object), settings, "VkPhysicalDeviceASTCDecodeFeaturesEXT", indents, dump_html_VkPhysicalDeviceASTCDecodeFeaturesEXT);
        break;
    case 1000068001:
        dump_html_pNext<const VkPhysicalDevicePipelineRobustnessFeaturesEXT>(static_cast<const VkPhysicalDevicePipelineRobustnessFeaturesEXT*>(object), settings, "VkPhysicalDevicePipelineRobustnessFeaturesEXT", indents, dump_html_VkPhysicalDevicePipelineRobustnessFeaturesEXT);
        break;
    case 1000068002:
        dump_html_pNext<const VkPhysicalDevicePipelineRobustnessPropertiesEXT>(static_cast<const VkPhysicalDevicePipelineRobustnessPropertiesEXT*>(object), settings, "VkPhysicalDevicePipelineRobustnessPropertiesEXT", indents, dump_html_VkPhysicalDevicePipelineRobustnessPropertiesEXT);
        break;
    case 1000068000:
        dump_html_pNext<const VkPipelineRobustnessCreateInfoEXT>(static_cast<const VkPipelineRobustnessCreateInfoEXT*>(object), settings, "VkPipelineRobustnessCreateInfoEXT", indents, dump_html_VkPipelineRobustnessCreateInfoEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000073000:
        dump_html_pNext<const VkImportMemoryWin32HandleInfoKHR>(static_cast<const VkImportMemoryWin32HandleInfoKHR*>(object), settings, "VkImportMemoryWin32HandleInfoKHR", indents, dump_html_VkImportMemoryWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000073001:
        dump_html_pNext<const VkExportMemoryWin32HandleInfoKHR>(static_cast<const VkExportMemoryWin32HandleInfoKHR*>(object), settings, "VkExportMemoryWin32HandleInfoKHR", indents, dump_html_VkExportMemoryWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000073002:
        dump_html_pNext<const VkMemoryWin32HandlePropertiesKHR>(static_cast<const VkMemoryWin32HandlePropertiesKHR*>(object), settings, "VkMemoryWin32HandlePropertiesKHR", indents, dump_html_VkMemoryWin32HandlePropertiesKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000073003:
        dump_html_pNext<const VkMemoryGetWin32HandleInfoKHR>(static_cast<const VkMemoryGetWin32HandleInfoKHR*>(object), settings, "VkMemoryGetWin32HandleInfoKHR", indents, dump_html_VkMemoryGetWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000074000:
        dump_html_pNext<const VkImportMemoryFdInfoKHR>(static_cast<const VkImportMemoryFdInfoKHR*>(object), settings, "VkImportMemoryFdInfoKHR", indents, dump_html_VkImportMemoryFdInfoKHR);
        break;
    case 1000074001:
        dump_html_pNext<const VkMemoryFdPropertiesKHR>(static_cast<const VkMemoryFdPropertiesKHR*>(object), settings, "VkMemoryFdPropertiesKHR", indents, dump_html_VkMemoryFdPropertiesKHR);
        break;
    case 1000074002:
        dump_html_pNext<const VkMemoryGetFdInfoKHR>(static_cast<const VkMemoryGetFdInfoKHR*>(object), settings, "VkMemoryGetFdInfoKHR", indents, dump_html_VkMemoryGetFdInfoKHR);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000075000:
        dump_html_pNext<const VkWin32KeyedMutexAcquireReleaseInfoKHR>(static_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(object), settings, "VkWin32KeyedMutexAcquireReleaseInfoKHR", indents, dump_html_VkWin32KeyedMutexAcquireReleaseInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000078000:
        dump_html_pNext<const VkImportSemaphoreWin32HandleInfoKHR>(static_cast<const VkImportSemaphoreWin32HandleInfoKHR*>(object), settings, "VkImportSemaphoreWin32HandleInfoKHR", indents, dump_html_VkImportSemaphoreWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000078001:
        dump_html_pNext<const VkExportSemaphoreWin32HandleInfoKHR>(static_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(object), settings, "VkExportSemaphoreWin32HandleInfoKHR", indents, dump_html_VkExportSemaphoreWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000078002:
        dump_html_pNext<const VkD3D12FenceSubmitInfoKHR>(static_cast<const VkD3D12FenceSubmitInfoKHR*>(object), settings, "VkD3D12FenceSubmitInfoKHR", indents, dump_html_VkD3D12FenceSubmitInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000078003:
        dump_html_pNext<const VkSemaphoreGetWin32HandleInfoKHR>(static_cast<const VkSemaphoreGetWin32HandleInfoKHR*>(object), settings, "VkSemaphoreGetWin32HandleInfoKHR", indents, dump_html_VkSemaphoreGetWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000079000:
        dump_html_pNext<const VkImportSemaphoreFdInfoKHR>(static_cast<const VkImportSemaphoreFdInfoKHR*>(object), settings, "VkImportSemaphoreFdInfoKHR", indents, dump_html_VkImportSemaphoreFdInfoKHR);
        break;
    case 1000079001:
        dump_html_pNext<const VkSemaphoreGetFdInfoKHR>(static_cast<const VkSemaphoreGetFdInfoKHR*>(object), settings, "VkSemaphoreGetFdInfoKHR", indents, dump_html_VkSemaphoreGetFdInfoKHR);
        break;
    case 1000080000:
        dump_html_pNext<const VkPhysicalDevicePushDescriptorPropertiesKHR>(static_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(object), settings, "VkPhysicalDevicePushDescriptorPropertiesKHR", indents, dump_html_VkPhysicalDevicePushDescriptorPropertiesKHR);
        break;
    case 1000081002:
        dump_html_pNext<const VkConditionalRenderingBeginInfoEXT>(static_cast<const VkConditionalRenderingBeginInfoEXT*>(object), settings, "VkConditionalRenderingBeginInfoEXT", indents, dump_html_VkConditionalRenderingBeginInfoEXT);
        break;
    case 1000081001:
        dump_html_pNext<const VkPhysicalDeviceConditionalRenderingFeaturesEXT>(static_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(object), settings, "VkPhysicalDeviceConditionalRenderingFeaturesEXT", indents, dump_html_VkPhysicalDeviceConditionalRenderingFeaturesEXT);
        break;
    case 1000081000:
        dump_html_pNext<const VkCommandBufferInheritanceConditionalRenderingInfoEXT>(static_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(object), settings, "VkCommandBufferInheritanceConditionalRenderingInfoEXT", indents, dump_html_VkCommandBufferInheritanceConditionalRenderingInfoEXT);
        break;
    case 1000084000:
        dump_html_pNext<const VkPresentRegionsKHR>(static_cast<const VkPresentRegionsKHR*>(object), settings, "VkPresentRegionsKHR", indents, dump_html_VkPresentRegionsKHR);
        break;
    case 1000087000:
        dump_html_pNext<const VkPipelineViewportWScalingStateCreateInfoNV>(static_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(object), settings, "VkPipelineViewportWScalingStateCreateInfoNV", indents, dump_html_VkPipelineViewportWScalingStateCreateInfoNV);
        break;
    case 1000090000:
        dump_html_pNext<const VkSurfaceCapabilities2EXT>(static_cast<const VkSurfaceCapabilities2EXT*>(object), settings, "VkSurfaceCapabilities2EXT", indents, dump_html_VkSurfaceCapabilities2EXT);
        break;
    case 1000091000:
        dump_html_pNext<const VkDisplayPowerInfoEXT>(static_cast<const VkDisplayPowerInfoEXT*>(object), settings, "VkDisplayPowerInfoEXT", indents, dump_html_VkDisplayPowerInfoEXT);
        break;
    case 1000091001:
        dump_html_pNext<const VkDeviceEventInfoEXT>(static_cast<const VkDeviceEventInfoEXT*>(object), settings, "VkDeviceEventInfoEXT", indents, dump_html_VkDeviceEventInfoEXT);
        break;
    case 1000091002:
        dump_html_pNext<const VkDisplayEventInfoEXT>(static_cast<const VkDisplayEventInfoEXT*>(object), settings, "VkDisplayEventInfoEXT", indents, dump_html_VkDisplayEventInfoEXT);
        break;
    case 1000091003:
        dump_html_pNext<const VkSwapchainCounterCreateInfoEXT>(static_cast<const VkSwapchainCounterCreateInfoEXT*>(object), settings, "VkSwapchainCounterCreateInfoEXT", indents, dump_html_VkSwapchainCounterCreateInfoEXT);
        break;
    case 1000092000:
        dump_html_pNext<const VkPresentTimesInfoGOOGLE>(static_cast<const VkPresentTimesInfoGOOGLE*>(object), settings, "VkPresentTimesInfoGOOGLE", indents, dump_html_VkPresentTimesInfoGOOGLE);
        break;
    case 1000097000:
        dump_html_pNext<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(static_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(object), settings, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", indents, dump_html_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);
        break;
    case 1000098000:
        dump_html_pNext<const VkPipelineViewportSwizzleStateCreateInfoNV>(static_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(object), settings, "VkPipelineViewportSwizzleStateCreateInfoNV", indents, dump_html_VkPipelineViewportSwizzleStateCreateInfoNV);
        break;
    case 1000099000:
        dump_html_pNext<const VkPhysicalDeviceDiscardRectanglePropertiesEXT>(static_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(object), settings, "VkPhysicalDeviceDiscardRectanglePropertiesEXT", indents, dump_html_VkPhysicalDeviceDiscardRectanglePropertiesEXT);
        break;
    case 1000099001:
        dump_html_pNext<const VkPipelineDiscardRectangleStateCreateInfoEXT>(static_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(object), settings, "VkPipelineDiscardRectangleStateCreateInfoEXT", indents, dump_html_VkPipelineDiscardRectangleStateCreateInfoEXT);
        break;
    case 1000101000:
        dump_html_pNext<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(static_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(object), settings, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT", indents, dump_html_VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
        break;
    case 1000101001:
        dump_html_pNext<const VkPipelineRasterizationConservativeStateCreateInfoEXT>(static_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(object), settings, "VkPipelineRasterizationConservativeStateCreateInfoEXT", indents, dump_html_VkPipelineRasterizationConservativeStateCreateInfoEXT);
        break;
    case 1000102000:
        dump_html_pNext<const VkPhysicalDeviceDepthClipEnableFeaturesEXT>(static_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(object), settings, "VkPhysicalDeviceDepthClipEnableFeaturesEXT", indents, dump_html_VkPhysicalDeviceDepthClipEnableFeaturesEXT);
        break;
    case 1000102001:
        dump_html_pNext<const VkPipelineRasterizationDepthClipStateCreateInfoEXT>(static_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(object), settings, "VkPipelineRasterizationDepthClipStateCreateInfoEXT", indents, dump_html_VkPipelineRasterizationDepthClipStateCreateInfoEXT);
        break;
    case 1000105000:
        dump_html_pNext<const VkHdrMetadataEXT>(static_cast<const VkHdrMetadataEXT*>(object), settings, "VkHdrMetadataEXT", indents, dump_html_VkHdrMetadataEXT);
        break;
    case 1000110000:
        dump_html_pNext<const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>(static_cast<const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*>(object), settings, "VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG", indents, dump_html_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG);
        break;
    case 1000111000:
        dump_html_pNext<const VkSharedPresentSurfaceCapabilitiesKHR>(static_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(object), settings, "VkSharedPresentSurfaceCapabilitiesKHR", indents, dump_html_VkSharedPresentSurfaceCapabilitiesKHR);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000114000:
        dump_html_pNext<const VkImportFenceWin32HandleInfoKHR>(static_cast<const VkImportFenceWin32HandleInfoKHR*>(object), settings, "VkImportFenceWin32HandleInfoKHR", indents, dump_html_VkImportFenceWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000114001:
        dump_html_pNext<const VkExportFenceWin32HandleInfoKHR>(static_cast<const VkExportFenceWin32HandleInfoKHR*>(object), settings, "VkExportFenceWin32HandleInfoKHR", indents, dump_html_VkExportFenceWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000114002:
        dump_html_pNext<const VkFenceGetWin32HandleInfoKHR>(static_cast<const VkFenceGetWin32HandleInfoKHR*>(object), settings, "VkFenceGetWin32HandleInfoKHR", indents, dump_html_VkFenceGetWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000115000:
        dump_html_pNext<const VkImportFenceFdInfoKHR>(static_cast<const VkImportFenceFdInfoKHR*>(object), settings, "VkImportFenceFdInfoKHR", indents, dump_html_VkImportFenceFdInfoKHR);
        break;
    case 1000115001:
        dump_html_pNext<const VkFenceGetFdInfoKHR>(static_cast<const VkFenceGetFdInfoKHR*>(object), settings, "VkFenceGetFdInfoKHR", indents, dump_html_VkFenceGetFdInfoKHR);
        break;
    case 1000116000:
        dump_html_pNext<const VkPhysicalDevicePerformanceQueryFeaturesKHR>(static_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(object), settings, "VkPhysicalDevicePerformanceQueryFeaturesKHR", indents, dump_html_VkPhysicalDevicePerformanceQueryFeaturesKHR);
        break;
    case 1000116001:
        dump_html_pNext<const VkPhysicalDevicePerformanceQueryPropertiesKHR>(static_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR*>(object), settings, "VkPhysicalDevicePerformanceQueryPropertiesKHR", indents, dump_html_VkPhysicalDevicePerformanceQueryPropertiesKHR);
        break;
    case 1000116005:
        dump_html_pNext<const VkPerformanceCounterKHR>(static_cast<const VkPerformanceCounterKHR*>(object), settings, "VkPerformanceCounterKHR", indents, dump_html_VkPerformanceCounterKHR);
        break;
    case 1000116006:
        dump_html_pNext<const VkPerformanceCounterDescriptionKHR>(static_cast<const VkPerformanceCounterDescriptionKHR*>(object), settings, "VkPerformanceCounterDescriptionKHR", indents, dump_html_VkPerformanceCounterDescriptionKHR);
        break;
    case 1000116002:
        dump_html_pNext<const VkQueryPoolPerformanceCreateInfoKHR>(static_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(object), settings, "VkQueryPoolPerformanceCreateInfoKHR", indents, dump_html_VkQueryPoolPerformanceCreateInfoKHR);
        break;
    case 1000116004:
        dump_html_pNext<const VkAcquireProfilingLockInfoKHR>(static_cast<const VkAcquireProfilingLockInfoKHR*>(object), settings, "VkAcquireProfilingLockInfoKHR", indents, dump_html_VkAcquireProfilingLockInfoKHR);
        break;
    case 1000116003:
        dump_html_pNext<const VkPerformanceQuerySubmitInfoKHR>(static_cast<const VkPerformanceQuerySubmitInfoKHR*>(object), settings, "VkPerformanceQuerySubmitInfoKHR", indents, dump_html_VkPerformanceQuerySubmitInfoKHR);
        break;
    case 1000119000:
        dump_html_pNext<const VkPhysicalDeviceSurfaceInfo2KHR>(static_cast<const VkPhysicalDeviceSurfaceInfo2KHR*>(object), settings, "VkPhysicalDeviceSurfaceInfo2KHR", indents, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        break;
    case 1000119001:
        dump_html_pNext<const VkSurfaceCapabilities2KHR>(static_cast<const VkSurfaceCapabilities2KHR*>(object), settings, "VkSurfaceCapabilities2KHR", indents, dump_html_VkSurfaceCapabilities2KHR);
        break;
    case 1000119002:
        dump_html_pNext<const VkSurfaceFormat2KHR>(static_cast<const VkSurfaceFormat2KHR*>(object), settings, "VkSurfaceFormat2KHR", indents, dump_html_VkSurfaceFormat2KHR);
        break;
    case 1000121000:
        dump_html_pNext<const VkDisplayProperties2KHR>(static_cast<const VkDisplayProperties2KHR*>(object), settings, "VkDisplayProperties2KHR", indents, dump_html_VkDisplayProperties2KHR);
        break;
    case 1000121001:
        dump_html_pNext<const VkDisplayPlaneProperties2KHR>(static_cast<const VkDisplayPlaneProperties2KHR*>(object), settings, "VkDisplayPlaneProperties2KHR", indents, dump_html_VkDisplayPlaneProperties2KHR);
        break;
    case 1000121002:
        dump_html_pNext<const VkDisplayModeProperties2KHR>(static_cast<const VkDisplayModeProperties2KHR*>(object), settings, "VkDisplayModeProperties2KHR", indents, dump_html_VkDisplayModeProperties2KHR);
        break;
    case 1000121003:
        dump_html_pNext<const VkDisplayPlaneInfo2KHR>(static_cast<const VkDisplayPlaneInfo2KHR*>(object), settings, "VkDisplayPlaneInfo2KHR", indents, dump_html_VkDisplayPlaneInfo2KHR);
        break;
    case 1000121004:
        dump_html_pNext<const VkDisplayPlaneCapabilities2KHR>(static_cast<const VkDisplayPlaneCapabilities2KHR*>(object), settings, "VkDisplayPlaneCapabilities2KHR", indents, dump_html_VkDisplayPlaneCapabilities2KHR);
        break;
#if defined(VK_USE_PLATFORM_IOS_MVK)
    case 1000122000:
        dump_html_pNext<const VkIOSSurfaceCreateInfoMVK>(static_cast<const VkIOSSurfaceCreateInfoMVK*>(object), settings, "VkIOSSurfaceCreateInfoMVK", indents, dump_html_VkIOSSurfaceCreateInfoMVK);
        break;
#endif // VK_USE_PLATFORM_IOS_MVK
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    case 1000123000:
        dump_html_pNext<const VkMacOSSurfaceCreateInfoMVK>(static_cast<const VkMacOSSurfaceCreateInfoMVK*>(object), settings, "VkMacOSSurfaceCreateInfoMVK", indents, dump_html_VkMacOSSurfaceCreateInfoMVK);
        break;
#endif // VK_USE_PLATFORM_MACOS_MVK
    case 1000128002:
        dump_html_pNext<const VkDebugUtilsLabelEXT>(static_cast<const VkDebugUtilsLabelEXT*>(object), settings, "VkDebugUtilsLabelEXT", indents, dump_html_VkDebugUtilsLabelEXT);
        break;
    case 1000128000:
        dump_html_pNext<const VkDebugUtilsObjectNameInfoEXT>(static_cast<const VkDebugUtilsObjectNameInfoEXT*>(object), settings, "VkDebugUtilsObjectNameInfoEXT", indents, dump_html_VkDebugUtilsObjectNameInfoEXT);
        break;
    case 1000128003:
        dump_html_pNext<const VkDebugUtilsMessengerCallbackDataEXT>(static_cast<const VkDebugUtilsMessengerCallbackDataEXT*>(object), settings, "VkDebugUtilsMessengerCallbackDataEXT", indents, dump_html_VkDebugUtilsMessengerCallbackDataEXT);
        break;
    case 1000128004:
        dump_html_pNext<const VkDebugUtilsMessengerCreateInfoEXT>(static_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(object), settings, "VkDebugUtilsMessengerCreateInfoEXT", indents, dump_html_VkDebugUtilsMessengerCreateInfoEXT);
        break;
    case 1000128001:
        dump_html_pNext<const VkDebugUtilsObjectTagInfoEXT>(static_cast<const VkDebugUtilsObjectTagInfoEXT*>(object), settings, "VkDebugUtilsObjectTagInfoEXT", indents, dump_html_VkDebugUtilsObjectTagInfoEXT);
        break;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129000:
        dump_html_pNext<const VkAndroidHardwareBufferUsageANDROID>(static_cast<const VkAndroidHardwareBufferUsageANDROID*>(object), settings, "VkAndroidHardwareBufferUsageANDROID", indents, dump_html_VkAndroidHardwareBufferUsageANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129001:
        dump_html_pNext<const VkAndroidHardwareBufferPropertiesANDROID>(static_cast<const VkAndroidHardwareBufferPropertiesANDROID*>(object), settings, "VkAndroidHardwareBufferPropertiesANDROID", indents, dump_html_VkAndroidHardwareBufferPropertiesANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129002:
        dump_html_pNext<const VkAndroidHardwareBufferFormatPropertiesANDROID>(static_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(object), settings, "VkAndroidHardwareBufferFormatPropertiesANDROID", indents, dump_html_VkAndroidHardwareBufferFormatPropertiesANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129003:
        dump_html_pNext<const VkImportAndroidHardwareBufferInfoANDROID>(static_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(object), settings, "VkImportAndroidHardwareBufferInfoANDROID", indents, dump_html_VkImportAndroidHardwareBufferInfoANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129004:
        dump_html_pNext<const VkMemoryGetAndroidHardwareBufferInfoANDROID>(static_cast<const VkMemoryGetAndroidHardwareBufferInfoANDROID*>(object), settings, "VkMemoryGetAndroidHardwareBufferInfoANDROID", indents, dump_html_VkMemoryGetAndroidHardwareBufferInfoANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129005:
        dump_html_pNext<const VkExternalFormatANDROID>(static_cast<const VkExternalFormatANDROID*>(object), settings, "VkExternalFormatANDROID", indents, dump_html_VkExternalFormatANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129006:
        dump_html_pNext<const VkAndroidHardwareBufferFormatProperties2ANDROID>(static_cast<const VkAndroidHardwareBufferFormatProperties2ANDROID*>(object), settings, "VkAndroidHardwareBufferFormatProperties2ANDROID", indents, dump_html_VkAndroidHardwareBufferFormatProperties2ANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000134000:
        dump_html_pNext<const VkPhysicalDeviceShaderEnqueueFeaturesAMDX>(static_cast<const VkPhysicalDeviceShaderEnqueueFeaturesAMDX*>(object), settings, "VkPhysicalDeviceShaderEnqueueFeaturesAMDX", indents, dump_html_VkPhysicalDeviceShaderEnqueueFeaturesAMDX);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000134001:
        dump_html_pNext<const VkPhysicalDeviceShaderEnqueuePropertiesAMDX>(static_cast<const VkPhysicalDeviceShaderEnqueuePropertiesAMDX*>(object), settings, "VkPhysicalDeviceShaderEnqueuePropertiesAMDX", indents, dump_html_VkPhysicalDeviceShaderEnqueuePropertiesAMDX);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000134002:
        dump_html_pNext<const VkExecutionGraphPipelineScratchSizeAMDX>(static_cast<const VkExecutionGraphPipelineScratchSizeAMDX*>(object), settings, "VkExecutionGraphPipelineScratchSizeAMDX", indents, dump_html_VkExecutionGraphPipelineScratchSizeAMDX);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
    case 1000290000:
        dump_html_pNext<const VkPipelineLibraryCreateInfoKHR>(static_cast<const VkPipelineLibraryCreateInfoKHR*>(object), settings, "VkPipelineLibraryCreateInfoKHR", indents, dump_html_VkPipelineLibraryCreateInfoKHR);
        break;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000134003:
        dump_html_pNext<const VkExecutionGraphPipelineCreateInfoAMDX>(static_cast<const VkExecutionGraphPipelineCreateInfoAMDX*>(object), settings, "VkExecutionGraphPipelineCreateInfoAMDX", indents, dump_html_VkExecutionGraphPipelineCreateInfoAMDX);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000134004:
        dump_html_pNext<const VkPipelineShaderStageNodeCreateInfoAMDX>(static_cast<const VkPipelineShaderStageNodeCreateInfoAMDX*>(object), settings, "VkPipelineShaderStageNodeCreateInfoAMDX", indents, dump_html_VkPipelineShaderStageNodeCreateInfoAMDX);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
    case 1000143000:
        dump_html_pNext<const VkSampleLocationsInfoEXT>(static_cast<const VkSampleLocationsInfoEXT*>(object), settings, "VkSampleLocationsInfoEXT", indents, dump_html_VkSampleLocationsInfoEXT);
        break;
    case 1000143001:
        dump_html_pNext<const VkRenderPassSampleLocationsBeginInfoEXT>(static_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(object), settings, "VkRenderPassSampleLocationsBeginInfoEXT", indents, dump_html_VkRenderPassSampleLocationsBeginInfoEXT);
        break;
    case 1000143002:
        dump_html_pNext<const VkPipelineSampleLocationsStateCreateInfoEXT>(static_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(object), settings, "VkPipelineSampleLocationsStateCreateInfoEXT", indents, dump_html_VkPipelineSampleLocationsStateCreateInfoEXT);
        break;
    case 1000143003:
        dump_html_pNext<const VkPhysicalDeviceSampleLocationsPropertiesEXT>(static_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(object), settings, "VkPhysicalDeviceSampleLocationsPropertiesEXT", indents, dump_html_VkPhysicalDeviceSampleLocationsPropertiesEXT);
        break;
    case 1000143004:
        dump_html_pNext<const VkMultisamplePropertiesEXT>(static_cast<const VkMultisamplePropertiesEXT*>(object), settings, "VkMultisamplePropertiesEXT", indents, dump_html_VkMultisamplePropertiesEXT);
        break;
    case 1000148000:
        dump_html_pNext<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(static_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(object), settings, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", indents, dump_html_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
        break;
    case 1000148001:
        dump_html_pNext<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(static_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(object), settings, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", indents, dump_html_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
        break;
    case 1000148002:
        dump_html_pNext<const VkPipelineColorBlendAdvancedStateCreateInfoEXT>(static_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(object), settings, "VkPipelineColorBlendAdvancedStateCreateInfoEXT", indents, dump_html_VkPipelineColorBlendAdvancedStateCreateInfoEXT);
        break;
    case 1000149000:
        dump_html_pNext<const VkPipelineCoverageToColorStateCreateInfoNV>(static_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(object), settings, "VkPipelineCoverageToColorStateCreateInfoNV", indents, dump_html_VkPipelineCoverageToColorStateCreateInfoNV);
        break;
    case 1000150005:
        dump_html_pNext<const VkAccelerationStructureGeometryTrianglesDataKHR>(static_cast<const VkAccelerationStructureGeometryTrianglesDataKHR*>(object), settings, "VkAccelerationStructureGeometryTrianglesDataKHR", indents, dump_html_VkAccelerationStructureGeometryTrianglesDataKHR);
        break;
    case 1000150003:
        dump_html_pNext<const VkAccelerationStructureGeometryAabbsDataKHR>(static_cast<const VkAccelerationStructureGeometryAabbsDataKHR*>(object), settings, "VkAccelerationStructureGeometryAabbsDataKHR", indents, dump_html_VkAccelerationStructureGeometryAabbsDataKHR);
        break;
    case 1000150004:
        dump_html_pNext<const VkAccelerationStructureGeometryInstancesDataKHR>(static_cast<const VkAccelerationStructureGeometryInstancesDataKHR*>(object), settings, "VkAccelerationStructureGeometryInstancesDataKHR", indents, dump_html_VkAccelerationStructureGeometryInstancesDataKHR);
        break;
    case 1000150006:
        dump_html_pNext<const VkAccelerationStructureGeometryKHR>(static_cast<const VkAccelerationStructureGeometryKHR*>(object), settings, "VkAccelerationStructureGeometryKHR", indents, dump_html_VkAccelerationStructureGeometryKHR);
        break;
    case 1000150000:
        dump_html_pNext<const VkAccelerationStructureBuildGeometryInfoKHR>(static_cast<const VkAccelerationStructureBuildGeometryInfoKHR*>(object), settings, "VkAccelerationStructureBuildGeometryInfoKHR", indents, dump_html_VkAccelerationStructureBuildGeometryInfoKHR);
        break;
    case 1000150017:
        dump_html_pNext<const VkAccelerationStructureCreateInfoKHR>(static_cast<const VkAccelerationStructureCreateInfoKHR*>(object), settings, "VkAccelerationStructureCreateInfoKHR", indents, dump_html_VkAccelerationStructureCreateInfoKHR);
        break;
    case 1000150007:
        dump_html_pNext<const VkWriteDescriptorSetAccelerationStructureKHR>(static_cast<const VkWriteDescriptorSetAccelerationStructureKHR*>(object), settings, "VkWriteDescriptorSetAccelerationStructureKHR", indents, dump_html_VkWriteDescriptorSetAccelerationStructureKHR);
        break;
    case 1000150013:
        dump_html_pNext<const VkPhysicalDeviceAccelerationStructureFeaturesKHR>(static_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(object), settings, "VkPhysicalDeviceAccelerationStructureFeaturesKHR", indents, dump_html_VkPhysicalDeviceAccelerationStructureFeaturesKHR);
        break;
    case 1000150014:
        dump_html_pNext<const VkPhysicalDeviceAccelerationStructurePropertiesKHR>(static_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(object), settings, "VkPhysicalDeviceAccelerationStructurePropertiesKHR", indents, dump_html_VkPhysicalDeviceAccelerationStructurePropertiesKHR);
        break;
    case 1000150002:
        dump_html_pNext<const VkAccelerationStructureDeviceAddressInfoKHR>(static_cast<const VkAccelerationStructureDeviceAddressInfoKHR*>(object), settings, "VkAccelerationStructureDeviceAddressInfoKHR", indents, dump_html_VkAccelerationStructureDeviceAddressInfoKHR);
        break;
    case 1000150009:
        dump_html_pNext<const VkAccelerationStructureVersionInfoKHR>(static_cast<const VkAccelerationStructureVersionInfoKHR*>(object), settings, "VkAccelerationStructureVersionInfoKHR", indents, dump_html_VkAccelerationStructureVersionInfoKHR);
        break;
    case 1000150011:
        dump_html_pNext<const VkCopyAccelerationStructureToMemoryInfoKHR>(static_cast<const VkCopyAccelerationStructureToMemoryInfoKHR*>(object), settings, "VkCopyAccelerationStructureToMemoryInfoKHR", indents, dump_html_VkCopyAccelerationStructureToMemoryInfoKHR);
        break;
    case 1000150012:
        dump_html_pNext<const VkCopyMemoryToAccelerationStructureInfoKHR>(static_cast<const VkCopyMemoryToAccelerationStructureInfoKHR*>(object), settings, "VkCopyMemoryToAccelerationStructureInfoKHR", indents, dump_html_VkCopyMemoryToAccelerationStructureInfoKHR);
        break;
    case 1000150010:
        dump_html_pNext<const VkCopyAccelerationStructureInfoKHR>(static_cast<const VkCopyAccelerationStructureInfoKHR*>(object), settings, "VkCopyAccelerationStructureInfoKHR", indents, dump_html_VkCopyAccelerationStructureInfoKHR);
        break;
    case 1000150020:
        dump_html_pNext<const VkAccelerationStructureBuildSizesInfoKHR>(static_cast<const VkAccelerationStructureBuildSizesInfoKHR*>(object), settings, "VkAccelerationStructureBuildSizesInfoKHR", indents, dump_html_VkAccelerationStructureBuildSizesInfoKHR);
        break;
    case 1000152000:
        dump_html_pNext<const VkPipelineCoverageModulationStateCreateInfoNV>(static_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(object), settings, "VkPipelineCoverageModulationStateCreateInfoNV", indents, dump_html_VkPipelineCoverageModulationStateCreateInfoNV);
        break;
    case 1000154001:
        dump_html_pNext<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(static_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(object), settings, "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", indents, dump_html_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);
        break;
    case 1000154000:
        dump_html_pNext<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(static_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(object), settings, "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV", indents, dump_html_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);
        break;
    case 1000158000:
        dump_html_pNext<const VkDrmFormatModifierPropertiesListEXT>(static_cast<const VkDrmFormatModifierPropertiesListEXT*>(object), settings, "VkDrmFormatModifierPropertiesListEXT", indents, dump_html_VkDrmFormatModifierPropertiesListEXT);
        break;
    case 1000158002:
        dump_html_pNext<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(static_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(object), settings, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT", indents, dump_html_VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
        break;
    case 1000158003:
        dump_html_pNext<const VkImageDrmFormatModifierListCreateInfoEXT>(static_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(object), settings, "VkImageDrmFormatModifierListCreateInfoEXT", indents, dump_html_VkImageDrmFormatModifierListCreateInfoEXT);
        break;
    case 1000158004:
        dump_html_pNext<const VkImageDrmFormatModifierExplicitCreateInfoEXT>(static_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(object), settings, "VkImageDrmFormatModifierExplicitCreateInfoEXT", indents, dump_html_VkImageDrmFormatModifierExplicitCreateInfoEXT);
        break;
    case 1000158005:
        dump_html_pNext<const VkImageDrmFormatModifierPropertiesEXT>(static_cast<const VkImageDrmFormatModifierPropertiesEXT*>(object), settings, "VkImageDrmFormatModifierPropertiesEXT", indents, dump_html_VkImageDrmFormatModifierPropertiesEXT);
        break;
    case 1000158006:
        dump_html_pNext<const VkDrmFormatModifierPropertiesList2EXT>(static_cast<const VkDrmFormatModifierPropertiesList2EXT*>(object), settings, "VkDrmFormatModifierPropertiesList2EXT", indents, dump_html_VkDrmFormatModifierPropertiesList2EXT);
        break;
    case 1000160000:
        dump_html_pNext<const VkValidationCacheCreateInfoEXT>(static_cast<const VkValidationCacheCreateInfoEXT*>(object), settings, "VkValidationCacheCreateInfoEXT", indents, dump_html_VkValidationCacheCreateInfoEXT);
        break;
    case 1000160001:
        dump_html_pNext<const VkShaderModuleValidationCacheCreateInfoEXT>(static_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(object), settings, "VkShaderModuleValidationCacheCreateInfoEXT", indents, dump_html_VkShaderModuleValidationCacheCreateInfoEXT);
        break;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000163000:
        dump_html_pNext<const VkPhysicalDevicePortabilitySubsetFeaturesKHR>(static_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(object), settings, "VkPhysicalDevicePortabilitySubsetFeaturesKHR", indents, dump_html_VkPhysicalDevicePortabilitySubsetFeaturesKHR);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000163001:
        dump_html_pNext<const VkPhysicalDevicePortabilitySubsetPropertiesKHR>(static_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(object), settings, "VkPhysicalDevicePortabilitySubsetPropertiesKHR", indents, dump_html_VkPhysicalDevicePortabilitySubsetPropertiesKHR);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
    case 1000164000:
        dump_html_pNext<const VkPipelineViewportShadingRateImageStateCreateInfoNV>(static_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(object), settings, "VkPipelineViewportShadingRateImageStateCreateInfoNV", indents, dump_html_VkPipelineViewportShadingRateImageStateCreateInfoNV);
        break;
    case 1000164001:
        dump_html_pNext<const VkPhysicalDeviceShadingRateImageFeaturesNV>(static_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(object), settings, "VkPhysicalDeviceShadingRateImageFeaturesNV", indents, dump_html_VkPhysicalDeviceShadingRateImageFeaturesNV);
        break;
    case 1000164002:
        dump_html_pNext<const VkPhysicalDeviceShadingRateImagePropertiesNV>(static_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(object), settings, "VkPhysicalDeviceShadingRateImagePropertiesNV", indents, dump_html_VkPhysicalDeviceShadingRateImagePropertiesNV);
        break;
    case 1000164005:
        dump_html_pNext<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(static_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(object), settings, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV", indents, dump_html_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);
        break;
    case 1000165011:
        dump_html_pNext<const VkRayTracingShaderGroupCreateInfoNV>(static_cast<const VkRayTracingShaderGroupCreateInfoNV*>(object), settings, "VkRayTracingShaderGroupCreateInfoNV", indents, dump_html_VkRayTracingShaderGroupCreateInfoNV);
        break;
    case 1000165000:
        dump_html_pNext<const VkRayTracingPipelineCreateInfoNV>(static_cast<const VkRayTracingPipelineCreateInfoNV*>(object), settings, "VkRayTracingPipelineCreateInfoNV", indents, dump_html_VkRayTracingPipelineCreateInfoNV);
        break;
    case 1000165004:
        dump_html_pNext<const VkGeometryTrianglesNV>(static_cast<const VkGeometryTrianglesNV*>(object), settings, "VkGeometryTrianglesNV", indents, dump_html_VkGeometryTrianglesNV);
        break;
    case 1000165005:
        dump_html_pNext<const VkGeometryAABBNV>(static_cast<const VkGeometryAABBNV*>(object), settings, "VkGeometryAABBNV", indents, dump_html_VkGeometryAABBNV);
        break;
    case 1000165003:
        dump_html_pNext<const VkGeometryNV>(static_cast<const VkGeometryNV*>(object), settings, "VkGeometryNV", indents, dump_html_VkGeometryNV);
        break;
    case 1000165012:
        dump_html_pNext<const VkAccelerationStructureInfoNV>(static_cast<const VkAccelerationStructureInfoNV*>(object), settings, "VkAccelerationStructureInfoNV", indents, dump_html_VkAccelerationStructureInfoNV);
        break;
    case 1000165001:
        dump_html_pNext<const VkAccelerationStructureCreateInfoNV>(static_cast<const VkAccelerationStructureCreateInfoNV*>(object), settings, "VkAccelerationStructureCreateInfoNV", indents, dump_html_VkAccelerationStructureCreateInfoNV);
        break;
    case 1000165006:
        dump_html_pNext<const VkBindAccelerationStructureMemoryInfoNV>(static_cast<const VkBindAccelerationStructureMemoryInfoNV*>(object), settings, "VkBindAccelerationStructureMemoryInfoNV", indents, dump_html_VkBindAccelerationStructureMemoryInfoNV);
        break;
    case 1000165007:
        dump_html_pNext<const VkWriteDescriptorSetAccelerationStructureNV>(static_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(object), settings, "VkWriteDescriptorSetAccelerationStructureNV", indents, dump_html_VkWriteDescriptorSetAccelerationStructureNV);
        break;
    case 1000165008:
        dump_html_pNext<const VkAccelerationStructureMemoryRequirementsInfoNV>(static_cast<const VkAccelerationStructureMemoryRequirementsInfoNV*>(object), settings, "VkAccelerationStructureMemoryRequirementsInfoNV", indents, dump_html_VkAccelerationStructureMemoryRequirementsInfoNV);
        break;
    case 1000165009:
        dump_html_pNext<const VkPhysicalDeviceRayTracingPropertiesNV>(static_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(object), settings, "VkPhysicalDeviceRayTracingPropertiesNV", indents, dump_html_VkPhysicalDeviceRayTracingPropertiesNV);
        break;
    case 1000166000:
        dump_html_pNext<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(static_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(object), settings, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV", indents, dump_html_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
        break;
    case 1000166001:
        dump_html_pNext<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(static_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(object), settings, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV", indents, dump_html_VkPipelineRepresentativeFragmentTestStateCreateInfoNV);
        break;
    case 1000170000:
        dump_html_pNext<const VkPhysicalDeviceImageViewImageFormatInfoEXT>(static_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(object), settings, "VkPhysicalDeviceImageViewImageFormatInfoEXT", indents, dump_html_VkPhysicalDeviceImageViewImageFormatInfoEXT);
        break;
    case 1000170001:
        dump_html_pNext<const VkFilterCubicImageViewImageFormatPropertiesEXT>(static_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(object), settings, "VkFilterCubicImageViewImageFormatPropertiesEXT", indents, dump_html_VkFilterCubicImageViewImageFormatPropertiesEXT);
        break;
    case 1000174000:
        dump_html_pNext<const VkDeviceQueueGlobalPriorityCreateInfoKHR>(static_cast<const VkDeviceQueueGlobalPriorityCreateInfoKHR*>(object), settings, "VkDeviceQueueGlobalPriorityCreateInfoKHR", indents, dump_html_VkDeviceQueueGlobalPriorityCreateInfoKHR);
        break;
    case 1000178000:
        dump_html_pNext<const VkImportMemoryHostPointerInfoEXT>(static_cast<const VkImportMemoryHostPointerInfoEXT*>(object), settings, "VkImportMemoryHostPointerInfoEXT", indents, dump_html_VkImportMemoryHostPointerInfoEXT);
        break;
    case 1000178001:
        dump_html_pNext<const VkMemoryHostPointerPropertiesEXT>(static_cast<const VkMemoryHostPointerPropertiesEXT*>(object), settings, "VkMemoryHostPointerPropertiesEXT", indents, dump_html_VkMemoryHostPointerPropertiesEXT);
        break;
    case 1000178002:
        dump_html_pNext<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(static_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(object), settings, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT", indents, dump_html_VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
        break;
    case 1000181000:
        dump_html_pNext<const VkPhysicalDeviceShaderClockFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderClockFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderClockFeaturesKHR);
        break;
    case 1000183000:
        dump_html_pNext<const VkPipelineCompilerControlCreateInfoAMD>(static_cast<const VkPipelineCompilerControlCreateInfoAMD*>(object), settings, "VkPipelineCompilerControlCreateInfoAMD", indents, dump_html_VkPipelineCompilerControlCreateInfoAMD);
        break;
    case 1000184000:
        dump_html_pNext<const VkCalibratedTimestampInfoKHR>(static_cast<const VkCalibratedTimestampInfoKHR*>(object), settings, "VkCalibratedTimestampInfoKHR", indents, dump_html_VkCalibratedTimestampInfoKHR);
        break;
    case 1000185000:
        dump_html_pNext<const VkPhysicalDeviceShaderCorePropertiesAMD>(static_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(object), settings, "VkPhysicalDeviceShaderCorePropertiesAMD", indents, dump_html_VkPhysicalDeviceShaderCorePropertiesAMD);
        break;
    case 1000187003:
        dump_html_pNext<const VkVideoDecodeH265ProfileInfoKHR>(static_cast<const VkVideoDecodeH265ProfileInfoKHR*>(object), settings, "VkVideoDecodeH265ProfileInfoKHR", indents, dump_html_VkVideoDecodeH265ProfileInfoKHR);
        break;
    case 1000187000:
        dump_html_pNext<const VkVideoDecodeH265CapabilitiesKHR>(static_cast<const VkVideoDecodeH265CapabilitiesKHR*>(object), settings, "VkVideoDecodeH265CapabilitiesKHR", indents, dump_html_VkVideoDecodeH265CapabilitiesKHR);
        break;
    case 1000187002:
        dump_html_pNext<const VkVideoDecodeH265SessionParametersAddInfoKHR>(static_cast<const VkVideoDecodeH265SessionParametersAddInfoKHR*>(object), settings, "VkVideoDecodeH265SessionParametersAddInfoKHR", indents, dump_html_VkVideoDecodeH265SessionParametersAddInfoKHR);
        break;
    case 1000187001:
        dump_html_pNext<const VkVideoDecodeH265SessionParametersCreateInfoKHR>(static_cast<const VkVideoDecodeH265SessionParametersCreateInfoKHR*>(object), settings, "VkVideoDecodeH265SessionParametersCreateInfoKHR", indents, dump_html_VkVideoDecodeH265SessionParametersCreateInfoKHR);
        break;
    case 1000187004:
        dump_html_pNext<const VkVideoDecodeH265PictureInfoKHR>(static_cast<const VkVideoDecodeH265PictureInfoKHR*>(object), settings, "VkVideoDecodeH265PictureInfoKHR", indents, dump_html_VkVideoDecodeH265PictureInfoKHR);
        break;
    case 1000187005:
        dump_html_pNext<const VkVideoDecodeH265DpbSlotInfoKHR>(static_cast<const VkVideoDecodeH265DpbSlotInfoKHR*>(object), settings, "VkVideoDecodeH265DpbSlotInfoKHR", indents, dump_html_VkVideoDecodeH265DpbSlotInfoKHR);
        break;
    case 1000388000:
        dump_html_pNext<const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>(static_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(object), settings, "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR", indents, dump_html_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR);
        break;
    case 1000388001:
        dump_html_pNext<const VkQueueFamilyGlobalPriorityPropertiesKHR>(static_cast<const VkQueueFamilyGlobalPriorityPropertiesKHR*>(object), settings, "VkQueueFamilyGlobalPriorityPropertiesKHR", indents, dump_html_VkQueueFamilyGlobalPriorityPropertiesKHR);
        break;
    case 1000189000:
        dump_html_pNext<const VkDeviceMemoryOverallocationCreateInfoAMD>(static_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(object), settings, "VkDeviceMemoryOverallocationCreateInfoAMD", indents, dump_html_VkDeviceMemoryOverallocationCreateInfoAMD);
        break;
    case 1000190000:
        dump_html_pNext<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(static_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(object), settings, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", indents, dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
        break;
    case 1000190001:
        dump_html_pNext<const VkPipelineVertexInputDivisorStateCreateInfoKHR>(static_cast<const VkPipelineVertexInputDivisorStateCreateInfoKHR*>(object), settings, "VkPipelineVertexInputDivisorStateCreateInfoKHR", indents, dump_html_VkPipelineVertexInputDivisorStateCreateInfoKHR);
        break;
    case 1000190002:
        dump_html_pNext<const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR>(static_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR*>(object), settings, "VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR", indents, dump_html_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR);
        break;
#if defined(VK_USE_PLATFORM_GGP)
    case 1000191000:
        dump_html_pNext<const VkPresentFrameTokenGGP>(static_cast<const VkPresentFrameTokenGGP*>(object), settings, "VkPresentFrameTokenGGP", indents, dump_html_VkPresentFrameTokenGGP);
        break;
#endif // VK_USE_PLATFORM_GGP
    case 1000201000:
        dump_html_pNext<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(static_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(object), settings, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV", indents, dump_html_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);
        break;
    case 1000202000:
        dump_html_pNext<const VkPhysicalDeviceMeshShaderFeaturesNV>(static_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(object), settings, "VkPhysicalDeviceMeshShaderFeaturesNV", indents, dump_html_VkPhysicalDeviceMeshShaderFeaturesNV);
        break;
    case 1000202001:
        dump_html_pNext<const VkPhysicalDeviceMeshShaderPropertiesNV>(static_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(object), settings, "VkPhysicalDeviceMeshShaderPropertiesNV", indents, dump_html_VkPhysicalDeviceMeshShaderPropertiesNV);
        break;
    case 1000203000:
        dump_html_pNext<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>(static_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*>(object), settings, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR", indents, dump_html_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR);
        break;
    case 1000204000:
        dump_html_pNext<const VkPhysicalDeviceShaderImageFootprintFeaturesNV>(static_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(object), settings, "VkPhysicalDeviceShaderImageFootprintFeaturesNV", indents, dump_html_VkPhysicalDeviceShaderImageFootprintFeaturesNV);
        break;
    case 1000205000:
        dump_html_pNext<const VkPipelineViewportExclusiveScissorStateCreateInfoNV>(static_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(object), settings, "VkPipelineViewportExclusiveScissorStateCreateInfoNV", indents, dump_html_VkPipelineViewportExclusiveScissorStateCreateInfoNV);
        break;
    case 1000205002:
        dump_html_pNext<const VkPhysicalDeviceExclusiveScissorFeaturesNV>(static_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(object), settings, "VkPhysicalDeviceExclusiveScissorFeaturesNV", indents, dump_html_VkPhysicalDeviceExclusiveScissorFeaturesNV);
        break;
    case 1000206001:
        dump_html_pNext<const VkQueueFamilyCheckpointPropertiesNV>(static_cast<const VkQueueFamilyCheckpointPropertiesNV*>(object), settings, "VkQueueFamilyCheckpointPropertiesNV", indents, dump_html_VkQueueFamilyCheckpointPropertiesNV);
        break;
    case 1000206000:
        dump_html_pNext<const VkCheckpointDataNV>(static_cast<const VkCheckpointDataNV*>(object), settings, "VkCheckpointDataNV", indents, dump_html_VkCheckpointDataNV);
        break;
    case 1000209000:
        dump_html_pNext<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(static_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(object), settings, "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", indents, dump_html_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
        break;
    case 1000210001:
        dump_html_pNext<const VkInitializePerformanceApiInfoINTEL>(static_cast<const VkInitializePerformanceApiInfoINTEL*>(object), settings, "VkInitializePerformanceApiInfoINTEL", indents, dump_html_VkInitializePerformanceApiInfoINTEL);
        break;
    case 1000210000:
        dump_html_pNext<const VkQueryPoolPerformanceQueryCreateInfoINTEL>(static_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL*>(object), settings, "VkQueryPoolPerformanceQueryCreateInfoINTEL", indents, dump_html_VkQueryPoolPerformanceQueryCreateInfoINTEL);
        break;
    case 1000210002:
        dump_html_pNext<const VkPerformanceMarkerInfoINTEL>(static_cast<const VkPerformanceMarkerInfoINTEL*>(object), settings, "VkPerformanceMarkerInfoINTEL", indents, dump_html_VkPerformanceMarkerInfoINTEL);
        break;
    case 1000210003:
        dump_html_pNext<const VkPerformanceStreamMarkerInfoINTEL>(static_cast<const VkPerformanceStreamMarkerInfoINTEL*>(object), settings, "VkPerformanceStreamMarkerInfoINTEL", indents, dump_html_VkPerformanceStreamMarkerInfoINTEL);
        break;
    case 1000210004:
        dump_html_pNext<const VkPerformanceOverrideInfoINTEL>(static_cast<const VkPerformanceOverrideInfoINTEL*>(object), settings, "VkPerformanceOverrideInfoINTEL", indents, dump_html_VkPerformanceOverrideInfoINTEL);
        break;
    case 1000210005:
        dump_html_pNext<const VkPerformanceConfigurationAcquireInfoINTEL>(static_cast<const VkPerformanceConfigurationAcquireInfoINTEL*>(object), settings, "VkPerformanceConfigurationAcquireInfoINTEL", indents, dump_html_VkPerformanceConfigurationAcquireInfoINTEL);
        break;
    case 1000212000:
        dump_html_pNext<const VkPhysicalDevicePCIBusInfoPropertiesEXT>(static_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(object), settings, "VkPhysicalDevicePCIBusInfoPropertiesEXT", indents, dump_html_VkPhysicalDevicePCIBusInfoPropertiesEXT);
        break;
    case 1000213000:
        dump_html_pNext<const VkDisplayNativeHdrSurfaceCapabilitiesAMD>(static_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(object), settings, "VkDisplayNativeHdrSurfaceCapabilitiesAMD", indents, dump_html_VkDisplayNativeHdrSurfaceCapabilitiesAMD);
        break;
    case 1000213001:
        dump_html_pNext<const VkSwapchainDisplayNativeHdrCreateInfoAMD>(static_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(object), settings, "VkSwapchainDisplayNativeHdrCreateInfoAMD", indents, dump_html_VkSwapchainDisplayNativeHdrCreateInfoAMD);
        break;
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000214000:
        dump_html_pNext<const VkImagePipeSurfaceCreateInfoFUCHSIA>(static_cast<const VkImagePipeSurfaceCreateInfoFUCHSIA*>(object), settings, "VkImagePipeSurfaceCreateInfoFUCHSIA", indents, dump_html_VkImagePipeSurfaceCreateInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000217000:
        dump_html_pNext<const VkMetalSurfaceCreateInfoEXT>(static_cast<const VkMetalSurfaceCreateInfoEXT*>(object), settings, "VkMetalSurfaceCreateInfoEXT", indents, dump_html_VkMetalSurfaceCreateInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
    case 1000218000:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(static_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(object), settings, "VkPhysicalDeviceFragmentDensityMapFeaturesEXT", indents, dump_html_VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
        break;
    case 1000218001:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(static_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(object), settings, "VkPhysicalDeviceFragmentDensityMapPropertiesEXT", indents, dump_html_VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
        break;
    case 1000218002:
        dump_html_pNext<const VkRenderPassFragmentDensityMapCreateInfoEXT>(static_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(object), settings, "VkRenderPassFragmentDensityMapCreateInfoEXT", indents, dump_html_VkRenderPassFragmentDensityMapCreateInfoEXT);
        break;
    case 1000226000:
        dump_html_pNext<const VkFragmentShadingRateAttachmentInfoKHR>(static_cast<const VkFragmentShadingRateAttachmentInfoKHR*>(object), settings, "VkFragmentShadingRateAttachmentInfoKHR", indents, dump_html_VkFragmentShadingRateAttachmentInfoKHR);
        break;
    case 1000226001:
        dump_html_pNext<const VkPipelineFragmentShadingRateStateCreateInfoKHR>(static_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR*>(object), settings, "VkPipelineFragmentShadingRateStateCreateInfoKHR", indents, dump_html_VkPipelineFragmentShadingRateStateCreateInfoKHR);
        break;
    case 1000226003:
        dump_html_pNext<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(static_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(object), settings, "VkPhysicalDeviceFragmentShadingRateFeaturesKHR", indents, dump_html_VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
        break;
    case 1000226002:
        dump_html_pNext<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(static_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(object), settings, "VkPhysicalDeviceFragmentShadingRatePropertiesKHR", indents, dump_html_VkPhysicalDeviceFragmentShadingRatePropertiesKHR);
        break;
    case 1000226004:
        dump_html_pNext<const VkPhysicalDeviceFragmentShadingRateKHR>(static_cast<const VkPhysicalDeviceFragmentShadingRateKHR*>(object), settings, "VkPhysicalDeviceFragmentShadingRateKHR", indents, dump_html_VkPhysicalDeviceFragmentShadingRateKHR);
        break;
    case 1000227000:
        dump_html_pNext<const VkPhysicalDeviceShaderCoreProperties2AMD>(static_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(object), settings, "VkPhysicalDeviceShaderCoreProperties2AMD", indents, dump_html_VkPhysicalDeviceShaderCoreProperties2AMD);
        break;
    case 1000229000:
        dump_html_pNext<const VkPhysicalDeviceCoherentMemoryFeaturesAMD>(static_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(object), settings, "VkPhysicalDeviceCoherentMemoryFeaturesAMD", indents, dump_html_VkPhysicalDeviceCoherentMemoryFeaturesAMD);
        break;
    case 1000232000:
        dump_html_pNext<const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR>(static_cast<const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR*>(object), settings, "VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR", indents, dump_html_VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR);
        break;
    case 1000232001:
        dump_html_pNext<const VkRenderingAttachmentLocationInfoKHR>(static_cast<const VkRenderingAttachmentLocationInfoKHR*>(object), settings, "VkRenderingAttachmentLocationInfoKHR", indents, dump_html_VkRenderingAttachmentLocationInfoKHR);
        break;
    case 1000232002:
        dump_html_pNext<const VkRenderingInputAttachmentIndexInfoKHR>(static_cast<const VkRenderingInputAttachmentIndexInfoKHR*>(object), settings, "VkRenderingInputAttachmentIndexInfoKHR", indents, dump_html_VkRenderingInputAttachmentIndexInfoKHR);
        break;
    case 1000234000:
        dump_html_pNext<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(static_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
        break;
    case 1000235000:
        dump_html_pNext<const VkPhysicalDeviceShaderQuadControlFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderQuadControlFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderQuadControlFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderQuadControlFeaturesKHR);
        break;
    case 1000237000:
        dump_html_pNext<const VkPhysicalDeviceMemoryBudgetPropertiesEXT>(static_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(object), settings, "VkPhysicalDeviceMemoryBudgetPropertiesEXT", indents, dump_html_VkPhysicalDeviceMemoryBudgetPropertiesEXT);
        break;
    case 1000238000:
        dump_html_pNext<const VkPhysicalDeviceMemoryPriorityFeaturesEXT>(static_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(object), settings, "VkPhysicalDeviceMemoryPriorityFeaturesEXT", indents, dump_html_VkPhysicalDeviceMemoryPriorityFeaturesEXT);
        break;
    case 1000238001:
        dump_html_pNext<const VkMemoryPriorityAllocateInfoEXT>(static_cast<const VkMemoryPriorityAllocateInfoEXT*>(object), settings, "VkMemoryPriorityAllocateInfoEXT", indents, dump_html_VkMemoryPriorityAllocateInfoEXT);
        break;
    case 1000239000:
        dump_html_pNext<const VkSurfaceProtectedCapabilitiesKHR>(static_cast<const VkSurfaceProtectedCapabilitiesKHR*>(object), settings, "VkSurfaceProtectedCapabilitiesKHR", indents, dump_html_VkSurfaceProtectedCapabilitiesKHR);
        break;
    case 1000240000:
        dump_html_pNext<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(static_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(object), settings, "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", indents, dump_html_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
        break;
    case 1000244000:
        dump_html_pNext<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(static_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(object), settings, "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", indents, dump_html_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
        break;
    case 1000244002:
        dump_html_pNext<const VkBufferDeviceAddressCreateInfoEXT>(static_cast<const VkBufferDeviceAddressCreateInfoEXT*>(object), settings, "VkBufferDeviceAddressCreateInfoEXT", indents, dump_html_VkBufferDeviceAddressCreateInfoEXT);
        break;
    case 1000247000:
        dump_html_pNext<const VkValidationFeaturesEXT>(static_cast<const VkValidationFeaturesEXT*>(object), settings, "VkValidationFeaturesEXT", indents, dump_html_VkValidationFeaturesEXT);
        break;
    case 1000248000:
        dump_html_pNext<const VkPhysicalDevicePresentWaitFeaturesKHR>(static_cast<const VkPhysicalDevicePresentWaitFeaturesKHR*>(object), settings, "VkPhysicalDevicePresentWaitFeaturesKHR", indents, dump_html_VkPhysicalDevicePresentWaitFeaturesKHR);
        break;
    case 1000249001:
        dump_html_pNext<const VkCooperativeMatrixPropertiesNV>(static_cast<const VkCooperativeMatrixPropertiesNV*>(object), settings, "VkCooperativeMatrixPropertiesNV", indents, dump_html_VkCooperativeMatrixPropertiesNV);
        break;
    case 1000249000:
        dump_html_pNext<const VkPhysicalDeviceCooperativeMatrixFeaturesNV>(static_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(object), settings, "VkPhysicalDeviceCooperativeMatrixFeaturesNV", indents, dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesNV);
        break;
    case 1000249002:
        dump_html_pNext<const VkPhysicalDeviceCooperativeMatrixPropertiesNV>(static_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(object), settings, "VkPhysicalDeviceCooperativeMatrixPropertiesNV", indents, dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesNV);
        break;
    case 1000250000:
        dump_html_pNext<const VkPhysicalDeviceCoverageReductionModeFeaturesNV>(static_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(object), settings, "VkPhysicalDeviceCoverageReductionModeFeaturesNV", indents, dump_html_VkPhysicalDeviceCoverageReductionModeFeaturesNV);
        break;
    case 1000250001:
        dump_html_pNext<const VkPipelineCoverageReductionStateCreateInfoNV>(static_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(object), settings, "VkPipelineCoverageReductionStateCreateInfoNV", indents, dump_html_VkPipelineCoverageReductionStateCreateInfoNV);
        break;
    case 1000250002:
        dump_html_pNext<const VkFramebufferMixedSamplesCombinationNV>(static_cast<const VkFramebufferMixedSamplesCombinationNV*>(object), settings, "VkFramebufferMixedSamplesCombinationNV", indents, dump_html_VkFramebufferMixedSamplesCombinationNV);
        break;
    case 1000251000:
        dump_html_pNext<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(static_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(object), settings, "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", indents, dump_html_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
        break;
    case 1000252000:
        dump_html_pNext<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(static_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(object), settings, "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", indents, dump_html_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
        break;
    case 1000254000:
        dump_html_pNext<const VkPhysicalDeviceProvokingVertexFeaturesEXT>(static_cast<const VkPhysicalDeviceProvokingVertexFeaturesEXT*>(object), settings, "VkPhysicalDeviceProvokingVertexFeaturesEXT", indents, dump_html_VkPhysicalDeviceProvokingVertexFeaturesEXT);
        break;
    case 1000254002:
        dump_html_pNext<const VkPhysicalDeviceProvokingVertexPropertiesEXT>(static_cast<const VkPhysicalDeviceProvokingVertexPropertiesEXT*>(object), settings, "VkPhysicalDeviceProvokingVertexPropertiesEXT", indents, dump_html_VkPhysicalDeviceProvokingVertexPropertiesEXT);
        break;
    case 1000254001:
        dump_html_pNext<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(static_cast<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(object), settings, "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT", indents, dump_html_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000255000:
        dump_html_pNext<const VkSurfaceFullScreenExclusiveInfoEXT>(static_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(object), settings, "VkSurfaceFullScreenExclusiveInfoEXT", indents, dump_html_VkSurfaceFullScreenExclusiveInfoEXT);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000255002:
        dump_html_pNext<const VkSurfaceCapabilitiesFullScreenExclusiveEXT>(static_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(object), settings, "VkSurfaceCapabilitiesFullScreenExclusiveEXT", indents, dump_html_VkSurfaceCapabilitiesFullScreenExclusiveEXT);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000255001:
        dump_html_pNext<const VkSurfaceFullScreenExclusiveWin32InfoEXT>(static_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(object), settings, "VkSurfaceFullScreenExclusiveWin32InfoEXT", indents, dump_html_VkSurfaceFullScreenExclusiveWin32InfoEXT);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000256000:
        dump_html_pNext<const VkHeadlessSurfaceCreateInfoEXT>(static_cast<const VkHeadlessSurfaceCreateInfoEXT*>(object), settings, "VkHeadlessSurfaceCreateInfoEXT", indents, dump_html_VkHeadlessSurfaceCreateInfoEXT);
        break;
    case 1000259000:
        dump_html_pNext<const VkPhysicalDeviceLineRasterizationFeaturesKHR>(static_cast<const VkPhysicalDeviceLineRasterizationFeaturesKHR*>(object), settings, "VkPhysicalDeviceLineRasterizationFeaturesKHR", indents, dump_html_VkPhysicalDeviceLineRasterizationFeaturesKHR);
        break;
    case 1000259002:
        dump_html_pNext<const VkPhysicalDeviceLineRasterizationPropertiesKHR>(static_cast<const VkPhysicalDeviceLineRasterizationPropertiesKHR*>(object), settings, "VkPhysicalDeviceLineRasterizationPropertiesKHR", indents, dump_html_VkPhysicalDeviceLineRasterizationPropertiesKHR);
        break;
    case 1000259001:
        dump_html_pNext<const VkPipelineRasterizationLineStateCreateInfoKHR>(static_cast<const VkPipelineRasterizationLineStateCreateInfoKHR*>(object), settings, "VkPipelineRasterizationLineStateCreateInfoKHR", indents, dump_html_VkPipelineRasterizationLineStateCreateInfoKHR);
        break;
    case 1000260000:
        dump_html_pNext<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>(static_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
        break;
    case 1000265000:
        dump_html_pNext<const VkPhysicalDeviceIndexTypeUint8FeaturesKHR>(static_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesKHR*>(object), settings, "VkPhysicalDeviceIndexTypeUint8FeaturesKHR", indents, dump_html_VkPhysicalDeviceIndexTypeUint8FeaturesKHR);
        break;
    case 1000267000:
        dump_html_pNext<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(static_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(object), settings, "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", indents, dump_html_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
        break;
    case 1000269000:
        dump_html_pNext<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(static_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(object), settings, "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR", indents, dump_html_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
        break;
    case 1000269001:
        dump_html_pNext<const VkPipelineInfoKHR>(static_cast<const VkPipelineInfoKHR*>(object), settings, "VkPipelineInfoKHR", indents, dump_html_VkPipelineInfoKHR);
        break;
    case 1000269002:
        dump_html_pNext<const VkPipelineExecutablePropertiesKHR>(static_cast<const VkPipelineExecutablePropertiesKHR*>(object), settings, "VkPipelineExecutablePropertiesKHR", indents, dump_html_VkPipelineExecutablePropertiesKHR);
        break;
    case 1000269003:
        dump_html_pNext<const VkPipelineExecutableInfoKHR>(static_cast<const VkPipelineExecutableInfoKHR*>(object), settings, "VkPipelineExecutableInfoKHR", indents, dump_html_VkPipelineExecutableInfoKHR);
        break;
    case 1000269004:
        dump_html_pNext<const VkPipelineExecutableStatisticKHR>(static_cast<const VkPipelineExecutableStatisticKHR*>(object), settings, "VkPipelineExecutableStatisticKHR", indents, dump_html_VkPipelineExecutableStatisticKHR);
        break;
    case 1000269005:
        dump_html_pNext<const VkPipelineExecutableInternalRepresentationKHR>(static_cast<const VkPipelineExecutableInternalRepresentationKHR*>(object), settings, "VkPipelineExecutableInternalRepresentationKHR", indents, dump_html_VkPipelineExecutableInternalRepresentationKHR);
        break;
    case 1000270000:
        dump_html_pNext<const VkPhysicalDeviceHostImageCopyFeaturesEXT>(static_cast<const VkPhysicalDeviceHostImageCopyFeaturesEXT*>(object), settings, "VkPhysicalDeviceHostImageCopyFeaturesEXT", indents, dump_html_VkPhysicalDeviceHostImageCopyFeaturesEXT);
        break;
    case 1000270001:
        dump_html_pNext<const VkPhysicalDeviceHostImageCopyPropertiesEXT>(static_cast<const VkPhysicalDeviceHostImageCopyPropertiesEXT*>(object), settings, "VkPhysicalDeviceHostImageCopyPropertiesEXT", indents, dump_html_VkPhysicalDeviceHostImageCopyPropertiesEXT);
        break;
    case 1000270002:
        dump_html_pNext<const VkMemoryToImageCopyEXT>(static_cast<const VkMemoryToImageCopyEXT*>(object), settings, "VkMemoryToImageCopyEXT", indents, dump_html_VkMemoryToImageCopyEXT);
        break;
    case 1000270003:
        dump_html_pNext<const VkImageToMemoryCopyEXT>(static_cast<const VkImageToMemoryCopyEXT*>(object), settings, "VkImageToMemoryCopyEXT", indents, dump_html_VkImageToMemoryCopyEXT);
        break;
    case 1000270005:
        dump_html_pNext<const VkCopyMemoryToImageInfoEXT>(static_cast<const VkCopyMemoryToImageInfoEXT*>(object), settings, "VkCopyMemoryToImageInfoEXT", indents, dump_html_VkCopyMemoryToImageInfoEXT);
        break;
    case 1000270004:
        dump_html_pNext<const VkCopyImageToMemoryInfoEXT>(static_cast<const VkCopyImageToMemoryInfoEXT*>(object), settings, "VkCopyImageToMemoryInfoEXT", indents, dump_html_VkCopyImageToMemoryInfoEXT);
        break;
    case 1000270007:
        dump_html_pNext<const VkCopyImageToImageInfoEXT>(static_cast<const VkCopyImageToImageInfoEXT*>(object), settings, "VkCopyImageToImageInfoEXT", indents, dump_html_VkCopyImageToImageInfoEXT);
        break;
    case 1000270006:
        dump_html_pNext<const VkHostImageLayoutTransitionInfoEXT>(static_cast<const VkHostImageLayoutTransitionInfoEXT*>(object), settings, "VkHostImageLayoutTransitionInfoEXT", indents, dump_html_VkHostImageLayoutTransitionInfoEXT);
        break;
    case 1000270008:
        dump_html_pNext<const VkSubresourceHostMemcpySizeEXT>(static_cast<const VkSubresourceHostMemcpySizeEXT*>(object), settings, "VkSubresourceHostMemcpySizeEXT", indents, dump_html_VkSubresourceHostMemcpySizeEXT);
        break;
    case 1000270009:
        dump_html_pNext<const VkHostImageCopyDevicePerformanceQueryEXT>(static_cast<const VkHostImageCopyDevicePerformanceQueryEXT*>(object), settings, "VkHostImageCopyDevicePerformanceQueryEXT", indents, dump_html_VkHostImageCopyDevicePerformanceQueryEXT);
        break;
    case 1000338002:
        dump_html_pNext<const VkSubresourceLayout2KHR>(static_cast<const VkSubresourceLayout2KHR*>(object), settings, "VkSubresourceLayout2KHR", indents, dump_html_VkSubresourceLayout2KHR);
        break;
    case 1000338003:
        dump_html_pNext<const VkImageSubresource2KHR>(static_cast<const VkImageSubresource2KHR*>(object), settings, "VkImageSubresource2KHR", indents, dump_html_VkImageSubresource2KHR);
        break;
    case 1000271000:
        dump_html_pNext<const VkMemoryMapInfoKHR>(static_cast<const VkMemoryMapInfoKHR*>(object), settings, "VkMemoryMapInfoKHR", indents, dump_html_VkMemoryMapInfoKHR);
        break;
    case 1000271001:
        dump_html_pNext<const VkMemoryUnmapInfoKHR>(static_cast<const VkMemoryUnmapInfoKHR*>(object), settings, "VkMemoryUnmapInfoKHR", indents, dump_html_VkMemoryUnmapInfoKHR);
        break;
    case 1000272000:
        dump_html_pNext<const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>(static_cast<const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*>(object), settings, "VkPhysicalDeviceMapMemoryPlacedFeaturesEXT", indents, dump_html_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT);
        break;
    case 1000272001:
        dump_html_pNext<const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>(static_cast<const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT*>(object), settings, "VkPhysicalDeviceMapMemoryPlacedPropertiesEXT", indents, dump_html_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT);
        break;
    case 1000272002:
        dump_html_pNext<const VkMemoryMapPlacedInfoEXT>(static_cast<const VkMemoryMapPlacedInfoEXT*>(object), settings, "VkMemoryMapPlacedInfoEXT", indents, dump_html_VkMemoryMapPlacedInfoEXT);
        break;
    case 1000273000:
        dump_html_pNext<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>(static_cast<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
        break;
    case 1000274000:
        dump_html_pNext<const VkSurfacePresentModeEXT>(static_cast<const VkSurfacePresentModeEXT*>(object), settings, "VkSurfacePresentModeEXT", indents, dump_html_VkSurfacePresentModeEXT);
        break;
    case 1000274001:
        dump_html_pNext<const VkSurfacePresentScalingCapabilitiesEXT>(static_cast<const VkSurfacePresentScalingCapabilitiesEXT*>(object), settings, "VkSurfacePresentScalingCapabilitiesEXT", indents, dump_html_VkSurfacePresentScalingCapabilitiesEXT);
        break;
    case 1000274002:
        dump_html_pNext<const VkSurfacePresentModeCompatibilityEXT>(static_cast<const VkSurfacePresentModeCompatibilityEXT*>(object), settings, "VkSurfacePresentModeCompatibilityEXT", indents, dump_html_VkSurfacePresentModeCompatibilityEXT);
        break;
    case 1000275000:
        dump_html_pNext<const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT>(static_cast<const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(object), settings, "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT", indents, dump_html_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT);
        break;
    case 1000275001:
        dump_html_pNext<const VkSwapchainPresentFenceInfoEXT>(static_cast<const VkSwapchainPresentFenceInfoEXT*>(object), settings, "VkSwapchainPresentFenceInfoEXT", indents, dump_html_VkSwapchainPresentFenceInfoEXT);
        break;
    case 1000275002:
        dump_html_pNext<const VkSwapchainPresentModesCreateInfoEXT>(static_cast<const VkSwapchainPresentModesCreateInfoEXT*>(object), settings, "VkSwapchainPresentModesCreateInfoEXT", indents, dump_html_VkSwapchainPresentModesCreateInfoEXT);
        break;
    case 1000275003:
        dump_html_pNext<const VkSwapchainPresentModeInfoEXT>(static_cast<const VkSwapchainPresentModeInfoEXT*>(object), settings, "VkSwapchainPresentModeInfoEXT", indents, dump_html_VkSwapchainPresentModeInfoEXT);
        break;
    case 1000275004:
        dump_html_pNext<const VkSwapchainPresentScalingCreateInfoEXT>(static_cast<const VkSwapchainPresentScalingCreateInfoEXT*>(object), settings, "VkSwapchainPresentScalingCreateInfoEXT", indents, dump_html_VkSwapchainPresentScalingCreateInfoEXT);
        break;
    case 1000275005:
        dump_html_pNext<const VkReleaseSwapchainImagesInfoEXT>(static_cast<const VkReleaseSwapchainImagesInfoEXT*>(object), settings, "VkReleaseSwapchainImagesInfoEXT", indents, dump_html_VkReleaseSwapchainImagesInfoEXT);
        break;
    case 1000277000:
        dump_html_pNext<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>(static_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(object), settings, "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV", indents, dump_html_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);
        break;
    case 1000277007:
        dump_html_pNext<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>(static_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(object), settings, "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV", indents, dump_html_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);
        break;
    case 1000277001:
        dump_html_pNext<const VkGraphicsShaderGroupCreateInfoNV>(static_cast<const VkGraphicsShaderGroupCreateInfoNV*>(object), settings, "VkGraphicsShaderGroupCreateInfoNV", indents, dump_html_VkGraphicsShaderGroupCreateInfoNV);
        break;
    case 1000277002:
        dump_html_pNext<const VkGraphicsPipelineShaderGroupsCreateInfoNV>(static_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV*>(object), settings, "VkGraphicsPipelineShaderGroupsCreateInfoNV", indents, dump_html_VkGraphicsPipelineShaderGroupsCreateInfoNV);
        break;
    case 1000277003:
        dump_html_pNext<const VkIndirectCommandsLayoutTokenNV>(static_cast<const VkIndirectCommandsLayoutTokenNV*>(object), settings, "VkIndirectCommandsLayoutTokenNV", indents, dump_html_VkIndirectCommandsLayoutTokenNV);
        break;
    case 1000277004:
        dump_html_pNext<const VkIndirectCommandsLayoutCreateInfoNV>(static_cast<const VkIndirectCommandsLayoutCreateInfoNV*>(object), settings, "VkIndirectCommandsLayoutCreateInfoNV", indents, dump_html_VkIndirectCommandsLayoutCreateInfoNV);
        break;
    case 1000277005:
        dump_html_pNext<const VkGeneratedCommandsInfoNV>(static_cast<const VkGeneratedCommandsInfoNV*>(object), settings, "VkGeneratedCommandsInfoNV", indents, dump_html_VkGeneratedCommandsInfoNV);
        break;
    case 1000277006:
        dump_html_pNext<const VkGeneratedCommandsMemoryRequirementsInfoNV>(static_cast<const VkGeneratedCommandsMemoryRequirementsInfoNV*>(object), settings, "VkGeneratedCommandsMemoryRequirementsInfoNV", indents, dump_html_VkGeneratedCommandsMemoryRequirementsInfoNV);
        break;
    case 1000278000:
        dump_html_pNext<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV>(static_cast<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(object), settings, "VkPhysicalDeviceInheritedViewportScissorFeaturesNV", indents, dump_html_VkPhysicalDeviceInheritedViewportScissorFeaturesNV);
        break;
    case 1000278001:
        dump_html_pNext<const VkCommandBufferInheritanceViewportScissorInfoNV>(static_cast<const VkCommandBufferInheritanceViewportScissorInfoNV*>(object), settings, "VkCommandBufferInheritanceViewportScissorInfoNV", indents, dump_html_VkCommandBufferInheritanceViewportScissorInfoNV);
        break;
    case 1000281000:
        dump_html_pNext<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(static_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(object), settings, "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", indents, dump_html_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
        break;
    case 1000282001:
        dump_html_pNext<const VkRenderPassTransformBeginInfoQCOM>(static_cast<const VkRenderPassTransformBeginInfoQCOM*>(object), settings, "VkRenderPassTransformBeginInfoQCOM", indents, dump_html_VkRenderPassTransformBeginInfoQCOM);
        break;
    case 1000282000:
        dump_html_pNext<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM>(static_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(object), settings, "VkCommandBufferInheritanceRenderPassTransformInfoQCOM", indents, dump_html_VkCommandBufferInheritanceRenderPassTransformInfoQCOM);
        break;
    case 1000283000:
        dump_html_pNext<const VkPhysicalDeviceDepthBiasControlFeaturesEXT>(static_cast<const VkPhysicalDeviceDepthBiasControlFeaturesEXT*>(object), settings, "VkPhysicalDeviceDepthBiasControlFeaturesEXT", indents, dump_html_VkPhysicalDeviceDepthBiasControlFeaturesEXT);
        break;
    case 1000283001:
        dump_html_pNext<const VkDepthBiasInfoEXT>(static_cast<const VkDepthBiasInfoEXT*>(object), settings, "VkDepthBiasInfoEXT", indents, dump_html_VkDepthBiasInfoEXT);
        break;
    case 1000283002:
        dump_html_pNext<const VkDepthBiasRepresentationInfoEXT>(static_cast<const VkDepthBiasRepresentationInfoEXT*>(object), settings, "VkDepthBiasRepresentationInfoEXT", indents, dump_html_VkDepthBiasRepresentationInfoEXT);
        break;
    case 1000284000:
        dump_html_pNext<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(static_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(object), settings, "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT", indents, dump_html_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
        break;
    case 1000284002:
        dump_html_pNext<const VkDeviceMemoryReportCallbackDataEXT>(static_cast<const VkDeviceMemoryReportCallbackDataEXT*>(object), settings, "VkDeviceMemoryReportCallbackDataEXT", indents, dump_html_VkDeviceMemoryReportCallbackDataEXT);
        break;
    case 1000284001:
        dump_html_pNext<const VkDeviceDeviceMemoryReportCreateInfoEXT>(static_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT*>(object), settings, "VkDeviceDeviceMemoryReportCreateInfoEXT", indents, dump_html_VkDeviceDeviceMemoryReportCreateInfoEXT);
        break;
    case 1000286000:
        dump_html_pNext<const VkPhysicalDeviceRobustness2FeaturesEXT>(static_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(object), settings, "VkPhysicalDeviceRobustness2FeaturesEXT", indents, dump_html_VkPhysicalDeviceRobustness2FeaturesEXT);
        break;
    case 1000286001:
        dump_html_pNext<const VkPhysicalDeviceRobustness2PropertiesEXT>(static_cast<const VkPhysicalDeviceRobustness2PropertiesEXT*>(object), settings, "VkPhysicalDeviceRobustness2PropertiesEXT", indents, dump_html_VkPhysicalDeviceRobustness2PropertiesEXT);
        break;
    case 1000287000:
        dump_html_pNext<const VkSamplerCustomBorderColorCreateInfoEXT>(static_cast<const VkSamplerCustomBorderColorCreateInfoEXT*>(object), settings, "VkSamplerCustomBorderColorCreateInfoEXT", indents, dump_html_VkSamplerCustomBorderColorCreateInfoEXT);
        break;
    case 1000287001:
        dump_html_pNext<const VkPhysicalDeviceCustomBorderColorPropertiesEXT>(static_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(object), settings, "VkPhysicalDeviceCustomBorderColorPropertiesEXT", indents, dump_html_VkPhysicalDeviceCustomBorderColorPropertiesEXT);
        break;
    case 1000287002:
        dump_html_pNext<const VkPhysicalDeviceCustomBorderColorFeaturesEXT>(static_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(object), settings, "VkPhysicalDeviceCustomBorderColorFeaturesEXT", indents, dump_html_VkPhysicalDeviceCustomBorderColorFeaturesEXT);
        break;
    case 1000292000:
        dump_html_pNext<const VkPhysicalDevicePresentBarrierFeaturesNV>(static_cast<const VkPhysicalDevicePresentBarrierFeaturesNV*>(object), settings, "VkPhysicalDevicePresentBarrierFeaturesNV", indents, dump_html_VkPhysicalDevicePresentBarrierFeaturesNV);
        break;
    case 1000292001:
        dump_html_pNext<const VkSurfaceCapabilitiesPresentBarrierNV>(static_cast<const VkSurfaceCapabilitiesPresentBarrierNV*>(object), settings, "VkSurfaceCapabilitiesPresentBarrierNV", indents, dump_html_VkSurfaceCapabilitiesPresentBarrierNV);
        break;
    case 1000292002:
        dump_html_pNext<const VkSwapchainPresentBarrierCreateInfoNV>(static_cast<const VkSwapchainPresentBarrierCreateInfoNV*>(object), settings, "VkSwapchainPresentBarrierCreateInfoNV", indents, dump_html_VkSwapchainPresentBarrierCreateInfoNV);
        break;
    case 1000294000:
        dump_html_pNext<const VkPresentIdKHR>(static_cast<const VkPresentIdKHR*>(object), settings, "VkPresentIdKHR", indents, dump_html_VkPresentIdKHR);
        break;
    case 1000294001:
        dump_html_pNext<const VkPhysicalDevicePresentIdFeaturesKHR>(static_cast<const VkPhysicalDevicePresentIdFeaturesKHR*>(object), settings, "VkPhysicalDevicePresentIdFeaturesKHR", indents, dump_html_VkPhysicalDevicePresentIdFeaturesKHR);
        break;
    case 1000299000:
        dump_html_pNext<const VkVideoEncodeInfoKHR>(static_cast<const VkVideoEncodeInfoKHR*>(object), settings, "VkVideoEncodeInfoKHR", indents, dump_html_VkVideoEncodeInfoKHR);
        break;
    case 1000299003:
        dump_html_pNext<const VkVideoEncodeCapabilitiesKHR>(static_cast<const VkVideoEncodeCapabilitiesKHR*>(object), settings, "VkVideoEncodeCapabilitiesKHR", indents, dump_html_VkVideoEncodeCapabilitiesKHR);
        break;
    case 1000299005:
        dump_html_pNext<const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>(static_cast<const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*>(object), settings, "VkQueryPoolVideoEncodeFeedbackCreateInfoKHR", indents, dump_html_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR);
        break;
    case 1000299004:
        dump_html_pNext<const VkVideoEncodeUsageInfoKHR>(static_cast<const VkVideoEncodeUsageInfoKHR*>(object), settings, "VkVideoEncodeUsageInfoKHR", indents, dump_html_VkVideoEncodeUsageInfoKHR);
        break;
    case 1000299002:
        dump_html_pNext<const VkVideoEncodeRateControlLayerInfoKHR>(static_cast<const VkVideoEncodeRateControlLayerInfoKHR*>(object), settings, "VkVideoEncodeRateControlLayerInfoKHR", indents, dump_html_VkVideoEncodeRateControlLayerInfoKHR);
        break;
    case 1000299001:
        dump_html_pNext<const VkVideoEncodeRateControlInfoKHR>(static_cast<const VkVideoEncodeRateControlInfoKHR*>(object), settings, "VkVideoEncodeRateControlInfoKHR", indents, dump_html_VkVideoEncodeRateControlInfoKHR);
        break;
    case 1000299006:
        dump_html_pNext<const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>(static_cast<const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*>(object), settings, "VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR", indents, dump_html_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR);
        break;
    case 1000299007:
        dump_html_pNext<const VkVideoEncodeQualityLevelPropertiesKHR>(static_cast<const VkVideoEncodeQualityLevelPropertiesKHR*>(object), settings, "VkVideoEncodeQualityLevelPropertiesKHR", indents, dump_html_VkVideoEncodeQualityLevelPropertiesKHR);
        break;
    case 1000299008:
        dump_html_pNext<const VkVideoEncodeQualityLevelInfoKHR>(static_cast<const VkVideoEncodeQualityLevelInfoKHR*>(object), settings, "VkVideoEncodeQualityLevelInfoKHR", indents, dump_html_VkVideoEncodeQualityLevelInfoKHR);
        break;
    case 1000299009:
        dump_html_pNext<const VkVideoEncodeSessionParametersGetInfoKHR>(static_cast<const VkVideoEncodeSessionParametersGetInfoKHR*>(object), settings, "VkVideoEncodeSessionParametersGetInfoKHR", indents, dump_html_VkVideoEncodeSessionParametersGetInfoKHR);
        break;
    case 1000299010:
        dump_html_pNext<const VkVideoEncodeSessionParametersFeedbackInfoKHR>(static_cast<const VkVideoEncodeSessionParametersFeedbackInfoKHR*>(object), settings, "VkVideoEncodeSessionParametersFeedbackInfoKHR", indents, dump_html_VkVideoEncodeSessionParametersFeedbackInfoKHR);
        break;
    case 1000300000:
        dump_html_pNext<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV>(static_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(object), settings, "VkPhysicalDeviceDiagnosticsConfigFeaturesNV", indents, dump_html_VkPhysicalDeviceDiagnosticsConfigFeaturesNV);
        break;
    case 1000300001:
        dump_html_pNext<const VkDeviceDiagnosticsConfigCreateInfoNV>(static_cast<const VkDeviceDiagnosticsConfigCreateInfoNV*>(object), settings, "VkDeviceDiagnosticsConfigCreateInfoNV", indents, dump_html_VkDeviceDiagnosticsConfigCreateInfoNV);
        break;
    case 1000307000:
        dump_html_pNext<const VkCudaModuleCreateInfoNV>(static_cast<const VkCudaModuleCreateInfoNV*>(object), settings, "VkCudaModuleCreateInfoNV", indents, dump_html_VkCudaModuleCreateInfoNV);
        break;
    case 1000307001:
        dump_html_pNext<const VkCudaFunctionCreateInfoNV>(static_cast<const VkCudaFunctionCreateInfoNV*>(object), settings, "VkCudaFunctionCreateInfoNV", indents, dump_html_VkCudaFunctionCreateInfoNV);
        break;
    case 1000307002:
        dump_html_pNext<const VkCudaLaunchInfoNV>(static_cast<const VkCudaLaunchInfoNV*>(object), settings, "VkCudaLaunchInfoNV", indents, dump_html_VkCudaLaunchInfoNV);
        break;
    case 1000307003:
        dump_html_pNext<const VkPhysicalDeviceCudaKernelLaunchFeaturesNV>(static_cast<const VkPhysicalDeviceCudaKernelLaunchFeaturesNV*>(object), settings, "VkPhysicalDeviceCudaKernelLaunchFeaturesNV", indents, dump_html_VkPhysicalDeviceCudaKernelLaunchFeaturesNV);
        break;
    case 1000307004:
        dump_html_pNext<const VkPhysicalDeviceCudaKernelLaunchPropertiesNV>(static_cast<const VkPhysicalDeviceCudaKernelLaunchPropertiesNV*>(object), settings, "VkPhysicalDeviceCudaKernelLaunchPropertiesNV", indents, dump_html_VkPhysicalDeviceCudaKernelLaunchPropertiesNV);
        break;
    case 1000310000:
        dump_html_pNext<const VkQueryLowLatencySupportNV>(static_cast<const VkQueryLowLatencySupportNV*>(object), settings, "VkQueryLowLatencySupportNV", indents, dump_html_VkQueryLowLatencySupportNV);
        break;
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311000:
        dump_html_pNext<const VkExportMetalObjectCreateInfoEXT>(static_cast<const VkExportMetalObjectCreateInfoEXT*>(object), settings, "VkExportMetalObjectCreateInfoEXT", indents, dump_html_VkExportMetalObjectCreateInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311001:
        dump_html_pNext<const VkExportMetalObjectsInfoEXT>(static_cast<const VkExportMetalObjectsInfoEXT*>(object), settings, "VkExportMetalObjectsInfoEXT", indents, dump_html_VkExportMetalObjectsInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311002:
        dump_html_pNext<const VkExportMetalDeviceInfoEXT>(static_cast<const VkExportMetalDeviceInfoEXT*>(object), settings, "VkExportMetalDeviceInfoEXT", indents, dump_html_VkExportMetalDeviceInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311003:
        dump_html_pNext<const VkExportMetalCommandQueueInfoEXT>(static_cast<const VkExportMetalCommandQueueInfoEXT*>(object), settings, "VkExportMetalCommandQueueInfoEXT", indents, dump_html_VkExportMetalCommandQueueInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311004:
        dump_html_pNext<const VkExportMetalBufferInfoEXT>(static_cast<const VkExportMetalBufferInfoEXT*>(object), settings, "VkExportMetalBufferInfoEXT", indents, dump_html_VkExportMetalBufferInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311005:
        dump_html_pNext<const VkImportMetalBufferInfoEXT>(static_cast<const VkImportMetalBufferInfoEXT*>(object), settings, "VkImportMetalBufferInfoEXT", indents, dump_html_VkImportMetalBufferInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311006:
        dump_html_pNext<const VkExportMetalTextureInfoEXT>(static_cast<const VkExportMetalTextureInfoEXT*>(object), settings, "VkExportMetalTextureInfoEXT", indents, dump_html_VkExportMetalTextureInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311007:
        dump_html_pNext<const VkImportMetalTextureInfoEXT>(static_cast<const VkImportMetalTextureInfoEXT*>(object), settings, "VkImportMetalTextureInfoEXT", indents, dump_html_VkImportMetalTextureInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311008:
        dump_html_pNext<const VkExportMetalIOSurfaceInfoEXT>(static_cast<const VkExportMetalIOSurfaceInfoEXT*>(object), settings, "VkExportMetalIOSurfaceInfoEXT", indents, dump_html_VkExportMetalIOSurfaceInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311009:
        dump_html_pNext<const VkImportMetalIOSurfaceInfoEXT>(static_cast<const VkImportMetalIOSurfaceInfoEXT*>(object), settings, "VkImportMetalIOSurfaceInfoEXT", indents, dump_html_VkImportMetalIOSurfaceInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311010:
        dump_html_pNext<const VkExportMetalSharedEventInfoEXT>(static_cast<const VkExportMetalSharedEventInfoEXT*>(object), settings, "VkExportMetalSharedEventInfoEXT", indents, dump_html_VkExportMetalSharedEventInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
#if defined(VK_USE_PLATFORM_METAL_EXT)
    case 1000311011:
        dump_html_pNext<const VkImportMetalSharedEventInfoEXT>(static_cast<const VkImportMetalSharedEventInfoEXT*>(object), settings, "VkImportMetalSharedEventInfoEXT", indents, dump_html_VkImportMetalSharedEventInfoEXT);
        break;
#endif // VK_USE_PLATFORM_METAL_EXT
    case 1000314008:
        dump_html_pNext<const VkQueueFamilyCheckpointProperties2NV>(static_cast<const VkQueueFamilyCheckpointProperties2NV*>(object), settings, "VkQueueFamilyCheckpointProperties2NV", indents, dump_html_VkQueueFamilyCheckpointProperties2NV);
        break;
    case 1000314009:
        dump_html_pNext<const VkCheckpointData2NV>(static_cast<const VkCheckpointData2NV*>(object), settings, "VkCheckpointData2NV", indents, dump_html_VkCheckpointData2NV);
        break;
    case 1000316000:
        dump_html_pNext<const VkPhysicalDeviceDescriptorBufferPropertiesEXT>(static_cast<const VkPhysicalDeviceDescriptorBufferPropertiesEXT*>(object), settings, "VkPhysicalDeviceDescriptorBufferPropertiesEXT", indents, dump_html_VkPhysicalDeviceDescriptorBufferPropertiesEXT);
        break;
    case 1000316001:
        dump_html_pNext<const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>(static_cast<const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*>(object), settings, "VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT", indents, dump_html_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT);
        break;
    case 1000316002:
        dump_html_pNext<const VkPhysicalDeviceDescriptorBufferFeaturesEXT>(static_cast<const VkPhysicalDeviceDescriptorBufferFeaturesEXT*>(object), settings, "VkPhysicalDeviceDescriptorBufferFeaturesEXT", indents, dump_html_VkPhysicalDeviceDescriptorBufferFeaturesEXT);
        break;
    case 1000316003:
        dump_html_pNext<const VkDescriptorAddressInfoEXT>(static_cast<const VkDescriptorAddressInfoEXT*>(object), settings, "VkDescriptorAddressInfoEXT", indents, dump_html_VkDescriptorAddressInfoEXT);
        break;
    case 1000316011:
        dump_html_pNext<const VkDescriptorBufferBindingInfoEXT>(static_cast<const VkDescriptorBufferBindingInfoEXT*>(object), settings, "VkDescriptorBufferBindingInfoEXT", indents, dump_html_VkDescriptorBufferBindingInfoEXT);
        break;
    case 1000316012:
        dump_html_pNext<const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>(static_cast<const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*>(object), settings, "VkDescriptorBufferBindingPushDescriptorBufferHandleEXT", indents, dump_html_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT);
        break;
    case 1000316004:
        dump_html_pNext<const VkDescriptorGetInfoEXT>(static_cast<const VkDescriptorGetInfoEXT*>(object), settings, "VkDescriptorGetInfoEXT", indents, dump_html_VkDescriptorGetInfoEXT);
        break;
    case 1000316005:
        dump_html_pNext<const VkBufferCaptureDescriptorDataInfoEXT>(static_cast<const VkBufferCaptureDescriptorDataInfoEXT*>(object), settings, "VkBufferCaptureDescriptorDataInfoEXT", indents, dump_html_VkBufferCaptureDescriptorDataInfoEXT);
        break;
    case 1000316006:
        dump_html_pNext<const VkImageCaptureDescriptorDataInfoEXT>(static_cast<const VkImageCaptureDescriptorDataInfoEXT*>(object), settings, "VkImageCaptureDescriptorDataInfoEXT", indents, dump_html_VkImageCaptureDescriptorDataInfoEXT);
        break;
    case 1000316007:
        dump_html_pNext<const VkImageViewCaptureDescriptorDataInfoEXT>(static_cast<const VkImageViewCaptureDescriptorDataInfoEXT*>(object), settings, "VkImageViewCaptureDescriptorDataInfoEXT", indents, dump_html_VkImageViewCaptureDescriptorDataInfoEXT);
        break;
    case 1000316008:
        dump_html_pNext<const VkSamplerCaptureDescriptorDataInfoEXT>(static_cast<const VkSamplerCaptureDescriptorDataInfoEXT*>(object), settings, "VkSamplerCaptureDescriptorDataInfoEXT", indents, dump_html_VkSamplerCaptureDescriptorDataInfoEXT);
        break;
    case 1000316010:
        dump_html_pNext<const VkOpaqueCaptureDescriptorDataCreateInfoEXT>(static_cast<const VkOpaqueCaptureDescriptorDataCreateInfoEXT*>(object), settings, "VkOpaqueCaptureDescriptorDataCreateInfoEXT", indents, dump_html_VkOpaqueCaptureDescriptorDataCreateInfoEXT);
        break;
    case 1000316009:
        dump_html_pNext<const VkAccelerationStructureCaptureDescriptorDataInfoEXT>(static_cast<const VkAccelerationStructureCaptureDescriptorDataInfoEXT*>(object), settings, "VkAccelerationStructureCaptureDescriptorDataInfoEXT", indents, dump_html_VkAccelerationStructureCaptureDescriptorDataInfoEXT);
        break;
    case 1000320000:
        dump_html_pNext<const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>(static_cast<const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(object), settings, "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT", indents, dump_html_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT);
        break;
    case 1000320001:
        dump_html_pNext<const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>(static_cast<const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*>(object), settings, "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT", indents, dump_html_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT);
        break;
    case 1000320002:
        dump_html_pNext<const VkGraphicsPipelineLibraryCreateInfoEXT>(static_cast<const VkGraphicsPipelineLibraryCreateInfoEXT*>(object), settings, "VkGraphicsPipelineLibraryCreateInfoEXT", indents, dump_html_VkGraphicsPipelineLibraryCreateInfoEXT);
        break;
    case 1000321000:
        dump_html_pNext<const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>(static_cast<const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*>(object), settings, "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD", indents, dump_html_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD);
        break;
    case 1000322000:
        dump_html_pNext<const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>(static_cast<const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*>(object), settings, "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR", indents, dump_html_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR);
        break;
    case 1000323000:
        dump_html_pNext<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
        break;
    case 1000326001:
        dump_html_pNext<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>(static_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(object), settings, "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV", indents, dump_html_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);
        break;
    case 1000326000:
        dump_html_pNext<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>(static_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(object), settings, "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV", indents, dump_html_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);
        break;
    case 1000326002:
        dump_html_pNext<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV>(static_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(object), settings, "VkPipelineFragmentShadingRateEnumStateCreateInfoNV", indents, dump_html_VkPipelineFragmentShadingRateEnumStateCreateInfoNV);
        break;
    case 1000327000:
        dump_html_pNext<const VkAccelerationStructureGeometryMotionTrianglesDataNV>(static_cast<const VkAccelerationStructureGeometryMotionTrianglesDataNV*>(object), settings, "VkAccelerationStructureGeometryMotionTrianglesDataNV", indents, dump_html_VkAccelerationStructureGeometryMotionTrianglesDataNV);
        break;
    case 1000327002:
        dump_html_pNext<const VkAccelerationStructureMotionInfoNV>(static_cast<const VkAccelerationStructureMotionInfoNV*>(object), settings, "VkAccelerationStructureMotionInfoNV", indents, dump_html_VkAccelerationStructureMotionInfoNV);
        break;
    case 1000327001:
        dump_html_pNext<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>(static_cast<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(object), settings, "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV", indents, dump_html_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV);
        break;
    case 1000328000:
        dump_html_pNext<const VkPhysicalDeviceMeshShaderFeaturesEXT>(static_cast<const VkPhysicalDeviceMeshShaderFeaturesEXT*>(object), settings, "VkPhysicalDeviceMeshShaderFeaturesEXT", indents, dump_html_VkPhysicalDeviceMeshShaderFeaturesEXT);
        break;
    case 1000328001:
        dump_html_pNext<const VkPhysicalDeviceMeshShaderPropertiesEXT>(static_cast<const VkPhysicalDeviceMeshShaderPropertiesEXT*>(object), settings, "VkPhysicalDeviceMeshShaderPropertiesEXT", indents, dump_html_VkPhysicalDeviceMeshShaderPropertiesEXT);
        break;
    case 1000330000:
        dump_html_pNext<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(static_cast<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(object), settings, "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT", indents, dump_html_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
        break;
    case 1000332000:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(static_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(object), settings, "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT", indents, dump_html_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
        break;
    case 1000332001:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(static_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(object), settings, "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT", indents, dump_html_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);
        break;
    case 1000333000:
        dump_html_pNext<const VkCopyCommandTransformInfoQCOM>(static_cast<const VkCopyCommandTransformInfoQCOM*>(object), settings, "VkCopyCommandTransformInfoQCOM", indents, dump_html_VkCopyCommandTransformInfoQCOM);
        break;
    case 1000336000:
        dump_html_pNext<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(static_cast<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(object), settings, "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR", indents, dump_html_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
        break;
    case 1000338000:
        dump_html_pNext<const VkPhysicalDeviceImageCompressionControlFeaturesEXT>(static_cast<const VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(object), settings, "VkPhysicalDeviceImageCompressionControlFeaturesEXT", indents, dump_html_VkPhysicalDeviceImageCompressionControlFeaturesEXT);
        break;
    case 1000338001:
        dump_html_pNext<const VkImageCompressionControlEXT>(static_cast<const VkImageCompressionControlEXT*>(object), settings, "VkImageCompressionControlEXT", indents, dump_html_VkImageCompressionControlEXT);
        break;
    case 1000338004:
        dump_html_pNext<const VkImageCompressionPropertiesEXT>(static_cast<const VkImageCompressionPropertiesEXT*>(object), settings, "VkImageCompressionPropertiesEXT", indents, dump_html_VkImageCompressionPropertiesEXT);
        break;
    case 1000339000:
        dump_html_pNext<const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>(static_cast<const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(object), settings, "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT", indents, dump_html_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT);
        break;
    case 1000340000:
        dump_html_pNext<const VkPhysicalDevice4444FormatsFeaturesEXT>(static_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(object), settings, "VkPhysicalDevice4444FormatsFeaturesEXT", indents, dump_html_VkPhysicalDevice4444FormatsFeaturesEXT);
        break;
    case 1000341000:
        dump_html_pNext<const VkPhysicalDeviceFaultFeaturesEXT>(static_cast<const VkPhysicalDeviceFaultFeaturesEXT*>(object), settings, "VkPhysicalDeviceFaultFeaturesEXT", indents, dump_html_VkPhysicalDeviceFaultFeaturesEXT);
        break;
    case 1000341001:
        dump_html_pNext<const VkDeviceFaultCountsEXT>(static_cast<const VkDeviceFaultCountsEXT*>(object), settings, "VkDeviceFaultCountsEXT", indents, dump_html_VkDeviceFaultCountsEXT);
        break;
    case 1000341002:
        dump_html_pNext<const VkDeviceFaultInfoEXT>(static_cast<const VkDeviceFaultInfoEXT*>(object), settings, "VkDeviceFaultInfoEXT", indents, dump_html_VkDeviceFaultInfoEXT);
        break;
    case 1000342000:
        dump_html_pNext<const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>(static_cast<const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*>(object), settings, "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT", indents, dump_html_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT);
        break;
    case 1000344000:
        dump_html_pNext<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>(static_cast<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(object), settings, "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT", indents, dump_html_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    case 1000346000:
        dump_html_pNext<const VkDirectFBSurfaceCreateInfoEXT>(static_cast<const VkDirectFBSurfaceCreateInfoEXT*>(object), settings, "VkDirectFBSurfaceCreateInfoEXT", indents, dump_html_VkDirectFBSurfaceCreateInfoEXT);
        break;
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
    case 1000150016:
        dump_html_pNext<const VkRayTracingShaderGroupCreateInfoKHR>(static_cast<const VkRayTracingShaderGroupCreateInfoKHR*>(object), settings, "VkRayTracingShaderGroupCreateInfoKHR", indents, dump_html_VkRayTracingShaderGroupCreateInfoKHR);
        break;
    case 1000150018:
        dump_html_pNext<const VkRayTracingPipelineInterfaceCreateInfoKHR>(static_cast<const VkRayTracingPipelineInterfaceCreateInfoKHR*>(object), settings, "VkRayTracingPipelineInterfaceCreateInfoKHR", indents, dump_html_VkRayTracingPipelineInterfaceCreateInfoKHR);
        break;
    case 1000150015:
        dump_html_pNext<const VkRayTracingPipelineCreateInfoKHR>(static_cast<const VkRayTracingPipelineCreateInfoKHR*>(object), settings, "VkRayTracingPipelineCreateInfoKHR", indents, dump_html_VkRayTracingPipelineCreateInfoKHR);
        break;
    case 1000347000:
        dump_html_pNext<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(static_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(object), settings, "VkPhysicalDeviceRayTracingPipelineFeaturesKHR", indents, dump_html_VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
        break;
    case 1000347001:
        dump_html_pNext<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(static_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(object), settings, "VkPhysicalDeviceRayTracingPipelinePropertiesKHR", indents, dump_html_VkPhysicalDeviceRayTracingPipelinePropertiesKHR);
        break;
    case 1000348013:
        dump_html_pNext<const VkPhysicalDeviceRayQueryFeaturesKHR>(static_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(object), settings, "VkPhysicalDeviceRayQueryFeaturesKHR", indents, dump_html_VkPhysicalDeviceRayQueryFeaturesKHR);
        break;
    case 1000351000:
        dump_html_pNext<const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>(static_cast<const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*>(object), settings, "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT", indents, dump_html_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT);
        break;
    case 1000351002:
        dump_html_pNext<const VkMutableDescriptorTypeCreateInfoEXT>(static_cast<const VkMutableDescriptorTypeCreateInfoEXT*>(object), settings, "VkMutableDescriptorTypeCreateInfoEXT", indents, dump_html_VkMutableDescriptorTypeCreateInfoEXT);
        break;
    case 1000352000:
        dump_html_pNext<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(static_cast<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(object), settings, "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT", indents, dump_html_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
        break;
    case 1000352001:
        dump_html_pNext<const VkVertexInputBindingDescription2EXT>(static_cast<const VkVertexInputBindingDescription2EXT*>(object), settings, "VkVertexInputBindingDescription2EXT", indents, dump_html_VkVertexInputBindingDescription2EXT);
        break;
    case 1000352002:
        dump_html_pNext<const VkVertexInputAttributeDescription2EXT>(static_cast<const VkVertexInputAttributeDescription2EXT*>(object), settings, "VkVertexInputAttributeDescription2EXT", indents, dump_html_VkVertexInputAttributeDescription2EXT);
        break;
    case 1000353000:
        dump_html_pNext<const VkPhysicalDeviceDrmPropertiesEXT>(static_cast<const VkPhysicalDeviceDrmPropertiesEXT*>(object), settings, "VkPhysicalDeviceDrmPropertiesEXT", indents, dump_html_VkPhysicalDeviceDrmPropertiesEXT);
        break;
    case 1000354000:
        dump_html_pNext<const VkPhysicalDeviceAddressBindingReportFeaturesEXT>(static_cast<const VkPhysicalDeviceAddressBindingReportFeaturesEXT*>(object), settings, "VkPhysicalDeviceAddressBindingReportFeaturesEXT", indents, dump_html_VkPhysicalDeviceAddressBindingReportFeaturesEXT);
        break;
    case 1000354001:
        dump_html_pNext<const VkDeviceAddressBindingCallbackDataEXT>(static_cast<const VkDeviceAddressBindingCallbackDataEXT*>(object), settings, "VkDeviceAddressBindingCallbackDataEXT", indents, dump_html_VkDeviceAddressBindingCallbackDataEXT);
        break;
    case 1000355000:
        dump_html_pNext<const VkPhysicalDeviceDepthClipControlFeaturesEXT>(static_cast<const VkPhysicalDeviceDepthClipControlFeaturesEXT*>(object), settings, "VkPhysicalDeviceDepthClipControlFeaturesEXT", indents, dump_html_VkPhysicalDeviceDepthClipControlFeaturesEXT);
        break;
    case 1000355001:
        dump_html_pNext<const VkPipelineViewportDepthClipControlCreateInfoEXT>(static_cast<const VkPipelineViewportDepthClipControlCreateInfoEXT*>(object), settings, "VkPipelineViewportDepthClipControlCreateInfoEXT", indents, dump_html_VkPipelineViewportDepthClipControlCreateInfoEXT);
        break;
    case 1000356000:
        dump_html_pNext<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>(static_cast<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(object), settings, "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT", indents, dump_html_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000364000:
        dump_html_pNext<const VkImportMemoryZirconHandleInfoFUCHSIA>(static_cast<const VkImportMemoryZirconHandleInfoFUCHSIA*>(object), settings, "VkImportMemoryZirconHandleInfoFUCHSIA", indents, dump_html_VkImportMemoryZirconHandleInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000364001:
        dump_html_pNext<const VkMemoryZirconHandlePropertiesFUCHSIA>(static_cast<const VkMemoryZirconHandlePropertiesFUCHSIA*>(object), settings, "VkMemoryZirconHandlePropertiesFUCHSIA", indents, dump_html_VkMemoryZirconHandlePropertiesFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000364002:
        dump_html_pNext<const VkMemoryGetZirconHandleInfoFUCHSIA>(static_cast<const VkMemoryGetZirconHandleInfoFUCHSIA*>(object), settings, "VkMemoryGetZirconHandleInfoFUCHSIA", indents, dump_html_VkMemoryGetZirconHandleInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000365000:
        dump_html_pNext<const VkImportSemaphoreZirconHandleInfoFUCHSIA>(static_cast<const VkImportSemaphoreZirconHandleInfoFUCHSIA*>(object), settings, "VkImportSemaphoreZirconHandleInfoFUCHSIA", indents, dump_html_VkImportSemaphoreZirconHandleInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000365001:
        dump_html_pNext<const VkSemaphoreGetZirconHandleInfoFUCHSIA>(static_cast<const VkSemaphoreGetZirconHandleInfoFUCHSIA*>(object), settings, "VkSemaphoreGetZirconHandleInfoFUCHSIA", indents, dump_html_VkSemaphoreGetZirconHandleInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366000:
        dump_html_pNext<const VkBufferCollectionCreateInfoFUCHSIA>(static_cast<const VkBufferCollectionCreateInfoFUCHSIA*>(object), settings, "VkBufferCollectionCreateInfoFUCHSIA", indents, dump_html_VkBufferCollectionCreateInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366001:
        dump_html_pNext<const VkImportMemoryBufferCollectionFUCHSIA>(static_cast<const VkImportMemoryBufferCollectionFUCHSIA*>(object), settings, "VkImportMemoryBufferCollectionFUCHSIA", indents, dump_html_VkImportMemoryBufferCollectionFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366002:
        dump_html_pNext<const VkBufferCollectionImageCreateInfoFUCHSIA>(static_cast<const VkBufferCollectionImageCreateInfoFUCHSIA*>(object), settings, "VkBufferCollectionImageCreateInfoFUCHSIA", indents, dump_html_VkBufferCollectionImageCreateInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366009:
        dump_html_pNext<const VkBufferCollectionConstraintsInfoFUCHSIA>(static_cast<const VkBufferCollectionConstraintsInfoFUCHSIA*>(object), settings, "VkBufferCollectionConstraintsInfoFUCHSIA", indents, dump_html_VkBufferCollectionConstraintsInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366004:
        dump_html_pNext<const VkBufferConstraintsInfoFUCHSIA>(static_cast<const VkBufferConstraintsInfoFUCHSIA*>(object), settings, "VkBufferConstraintsInfoFUCHSIA", indents, dump_html_VkBufferConstraintsInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366005:
        dump_html_pNext<const VkBufferCollectionBufferCreateInfoFUCHSIA>(static_cast<const VkBufferCollectionBufferCreateInfoFUCHSIA*>(object), settings, "VkBufferCollectionBufferCreateInfoFUCHSIA", indents, dump_html_VkBufferCollectionBufferCreateInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366008:
        dump_html_pNext<const VkSysmemColorSpaceFUCHSIA>(static_cast<const VkSysmemColorSpaceFUCHSIA*>(object), settings, "VkSysmemColorSpaceFUCHSIA", indents, dump_html_VkSysmemColorSpaceFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366003:
        dump_html_pNext<const VkBufferCollectionPropertiesFUCHSIA>(static_cast<const VkBufferCollectionPropertiesFUCHSIA*>(object), settings, "VkBufferCollectionPropertiesFUCHSIA", indents, dump_html_VkBufferCollectionPropertiesFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366007:
        dump_html_pNext<const VkImageFormatConstraintsInfoFUCHSIA>(static_cast<const VkImageFormatConstraintsInfoFUCHSIA*>(object), settings, "VkImageFormatConstraintsInfoFUCHSIA", indents, dump_html_VkImageFormatConstraintsInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
    case 1000366006:
        dump_html_pNext<const VkImageConstraintsInfoFUCHSIA>(static_cast<const VkImageConstraintsInfoFUCHSIA*>(object), settings, "VkImageConstraintsInfoFUCHSIA", indents, dump_html_VkImageConstraintsInfoFUCHSIA);
        break;
#endif // VK_USE_PLATFORM_FUCHSIA
    case 1000369000:
        dump_html_pNext<const VkSubpassShadingPipelineCreateInfoHUAWEI>(static_cast<const VkSubpassShadingPipelineCreateInfoHUAWEI*>(object), settings, "VkSubpassShadingPipelineCreateInfoHUAWEI", indents, dump_html_VkSubpassShadingPipelineCreateInfoHUAWEI);
        break;
    case 1000369001:
        dump_html_pNext<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>(static_cast<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*>(object), settings, "VkPhysicalDeviceSubpassShadingFeaturesHUAWEI", indents, dump_html_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI);
        break;
    case 1000369002:
        dump_html_pNext<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>(static_cast<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*>(object), settings, "VkPhysicalDeviceSubpassShadingPropertiesHUAWEI", indents, dump_html_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI);
        break;
    case 1000370000:
        dump_html_pNext<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>(static_cast<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(object), settings, "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI", indents, dump_html_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI);
        break;
    case 1000371000:
        dump_html_pNext<const VkMemoryGetRemoteAddressInfoNV>(static_cast<const VkMemoryGetRemoteAddressInfoNV*>(object), settings, "VkMemoryGetRemoteAddressInfoNV", indents, dump_html_VkMemoryGetRemoteAddressInfoNV);
        break;
    case 1000371001:
        dump_html_pNext<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>(static_cast<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(object), settings, "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV", indents, dump_html_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV);
        break;
    case 1000372000:
        dump_html_pNext<const VkPipelinePropertiesIdentifierEXT>(static_cast<const VkPipelinePropertiesIdentifierEXT*>(object), settings, "VkPipelinePropertiesIdentifierEXT", indents, dump_html_VkPipelinePropertiesIdentifierEXT);
        break;
    case 1000372001:
        dump_html_pNext<const VkPhysicalDevicePipelinePropertiesFeaturesEXT>(static_cast<const VkPhysicalDevicePipelinePropertiesFeaturesEXT*>(object), settings, "VkPhysicalDevicePipelinePropertiesFeaturesEXT", indents, dump_html_VkPhysicalDevicePipelinePropertiesFeaturesEXT);
        break;
    case 1000375000:
        dump_html_pNext<const VkPhysicalDeviceFrameBoundaryFeaturesEXT>(static_cast<const VkPhysicalDeviceFrameBoundaryFeaturesEXT*>(object), settings, "VkPhysicalDeviceFrameBoundaryFeaturesEXT", indents, dump_html_VkPhysicalDeviceFrameBoundaryFeaturesEXT);
        break;
    case 1000375001:
        dump_html_pNext<const VkFrameBoundaryEXT>(static_cast<const VkFrameBoundaryEXT*>(object), settings, "VkFrameBoundaryEXT", indents, dump_html_VkFrameBoundaryEXT);
        break;
    case 1000376000:
        dump_html_pNext<const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>(static_cast<const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*>(object), settings, "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT", indents, dump_html_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT);
        break;
    case 1000376001:
        dump_html_pNext<const VkSubpassResolvePerformanceQueryEXT>(static_cast<const VkSubpassResolvePerformanceQueryEXT*>(object), settings, "VkSubpassResolvePerformanceQueryEXT", indents, dump_html_VkSubpassResolvePerformanceQueryEXT);
        break;
    case 1000376002:
        dump_html_pNext<const VkMultisampledRenderToSingleSampledInfoEXT>(static_cast<const VkMultisampledRenderToSingleSampledInfoEXT*>(object), settings, "VkMultisampledRenderToSingleSampledInfoEXT", indents, dump_html_VkMultisampledRenderToSingleSampledInfoEXT);
        break;
    case 1000377000:
        dump_html_pNext<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(static_cast<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(object), settings, "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT", indents, dump_html_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    case 1000378000:
        dump_html_pNext<const VkScreenSurfaceCreateInfoQNX>(static_cast<const VkScreenSurfaceCreateInfoQNX*>(object), settings, "VkScreenSurfaceCreateInfoQNX", indents, dump_html_VkScreenSurfaceCreateInfoQNX);
        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX
    case 1000381000:
        dump_html_pNext<const VkPhysicalDeviceColorWriteEnableFeaturesEXT>(static_cast<const VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(object), settings, "VkPhysicalDeviceColorWriteEnableFeaturesEXT", indents, dump_html_VkPhysicalDeviceColorWriteEnableFeaturesEXT);
        break;
    case 1000381001:
        dump_html_pNext<const VkPipelineColorWriteCreateInfoEXT>(static_cast<const VkPipelineColorWriteCreateInfoEXT*>(object), settings, "VkPipelineColorWriteCreateInfoEXT", indents, dump_html_VkPipelineColorWriteCreateInfoEXT);
        break;
    case 1000382000:
        dump_html_pNext<const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>(static_cast<const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*>(object), settings, "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT", indents, dump_html_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT);
        break;
    case 1000386000:
        dump_html_pNext<const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>(static_cast<const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*>(object), settings, "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR", indents, dump_html_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR);
        break;
    case 1000391000:
        dump_html_pNext<const VkPhysicalDeviceImageViewMinLodFeaturesEXT>(static_cast<const VkPhysicalDeviceImageViewMinLodFeaturesEXT*>(object), settings, "VkPhysicalDeviceImageViewMinLodFeaturesEXT", indents, dump_html_VkPhysicalDeviceImageViewMinLodFeaturesEXT);
        break;
    case 1000391001:
        dump_html_pNext<const VkImageViewMinLodCreateInfoEXT>(static_cast<const VkImageViewMinLodCreateInfoEXT*>(object), settings, "VkImageViewMinLodCreateInfoEXT", indents, dump_html_VkImageViewMinLodCreateInfoEXT);
        break;
    case 1000392000:
        dump_html_pNext<const VkPhysicalDeviceMultiDrawFeaturesEXT>(static_cast<const VkPhysicalDeviceMultiDrawFeaturesEXT*>(object), settings, "VkPhysicalDeviceMultiDrawFeaturesEXT", indents, dump_html_VkPhysicalDeviceMultiDrawFeaturesEXT);
        break;
    case 1000392001:
        dump_html_pNext<const VkPhysicalDeviceMultiDrawPropertiesEXT>(static_cast<const VkPhysicalDeviceMultiDrawPropertiesEXT*>(object), settings, "VkPhysicalDeviceMultiDrawPropertiesEXT", indents, dump_html_VkPhysicalDeviceMultiDrawPropertiesEXT);
        break;
    case 1000393000:
        dump_html_pNext<const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>(static_cast<const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*>(object), settings, "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT", indents, dump_html_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT);
        break;
    case 1000395000:
        dump_html_pNext<const VkPhysicalDeviceShaderTileImageFeaturesEXT>(static_cast<const VkPhysicalDeviceShaderTileImageFeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderTileImageFeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderTileImageFeaturesEXT);
        break;
    case 1000395001:
        dump_html_pNext<const VkPhysicalDeviceShaderTileImagePropertiesEXT>(static_cast<const VkPhysicalDeviceShaderTileImagePropertiesEXT*>(object), settings, "VkPhysicalDeviceShaderTileImagePropertiesEXT", indents, dump_html_VkPhysicalDeviceShaderTileImagePropertiesEXT);
        break;
    case 1000396000:
        dump_html_pNext<const VkMicromapBuildInfoEXT>(static_cast<const VkMicromapBuildInfoEXT*>(object), settings, "VkMicromapBuildInfoEXT", indents, dump_html_VkMicromapBuildInfoEXT);
        break;
    case 1000396007:
        dump_html_pNext<const VkMicromapCreateInfoEXT>(static_cast<const VkMicromapCreateInfoEXT*>(object), settings, "VkMicromapCreateInfoEXT", indents, dump_html_VkMicromapCreateInfoEXT);
        break;
    case 1000396005:
        dump_html_pNext<const VkPhysicalDeviceOpacityMicromapFeaturesEXT>(static_cast<const VkPhysicalDeviceOpacityMicromapFeaturesEXT*>(object), settings, "VkPhysicalDeviceOpacityMicromapFeaturesEXT", indents, dump_html_VkPhysicalDeviceOpacityMicromapFeaturesEXT);
        break;
    case 1000396006:
        dump_html_pNext<const VkPhysicalDeviceOpacityMicromapPropertiesEXT>(static_cast<const VkPhysicalDeviceOpacityMicromapPropertiesEXT*>(object), settings, "VkPhysicalDeviceOpacityMicromapPropertiesEXT", indents, dump_html_VkPhysicalDeviceOpacityMicromapPropertiesEXT);
        break;
    case 1000396001:
        dump_html_pNext<const VkMicromapVersionInfoEXT>(static_cast<const VkMicromapVersionInfoEXT*>(object), settings, "VkMicromapVersionInfoEXT", indents, dump_html_VkMicromapVersionInfoEXT);
        break;
    case 1000396003:
        dump_html_pNext<const VkCopyMicromapToMemoryInfoEXT>(static_cast<const VkCopyMicromapToMemoryInfoEXT*>(object), settings, "VkCopyMicromapToMemoryInfoEXT", indents, dump_html_VkCopyMicromapToMemoryInfoEXT);
        break;
    case 1000396004:
        dump_html_pNext<const VkCopyMemoryToMicromapInfoEXT>(static_cast<const VkCopyMemoryToMicromapInfoEXT*>(object), settings, "VkCopyMemoryToMicromapInfoEXT", indents, dump_html_VkCopyMemoryToMicromapInfoEXT);
        break;
    case 1000396002:
        dump_html_pNext<const VkCopyMicromapInfoEXT>(static_cast<const VkCopyMicromapInfoEXT*>(object), settings, "VkCopyMicromapInfoEXT", indents, dump_html_VkCopyMicromapInfoEXT);
        break;
    case 1000396008:
        dump_html_pNext<const VkMicromapBuildSizesInfoEXT>(static_cast<const VkMicromapBuildSizesInfoEXT*>(object), settings, "VkMicromapBuildSizesInfoEXT", indents, dump_html_VkMicromapBuildSizesInfoEXT);
        break;
    case 1000396009:
        dump_html_pNext<const VkAccelerationStructureTrianglesOpacityMicromapEXT>(static_cast<const VkAccelerationStructureTrianglesOpacityMicromapEXT*>(object), settings, "VkAccelerationStructureTrianglesOpacityMicromapEXT", indents, dump_html_VkAccelerationStructureTrianglesOpacityMicromapEXT);
        break;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000397000:
        dump_html_pNext<const VkPhysicalDeviceDisplacementMicromapFeaturesNV>(static_cast<const VkPhysicalDeviceDisplacementMicromapFeaturesNV*>(object), settings, "VkPhysicalDeviceDisplacementMicromapFeaturesNV", indents, dump_html_VkPhysicalDeviceDisplacementMicromapFeaturesNV);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000397001:
        dump_html_pNext<const VkPhysicalDeviceDisplacementMicromapPropertiesNV>(static_cast<const VkPhysicalDeviceDisplacementMicromapPropertiesNV*>(object), settings, "VkPhysicalDeviceDisplacementMicromapPropertiesNV", indents, dump_html_VkPhysicalDeviceDisplacementMicromapPropertiesNV);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    case 1000397002:
        dump_html_pNext<const VkAccelerationStructureTrianglesDisplacementMicromapNV>(static_cast<const VkAccelerationStructureTrianglesDisplacementMicromapNV*>(object), settings, "VkAccelerationStructureTrianglesDisplacementMicromapNV", indents, dump_html_VkAccelerationStructureTrianglesDisplacementMicromapNV);
        break;
#endif // VK_ENABLE_BETA_EXTENSIONS
    case 1000404000:
        dump_html_pNext<const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>(static_cast<const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*>(object), settings, "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI", indents, dump_html_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI);
        break;
    case 1000404001:
        dump_html_pNext<const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>(static_cast<const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*>(object), settings, "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI", indents, dump_html_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI);
        break;
    case 1000404002:
        dump_html_pNext<const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>(static_cast<const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*>(object), settings, "VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI", indents, dump_html_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI);
        break;
    case 1000411000:
        dump_html_pNext<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>(static_cast<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(object), settings, "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT", indents, dump_html_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
        break;
    case 1000411001:
        dump_html_pNext<const VkSamplerBorderColorComponentMappingCreateInfoEXT>(static_cast<const VkSamplerBorderColorComponentMappingCreateInfoEXT*>(object), settings, "VkSamplerBorderColorComponentMappingCreateInfoEXT", indents, dump_html_VkSamplerBorderColorComponentMappingCreateInfoEXT);
        break;
    case 1000412000:
        dump_html_pNext<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>(static_cast<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(object), settings, "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT", indents, dump_html_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
        break;
    case 1000415000:
        dump_html_pNext<const VkPhysicalDeviceShaderCorePropertiesARM>(static_cast<const VkPhysicalDeviceShaderCorePropertiesARM*>(object), settings, "VkPhysicalDeviceShaderCorePropertiesARM", indents, dump_html_VkPhysicalDeviceShaderCorePropertiesARM);
        break;
    case 1000416000:
        dump_html_pNext<const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR);
        break;
    case 1000417000:
        dump_html_pNext<const VkDeviceQueueShaderCoreControlCreateInfoARM>(static_cast<const VkDeviceQueueShaderCoreControlCreateInfoARM*>(object), settings, "VkDeviceQueueShaderCoreControlCreateInfoARM", indents, dump_html_VkDeviceQueueShaderCoreControlCreateInfoARM);
        break;
    case 1000417001:
        dump_html_pNext<const VkPhysicalDeviceSchedulingControlsFeaturesARM>(static_cast<const VkPhysicalDeviceSchedulingControlsFeaturesARM*>(object), settings, "VkPhysicalDeviceSchedulingControlsFeaturesARM", indents, dump_html_VkPhysicalDeviceSchedulingControlsFeaturesARM);
        break;
    case 1000417002:
        dump_html_pNext<const VkPhysicalDeviceSchedulingControlsPropertiesARM>(static_cast<const VkPhysicalDeviceSchedulingControlsPropertiesARM*>(object), settings, "VkPhysicalDeviceSchedulingControlsPropertiesARM", indents, dump_html_VkPhysicalDeviceSchedulingControlsPropertiesARM);
        break;
    case 1000418000:
        dump_html_pNext<const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>(static_cast<const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*>(object), settings, "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT", indents, dump_html_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT);
        break;
    case 1000418001:
        dump_html_pNext<const VkImageViewSlicedCreateInfoEXT>(static_cast<const VkImageViewSlicedCreateInfoEXT*>(object), settings, "VkImageViewSlicedCreateInfoEXT", indents, dump_html_VkImageViewSlicedCreateInfoEXT);
        break;
    case 1000420000:
        dump_html_pNext<const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>(static_cast<const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*>(object), settings, "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE", indents, dump_html_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE);
        break;
    case 1000420001:
        dump_html_pNext<const VkDescriptorSetBindingReferenceVALVE>(static_cast<const VkDescriptorSetBindingReferenceVALVE*>(object), settings, "VkDescriptorSetBindingReferenceVALVE", indents, dump_html_VkDescriptorSetBindingReferenceVALVE);
        break;
    case 1000420002:
        dump_html_pNext<const VkDescriptorSetLayoutHostMappingInfoVALVE>(static_cast<const VkDescriptorSetLayoutHostMappingInfoVALVE*>(object), settings, "VkDescriptorSetLayoutHostMappingInfoVALVE", indents, dump_html_VkDescriptorSetLayoutHostMappingInfoVALVE);
        break;
    case 1000421000:
        dump_html_pNext<const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>(static_cast<const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*>(object), settings, "VkPhysicalDeviceDepthClampZeroOneFeaturesEXT", indents, dump_html_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT);
        break;
    case 1000422000:
        dump_html_pNext<const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>(static_cast<const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(object), settings, "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT", indents, dump_html_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT);
        break;
    case 1000424000:
        dump_html_pNext<const VkPhysicalDeviceRenderPassStripedFeaturesARM>(static_cast<const VkPhysicalDeviceRenderPassStripedFeaturesARM*>(object), settings, "VkPhysicalDeviceRenderPassStripedFeaturesARM", indents, dump_html_VkPhysicalDeviceRenderPassStripedFeaturesARM);
        break;
    case 1000424001:
        dump_html_pNext<const VkPhysicalDeviceRenderPassStripedPropertiesARM>(static_cast<const VkPhysicalDeviceRenderPassStripedPropertiesARM*>(object), settings, "VkPhysicalDeviceRenderPassStripedPropertiesARM", indents, dump_html_VkPhysicalDeviceRenderPassStripedPropertiesARM);
        break;
    case 1000424003:
        dump_html_pNext<const VkRenderPassStripeInfoARM>(static_cast<const VkRenderPassStripeInfoARM*>(object), settings, "VkRenderPassStripeInfoARM", indents, dump_html_VkRenderPassStripeInfoARM);
        break;
    case 1000424002:
        dump_html_pNext<const VkRenderPassStripeBeginInfoARM>(static_cast<const VkRenderPassStripeBeginInfoARM*>(object), settings, "VkRenderPassStripeBeginInfoARM", indents, dump_html_VkRenderPassStripeBeginInfoARM);
        break;
    case 1000424004:
        dump_html_pNext<const VkRenderPassStripeSubmitInfoARM>(static_cast<const VkRenderPassStripeSubmitInfoARM*>(object), settings, "VkRenderPassStripeSubmitInfoARM", indents, dump_html_VkRenderPassStripeSubmitInfoARM);
        break;
    case 1000425000:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>(static_cast<const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*>(object), settings, "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM", indents, dump_html_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM);
        break;
    case 1000425001:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM>(static_cast<const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*>(object), settings, "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM", indents, dump_html_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM);
        break;
    case 1000425002:
        dump_html_pNext<const VkSubpassFragmentDensityMapOffsetEndInfoQCOM>(static_cast<const VkSubpassFragmentDensityMapOffsetEndInfoQCOM*>(object), settings, "VkSubpassFragmentDensityMapOffsetEndInfoQCOM", indents, dump_html_VkSubpassFragmentDensityMapOffsetEndInfoQCOM);
        break;
    case 1000426000:
        dump_html_pNext<const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>(static_cast<const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*>(object), settings, "VkPhysicalDeviceCopyMemoryIndirectFeaturesNV", indents, dump_html_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV);
        break;
    case 1000426001:
        dump_html_pNext<const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>(static_cast<const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*>(object), settings, "VkPhysicalDeviceCopyMemoryIndirectPropertiesNV", indents, dump_html_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV);
        break;
    case 1000427000:
        dump_html_pNext<const VkPhysicalDeviceMemoryDecompressionFeaturesNV>(static_cast<const VkPhysicalDeviceMemoryDecompressionFeaturesNV*>(object), settings, "VkPhysicalDeviceMemoryDecompressionFeaturesNV", indents, dump_html_VkPhysicalDeviceMemoryDecompressionFeaturesNV);
        break;
    case 1000427001:
        dump_html_pNext<const VkPhysicalDeviceMemoryDecompressionPropertiesNV>(static_cast<const VkPhysicalDeviceMemoryDecompressionPropertiesNV*>(object), settings, "VkPhysicalDeviceMemoryDecompressionPropertiesNV", indents, dump_html_VkPhysicalDeviceMemoryDecompressionPropertiesNV);
        break;
    case 1000428000:
        dump_html_pNext<const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>(static_cast<const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*>(object), settings, "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV", indents, dump_html_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV);
        break;
    case 1000428001:
        dump_html_pNext<const VkComputePipelineIndirectBufferInfoNV>(static_cast<const VkComputePipelineIndirectBufferInfoNV*>(object), settings, "VkComputePipelineIndirectBufferInfoNV", indents, dump_html_VkComputePipelineIndirectBufferInfoNV);
        break;
    case 1000428002:
        dump_html_pNext<const VkPipelineIndirectDeviceAddressInfoNV>(static_cast<const VkPipelineIndirectDeviceAddressInfoNV*>(object), settings, "VkPipelineIndirectDeviceAddressInfoNV", indents, dump_html_VkPipelineIndirectDeviceAddressInfoNV);
        break;
    case 1000430000:
        dump_html_pNext<const VkPhysicalDeviceLinearColorAttachmentFeaturesNV>(static_cast<const VkPhysicalDeviceLinearColorAttachmentFeaturesNV*>(object), settings, "VkPhysicalDeviceLinearColorAttachmentFeaturesNV", indents, dump_html_VkPhysicalDeviceLinearColorAttachmentFeaturesNV);
        break;
    case 1000434000:
        dump_html_pNext<const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR);
        break;
    case 1000437000:
        dump_html_pNext<const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>(static_cast<const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(object), settings, "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT", indents, dump_html_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT);
        break;
    case 1000440002:
        dump_html_pNext<const VkImageViewSampleWeightCreateInfoQCOM>(static_cast<const VkImageViewSampleWeightCreateInfoQCOM*>(object), settings, "VkImageViewSampleWeightCreateInfoQCOM", indents, dump_html_VkImageViewSampleWeightCreateInfoQCOM);
        break;
    case 1000440000:
        dump_html_pNext<const VkPhysicalDeviceImageProcessingFeaturesQCOM>(static_cast<const VkPhysicalDeviceImageProcessingFeaturesQCOM*>(object), settings, "VkPhysicalDeviceImageProcessingFeaturesQCOM", indents, dump_html_VkPhysicalDeviceImageProcessingFeaturesQCOM);
        break;
    case 1000440001:
        dump_html_pNext<const VkPhysicalDeviceImageProcessingPropertiesQCOM>(static_cast<const VkPhysicalDeviceImageProcessingPropertiesQCOM*>(object), settings, "VkPhysicalDeviceImageProcessingPropertiesQCOM", indents, dump_html_VkPhysicalDeviceImageProcessingPropertiesQCOM);
        break;
    case 1000451000:
        dump_html_pNext<const VkPhysicalDeviceNestedCommandBufferFeaturesEXT>(static_cast<const VkPhysicalDeviceNestedCommandBufferFeaturesEXT*>(object), settings, "VkPhysicalDeviceNestedCommandBufferFeaturesEXT", indents, dump_html_VkPhysicalDeviceNestedCommandBufferFeaturesEXT);
        break;
    case 1000451001:
        dump_html_pNext<const VkPhysicalDeviceNestedCommandBufferPropertiesEXT>(static_cast<const VkPhysicalDeviceNestedCommandBufferPropertiesEXT*>(object), settings, "VkPhysicalDeviceNestedCommandBufferPropertiesEXT", indents, dump_html_VkPhysicalDeviceNestedCommandBufferPropertiesEXT);
        break;
    case 1000453000:
        dump_html_pNext<const VkExternalMemoryAcquireUnmodifiedEXT>(static_cast<const VkExternalMemoryAcquireUnmodifiedEXT*>(object), settings, "VkExternalMemoryAcquireUnmodifiedEXT", indents, dump_html_VkExternalMemoryAcquireUnmodifiedEXT);
        break;
    case 1000455000:
        dump_html_pNext<const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>(static_cast<const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(object), settings, "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT", indents, dump_html_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT);
        break;
    case 1000455001:
        dump_html_pNext<const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>(static_cast<const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*>(object), settings, "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT", indents, dump_html_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT);
        break;
    case 1000458000:
        dump_html_pNext<const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>(static_cast<const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*>(object), settings, "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT", indents, dump_html_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT);
        break;
    case 1000458001:
        dump_html_pNext<const VkRenderPassCreationControlEXT>(static_cast<const VkRenderPassCreationControlEXT*>(object), settings, "VkRenderPassCreationControlEXT", indents, dump_html_VkRenderPassCreationControlEXT);
        break;
    case 1000458002:
        dump_html_pNext<const VkRenderPassCreationFeedbackCreateInfoEXT>(static_cast<const VkRenderPassCreationFeedbackCreateInfoEXT*>(object), settings, "VkRenderPassCreationFeedbackCreateInfoEXT", indents, dump_html_VkRenderPassCreationFeedbackCreateInfoEXT);
        break;
    case 1000458003:
        dump_html_pNext<const VkRenderPassSubpassFeedbackCreateInfoEXT>(static_cast<const VkRenderPassSubpassFeedbackCreateInfoEXT*>(object), settings, "VkRenderPassSubpassFeedbackCreateInfoEXT", indents, dump_html_VkRenderPassSubpassFeedbackCreateInfoEXT);
        break;
    case 1000459000:
        dump_html_pNext<const VkDirectDriverLoadingInfoLUNARG>(static_cast<const VkDirectDriverLoadingInfoLUNARG*>(object), settings, "VkDirectDriverLoadingInfoLUNARG", indents, dump_html_VkDirectDriverLoadingInfoLUNARG);
        break;
    case 1000459001:
        dump_html_pNext<const VkDirectDriverLoadingListLUNARG>(static_cast<const VkDirectDriverLoadingListLUNARG*>(object), settings, "VkDirectDriverLoadingListLUNARG", indents, dump_html_VkDirectDriverLoadingListLUNARG);
        break;
    case 1000462000:
        dump_html_pNext<const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>(static_cast<const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT);
        break;
    case 1000462001:
        dump_html_pNext<const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>(static_cast<const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*>(object), settings, "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT", indents, dump_html_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT);
        break;
    case 1000462002:
        dump_html_pNext<const VkPipelineShaderStageModuleIdentifierCreateInfoEXT>(static_cast<const VkPipelineShaderStageModuleIdentifierCreateInfoEXT*>(object), settings, "VkPipelineShaderStageModuleIdentifierCreateInfoEXT", indents, dump_html_VkPipelineShaderStageModuleIdentifierCreateInfoEXT);
        break;
    case 1000462003:
        dump_html_pNext<const VkShaderModuleIdentifierEXT>(static_cast<const VkShaderModuleIdentifierEXT*>(object), settings, "VkShaderModuleIdentifierEXT", indents, dump_html_VkShaderModuleIdentifierEXT);
        break;
    case 1000464000:
        dump_html_pNext<const VkPhysicalDeviceOpticalFlowFeaturesNV>(static_cast<const VkPhysicalDeviceOpticalFlowFeaturesNV*>(object), settings, "VkPhysicalDeviceOpticalFlowFeaturesNV", indents, dump_html_VkPhysicalDeviceOpticalFlowFeaturesNV);
        break;
    case 1000464001:
        dump_html_pNext<const VkPhysicalDeviceOpticalFlowPropertiesNV>(static_cast<const VkPhysicalDeviceOpticalFlowPropertiesNV*>(object), settings, "VkPhysicalDeviceOpticalFlowPropertiesNV", indents, dump_html_VkPhysicalDeviceOpticalFlowPropertiesNV);
        break;
    case 1000464002:
        dump_html_pNext<const VkOpticalFlowImageFormatInfoNV>(static_cast<const VkOpticalFlowImageFormatInfoNV*>(object), settings, "VkOpticalFlowImageFormatInfoNV", indents, dump_html_VkOpticalFlowImageFormatInfoNV);
        break;
    case 1000464003:
        dump_html_pNext<const VkOpticalFlowImageFormatPropertiesNV>(static_cast<const VkOpticalFlowImageFormatPropertiesNV*>(object), settings, "VkOpticalFlowImageFormatPropertiesNV", indents, dump_html_VkOpticalFlowImageFormatPropertiesNV);
        break;
    case 1000464004:
        dump_html_pNext<const VkOpticalFlowSessionCreateInfoNV>(static_cast<const VkOpticalFlowSessionCreateInfoNV*>(object), settings, "VkOpticalFlowSessionCreateInfoNV", indents, dump_html_VkOpticalFlowSessionCreateInfoNV);
        break;
    case 1000464010:
        dump_html_pNext<const VkOpticalFlowSessionCreatePrivateDataInfoNV>(static_cast<const VkOpticalFlowSessionCreatePrivateDataInfoNV*>(object), settings, "VkOpticalFlowSessionCreatePrivateDataInfoNV", indents, dump_html_VkOpticalFlowSessionCreatePrivateDataInfoNV);
        break;
    case 1000464005:
        dump_html_pNext<const VkOpticalFlowExecuteInfoNV>(static_cast<const VkOpticalFlowExecuteInfoNV*>(object), settings, "VkOpticalFlowExecuteInfoNV", indents, dump_html_VkOpticalFlowExecuteInfoNV);
        break;
    case 1000465000:
        dump_html_pNext<const VkPhysicalDeviceLegacyDitheringFeaturesEXT>(static_cast<const VkPhysicalDeviceLegacyDitheringFeaturesEXT*>(object), settings, "VkPhysicalDeviceLegacyDitheringFeaturesEXT", indents, dump_html_VkPhysicalDeviceLegacyDitheringFeaturesEXT);
        break;
    case 1000466000:
        dump_html_pNext<const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>(static_cast<const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*>(object), settings, "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT", indents, dump_html_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000468000:
        dump_html_pNext<const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>(static_cast<const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*>(object), settings, "VkPhysicalDeviceExternalFormatResolveFeaturesANDROID", indents, dump_html_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000468001:
        dump_html_pNext<const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>(static_cast<const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID*>(object), settings, "VkPhysicalDeviceExternalFormatResolvePropertiesANDROID", indents, dump_html_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000468002:
        dump_html_pNext<const VkAndroidHardwareBufferFormatResolvePropertiesANDROID>(static_cast<const VkAndroidHardwareBufferFormatResolvePropertiesANDROID*>(object), settings, "VkAndroidHardwareBufferFormatResolvePropertiesANDROID", indents, dump_html_VkAndroidHardwareBufferFormatResolvePropertiesANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
    case 1000470000:
        dump_html_pNext<const VkPhysicalDeviceMaintenance5FeaturesKHR>(static_cast<const VkPhysicalDeviceMaintenance5FeaturesKHR*>(object), settings, "VkPhysicalDeviceMaintenance5FeaturesKHR", indents, dump_html_VkPhysicalDeviceMaintenance5FeaturesKHR);
        break;
    case 1000470001:
        dump_html_pNext<const VkPhysicalDeviceMaintenance5PropertiesKHR>(static_cast<const VkPhysicalDeviceMaintenance5PropertiesKHR*>(object), settings, "VkPhysicalDeviceMaintenance5PropertiesKHR", indents, dump_html_VkPhysicalDeviceMaintenance5PropertiesKHR);
        break;
    case 1000470003:
        dump_html_pNext<const VkRenderingAreaInfoKHR>(static_cast<const VkRenderingAreaInfoKHR*>(object), settings, "VkRenderingAreaInfoKHR", indents, dump_html_VkRenderingAreaInfoKHR);
        break;
    case 1000470004:
        dump_html_pNext<const VkDeviceImageSubresourceInfoKHR>(static_cast<const VkDeviceImageSubresourceInfoKHR*>(object), settings, "VkDeviceImageSubresourceInfoKHR", indents, dump_html_VkDeviceImageSubresourceInfoKHR);
        break;
    case 1000470005:
        dump_html_pNext<const VkPipelineCreateFlags2CreateInfoKHR>(static_cast<const VkPipelineCreateFlags2CreateInfoKHR*>(object), settings, "VkPipelineCreateFlags2CreateInfoKHR", indents, dump_html_VkPipelineCreateFlags2CreateInfoKHR);
        break;
    case 1000470006:
        dump_html_pNext<const VkBufferUsageFlags2CreateInfoKHR>(static_cast<const VkBufferUsageFlags2CreateInfoKHR*>(object), settings, "VkBufferUsageFlags2CreateInfoKHR", indents, dump_html_VkBufferUsageFlags2CreateInfoKHR);
        break;
    case 1000481000:
        dump_html_pNext<const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>(static_cast<const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*>(object), settings, "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR", indents, dump_html_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR);
        break;
    case 1000482000:
        dump_html_pNext<const VkPhysicalDeviceShaderObjectFeaturesEXT>(static_cast<const VkPhysicalDeviceShaderObjectFeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderObjectFeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderObjectFeaturesEXT);
        break;
    case 1000482001:
        dump_html_pNext<const VkPhysicalDeviceShaderObjectPropertiesEXT>(static_cast<const VkPhysicalDeviceShaderObjectPropertiesEXT*>(object), settings, "VkPhysicalDeviceShaderObjectPropertiesEXT", indents, dump_html_VkPhysicalDeviceShaderObjectPropertiesEXT);
        break;
    case 1000482002:
        dump_html_pNext<const VkShaderCreateInfoEXT>(static_cast<const VkShaderCreateInfoEXT*>(object), settings, "VkShaderCreateInfoEXT", indents, dump_html_VkShaderCreateInfoEXT);
        break;
    case 1000484000:
        dump_html_pNext<const VkPhysicalDeviceTilePropertiesFeaturesQCOM>(static_cast<const VkPhysicalDeviceTilePropertiesFeaturesQCOM*>(object), settings, "VkPhysicalDeviceTilePropertiesFeaturesQCOM", indents, dump_html_VkPhysicalDeviceTilePropertiesFeaturesQCOM);
        break;
    case 1000484001:
        dump_html_pNext<const VkTilePropertiesQCOM>(static_cast<const VkTilePropertiesQCOM*>(object), settings, "VkTilePropertiesQCOM", indents, dump_html_VkTilePropertiesQCOM);
        break;
    case 1000485000:
        dump_html_pNext<const VkPhysicalDeviceAmigoProfilingFeaturesSEC>(static_cast<const VkPhysicalDeviceAmigoProfilingFeaturesSEC*>(object), settings, "VkPhysicalDeviceAmigoProfilingFeaturesSEC", indents, dump_html_VkPhysicalDeviceAmigoProfilingFeaturesSEC);
        break;
    case 1000485001:
        dump_html_pNext<const VkAmigoProfilingSubmitInfoSEC>(static_cast<const VkAmigoProfilingSubmitInfoSEC*>(object), settings, "VkAmigoProfilingSubmitInfoSEC", indents, dump_html_VkAmigoProfilingSubmitInfoSEC);
        break;
    case 1000488000:
        dump_html_pNext<const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>(static_cast<const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*>(object), settings, "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM", indents, dump_html_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM);
        break;
    case 1000490001:
        dump_html_pNext<const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>(static_cast<const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*>(object), settings, "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV", indents, dump_html_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV);
        break;
    case 1000490000:
        dump_html_pNext<const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>(static_cast<const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*>(object), settings, "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV", indents, dump_html_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV);
        break;
    case 1000492000:
        dump_html_pNext<const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>(static_cast<const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*>(object), settings, "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV", indents, dump_html_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV);
        break;
    case 1000492001:
        dump_html_pNext<const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>(static_cast<const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*>(object), settings, "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV", indents, dump_html_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV);
        break;
    case 1000496000:
        dump_html_pNext<const VkLayerSettingsCreateInfoEXT>(static_cast<const VkLayerSettingsCreateInfoEXT*>(object), settings, "VkLayerSettingsCreateInfoEXT", indents, dump_html_VkLayerSettingsCreateInfoEXT);
        break;
    case 1000497000:
        dump_html_pNext<const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>(static_cast<const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*>(object), settings, "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM", indents, dump_html_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM);
        break;
    case 1000497001:
        dump_html_pNext<const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>(static_cast<const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*>(object), settings, "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM", indents, dump_html_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM);
        break;
    case 1000498000:
        dump_html_pNext<const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>(static_cast<const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*>(object), settings, "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT", indents, dump_html_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT);
        break;
    case 1000499000:
        dump_html_pNext<const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>(static_cast<const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*>(object), settings, "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT", indents, dump_html_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT);
        break;
    case 1000505000:
        dump_html_pNext<const VkLatencySleepModeInfoNV>(static_cast<const VkLatencySleepModeInfoNV*>(object), settings, "VkLatencySleepModeInfoNV", indents, dump_html_VkLatencySleepModeInfoNV);
        break;
    case 1000505001:
        dump_html_pNext<const VkLatencySleepInfoNV>(static_cast<const VkLatencySleepInfoNV*>(object), settings, "VkLatencySleepInfoNV", indents, dump_html_VkLatencySleepInfoNV);
        break;
    case 1000505002:
        dump_html_pNext<const VkSetLatencyMarkerInfoNV>(static_cast<const VkSetLatencyMarkerInfoNV*>(object), settings, "VkSetLatencyMarkerInfoNV", indents, dump_html_VkSetLatencyMarkerInfoNV);
        break;
    case 1000505004:
        dump_html_pNext<const VkLatencyTimingsFrameReportNV>(static_cast<const VkLatencyTimingsFrameReportNV*>(object), settings, "VkLatencyTimingsFrameReportNV", indents, dump_html_VkLatencyTimingsFrameReportNV);
        break;
    case 1000505003:
        dump_html_pNext<const VkGetLatencyMarkerInfoNV>(static_cast<const VkGetLatencyMarkerInfoNV*>(object), settings, "VkGetLatencyMarkerInfoNV", indents, dump_html_VkGetLatencyMarkerInfoNV);
        break;
    case 1000505005:
        dump_html_pNext<const VkLatencySubmissionPresentIdNV>(static_cast<const VkLatencySubmissionPresentIdNV*>(object), settings, "VkLatencySubmissionPresentIdNV", indents, dump_html_VkLatencySubmissionPresentIdNV);
        break;
    case 1000505007:
        dump_html_pNext<const VkSwapchainLatencyCreateInfoNV>(static_cast<const VkSwapchainLatencyCreateInfoNV*>(object), settings, "VkSwapchainLatencyCreateInfoNV", indents, dump_html_VkSwapchainLatencyCreateInfoNV);
        break;
    case 1000505006:
        dump_html_pNext<const VkOutOfBandQueueTypeInfoNV>(static_cast<const VkOutOfBandQueueTypeInfoNV*>(object), settings, "VkOutOfBandQueueTypeInfoNV", indents, dump_html_VkOutOfBandQueueTypeInfoNV);
        break;
    case 1000505008:
        dump_html_pNext<const VkLatencySurfaceCapabilitiesNV>(static_cast<const VkLatencySurfaceCapabilitiesNV*>(object), settings, "VkLatencySurfaceCapabilitiesNV", indents, dump_html_VkLatencySurfaceCapabilitiesNV);
        break;
    case 1000506001:
        dump_html_pNext<const VkCooperativeMatrixPropertiesKHR>(static_cast<const VkCooperativeMatrixPropertiesKHR*>(object), settings, "VkCooperativeMatrixPropertiesKHR", indents, dump_html_VkCooperativeMatrixPropertiesKHR);
        break;
    case 1000506000:
        dump_html_pNext<const VkPhysicalDeviceCooperativeMatrixFeaturesKHR>(static_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesKHR*>(object), settings, "VkPhysicalDeviceCooperativeMatrixFeaturesKHR", indents, dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesKHR);
        break;
    case 1000506002:
        dump_html_pNext<const VkPhysicalDeviceCooperativeMatrixPropertiesKHR>(static_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesKHR*>(object), settings, "VkPhysicalDeviceCooperativeMatrixPropertiesKHR", indents, dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesKHR);
        break;
    case 1000510000:
        dump_html_pNext<const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>(static_cast<const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*>(object), settings, "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM", indents, dump_html_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM);
        break;
    case 1000510001:
        dump_html_pNext<const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>(static_cast<const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*>(object), settings, "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM", indents, dump_html_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM);
        break;
    case 1000512003:
        dump_html_pNext<const VkVideoDecodeAV1ProfileInfoKHR>(static_cast<const VkVideoDecodeAV1ProfileInfoKHR*>(object), settings, "VkVideoDecodeAV1ProfileInfoKHR", indents, dump_html_VkVideoDecodeAV1ProfileInfoKHR);
        break;
    case 1000512000:
        dump_html_pNext<const VkVideoDecodeAV1CapabilitiesKHR>(static_cast<const VkVideoDecodeAV1CapabilitiesKHR*>(object), settings, "VkVideoDecodeAV1CapabilitiesKHR", indents, dump_html_VkVideoDecodeAV1CapabilitiesKHR);
        break;
    case 1000512004:
        dump_html_pNext<const VkVideoDecodeAV1SessionParametersCreateInfoKHR>(static_cast<const VkVideoDecodeAV1SessionParametersCreateInfoKHR*>(object), settings, "VkVideoDecodeAV1SessionParametersCreateInfoKHR", indents, dump_html_VkVideoDecodeAV1SessionParametersCreateInfoKHR);
        break;
    case 1000512001:
        dump_html_pNext<const VkVideoDecodeAV1PictureInfoKHR>(static_cast<const VkVideoDecodeAV1PictureInfoKHR*>(object), settings, "VkVideoDecodeAV1PictureInfoKHR", indents, dump_html_VkVideoDecodeAV1PictureInfoKHR);
        break;
    case 1000512005:
        dump_html_pNext<const VkVideoDecodeAV1DpbSlotInfoKHR>(static_cast<const VkVideoDecodeAV1DpbSlotInfoKHR*>(object), settings, "VkVideoDecodeAV1DpbSlotInfoKHR", indents, dump_html_VkVideoDecodeAV1DpbSlotInfoKHR);
        break;
    case 1000515000:
        dump_html_pNext<const VkPhysicalDeviceVideoMaintenance1FeaturesKHR>(static_cast<const VkPhysicalDeviceVideoMaintenance1FeaturesKHR*>(object), settings, "VkPhysicalDeviceVideoMaintenance1FeaturesKHR", indents, dump_html_VkPhysicalDeviceVideoMaintenance1FeaturesKHR);
        break;
    case 1000515001:
        dump_html_pNext<const VkVideoInlineQueryInfoKHR>(static_cast<const VkVideoInlineQueryInfoKHR*>(object), settings, "VkVideoInlineQueryInfoKHR", indents, dump_html_VkVideoInlineQueryInfoKHR);
        break;
    case 1000516000:
        dump_html_pNext<const VkPhysicalDevicePerStageDescriptorSetFeaturesNV>(static_cast<const VkPhysicalDevicePerStageDescriptorSetFeaturesNV*>(object), settings, "VkPhysicalDevicePerStageDescriptorSetFeaturesNV", indents, dump_html_VkPhysicalDevicePerStageDescriptorSetFeaturesNV);
        break;
    case 1000518000:
        dump_html_pNext<const VkPhysicalDeviceImageProcessing2FeaturesQCOM>(static_cast<const VkPhysicalDeviceImageProcessing2FeaturesQCOM*>(object), settings, "VkPhysicalDeviceImageProcessing2FeaturesQCOM", indents, dump_html_VkPhysicalDeviceImageProcessing2FeaturesQCOM);
        break;
    case 1000518001:
        dump_html_pNext<const VkPhysicalDeviceImageProcessing2PropertiesQCOM>(static_cast<const VkPhysicalDeviceImageProcessing2PropertiesQCOM*>(object), settings, "VkPhysicalDeviceImageProcessing2PropertiesQCOM", indents, dump_html_VkPhysicalDeviceImageProcessing2PropertiesQCOM);
        break;
    case 1000518002:
        dump_html_pNext<const VkSamplerBlockMatchWindowCreateInfoQCOM>(static_cast<const VkSamplerBlockMatchWindowCreateInfoQCOM*>(object), settings, "VkSamplerBlockMatchWindowCreateInfoQCOM", indents, dump_html_VkSamplerBlockMatchWindowCreateInfoQCOM);
        break;
    case 1000519001:
        dump_html_pNext<const VkPhysicalDeviceCubicWeightsFeaturesQCOM>(static_cast<const VkPhysicalDeviceCubicWeightsFeaturesQCOM*>(object), settings, "VkPhysicalDeviceCubicWeightsFeaturesQCOM", indents, dump_html_VkPhysicalDeviceCubicWeightsFeaturesQCOM);
        break;
    case 1000519000:
        dump_html_pNext<const VkSamplerCubicWeightsCreateInfoQCOM>(static_cast<const VkSamplerCubicWeightsCreateInfoQCOM*>(object), settings, "VkSamplerCubicWeightsCreateInfoQCOM", indents, dump_html_VkSamplerCubicWeightsCreateInfoQCOM);
        break;
    case 1000519002:
        dump_html_pNext<const VkBlitImageCubicWeightsInfoQCOM>(static_cast<const VkBlitImageCubicWeightsInfoQCOM*>(object), settings, "VkBlitImageCubicWeightsInfoQCOM", indents, dump_html_VkBlitImageCubicWeightsInfoQCOM);
        break;
    case 1000520000:
        dump_html_pNext<const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>(static_cast<const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*>(object), settings, "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM", indents, dump_html_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM);
        break;
    case 1000520001:
        dump_html_pNext<const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>(static_cast<const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*>(object), settings, "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM", indents, dump_html_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM);
        break;
    case 1000521000:
        dump_html_pNext<const VkPhysicalDeviceCubicClampFeaturesQCOM>(static_cast<const VkPhysicalDeviceCubicClampFeaturesQCOM*>(object), settings, "VkPhysicalDeviceCubicClampFeaturesQCOM", indents, dump_html_VkPhysicalDeviceCubicClampFeaturesQCOM);
        break;
    case 1000524000:
        dump_html_pNext<const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>(static_cast<const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*>(object), settings, "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT", indents, dump_html_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT);
        break;
    case 1000525000:
        dump_html_pNext<const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR>(static_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR*>(object), settings, "VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR", indents, dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR);
        break;
    case 1000528000:
        dump_html_pNext<const VkPhysicalDeviceShaderFloatControls2FeaturesKHR>(static_cast<const VkPhysicalDeviceShaderFloatControls2FeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderFloatControls2FeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderFloatControls2FeaturesKHR);
        break;
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    case 1000529000:
        dump_html_pNext<const VkScreenBufferPropertiesQNX>(static_cast<const VkScreenBufferPropertiesQNX*>(object), settings, "VkScreenBufferPropertiesQNX", indents, dump_html_VkScreenBufferPropertiesQNX);
        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    case 1000529001:
        dump_html_pNext<const VkScreenBufferFormatPropertiesQNX>(static_cast<const VkScreenBufferFormatPropertiesQNX*>(object), settings, "VkScreenBufferFormatPropertiesQNX", indents, dump_html_VkScreenBufferFormatPropertiesQNX);
        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    case 1000529002:
        dump_html_pNext<const VkImportScreenBufferInfoQNX>(static_cast<const VkImportScreenBufferInfoQNX*>(object), settings, "VkImportScreenBufferInfoQNX", indents, dump_html_VkImportScreenBufferInfoQNX);
        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    case 1000529003:
        dump_html_pNext<const VkExternalFormatQNX>(static_cast<const VkExternalFormatQNX*>(object), settings, "VkExternalFormatQNX", indents, dump_html_VkExternalFormatQNX);
        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    case 1000529004:
        dump_html_pNext<const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>(static_cast<const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*>(object), settings, "VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX", indents, dump_html_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX);
        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX
    case 1000530000:
        dump_html_pNext<const VkPhysicalDeviceLayeredDriverPropertiesMSFT>(static_cast<const VkPhysicalDeviceLayeredDriverPropertiesMSFT*>(object), settings, "VkPhysicalDeviceLayeredDriverPropertiesMSFT", indents, dump_html_VkPhysicalDeviceLayeredDriverPropertiesMSFT);
        break;
    case 1000544000:
        dump_html_pNext<const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderExpectAssumeFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderExpectAssumeFeaturesKHR);
        break;
    case 1000545000:
        dump_html_pNext<const VkPhysicalDeviceMaintenance6FeaturesKHR>(static_cast<const VkPhysicalDeviceMaintenance6FeaturesKHR*>(object), settings, "VkPhysicalDeviceMaintenance6FeaturesKHR", indents, dump_html_VkPhysicalDeviceMaintenance6FeaturesKHR);
        break;
    case 1000545001:
        dump_html_pNext<const VkPhysicalDeviceMaintenance6PropertiesKHR>(static_cast<const VkPhysicalDeviceMaintenance6PropertiesKHR*>(object), settings, "VkPhysicalDeviceMaintenance6PropertiesKHR", indents, dump_html_VkPhysicalDeviceMaintenance6PropertiesKHR);
        break;
    case 1000545002:
        dump_html_pNext<const VkBindMemoryStatusKHR>(static_cast<const VkBindMemoryStatusKHR*>(object), settings, "VkBindMemoryStatusKHR", indents, dump_html_VkBindMemoryStatusKHR);
        break;
    case 1000545003:
        dump_html_pNext<const VkBindDescriptorSetsInfoKHR>(static_cast<const VkBindDescriptorSetsInfoKHR*>(object), settings, "VkBindDescriptorSetsInfoKHR", indents, dump_html_VkBindDescriptorSetsInfoKHR);
        break;
    case 1000545004:
        dump_html_pNext<const VkPushConstantsInfoKHR>(static_cast<const VkPushConstantsInfoKHR*>(object), settings, "VkPushConstantsInfoKHR", indents, dump_html_VkPushConstantsInfoKHR);
        break;
    case 1000545005:
        dump_html_pNext<const VkPushDescriptorSetInfoKHR>(static_cast<const VkPushDescriptorSetInfoKHR*>(object), settings, "VkPushDescriptorSetInfoKHR", indents, dump_html_VkPushDescriptorSetInfoKHR);
        break;
    case 1000545006:
        dump_html_pNext<const VkPushDescriptorSetWithTemplateInfoKHR>(static_cast<const VkPushDescriptorSetWithTemplateInfoKHR*>(object), settings, "VkPushDescriptorSetWithTemplateInfoKHR", indents, dump_html_VkPushDescriptorSetWithTemplateInfoKHR);
        break;
    case 1000545007:
        dump_html_pNext<const VkSetDescriptorBufferOffsetsInfoEXT>(static_cast<const VkSetDescriptorBufferOffsetsInfoEXT*>(object), settings, "VkSetDescriptorBufferOffsetsInfoEXT", indents, dump_html_VkSetDescriptorBufferOffsetsInfoEXT);
        break;
    case 1000545008:
        dump_html_pNext<const VkBindDescriptorBufferEmbeddedSamplersInfoEXT>(static_cast<const VkBindDescriptorBufferEmbeddedSamplersInfoEXT*>(object), settings, "VkBindDescriptorBufferEmbeddedSamplersInfoEXT", indents, dump_html_VkBindDescriptorBufferEmbeddedSamplersInfoEXT);
        break;
    case 1000546000:
        dump_html_pNext<const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>(static_cast<const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*>(object), settings, "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV", indents, dump_html_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV);
        break;
    case 1000555000:
        dump_html_pNext<const VkPhysicalDeviceRawAccessChainsFeaturesNV>(static_cast<const VkPhysicalDeviceRawAccessChainsFeaturesNV*>(object), settings, "VkPhysicalDeviceRawAccessChainsFeaturesNV", indents, dump_html_VkPhysicalDeviceRawAccessChainsFeaturesNV);
        break;
    case 1000563000:
        dump_html_pNext<const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>(static_cast<const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*>(object), settings, "VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV", indents, dump_html_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV);
        break;
    case 1000568000:
        dump_html_pNext<const VkPhysicalDeviceRayTracingValidationFeaturesNV>(static_cast<const VkPhysicalDeviceRayTracingValidationFeaturesNV*>(object), settings, "VkPhysicalDeviceRayTracingValidationFeaturesNV", indents, dump_html_VkPhysicalDeviceRayTracingValidationFeaturesNV);
        break;
    case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: // 47
    case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: // 48
        if(static_cast<const VkBaseInStructure*>(object)->pNext != nullptr){
            dump_html_pNext_trampoline(static_cast<const void*>(static_cast<const VkBaseInStructure*>(object)->pNext), settings, indents);
        } else {
            settings.stream() << "<details class='data'><summary>";
            dump_html_nametype(settings.stream(), settings.showType(), "pNext", "const void*");
            settings.stream() << "<div class='val'> NULL</div></summary></details>";
        }
        break;
    default:
        settings.stream() << "<details class='data'><summary>";
        dump_html_nametype(settings.stream(), settings.showType(), "pNext", "const void*");
        settings.stream() << "<div class='val'>UNKNOWN (" << (int64_t) (static_cast<const VkBaseInStructure*>(object)->sType) <<")</div></summary></details>";
    }
}

//========================= Function Implementations ========================//

void dump_html_vkCreateInstance(ApiDumpInstance& dump_inst, VkResult result, const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_pointer<const VkInstanceCreateInfo>(pCreateInfo, settings, "const VkInstanceCreateInfo*", "pCreateInfo", 1, dump_html_VkInstanceCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkInstance>(pInstance, settings, "VkInstance*", "pInstance", 1, dump_html_VkInstance);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyInstance(ApiDumpInstance& dump_inst, VkInstance instance, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumeratePhysicalDevices(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const uint32_t>(pPhysicalDeviceCount, settings, "uint32_t*", "pPhysicalDeviceCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDevice>(pPhysicalDevices, *pPhysicalDeviceCount, settings, "VkPhysicalDevice*", "VkPhysicalDevice", "pPhysicalDevices", 1, dump_html_VkPhysicalDevice); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceFeatures(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceFeatures>(pFeatures, settings, "VkPhysicalDeviceFeatures*", "pFeatures", 1, dump_html_VkPhysicalDeviceFeatures);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_pointer<const VkFormatProperties>(pFormatProperties, settings, "VkFormatProperties*", "pFormatProperties", 1, dump_html_VkFormatProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceImageFormatProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_value<const VkImageType>(type, settings, "VkImageType", "type", 1, dump_html_VkImageType);
        dump_html_value<const VkImageTiling>(tiling, settings, "VkImageTiling", "tiling", 1, dump_html_VkImageTiling);
        dump_html_value<const VkImageUsageFlags>(usage, settings, "VkImageUsageFlags", "usage", 1, dump_html_VkImageUsageFlags);
        dump_html_value<const VkImageCreateFlags>(flags, settings, "VkImageCreateFlags", "flags", 1, dump_html_VkImageCreateFlags);
        dump_html_pointer<const VkImageFormatProperties>(pImageFormatProperties, settings, "VkImageFormatProperties*", "pImageFormatProperties", 1, dump_html_VkImageFormatProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceProperties>(pProperties, settings, "VkPhysicalDeviceProperties*", "pProperties", 1, dump_html_VkPhysicalDeviceProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceQueueFamilyProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pQueueFamilyPropertyCount, settings, "uint32_t*", "pQueueFamilyPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkQueueFamilyProperties>(pQueueFamilyProperties, *pQueueFamilyPropertyCount, settings, "VkQueueFamilyProperties*", "VkQueueFamilyProperties", "pQueueFamilyProperties", 1, dump_html_VkQueueFamilyProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceMemoryProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceMemoryProperties>(pMemoryProperties, settings, "VkPhysicalDeviceMemoryProperties*", "pMemoryProperties", 1, dump_html_VkPhysicalDeviceMemoryProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDevice(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkDeviceCreateInfo>(pCreateInfo, settings, "const VkDeviceCreateInfo*", "pCreateInfo", 1, dump_html_VkDeviceCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDevice>(pDevice, settings, "VkDevice*", "pDevice", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDevice(ApiDumpInstance& dump_inst, VkDevice device, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumerateInstanceExtensionProperties(ApiDumpInstance& dump_inst, VkResult result, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const char*>(pLayerName, settings, "const char*", "pLayerName", 1, dump_html_cstring);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkExtensionProperties>(pProperties, *pPropertyCount, settings, "VkExtensionProperties*", "VkExtensionProperties", "pProperties", 1, dump_html_VkExtensionProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumerateDeviceExtensionProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const char*>(pLayerName, settings, "const char*", "pLayerName", 1, dump_html_cstring);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkExtensionProperties>(pProperties, *pPropertyCount, settings, "VkExtensionProperties*", "VkExtensionProperties", "pProperties", 1, dump_html_VkExtensionProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumerateInstanceLayerProperties(ApiDumpInstance& dump_inst, VkResult result, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkLayerProperties>(pProperties, *pPropertyCount, settings, "VkLayerProperties*", "VkLayerProperties", "pProperties", 1, dump_html_VkLayerProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumerateDeviceLayerProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkLayerProperties>(pProperties, *pPropertyCount, settings, "VkLayerProperties*", "VkLayerProperties", "pProperties", 1, dump_html_VkLayerProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceQueue(ApiDumpInstance& dump_inst, VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queueIndex, settings, "uint32_t", "queueIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkQueue>(pQueue, settings, "VkQueue*", "pQueue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueSubmit(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const uint32_t>(submitCount, settings, "uint32_t", "submitCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSubmitInfo>(pSubmits, submitCount, settings, "const VkSubmitInfo*", "const VkSubmitInfo", "pSubmits", 1, dump_html_VkSubmitInfo); // ZRZ
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueWaitIdle(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDeviceWaitIdle(ApiDumpInstance& dump_inst, VkResult result, VkDevice device)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAllocateMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryAllocateInfo>(pAllocateInfo, settings, "const VkMemoryAllocateInfo*", "pAllocateInfo", 1, dump_html_VkMemoryAllocateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDeviceMemory>(pMemory, settings, "VkDeviceMemory*", "pMemory", 1, dump_html_VkDeviceMemory);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkFreeMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkMapMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(size, settings, "VkDeviceSize", "size", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkMemoryMapFlags>(flags, settings, "VkMemoryMapFlags", "flags", 1, dump_html_VkMemoryMapFlags);
        dump_html_pointer<const void*>(ppData, settings, "void**", "ppData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUnmapMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkFlushMappedMemoryRanges(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(memoryRangeCount, settings, "uint32_t", "memoryRangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMappedMemoryRange>(pMemoryRanges, memoryRangeCount, settings, "const VkMappedMemoryRange*", "const VkMappedMemoryRange", "pMemoryRanges", 1, dump_html_VkMappedMemoryRange); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkInvalidateMappedMemoryRanges(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(memoryRangeCount, settings, "uint32_t", "memoryRangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMappedMemoryRange>(pMemoryRanges, memoryRangeCount, settings, "const VkMappedMemoryRange*", "const VkMappedMemoryRange", "pMemoryRanges", 1, dump_html_VkMappedMemoryRange); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceMemoryCommitment(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_pointer<const VkDeviceSize>(pCommittedMemoryInBytes, settings, "VkDeviceSize*", "pCommittedMemoryInBytes", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindBufferMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkDeviceSize>(memoryOffset, settings, "VkDeviceSize", "memoryOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindImageMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkDeviceSize>(memoryOffset, settings, "VkDeviceSize", "memoryOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_pointer<const VkMemoryRequirements>(pMemoryRequirements, settings, "VkMemoryRequirements*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkMemoryRequirements>(pMemoryRequirements, settings, "VkMemoryRequirements*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageSparseMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements*", "VkSparseImageMemoryRequirements", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSparseImageFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_value<const VkImageType>(type, settings, "VkImageType", "type", 1, dump_html_VkImageType);
        dump_html_value<const VkSampleCountFlagBits>(samples, settings, "VkSampleCountFlagBits", "samples", 1, dump_html_VkSampleCountFlagBits);
        dump_html_value<const VkImageUsageFlags>(usage, settings, "VkImageUsageFlags", "usage", 1, dump_html_VkImageUsageFlags);
        dump_html_value<const VkImageTiling>(tiling, settings, "VkImageTiling", "tiling", 1, dump_html_VkImageTiling);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageFormatProperties>(pProperties, *pPropertyCount, settings, "VkSparseImageFormatProperties*", "VkSparseImageFormatProperties", "pProperties", 1, dump_html_VkSparseImageFormatProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueBindSparse(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindSparseInfo>(pBindInfo, bindInfoCount, settings, "const VkBindSparseInfo*", "const VkBindSparseInfo", "pBindInfo", 1, dump_html_VkBindSparseInfo); // ZRZ
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateFence(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFenceCreateInfo>(pCreateInfo, settings, "const VkFenceCreateInfo*", "pCreateInfo", 1, dump_html_VkFenceCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFence>(pFence, settings, "VkFence*", "pFence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyFence(ApiDumpInstance& dump_inst, VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetFences(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t fenceCount, const VkFence* pFences)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(fenceCount, settings, "uint32_t", "fenceCount", 1, dump_html_uint32_t);
        dump_html_array<const VkFence>(pFences, fenceCount, settings, "const VkFence*", "const VkFence", "pFences", 1, dump_html_VkFence); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetFenceStatus(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkFence fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkWaitForFences(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(fenceCount, settings, "uint32_t", "fenceCount", 1, dump_html_uint32_t);
        dump_html_array<const VkFence>(pFences, fenceCount, settings, "const VkFence*", "const VkFence", "pFences", 1, dump_html_VkFence); // ZRZ
        dump_html_value<const VkBool32>(waitAll, settings, "VkBool32", "waitAll", 1, dump_html_VkBool32);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateSemaphore(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreCreateInfo>(pCreateInfo, settings, "const VkSemaphoreCreateInfo*", "pCreateInfo", 1, dump_html_VkSemaphoreCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSemaphore>(pSemaphore, settings, "VkSemaphore*", "pSemaphore", 1, dump_html_VkSemaphore);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroySemaphore(ApiDumpInstance& dump_inst, VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateEvent(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkEventCreateInfo>(pCreateInfo, settings, "const VkEventCreateInfo*", "pCreateInfo", 1, dump_html_VkEventCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkEvent>(pEvent, settings, "VkEvent*", "pEvent", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyEvent(ApiDumpInstance& dump_inst, VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetEventStatus(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkEvent event)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetEvent(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkEvent event)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetEvent(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkEvent event)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateQueryPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkQueryPoolCreateInfo>(pCreateInfo, settings, "const VkQueryPoolCreateInfo*", "pCreateInfo", 1, dump_html_VkQueryPoolCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkQueryPool>(pQueryPool, settings, "VkQueryPool*", "pQueryPool", 1, dump_html_VkQueryPool);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyQueryPool(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetQueryPoolResults(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
        dump_html_value<const VkDeviceSize>(stride, settings, "VkDeviceSize", "stride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkQueryResultFlags>(flags, settings, "VkQueryResultFlags", "flags", 1, dump_html_VkQueryResultFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateBuffer(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferCreateInfo>(pCreateInfo, settings, "const VkBufferCreateInfo*", "pCreateInfo", 1, dump_html_VkBufferCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkBuffer>(pBuffer, settings, "VkBuffer*", "pBuffer", 1, dump_html_VkBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyBuffer(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateBufferView(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferViewCreateInfo>(pCreateInfo, settings, "const VkBufferViewCreateInfo*", "pCreateInfo", 1, dump_html_VkBufferViewCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkBufferView>(pView, settings, "VkBufferView*", "pView", 1, dump_html_VkBufferView);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyBufferView(ApiDumpInstance& dump_inst, VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBufferView>(bufferView, settings, "VkBufferView", "bufferView", 1, dump_html_VkBufferView);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateImage(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageCreateInfo>(pCreateInfo, settings, "const VkImageCreateInfo*", "pCreateInfo", 1, dump_html_VkImageCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkImage>(pImage, settings, "VkImage*", "pImage", 1, dump_html_VkImage);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyImage(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageSubresourceLayout(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkImageSubresource>(pSubresource, settings, "const VkImageSubresource*", "pSubresource", 1, dump_html_VkImageSubresource);
        dump_html_pointer<const VkSubresourceLayout>(pLayout, settings, "VkSubresourceLayout*", "pLayout", 1, dump_html_VkSubresourceLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateImageView(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageViewCreateInfo>(pCreateInfo, settings, "const VkImageViewCreateInfo*", "pCreateInfo", 1, dump_html_VkImageViewCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkImageView>(pView, settings, "VkImageView*", "pView", 1, dump_html_VkImageView);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyImageView(ApiDumpInstance& dump_inst, VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImageView>(imageView, settings, "VkImageView", "imageView", 1, dump_html_VkImageView);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateShaderModule(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkShaderModuleCreateInfo>(pCreateInfo, settings, "const VkShaderModuleCreateInfo*", "pCreateInfo", 1, dump_html_VkShaderModuleCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkShaderModule>(pShaderModule, settings, "VkShaderModule*", "pShaderModule", 1, dump_html_VkShaderModule);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyShaderModule(ApiDumpInstance& dump_inst, VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkShaderModule>(shaderModule, settings, "VkShaderModule", "shaderModule", 1, dump_html_VkShaderModule);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreatePipelineCache(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineCacheCreateInfo>(pCreateInfo, settings, "const VkPipelineCacheCreateInfo*", "pCreateInfo", 1, dump_html_VkPipelineCacheCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkPipelineCache>(pPipelineCache, settings, "VkPipelineCache*", "pPipelineCache", 1, dump_html_VkPipelineCache);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyPipelineCache(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelineCacheData(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_pointer<const size_t>(pDataSize, settings, "size_t*", "pDataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkMergePipelineCaches(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(dstCache, settings, "VkPipelineCache", "dstCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(srcCacheCount, settings, "uint32_t", "srcCacheCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineCache>(pSrcCaches, srcCacheCount, settings, "const VkPipelineCache*", "const VkPipelineCache", "pSrcCaches", 1, dump_html_VkPipelineCache); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateGraphicsPipelines(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkGraphicsPipelineCreateInfo>(pCreateInfos, createInfoCount, settings, "const VkGraphicsPipelineCreateInfo*", "const VkGraphicsPipelineCreateInfo", "pCreateInfos", 1, dump_html_VkGraphicsPipelineCreateInfo); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateComputePipelines(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkComputePipelineCreateInfo>(pCreateInfos, createInfoCount, settings, "const VkComputePipelineCreateInfo*", "const VkComputePipelineCreateInfo", "pCreateInfos", 1, dump_html_VkComputePipelineCreateInfo); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyPipeline(ApiDumpInstance& dump_inst, VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreatePipelineLayout(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineLayoutCreateInfo>(pCreateInfo, settings, "const VkPipelineLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkPipelineLayoutCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkPipelineLayout>(pPipelineLayout, settings, "VkPipelineLayout*", "pPipelineLayout", 1, dump_html_VkPipelineLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyPipelineLayout(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineLayout>(pipelineLayout, settings, "VkPipelineLayout", "pipelineLayout", 1, dump_html_VkPipelineLayout);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateSampler(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerCreateInfo>(pCreateInfo, settings, "const VkSamplerCreateInfo*", "pCreateInfo", 1, dump_html_VkSamplerCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSampler>(pSampler, settings, "VkSampler*", "pSampler", 1, dump_html_VkSampler);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroySampler(ApiDumpInstance& dump_inst, VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSampler>(sampler, settings, "VkSampler", "sampler", 1, dump_html_VkSampler);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDescriptorSetLayout(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetLayoutCreateInfo>(pCreateInfo, settings, "const VkDescriptorSetLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorSetLayoutCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorSetLayout>(pSetLayout, settings, "VkDescriptorSetLayout*", "pSetLayout", 1, dump_html_VkDescriptorSetLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDescriptorSetLayout(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSetLayout>(descriptorSetLayout, settings, "VkDescriptorSetLayout", "descriptorSetLayout", 1, dump_html_VkDescriptorSetLayout);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDescriptorPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorPoolCreateInfo>(pCreateInfo, settings, "const VkDescriptorPoolCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorPoolCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorPool>(pDescriptorPool, settings, "VkDescriptorPool*", "pDescriptorPool", 1, dump_html_VkDescriptorPool);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDescriptorPool(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorPool>(descriptorPool, settings, "VkDescriptorPool", "descriptorPool", 1, dump_html_VkDescriptorPool);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetDescriptorPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorPool>(descriptorPool, settings, "VkDescriptorPool", "descriptorPool", 1, dump_html_VkDescriptorPool);
        dump_html_value<const VkDescriptorPoolResetFlags>(flags, settings, "VkDescriptorPoolResetFlags", "flags", 1, dump_html_VkDescriptorPoolResetFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAllocateDescriptorSets(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetAllocateInfo>(pAllocateInfo, settings, "const VkDescriptorSetAllocateInfo*", "pAllocateInfo", 1, dump_html_VkDescriptorSetAllocateInfo);
        dump_html_array<const VkDescriptorSet>(pDescriptorSets, pAllocateInfo->descriptorSetCount, settings, "VkDescriptorSet*", "VkDescriptorSet", "pDescriptorSets", 1, dump_html_VkDescriptorSet); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkFreeDescriptorSets(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorPool>(descriptorPool, settings, "VkDescriptorPool", "descriptorPool", 1, dump_html_VkDescriptorPool);
        dump_html_value<const uint32_t>(descriptorSetCount, settings, "uint32_t", "descriptorSetCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDescriptorSet>(pDescriptorSets, descriptorSetCount, settings, "const VkDescriptorSet*", "const VkDescriptorSet", "pDescriptorSets", 1, dump_html_VkDescriptorSet); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUpdateDescriptorSets(ApiDumpInstance& dump_inst, VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(descriptorWriteCount, settings, "uint32_t", "descriptorWriteCount", 1, dump_html_uint32_t);
        dump_html_array<const VkWriteDescriptorSet>(pDescriptorWrites, descriptorWriteCount, settings, "const VkWriteDescriptorSet*", "const VkWriteDescriptorSet", "pDescriptorWrites", 1, dump_html_VkWriteDescriptorSet); // ZRZ
        dump_html_value<const uint32_t>(descriptorCopyCount, settings, "uint32_t", "descriptorCopyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCopyDescriptorSet>(pDescriptorCopies, descriptorCopyCount, settings, "const VkCopyDescriptorSet*", "const VkCopyDescriptorSet", "pDescriptorCopies", 1, dump_html_VkCopyDescriptorSet); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateFramebuffer(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFramebufferCreateInfo>(pCreateInfo, settings, "const VkFramebufferCreateInfo*", "pCreateInfo", 1, dump_html_VkFramebufferCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFramebuffer>(pFramebuffer, settings, "VkFramebuffer*", "pFramebuffer", 1, dump_html_VkFramebuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyFramebuffer(ApiDumpInstance& dump_inst, VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFramebuffer>(framebuffer, settings, "VkFramebuffer", "framebuffer", 1, dump_html_VkFramebuffer);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateRenderPass(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderPassCreateInfo>(pCreateInfo, settings, "const VkRenderPassCreateInfo*", "pCreateInfo", 1, dump_html_VkRenderPassCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkRenderPass>(pRenderPass, settings, "VkRenderPass*", "pRenderPass", 1, dump_html_VkRenderPass);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyRenderPass(ApiDumpInstance& dump_inst, VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkRenderPass>(renderPass, settings, "VkRenderPass", "renderPass", 1, dump_html_VkRenderPass);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRenderAreaGranularity(ApiDumpInstance& dump_inst, VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkRenderPass>(renderPass, settings, "VkRenderPass", "renderPass", 1, dump_html_VkRenderPass);
        dump_html_pointer<const VkExtent2D>(pGranularity, settings, "VkExtent2D*", "pGranularity", 1, dump_html_VkExtent2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateCommandPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCommandPoolCreateInfo>(pCreateInfo, settings, "const VkCommandPoolCreateInfo*", "pCreateInfo", 1, dump_html_VkCommandPoolCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkCommandPool>(pCommandPool, settings, "VkCommandPool*", "pCommandPool", 1, dump_html_VkCommandPool);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetCommandPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const VkCommandPoolResetFlags>(flags, settings, "VkCommandPoolResetFlags", "flags", 1, dump_html_VkCommandPoolResetFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAllocateCommandBuffers(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCommandBufferAllocateInfo>(pAllocateInfo, settings, "const VkCommandBufferAllocateInfo*", "pAllocateInfo", 1, dump_html_VkCommandBufferAllocateInfo);
        dump_html_array<const VkCommandBuffer>(pCommandBuffers, pAllocateInfo->commandBufferCount, settings, "VkCommandBuffer*", "VkCommandBuffer", "pCommandBuffers", 1, dump_html_VkCommandBuffer); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkFreeCommandBuffers(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const uint32_t>(commandBufferCount, settings, "uint32_t", "commandBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCommandBuffer>(pCommandBuffers, commandBufferCount, settings, "const VkCommandBuffer*", "const VkCommandBuffer", "pCommandBuffers", 1, dump_html_VkCommandBuffer); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBeginCommandBuffer(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        ApiDumpInstance::current().setCmdBuffer(commandBuffer);
        dump_html_pointer<const VkCommandBufferBeginInfo>(pBeginInfo, settings, "const VkCommandBufferBeginInfo*", "pBeginInfo", 1, dump_html_VkCommandBufferBeginInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEndCommandBuffer(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetCommandBuffer(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCommandBufferResetFlags>(flags, settings, "VkCommandBufferResetFlags", "flags", 1, dump_html_VkCommandBufferResetFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindPipeline(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewport(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewport>(pViewports, viewportCount, settings, "const VkViewport*", "const VkViewport", "pViewports", 1, dump_html_VkViewport); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetScissor(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstScissor, settings, "uint32_t", "firstScissor", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(scissorCount, settings, "uint32_t", "scissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pScissors, scissorCount, settings, "const VkRect2D*", "const VkRect2D", "pScissors", 1, dump_html_VkRect2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLineWidth(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float lineWidth)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(lineWidth, settings, "float", "lineWidth", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBias(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(depthBiasConstantFactor, settings, "float", "depthBiasConstantFactor", 1, dump_html_float);
        dump_html_value<const float>(depthBiasClamp, settings, "float", "depthBiasClamp", 1, dump_html_float);
        dump_html_value<const float>(depthBiasSlopeFactor, settings, "float", "depthBiasSlopeFactor", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetBlendConstants(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const float blendConstants[4])
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_array<const float>(blendConstants, 4, settings, "const float[4]", "const float", "blendConstants", 1, dump_html_float); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBounds(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(minDepthBounds, settings, "float", "minDepthBounds", 1, dump_html_float);
        dump_html_value<const float>(maxDepthBounds, settings, "float", "maxDepthBounds", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilCompareMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const uint32_t>(compareMask, settings, "uint32_t", "compareMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilWriteMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const uint32_t>(writeMask, settings, "uint32_t", "writeMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilReference(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const uint32_t>(reference, settings, "uint32_t", "reference", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindDescriptorSets(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(firstSet, settings, "uint32_t", "firstSet", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(descriptorSetCount, settings, "uint32_t", "descriptorSetCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDescriptorSet>(pDescriptorSets, descriptorSetCount, settings, "const VkDescriptorSet*", "const VkDescriptorSet", "pDescriptorSets", 1, dump_html_VkDescriptorSet); // ZRZ
        dump_html_value<const uint32_t>(dynamicOffsetCount, settings, "uint32_t", "dynamicOffsetCount", 1, dump_html_uint32_t);
        dump_html_array<const uint32_t>(pDynamicOffsets, dynamicOffsetCount, settings, "const uint32_t*", "const uint32_t", "pDynamicOffsets", 1, dump_html_uint32_t); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindIndexBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkIndexType>(indexType, settings, "VkIndexType", "indexType", 1, dump_html_VkIndexType);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindVertexBuffers(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstBinding, settings, "uint32_t", "firstBinding", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(bindingCount, settings, "uint32_t", "bindingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pBuffers, bindingCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", 1, dump_html_VkBuffer); // ZRZ
        dump_html_array<const VkDeviceSize>(pOffsets, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDraw(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(vertexCount, settings, "uint32_t", "vertexCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstVertex, settings, "uint32_t", "firstVertex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndexed(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(indexCount, settings, "uint32_t", "indexCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstIndex, settings, "uint32_t", "firstIndex", 1, dump_html_uint32_t);
        dump_html_value<const int32_t>(vertexOffset, settings, "int32_t", "vertexOffset", 1, dump_html_int32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndexedIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDispatch(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDispatchIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(srcBuffer, settings, "VkBuffer", "srcBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferCopy>(pRegions, regionCount, settings, "const VkBufferCopy*", "const VkBufferCopy", "pRegions", 1, dump_html_VkBufferCopy); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageCopy>(pRegions, regionCount, settings, "const VkImageCopy*", "const VkImageCopy", "pRegions", 1, dump_html_VkImageCopy); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBlitImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageBlit>(pRegions, regionCount, settings, "const VkImageBlit*", "const VkImageBlit", "pRegions", 1, dump_html_VkImageBlit); // ZRZ
        dump_html_value<const VkFilter>(filter, settings, "VkFilter", "filter", 1, dump_html_VkFilter);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyBufferToImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(srcBuffer, settings, "VkBuffer", "srcBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferImageCopy>(pRegions, regionCount, settings, "const VkBufferImageCopy*", "const VkBufferImageCopy", "pRegions", 1, dump_html_VkBufferImageCopy); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyImageToBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferImageCopy>(pRegions, regionCount, settings, "const VkBufferImageCopy*", "const VkBufferImageCopy", "pRegions", 1, dump_html_VkBufferImageCopy); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdUpdateBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(dataSize, settings, "VkDeviceSize", "dataSize", 1, dump_html_VkDeviceSize);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdFillBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(size, settings, "VkDeviceSize", "size", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(data, settings, "uint32_t", "data", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdClearColorImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
        dump_html_pointer<const VkClearColorValue>(pColor, settings, "const VkClearColorValue*", "pColor", 1, dump_html_VkClearColorValue);
        dump_html_value<const uint32_t>(rangeCount, settings, "uint32_t", "rangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageSubresourceRange>(pRanges, rangeCount, settings, "const VkImageSubresourceRange*", "const VkImageSubresourceRange", "pRanges", 1, dump_html_VkImageSubresourceRange); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdClearDepthStencilImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
        dump_html_pointer<const VkClearDepthStencilValue>(pDepthStencil, settings, "const VkClearDepthStencilValue*", "pDepthStencil", 1, dump_html_VkClearDepthStencilValue);
        dump_html_value<const uint32_t>(rangeCount, settings, "uint32_t", "rangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageSubresourceRange>(pRanges, rangeCount, settings, "const VkImageSubresourceRange*", "const VkImageSubresourceRange", "pRanges", 1, dump_html_VkImageSubresourceRange); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdClearAttachments(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkClearAttachment>(pAttachments, attachmentCount, settings, "const VkClearAttachment*", "const VkClearAttachment", "pAttachments", 1, dump_html_VkClearAttachment); // ZRZ
        dump_html_value<const uint32_t>(rectCount, settings, "uint32_t", "rectCount", 1, dump_html_uint32_t);
        dump_html_array<const VkClearRect>(pRects, rectCount, settings, "const VkClearRect*", "const VkClearRect", "pRects", 1, dump_html_VkClearRect); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResolveImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageResolve>(pRegions, regionCount, settings, "const VkImageResolve*", "const VkImageResolve", "pRegions", 1, dump_html_VkImageResolve); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetEvent(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags>(stageMask, settings, "VkPipelineStageFlags", "stageMask", 1, dump_html_VkPipelineStageFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResetEvent(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags>(stageMask, settings, "VkPipelineStageFlags", "stageMask", 1, dump_html_VkPipelineStageFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWaitEvents(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(eventCount, settings, "uint32_t", "eventCount", 1, dump_html_uint32_t);
        dump_html_array<const VkEvent>(pEvents, eventCount, settings, "const VkEvent*", "const VkEvent", "pEvents", 1, dump_html_VkEvent); // ZRZ
        dump_html_value<const VkPipelineStageFlags>(srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const VkPipelineStageFlags>(dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const uint32_t>(memoryBarrierCount, settings, "uint32_t", "memoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMemoryBarrier>(pMemoryBarriers, memoryBarrierCount, settings, "const VkMemoryBarrier*", "const VkMemoryBarrier", "pMemoryBarriers", 1, dump_html_VkMemoryBarrier); // ZRZ
        dump_html_value<const uint32_t>(bufferMemoryBarrierCount, settings, "uint32_t", "bufferMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferMemoryBarrier>(pBufferMemoryBarriers, bufferMemoryBarrierCount, settings, "const VkBufferMemoryBarrier*", "const VkBufferMemoryBarrier", "pBufferMemoryBarriers", 1, dump_html_VkBufferMemoryBarrier); // ZRZ
        dump_html_value<const uint32_t>(imageMemoryBarrierCount, settings, "uint32_t", "imageMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageMemoryBarrier>(pImageMemoryBarriers, imageMemoryBarrierCount, settings, "const VkImageMemoryBarrier*", "const VkImageMemoryBarrier", "pImageMemoryBarriers", 1, dump_html_VkImageMemoryBarrier); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPipelineBarrier(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlags>(srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const VkPipelineStageFlags>(dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const VkDependencyFlags>(dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", 1, dump_html_VkDependencyFlags);
        dump_html_value<const uint32_t>(memoryBarrierCount, settings, "uint32_t", "memoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMemoryBarrier>(pMemoryBarriers, memoryBarrierCount, settings, "const VkMemoryBarrier*", "const VkMemoryBarrier", "pMemoryBarriers", 1, dump_html_VkMemoryBarrier); // ZRZ
        dump_html_value<const uint32_t>(bufferMemoryBarrierCount, settings, "uint32_t", "bufferMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferMemoryBarrier>(pBufferMemoryBarriers, bufferMemoryBarrierCount, settings, "const VkBufferMemoryBarrier*", "const VkBufferMemoryBarrier", "pBufferMemoryBarriers", 1, dump_html_VkBufferMemoryBarrier); // ZRZ
        dump_html_value<const uint32_t>(imageMemoryBarrierCount, settings, "uint32_t", "imageMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageMemoryBarrier>(pImageMemoryBarriers, imageMemoryBarrierCount, settings, "const VkImageMemoryBarrier*", "const VkImageMemoryBarrier", "pImageMemoryBarriers", 1, dump_html_VkImageMemoryBarrier); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginQuery(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
        dump_html_value<const VkQueryControlFlags>(flags, settings, "VkQueryControlFlags", "flags", 1, dump_html_VkQueryControlFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndQuery(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResetQueryPool(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteTimestamp(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlagBits>(pipelineStage, settings, "VkPipelineStageFlagBits", "pipelineStage", 1, dump_html_VkPipelineStageFlagBits);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyQueryPoolResults(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(stride, settings, "VkDeviceSize", "stride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkQueryResultFlags>(flags, settings, "VkQueryResultFlags", "flags", 1, dump_html_VkQueryResultFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPushConstants(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const VkShaderStageFlags>(stageFlags, settings, "VkShaderStageFlags", "stageFlags", 1, dump_html_VkShaderStageFlags);
        dump_html_value<const uint32_t>(offset, settings, "uint32_t", "offset", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(size, settings, "uint32_t", "size", 1, dump_html_uint32_t);
        dump_html_value<const void*>(pValues, settings, "const void*", "pValues", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginRenderPass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderPassBeginInfo>(pRenderPassBegin, settings, "const VkRenderPassBeginInfo*", "pRenderPassBegin", 1, dump_html_VkRenderPassBeginInfo);
        dump_html_value<const VkSubpassContents>(contents, settings, "VkSubpassContents", "contents", 1, dump_html_VkSubpassContents);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdNextSubpass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkSubpassContents contents)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkSubpassContents>(contents, settings, "VkSubpassContents", "contents", 1, dump_html_VkSubpassContents);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndRenderPass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdExecuteCommands(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(commandBufferCount, settings, "uint32_t", "commandBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCommandBuffer>(pCommandBuffers, commandBufferCount, settings, "const VkCommandBuffer*", "const VkCommandBuffer", "pCommandBuffers", 1, dump_html_VkCommandBuffer); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindBufferMemory2(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindBufferMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindBufferMemoryInfo*", "const VkBindBufferMemoryInfo", "pBindInfos", 1, dump_html_VkBindBufferMemoryInfo); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindImageMemory2(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindImageMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindImageMemoryInfo*", "const VkBindImageMemoryInfo", "pBindInfos", 1, dump_html_VkBindImageMemoryInfo); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceGroupPeerMemoryFeatures(ApiDumpInstance& dump_inst, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(heapIndex, settings, "uint32_t", "heapIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(localDeviceIndex, settings, "uint32_t", "localDeviceIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(remoteDeviceIndex, settings, "uint32_t", "remoteDeviceIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkPeerMemoryFeatureFlags>(pPeerMemoryFeatures, settings, "VkPeerMemoryFeatureFlags*", "pPeerMemoryFeatures", 1, dump_html_VkPeerMemoryFeatureFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDeviceMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(deviceMask, settings, "uint32_t", "deviceMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDispatchBase(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(baseGroupX, settings, "uint32_t", "baseGroupX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupY, settings, "uint32_t", "baseGroupY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupZ, settings, "uint32_t", "baseGroupZ", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumeratePhysicalDeviceGroups(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const uint32_t>(pPhysicalDeviceGroupCount, settings, "uint32_t*", "pPhysicalDeviceGroupCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceGroupProperties>(pPhysicalDeviceGroupProperties, *pPhysicalDeviceGroupCount, settings, "VkPhysicalDeviceGroupProperties*", "VkPhysicalDeviceGroupProperties", "pPhysicalDeviceGroupProperties", 1, dump_html_VkPhysicalDeviceGroupProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageMemoryRequirementsInfo2>(pInfo, settings, "const VkImageMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferMemoryRequirementsInfo2>(pInfo, settings, "const VkBufferMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkBufferMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageSparseMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageSparseMemoryRequirementsInfo2>(pInfo, settings, "const VkImageSparseMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageSparseMemoryRequirementsInfo2);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements2>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements2*", "VkSparseImageMemoryRequirements2", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceFeatures2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceFeatures2>(pFeatures, settings, "VkPhysicalDeviceFeatures2*", "pFeatures", 1, dump_html_VkPhysicalDeviceFeatures2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceProperties2>(pProperties, settings, "VkPhysicalDeviceProperties2*", "pProperties", 1, dump_html_VkPhysicalDeviceProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_pointer<const VkFormatProperties2>(pFormatProperties, settings, "VkFormatProperties2*", "pFormatProperties", 1, dump_html_VkFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceImageFormatProperties2(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceImageFormatInfo2>(pImageFormatInfo, settings, "const VkPhysicalDeviceImageFormatInfo2*", "pImageFormatInfo", 1, dump_html_VkPhysicalDeviceImageFormatInfo2);
        dump_html_pointer<const VkImageFormatProperties2>(pImageFormatProperties, settings, "VkImageFormatProperties2*", "pImageFormatProperties", 1, dump_html_VkImageFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceQueueFamilyProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pQueueFamilyPropertyCount, settings, "uint32_t*", "pQueueFamilyPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkQueueFamilyProperties2>(pQueueFamilyProperties, *pQueueFamilyPropertyCount, settings, "VkQueueFamilyProperties2*", "VkQueueFamilyProperties2", "pQueueFamilyProperties", 1, dump_html_VkQueueFamilyProperties2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceMemoryProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceMemoryProperties2>(pMemoryProperties, settings, "VkPhysicalDeviceMemoryProperties2*", "pMemoryProperties", 1, dump_html_VkPhysicalDeviceMemoryProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSparseImageFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSparseImageFormatInfo2>(pFormatInfo, settings, "const VkPhysicalDeviceSparseImageFormatInfo2*", "pFormatInfo", 1, dump_html_VkPhysicalDeviceSparseImageFormatInfo2);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageFormatProperties2>(pProperties, *pPropertyCount, settings, "VkSparseImageFormatProperties2*", "VkSparseImageFormatProperties2", "pProperties", 1, dump_html_VkSparseImageFormatProperties2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkTrimCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const VkCommandPoolTrimFlags>(flags, settings, "VkCommandPoolTrimFlags", "flags", 1, dump_html_VkCommandPoolTrimFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceQueue2(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceQueueInfo2>(pQueueInfo, settings, "const VkDeviceQueueInfo2*", "pQueueInfo", 1, dump_html_VkDeviceQueueInfo2);
        dump_html_pointer<const VkQueue>(pQueue, settings, "VkQueue*", "pQueue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateSamplerYcbcrConversion(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerYcbcrConversionCreateInfo>(pCreateInfo, settings, "const VkSamplerYcbcrConversionCreateInfo*", "pCreateInfo", 1, dump_html_VkSamplerYcbcrConversionCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSamplerYcbcrConversion>(pYcbcrConversion, settings, "VkSamplerYcbcrConversion*", "pYcbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroySamplerYcbcrConversion(ApiDumpInstance& dump_inst, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSamplerYcbcrConversion>(ycbcrConversion, settings, "VkSamplerYcbcrConversion", "ycbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDescriptorUpdateTemplate(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorUpdateTemplateCreateInfo>(pCreateInfo, settings, "const VkDescriptorUpdateTemplateCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorUpdateTemplateCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorUpdateTemplate>(pDescriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate*", "pDescriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDescriptorUpdateTemplate(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUpdateDescriptorSetWithTemplate(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSet>(descriptorSet, settings, "VkDescriptorSet", "descriptorSet", 1, dump_html_VkDescriptorSet);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceExternalBufferProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalBufferInfo>(pExternalBufferInfo, settings, "const VkPhysicalDeviceExternalBufferInfo*", "pExternalBufferInfo", 1, dump_html_VkPhysicalDeviceExternalBufferInfo);
        dump_html_pointer<const VkExternalBufferProperties>(pExternalBufferProperties, settings, "VkExternalBufferProperties*", "pExternalBufferProperties", 1, dump_html_VkExternalBufferProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceExternalFenceProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalFenceInfo>(pExternalFenceInfo, settings, "const VkPhysicalDeviceExternalFenceInfo*", "pExternalFenceInfo", 1, dump_html_VkPhysicalDeviceExternalFenceInfo);
        dump_html_pointer<const VkExternalFenceProperties>(pExternalFenceProperties, settings, "VkExternalFenceProperties*", "pExternalFenceProperties", 1, dump_html_VkExternalFenceProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceExternalSemaphoreProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalSemaphoreInfo>(pExternalSemaphoreInfo, settings, "const VkPhysicalDeviceExternalSemaphoreInfo*", "pExternalSemaphoreInfo", 1, dump_html_VkPhysicalDeviceExternalSemaphoreInfo);
        dump_html_pointer<const VkExternalSemaphoreProperties>(pExternalSemaphoreProperties, settings, "VkExternalSemaphoreProperties*", "pExternalSemaphoreProperties", 1, dump_html_VkExternalSemaphoreProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorSetLayoutSupport(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetLayoutCreateInfo>(pCreateInfo, settings, "const VkDescriptorSetLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorSetLayoutCreateInfo);
        dump_html_pointer<const VkDescriptorSetLayoutSupport>(pSupport, settings, "VkDescriptorSetLayoutSupport*", "pSupport", 1, dump_html_VkDescriptorSetLayoutSupport);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndirectCount(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndexedIndirectCount(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateRenderPass2(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderPassCreateInfo2>(pCreateInfo, settings, "const VkRenderPassCreateInfo2*", "pCreateInfo", 1, dump_html_VkRenderPassCreateInfo2);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkRenderPass>(pRenderPass, settings, "VkRenderPass*", "pRenderPass", 1, dump_html_VkRenderPass);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginRenderPass2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo*      pRenderPassBegin, const VkSubpassBeginInfo*      pSubpassBeginInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderPassBeginInfo>(pRenderPassBegin, settings, "const VkRenderPassBeginInfo*", "pRenderPassBegin", 1, dump_html_VkRenderPassBeginInfo);
        dump_html_pointer<const VkSubpassBeginInfo>(pSubpassBeginInfo, settings, "const VkSubpassBeginInfo*", "pSubpassBeginInfo", 1, dump_html_VkSubpassBeginInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdNextSubpass2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassBeginInfo*      pSubpassBeginInfo, const VkSubpassEndInfo*        pSubpassEndInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSubpassBeginInfo>(pSubpassBeginInfo, settings, "const VkSubpassBeginInfo*", "pSubpassBeginInfo", 1, dump_html_VkSubpassBeginInfo);
        dump_html_pointer<const VkSubpassEndInfo>(pSubpassEndInfo, settings, "const VkSubpassEndInfo*", "pSubpassEndInfo", 1, dump_html_VkSubpassEndInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndRenderPass2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassEndInfo*        pSubpassEndInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSubpassEndInfo>(pSubpassEndInfo, settings, "const VkSubpassEndInfo*", "pSubpassEndInfo", 1, dump_html_VkSubpassEndInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetQueryPool(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSemaphoreCounterValue(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSemaphore semaphore, uint64_t* pValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_pointer<const uint64_t>(pValue, settings, "uint64_t*", "pValue", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkWaitSemaphores(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreWaitInfo>(pWaitInfo, settings, "const VkSemaphoreWaitInfo*", "pWaitInfo", 1, dump_html_VkSemaphoreWaitInfo);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSignalSemaphore(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreSignalInfo>(pSignalInfo, settings, "const VkSemaphoreSignalInfo*", "pSignalInfo", 1, dump_html_VkSemaphoreSignalInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferDeviceAddress(ApiDumpInstance& dump_inst, VkDeviceAddress result, VkDevice device, const VkBufferDeviceAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceAddress(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferDeviceAddressInfo>(pInfo, settings, "const VkBufferDeviceAddressInfo*", "pInfo", 1, dump_html_VkBufferDeviceAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferOpaqueCaptureAddress(ApiDumpInstance& dump_inst, uint64_t result, VkDevice device, const VkBufferDeviceAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint64_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferDeviceAddressInfo>(pInfo, settings, "const VkBufferDeviceAddressInfo*", "pInfo", 1, dump_html_VkBufferDeviceAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceMemoryOpaqueCaptureAddress(ApiDumpInstance& dump_inst, uint64_t result, VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint64_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceMemoryOpaqueCaptureAddressInfo>(pInfo, settings, "const VkDeviceMemoryOpaqueCaptureAddressInfo*", "pInfo", 1, dump_html_VkDeviceMemoryOpaqueCaptureAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceToolProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pToolCount, settings, "uint32_t*", "pToolCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceToolProperties>(pToolProperties, *pToolCount, settings, "VkPhysicalDeviceToolProperties*", "VkPhysicalDeviceToolProperties", "pToolProperties", 1, dump_html_VkPhysicalDeviceToolProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreatePrivateDataSlot(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPrivateDataSlotCreateInfo>(pCreateInfo, settings, "const VkPrivateDataSlotCreateInfo*", "pCreateInfo", 1, dump_html_VkPrivateDataSlotCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkPrivateDataSlot>(pPrivateDataSlot, settings, "VkPrivateDataSlot*", "pPrivateDataSlot", 1, dump_html_VkPrivateDataSlot);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyPrivateDataSlot(ApiDumpInstance& dump_inst, VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPrivateDataSlot>(privateDataSlot, settings, "VkPrivateDataSlot", "privateDataSlot", 1, dump_html_VkPrivateDataSlot);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetPrivateData(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectType>(objectType, settings, "VkObjectType", "objectType", 1, dump_html_VkObjectType);
        dump_html_value<const uint64_t>(objectHandle, settings, "uint64_t", "objectHandle", 1, dump_html_uint64_t);
        dump_html_value<const VkPrivateDataSlot>(privateDataSlot, settings, "VkPrivateDataSlot", "privateDataSlot", 1, dump_html_VkPrivateDataSlot);
        dump_html_value<const uint64_t>(data, settings, "uint64_t", "data", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPrivateData(ApiDumpInstance& dump_inst, VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectType>(objectType, settings, "VkObjectType", "objectType", 1, dump_html_VkObjectType);
        dump_html_value<const uint64_t>(objectHandle, settings, "uint64_t", "objectHandle", 1, dump_html_uint64_t);
        dump_html_value<const VkPrivateDataSlot>(privateDataSlot, settings, "VkPrivateDataSlot", "privateDataSlot", 1, dump_html_VkPrivateDataSlot);
        dump_html_pointer<const uint64_t>(pData, settings, "uint64_t*", "pData", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetEvent2(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkEvent                                             event, const VkDependencyInfo*                             pDependencyInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_pointer<const VkDependencyInfo>(pDependencyInfo, settings, "const VkDependencyInfo*", "pDependencyInfo", 1, dump_html_VkDependencyInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResetEvent2(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkEvent                                             event, VkPipelineStageFlags2               stageMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags2>(stageMask, settings, "VkPipelineStageFlags2", "stageMask", 1, dump_html_VkPipelineStageFlags2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWaitEvents2(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, uint32_t                                            eventCount, const VkEvent*                     pEvents, const VkDependencyInfo*            pDependencyInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(eventCount, settings, "uint32_t", "eventCount", 1, dump_html_uint32_t);
        dump_html_array<const VkEvent>(pEvents, eventCount, settings, "const VkEvent*", "const VkEvent", "pEvents", 1, dump_html_VkEvent); // ZRZ
        dump_html_array<const VkDependencyInfo>(pDependencyInfos, eventCount, settings, "const VkDependencyInfo*", "const VkDependencyInfo", "pDependencyInfos", 1, dump_html_VkDependencyInfo); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPipelineBarrier2(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, const VkDependencyInfo*                             pDependencyInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDependencyInfo>(pDependencyInfo, settings, "const VkDependencyInfo*", "pDependencyInfo", 1, dump_html_VkDependencyInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteTimestamp2(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkQueryPool                                         queryPool, uint32_t                                            query)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlags2>(stage, settings, "VkPipelineStageFlags2", "stage", 1, dump_html_VkPipelineStageFlags2);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueSubmit2(ApiDumpInstance& dump_inst, VkResult result, VkQueue                           queue, uint32_t                            submitCount, const VkSubmitInfo2*              pSubmits, VkFence           fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const uint32_t>(submitCount, settings, "uint32_t", "submitCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSubmitInfo2>(pSubmits, submitCount, settings, "const VkSubmitInfo2*", "const VkSubmitInfo2", "pSubmits", 1, dump_html_VkSubmitInfo2); // ZRZ
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyBuffer2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyBufferInfo2>(pCopyBufferInfo, settings, "const VkCopyBufferInfo2*", "pCopyBufferInfo", 1, dump_html_VkCopyBufferInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyImage2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyImageInfo2>(pCopyImageInfo, settings, "const VkCopyImageInfo2*", "pCopyImageInfo", 1, dump_html_VkCopyImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyBufferToImage2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyBufferToImageInfo2>(pCopyBufferToImageInfo, settings, "const VkCopyBufferToImageInfo2*", "pCopyBufferToImageInfo", 1, dump_html_VkCopyBufferToImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyImageToBuffer2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyImageToBufferInfo2>(pCopyImageToBufferInfo, settings, "const VkCopyImageToBufferInfo2*", "pCopyImageToBufferInfo", 1, dump_html_VkCopyImageToBufferInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBlitImage2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkBlitImageInfo2>(pBlitImageInfo, settings, "const VkBlitImageInfo2*", "pBlitImageInfo", 1, dump_html_VkBlitImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResolveImage2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkResolveImageInfo2>(pResolveImageInfo, settings, "const VkResolveImageInfo2*", "pResolveImageInfo", 1, dump_html_VkResolveImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginRendering(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, const VkRenderingInfo*                              pRenderingInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderingInfo>(pRenderingInfo, settings, "const VkRenderingInfo*", "pRenderingInfo", 1, dump_html_VkRenderingInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndRendering(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCullMode(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCullModeFlags cullMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCullModeFlags>(cullMode, settings, "VkCullModeFlags", "cullMode", 1, dump_html_VkCullModeFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetFrontFace(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkFrontFace frontFace)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkFrontFace>(frontFace, settings, "VkFrontFace", "frontFace", 1, dump_html_VkFrontFace);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPrimitiveTopology(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPrimitiveTopology>(primitiveTopology, settings, "VkPrimitiveTopology", "primitiveTopology", 1, dump_html_VkPrimitiveTopology);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewportWithCount(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewport>(pViewports, viewportCount, settings, "const VkViewport*", "const VkViewport", "pViewports", 1, dump_html_VkViewport); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetScissorWithCount(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(scissorCount, settings, "uint32_t", "scissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pScissors, scissorCount, settings, "const VkRect2D*", "const VkRect2D", "pScissors", 1, dump_html_VkRect2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindVertexBuffers2(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstBinding, settings, "uint32_t", "firstBinding", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(bindingCount, settings, "uint32_t", "bindingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pBuffers, bindingCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", 1, dump_html_VkBuffer); // ZRZ
        dump_html_array<const VkDeviceSize>(pOffsets, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize); // ZRZ
        dump_html_array<const VkDeviceSize>(pSizes, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pSizes", 1, dump_html_VkDeviceSize); // ZRZ
        dump_html_array<const VkDeviceSize>(pStrides, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pStrides", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthTestEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthTestEnable, settings, "VkBool32", "depthTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthWriteEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthWriteEnable, settings, "VkBool32", "depthWriteEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthCompareOp(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCompareOp>(depthCompareOp, settings, "VkCompareOp", "depthCompareOp", 1, dump_html_VkCompareOp);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBoundsTestEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthBoundsTestEnable, settings, "VkBool32", "depthBoundsTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilTestEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(stencilTestEnable, settings, "VkBool32", "stencilTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilOp(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const VkStencilOp>(failOp, settings, "VkStencilOp", "failOp", 1, dump_html_VkStencilOp);
        dump_html_value<const VkStencilOp>(passOp, settings, "VkStencilOp", "passOp", 1, dump_html_VkStencilOp);
        dump_html_value<const VkStencilOp>(depthFailOp, settings, "VkStencilOp", "depthFailOp", 1, dump_html_VkStencilOp);
        dump_html_value<const VkCompareOp>(compareOp, settings, "VkCompareOp", "compareOp", 1, dump_html_VkCompareOp);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRasterizerDiscardEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(rasterizerDiscardEnable, settings, "VkBool32", "rasterizerDiscardEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBiasEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthBiasEnable, settings, "VkBool32", "depthBiasEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPrimitiveRestartEnable(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(primitiveRestartEnable, settings, "VkBool32", "primitiveRestartEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceBufferMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceBufferMemoryRequirements>(pInfo, settings, "const VkDeviceBufferMemoryRequirements*", "pInfo", 1, dump_html_VkDeviceBufferMemoryRequirements);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceImageMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceImageMemoryRequirements>(pInfo, settings, "const VkDeviceImageMemoryRequirements*", "pInfo", 1, dump_html_VkDeviceImageMemoryRequirements);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceImageSparseMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceImageMemoryRequirements>(pInfo, settings, "const VkDeviceImageMemoryRequirements*", "pInfo", 1, dump_html_VkDeviceImageMemoryRequirements);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements2>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements2*", "VkSparseImageMemoryRequirements2", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroySurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSurfaceSupportKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkBool32>(pSupported, settings, "VkBool32*", "pSupported", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkSurfaceCapabilitiesKHR>(pSurfaceCapabilities, settings, "VkSurfaceCapabilitiesKHR*", "pSurfaceCapabilities", 1, dump_html_VkSurfaceCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSurfaceFormatsKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const uint32_t>(pSurfaceFormatCount, settings, "uint32_t*", "pSurfaceFormatCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSurfaceFormatKHR>(pSurfaceFormats, *pSurfaceFormatCount, settings, "VkSurfaceFormatKHR*", "VkSurfaceFormatKHR", "pSurfaceFormats", 1, dump_html_VkSurfaceFormatKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSurfacePresentModesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const uint32_t>(pPresentModeCount, settings, "uint32_t*", "pPresentModeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPresentModeKHR>(pPresentModes, *pPresentModeCount, settings, "VkPresentModeKHR*", "VkPresentModeKHR", "pPresentModes", 1, dump_html_VkPresentModeKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateSwapchainKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSwapchainCreateInfoKHR>(pCreateInfo, settings, "const VkSwapchainCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkSwapchainCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSwapchainKHR>(pSwapchain, settings, "VkSwapchainKHR*", "pSwapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroySwapchainKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSwapchainImagesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const uint32_t>(pSwapchainImageCount, settings, "uint32_t*", "pSwapchainImageCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImage>(pSwapchainImages, *pSwapchainImageCount, settings, "VkImage*", "VkImage", "pSwapchainImages", 1, dump_html_VkImage); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAcquireNextImageKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
        dump_html_pointer<const uint32_t>(pImageIndex, settings, "uint32_t*", "pImageIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueuePresentKHR(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, const VkPresentInfoKHR* pPresentInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkPresentInfoKHR>(pPresentInfo, settings, "const VkPresentInfoKHR*", "pPresentInfo", 1, dump_html_VkPresentInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceGroupPresentCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceGroupPresentCapabilitiesKHR>(pDeviceGroupPresentCapabilities, settings, "VkDeviceGroupPresentCapabilitiesKHR*", "pDeviceGroupPresentCapabilities", 1, dump_html_VkDeviceGroupPresentCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceGroupSurfacePresentModesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkDeviceGroupPresentModeFlagsKHR>(pModes, settings, "VkDeviceGroupPresentModeFlagsKHR*", "pModes", 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDevicePresentRectanglesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const uint32_t>(pRectCount, settings, "uint32_t*", "pRectCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pRects, *pRectCount, settings, "VkRect2D*", "VkRect2D", "pRects", 1, dump_html_VkRect2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAcquireNextImage2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAcquireNextImageInfoKHR>(pAcquireInfo, settings, "const VkAcquireNextImageInfoKHR*", "pAcquireInfo", 1, dump_html_VkAcquireNextImageInfoKHR);
        dump_html_pointer<const uint32_t>(pImageIndex, settings, "uint32_t*", "pImageIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceDisplayPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayPropertiesKHR>(pProperties, *pPropertyCount, settings, "VkDisplayPropertiesKHR*", "VkDisplayPropertiesKHR", "pProperties", 1, dump_html_VkDisplayPropertiesKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayPlanePropertiesKHR>(pProperties, *pPropertyCount, settings, "VkDisplayPlanePropertiesKHR*", "VkDisplayPlanePropertiesKHR", "pProperties", 1, dump_html_VkDisplayPlanePropertiesKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDisplayPlaneSupportedDisplaysKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(planeIndex, settings, "uint32_t", "planeIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const uint32_t>(pDisplayCount, settings, "uint32_t*", "pDisplayCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayKHR>(pDisplays, *pDisplayCount, settings, "VkDisplayKHR*", "VkDisplayKHR", "pDisplays", 1, dump_html_VkDisplayKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDisplayModePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayModePropertiesKHR>(pProperties, *pPropertyCount, settings, "VkDisplayModePropertiesKHR*", "VkDisplayModePropertiesKHR", "pProperties", 1, dump_html_VkDisplayModePropertiesKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDisplayModeKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const VkDisplayModeCreateInfoKHR>(pCreateInfo, settings, "const VkDisplayModeCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkDisplayModeCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDisplayModeKHR>(pMode, settings, "VkDisplayModeKHR*", "pMode", 1, dump_html_VkDisplayModeKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDisplayPlaneCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayModeKHR>(mode, settings, "VkDisplayModeKHR", "mode", 1, dump_html_VkDisplayModeKHR);
        dump_html_value<const uint32_t>(planeIndex, settings, "uint32_t", "planeIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkDisplayPlaneCapabilitiesKHR>(pCapabilities, settings, "VkDisplayPlaneCapabilitiesKHR*", "pCapabilities", 1, dump_html_VkDisplayPlaneCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDisplayPlaneSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDisplaySurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkDisplaySurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkDisplaySurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateSharedSwapchainsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(swapchainCount, settings, "uint32_t", "swapchainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSwapchainCreateInfoKHR>(pCreateInfos, swapchainCount, settings, "const VkSwapchainCreateInfoKHR*", "const VkSwapchainCreateInfoKHR", "pCreateInfos", 1, dump_html_VkSwapchainCreateInfoKHR); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkSwapchainKHR>(pSwapchains, swapchainCount, settings, "VkSwapchainKHR*", "VkSwapchainKHR", "pSwapchains", 1, dump_html_VkSwapchainKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_vkCreateXlibSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkXlibSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkXlibSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkXlibSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
void dump_html_vkGetPhysicalDeviceXlibPresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const Display*>(dpy, settings, "Display*", "dpy", 1, dump_html_Display);
        dump_html_value<const VisualID>(visualID, settings, "VisualID", "visualID", 1, dump_html_VisualID);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_vkCreateXcbSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkXcbSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkXcbSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkXcbSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
void dump_html_vkGetPhysicalDeviceXcbPresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const xcb_connection_t*>(connection, settings, "xcb_connection_t*", "connection", 1, dump_html_xcb_connection_t);
        dump_html_value<const xcb_visualid_t>(visual_id, settings, "xcb_visualid_t", "visual_id", 1, dump_html_xcb_visualid_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
void dump_html_vkCreateWaylandSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkWaylandSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkWaylandSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkWaylandSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
void dump_html_vkGetPhysicalDeviceWaylandPresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const wl_display*>(display, settings, "struct wl_display*", "display", 1, dump_html_wl_display);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_vkCreateAndroidSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkAndroidSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkAndroidSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkAndroidSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkCreateWin32SurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkWin32SurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkWin32SurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkWin32SurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetPhysicalDeviceWin32PresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_vkCreateDebugReportCallbackEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDebugReportCallbackCreateInfoEXT>(pCreateInfo, settings, "const VkDebugReportCallbackCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkDebugReportCallbackCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDebugReportCallbackEXT>(pCallback, settings, "VkDebugReportCallbackEXT*", "pCallback", 1, dump_html_VkDebugReportCallbackEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDebugReportCallbackEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugReportCallbackEXT>(callback, settings, "VkDebugReportCallbackEXT", "callback", 1, dump_html_VkDebugReportCallbackEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDebugReportMessageEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugReportFlagsEXT>(flags, settings, "VkDebugReportFlagsEXT", "flags", 1, dump_html_VkDebugReportFlagsEXT);
        dump_html_value<const VkDebugReportObjectTypeEXT>(objectType, settings, "VkDebugReportObjectTypeEXT", "objectType", 1, dump_html_VkDebugReportObjectTypeEXT);
        dump_html_value<const uint64_t>(object, settings, "uint64_t", "object", 1, dump_html_uint64_t);
        dump_html_value<const size_t>(location, settings, "size_t", "location", 1, dump_html_size_t);
        dump_html_value<const int32_t>(messageCode, settings, "int32_t", "messageCode", 1, dump_html_int32_t);
        dump_html_value<const char*>(pLayerPrefix, settings, "const char*", "pLayerPrefix", 1, dump_html_cstring);
        dump_html_value<const char*>(pMessage, settings, "const char*", "pMessage", 1, dump_html_cstring);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDebugMarkerSetObjectTagEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugMarkerObjectTagInfoEXT>(pTagInfo, settings, "const VkDebugMarkerObjectTagInfoEXT*", "pTagInfo", 1, dump_html_VkDebugMarkerObjectTagInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDebugMarkerSetObjectNameEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugMarkerObjectNameInfoEXT>(pNameInfo, settings, "const VkDebugMarkerObjectNameInfoEXT*", "pNameInfo", 1, dump_html_VkDebugMarkerObjectNameInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDebugMarkerBeginEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugMarkerMarkerInfoEXT>(pMarkerInfo, settings, "const VkDebugMarkerMarkerInfoEXT*", "pMarkerInfo", 1, dump_html_VkDebugMarkerMarkerInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDebugMarkerEndEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDebugMarkerInsertEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugMarkerMarkerInfoEXT>(pMarkerInfo, settings, "const VkDebugMarkerMarkerInfoEXT*", "pMarkerInfo", 1, dump_html_VkDebugMarkerMarkerInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceVideoCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkVideoProfileInfoKHR>(pVideoProfile, settings, "const VkVideoProfileInfoKHR*", "pVideoProfile", 1, dump_html_VkVideoProfileInfoKHR);
        dump_html_pointer<const VkVideoCapabilitiesKHR>(pCapabilities, settings, "VkVideoCapabilitiesKHR*", "pCapabilities", 1, dump_html_VkVideoCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceVideoFormatPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceVideoFormatInfoKHR>(pVideoFormatInfo, settings, "const VkPhysicalDeviceVideoFormatInfoKHR*", "pVideoFormatInfo", 1, dump_html_VkPhysicalDeviceVideoFormatInfoKHR);
        dump_html_pointer<const uint32_t>(pVideoFormatPropertyCount, settings, "uint32_t*", "pVideoFormatPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkVideoFormatPropertiesKHR>(pVideoFormatProperties, *pVideoFormatPropertyCount, settings, "VkVideoFormatPropertiesKHR*", "VkVideoFormatPropertiesKHR", "pVideoFormatProperties", 1, dump_html_VkVideoFormatPropertiesKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateVideoSessionKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkVideoSessionCreateInfoKHR>(pCreateInfo, settings, "const VkVideoSessionCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkVideoSessionCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkVideoSessionKHR>(pVideoSession, settings, "VkVideoSessionKHR*", "pVideoSession", 1, dump_html_VkVideoSessionKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyVideoSessionKHR(ApiDumpInstance& dump_inst, VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkVideoSessionKHR>(videoSession, settings, "VkVideoSessionKHR", "videoSession", 1, dump_html_VkVideoSessionKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetVideoSessionMemoryRequirementsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkVideoSessionKHR>(videoSession, settings, "VkVideoSessionKHR", "videoSession", 1, dump_html_VkVideoSessionKHR);
        dump_html_pointer<const uint32_t>(pMemoryRequirementsCount, settings, "uint32_t*", "pMemoryRequirementsCount", 1, dump_html_uint32_t);
        dump_html_array<const VkVideoSessionMemoryRequirementsKHR>(pMemoryRequirements, *pMemoryRequirementsCount, settings, "VkVideoSessionMemoryRequirementsKHR*", "VkVideoSessionMemoryRequirementsKHR", "pMemoryRequirements", 1, dump_html_VkVideoSessionMemoryRequirementsKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindVideoSessionMemoryKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkVideoSessionKHR>(videoSession, settings, "VkVideoSessionKHR", "videoSession", 1, dump_html_VkVideoSessionKHR);
        dump_html_value<const uint32_t>(bindSessionMemoryInfoCount, settings, "uint32_t", "bindSessionMemoryInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindVideoSessionMemoryInfoKHR>(pBindSessionMemoryInfos, bindSessionMemoryInfoCount, settings, "const VkBindVideoSessionMemoryInfoKHR*", "const VkBindVideoSessionMemoryInfoKHR", "pBindSessionMemoryInfos", 1, dump_html_VkBindVideoSessionMemoryInfoKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateVideoSessionParametersKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkVideoSessionParametersCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkVideoSessionParametersCreateInfoKHR>(pCreateInfo, settings, "const VkVideoSessionParametersCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkVideoSessionParametersCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkVideoSessionParametersKHR>(pVideoSessionParameters, settings, "VkVideoSessionParametersKHR*", "pVideoSessionParameters", 1, dump_html_VkVideoSessionParametersKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUpdateVideoSessionParametersKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkVideoSessionParametersKHR>(videoSessionParameters, settings, "VkVideoSessionParametersKHR", "videoSessionParameters", 1, dump_html_VkVideoSessionParametersKHR);
        dump_html_pointer<const VkVideoSessionParametersUpdateInfoKHR>(pUpdateInfo, settings, "const VkVideoSessionParametersUpdateInfoKHR*", "pUpdateInfo", 1, dump_html_VkVideoSessionParametersUpdateInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyVideoSessionParametersKHR(ApiDumpInstance& dump_inst, VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkVideoSessionParametersKHR>(videoSessionParameters, settings, "VkVideoSessionParametersKHR", "videoSessionParameters", 1, dump_html_VkVideoSessionParametersKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginVideoCodingKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkVideoBeginCodingInfoKHR>(pBeginInfo, settings, "const VkVideoBeginCodingInfoKHR*", "pBeginInfo", 1, dump_html_VkVideoBeginCodingInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndVideoCodingKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkVideoEndCodingInfoKHR>(pEndCodingInfo, settings, "const VkVideoEndCodingInfoKHR*", "pEndCodingInfo", 1, dump_html_VkVideoEndCodingInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdControlVideoCodingKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkVideoCodingControlInfoKHR>(pCodingControlInfo, settings, "const VkVideoCodingControlInfoKHR*", "pCodingControlInfo", 1, dump_html_VkVideoCodingControlInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDecodeVideoKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkVideoDecodeInfoKHR>(pDecodeInfo, settings, "const VkVideoDecodeInfoKHR*", "pDecodeInfo", 1, dump_html_VkVideoDecodeInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindTransformFeedbackBuffersEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstBinding, settings, "uint32_t", "firstBinding", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(bindingCount, settings, "uint32_t", "bindingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pBuffers, bindingCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", 1, dump_html_VkBuffer); // ZRZ
        dump_html_array<const VkDeviceSize>(pOffsets, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize); // ZRZ
        dump_html_array<const VkDeviceSize>(pSizes, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pSizes", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginTransformFeedbackEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstCounterBuffer, settings, "uint32_t", "firstCounterBuffer", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(counterBufferCount, settings, "uint32_t", "counterBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pCounterBuffers, counterBufferCount, settings, "const VkBuffer*", "const VkBuffer", "pCounterBuffers", 1, dump_html_VkBuffer); // ZRZ
        dump_html_array<const VkDeviceSize>(pCounterBufferOffsets, counterBufferCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pCounterBufferOffsets", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndTransformFeedbackEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstCounterBuffer, settings, "uint32_t", "firstCounterBuffer", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(counterBufferCount, settings, "uint32_t", "counterBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pCounterBuffers, counterBufferCount, settings, "const VkBuffer*", "const VkBuffer", "pCounterBuffers", 1, dump_html_VkBuffer); // ZRZ
        dump_html_array<const VkDeviceSize>(pCounterBufferOffsets, counterBufferCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pCounterBufferOffsets", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginQueryIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
        dump_html_value<const VkQueryControlFlags>(flags, settings, "VkQueryControlFlags", "flags", 1, dump_html_VkQueryControlFlags);
        dump_html_value<const uint32_t>(index, settings, "uint32_t", "index", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndQueryIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(index, settings, "uint32_t", "index", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndirectByteCountEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
        dump_html_value<const VkBuffer>(counterBuffer, settings, "VkBuffer", "counterBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(counterBufferOffset, settings, "VkDeviceSize", "counterBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(counterOffset, settings, "uint32_t", "counterOffset", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(vertexStride, settings, "uint32_t", "vertexStride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateCuModuleNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCuModuleCreateInfoNVX>(pCreateInfo, settings, "const VkCuModuleCreateInfoNVX*", "pCreateInfo", 1, dump_html_VkCuModuleCreateInfoNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkCuModuleNVX>(pModule, settings, "VkCuModuleNVX*", "pModule", 1, dump_html_VkCuModuleNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateCuFunctionNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCuFunctionCreateInfoNVX>(pCreateInfo, settings, "const VkCuFunctionCreateInfoNVX*", "pCreateInfo", 1, dump_html_VkCuFunctionCreateInfoNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkCuFunctionNVX>(pFunction, settings, "VkCuFunctionNVX*", "pFunction", 1, dump_html_VkCuFunctionNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyCuModuleNVX(ApiDumpInstance& dump_inst, VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCuModuleNVX>(module, settings, "VkCuModuleNVX", "module", 1, dump_html_VkCuModuleNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyCuFunctionNVX(ApiDumpInstance& dump_inst, VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCuFunctionNVX>(function, settings, "VkCuFunctionNVX", "function", 1, dump_html_VkCuFunctionNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCuLaunchKernelNVX(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCuLaunchInfoNVX>(pLaunchInfo, settings, "const VkCuLaunchInfoNVX*", "pLaunchInfo", 1, dump_html_VkCuLaunchInfoNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageViewHandleNVX(ApiDumpInstance& dump_inst, uint32_t result, VkDevice device, const VkImageViewHandleInfoNVX* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint32_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageViewHandleInfoNVX>(pInfo, settings, "const VkImageViewHandleInfoNVX*", "pInfo", 1, dump_html_VkImageViewHandleInfoNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageViewAddressNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImageView>(imageView, settings, "VkImageView", "imageView", 1, dump_html_VkImageView);
        dump_html_pointer<const VkImageViewAddressPropertiesNVX>(pProperties, settings, "VkImageViewAddressPropertiesNVX*", "pProperties", 1, dump_html_VkImageViewAddressPropertiesNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndirectCountAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndexedIndirectCountAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetShaderInfoAMD(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const VkShaderStageFlagBits>(shaderStage, settings, "VkShaderStageFlagBits", "shaderStage", 1, dump_html_VkShaderStageFlagBits);
        dump_html_value<const VkShaderInfoTypeAMD>(infoType, settings, "VkShaderInfoTypeAMD", "infoType", 1, dump_html_VkShaderInfoTypeAMD);
        dump_html_pointer<const size_t>(pInfoSize, settings, "size_t*", "pInfoSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pInfo, settings, "void*", "pInfo", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginRenderingKHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, const VkRenderingInfo*                              pRenderingInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderingInfo>(pRenderingInfo, settings, "const VkRenderingInfo*", "pRenderingInfo", 1, dump_html_VkRenderingInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndRenderingKHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_GGP)
void dump_html_vkCreateStreamDescriptorSurfaceGGP(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkStreamDescriptorSurfaceCreateInfoGGP>(pCreateInfo, settings, "const VkStreamDescriptorSurfaceCreateInfoGGP*", "pCreateInfo", 1, dump_html_VkStreamDescriptorSurfaceCreateInfoGGP);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_GGP
void dump_html_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_value<const VkImageType>(type, settings, "VkImageType", "type", 1, dump_html_VkImageType);
        dump_html_value<const VkImageTiling>(tiling, settings, "VkImageTiling", "tiling", 1, dump_html_VkImageTiling);
        dump_html_value<const VkImageUsageFlags>(usage, settings, "VkImageUsageFlags", "usage", 1, dump_html_VkImageUsageFlags);
        dump_html_value<const VkImageCreateFlags>(flags, settings, "VkImageCreateFlags", "flags", 1, dump_html_VkImageCreateFlags);
        dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(externalHandleType, settings, "VkExternalMemoryHandleTypeFlagsNV", "externalHandleType", 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
        dump_html_pointer<const VkExternalImageFormatPropertiesNV>(pExternalImageFormatProperties, settings, "VkExternalImageFormatPropertiesNV*", "pExternalImageFormatProperties", 1, dump_html_VkExternalImageFormatPropertiesNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetMemoryWin32HandleNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(handleType, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_vkGetPhysicalDeviceFeatures2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceFeatures2>(pFeatures, settings, "VkPhysicalDeviceFeatures2*", "pFeatures", 1, dump_html_VkPhysicalDeviceFeatures2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceProperties2>(pProperties, settings, "VkPhysicalDeviceProperties2*", "pProperties", 1, dump_html_VkPhysicalDeviceProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_pointer<const VkFormatProperties2>(pFormatProperties, settings, "VkFormatProperties2*", "pFormatProperties", 1, dump_html_VkFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceImageFormatProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceImageFormatInfo2>(pImageFormatInfo, settings, "const VkPhysicalDeviceImageFormatInfo2*", "pImageFormatInfo", 1, dump_html_VkPhysicalDeviceImageFormatInfo2);
        dump_html_pointer<const VkImageFormatProperties2>(pImageFormatProperties, settings, "VkImageFormatProperties2*", "pImageFormatProperties", 1, dump_html_VkImageFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceQueueFamilyProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pQueueFamilyPropertyCount, settings, "uint32_t*", "pQueueFamilyPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkQueueFamilyProperties2>(pQueueFamilyProperties, *pQueueFamilyPropertyCount, settings, "VkQueueFamilyProperties2*", "VkQueueFamilyProperties2", "pQueueFamilyProperties", 1, dump_html_VkQueueFamilyProperties2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceMemoryProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceMemoryProperties2>(pMemoryProperties, settings, "VkPhysicalDeviceMemoryProperties2*", "pMemoryProperties", 1, dump_html_VkPhysicalDeviceMemoryProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSparseImageFormatInfo2>(pFormatInfo, settings, "const VkPhysicalDeviceSparseImageFormatInfo2*", "pFormatInfo", 1, dump_html_VkPhysicalDeviceSparseImageFormatInfo2);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageFormatProperties2>(pProperties, *pPropertyCount, settings, "VkSparseImageFormatProperties2*", "VkSparseImageFormatProperties2", "pProperties", 1, dump_html_VkSparseImageFormatProperties2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceGroupPeerMemoryFeaturesKHR(ApiDumpInstance& dump_inst, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(heapIndex, settings, "uint32_t", "heapIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(localDeviceIndex, settings, "uint32_t", "localDeviceIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(remoteDeviceIndex, settings, "uint32_t", "remoteDeviceIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkPeerMemoryFeatureFlags>(pPeerMemoryFeatures, settings, "VkPeerMemoryFeatureFlags*", "pPeerMemoryFeatures", 1, dump_html_VkPeerMemoryFeatureFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDeviceMaskKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(deviceMask, settings, "uint32_t", "deviceMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDispatchBaseKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(baseGroupX, settings, "uint32_t", "baseGroupX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupY, settings, "uint32_t", "baseGroupY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupZ, settings, "uint32_t", "baseGroupZ", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_VI_NN)
void dump_html_vkCreateViSurfaceNN(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkViSurfaceCreateInfoNN>(pCreateInfo, settings, "const VkViSurfaceCreateInfoNN*", "pCreateInfo", 1, dump_html_VkViSurfaceCreateInfoNN);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_VI_NN
void dump_html_vkTrimCommandPoolKHR(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const VkCommandPoolTrimFlags>(flags, settings, "VkCommandPoolTrimFlags", "flags", 1, dump_html_VkCommandPoolTrimFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumeratePhysicalDeviceGroupsKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const uint32_t>(pPhysicalDeviceGroupCount, settings, "uint32_t*", "pPhysicalDeviceGroupCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceGroupProperties>(pPhysicalDeviceGroupProperties, *pPhysicalDeviceGroupCount, settings, "VkPhysicalDeviceGroupProperties*", "VkPhysicalDeviceGroupProperties", "pPhysicalDeviceGroupProperties", 1, dump_html_VkPhysicalDeviceGroupProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceExternalBufferPropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalBufferInfo>(pExternalBufferInfo, settings, "const VkPhysicalDeviceExternalBufferInfo*", "pExternalBufferInfo", 1, dump_html_VkPhysicalDeviceExternalBufferInfo);
        dump_html_pointer<const VkExternalBufferProperties>(pExternalBufferProperties, settings, "VkExternalBufferProperties*", "pExternalBufferProperties", 1, dump_html_VkExternalBufferProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetMemoryWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetWin32HandleInfoKHR>(pGetWin32HandleInfo, settings, "const VkMemoryGetWin32HandleInfoKHR*", "pGetWin32HandleInfo", 1, dump_html_VkMemoryGetWin32HandleInfoKHR);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetMemoryWin32HandlePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const HANDLE>(handle, settings, "HANDLE", "handle", 1, dump_html_HANDLE);
        dump_html_pointer<const VkMemoryWin32HandlePropertiesKHR>(pMemoryWin32HandleProperties, settings, "VkMemoryWin32HandlePropertiesKHR*", "pMemoryWin32HandleProperties", 1, dump_html_VkMemoryWin32HandlePropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_vkGetMemoryFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetFdInfoKHR>(pGetFdInfo, settings, "const VkMemoryGetFdInfoKHR*", "pGetFdInfo", 1, dump_html_VkMemoryGetFdInfoKHR);
        dump_html_pointer<const int>(pFd, settings, "int*", "pFd", 1, dump_html_int);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetMemoryFdPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const int>(fd, settings, "int", "fd", 1, dump_html_int);
        dump_html_pointer<const VkMemoryFdPropertiesKHR>(pMemoryFdProperties, settings, "VkMemoryFdPropertiesKHR*", "pMemoryFdProperties", 1, dump_html_VkMemoryFdPropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalSemaphoreInfo>(pExternalSemaphoreInfo, settings, "const VkPhysicalDeviceExternalSemaphoreInfo*", "pExternalSemaphoreInfo", 1, dump_html_VkPhysicalDeviceExternalSemaphoreInfo);
        dump_html_pointer<const VkExternalSemaphoreProperties>(pExternalSemaphoreProperties, settings, "VkExternalSemaphoreProperties*", "pExternalSemaphoreProperties", 1, dump_html_VkExternalSemaphoreProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkImportSemaphoreWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportSemaphoreWin32HandleInfoKHR>(pImportSemaphoreWin32HandleInfo, settings, "const VkImportSemaphoreWin32HandleInfoKHR*", "pImportSemaphoreWin32HandleInfo", 1, dump_html_VkImportSemaphoreWin32HandleInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetSemaphoreWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreGetWin32HandleInfoKHR>(pGetWin32HandleInfo, settings, "const VkSemaphoreGetWin32HandleInfoKHR*", "pGetWin32HandleInfo", 1, dump_html_VkSemaphoreGetWin32HandleInfoKHR);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_vkImportSemaphoreFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportSemaphoreFdInfoKHR>(pImportSemaphoreFdInfo, settings, "const VkImportSemaphoreFdInfoKHR*", "pImportSemaphoreFdInfo", 1, dump_html_VkImportSemaphoreFdInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSemaphoreFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreGetFdInfoKHR>(pGetFdInfo, settings, "const VkSemaphoreGetFdInfoKHR*", "pGetFdInfo", 1, dump_html_VkSemaphoreGetFdInfoKHR);
        dump_html_pointer<const int>(pFd, settings, "int*", "pFd", 1, dump_html_int);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPushDescriptorSetKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(set, settings, "uint32_t", "set", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(descriptorWriteCount, settings, "uint32_t", "descriptorWriteCount", 1, dump_html_uint32_t);
        dump_html_array<const VkWriteDescriptorSet>(pDescriptorWrites, descriptorWriteCount, settings, "const VkWriteDescriptorSet*", "const VkWriteDescriptorSet", "pDescriptorWrites", 1, dump_html_VkWriteDescriptorSet); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPushDescriptorSetWithTemplateKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(set, settings, "uint32_t", "set", 1, dump_html_uint32_t);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginConditionalRenderingEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkConditionalRenderingBeginInfoEXT>(pConditionalRenderingBegin, settings, "const VkConditionalRenderingBeginInfoEXT*", "pConditionalRenderingBegin", 1, dump_html_VkConditionalRenderingBeginInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndConditionalRenderingEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDescriptorUpdateTemplateKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorUpdateTemplateCreateInfo>(pCreateInfo, settings, "const VkDescriptorUpdateTemplateCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorUpdateTemplateCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorUpdateTemplate>(pDescriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate*", "pDescriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDescriptorUpdateTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUpdateDescriptorSetWithTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSet>(descriptorSet, settings, "VkDescriptorSet", "descriptorSet", 1, dump_html_VkDescriptorSet);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewportWScalingNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewportWScalingNV>(pViewportWScalings, viewportCount, settings, "const VkViewportWScalingNV*", "const VkViewportWScalingNV", "pViewportWScalings", 1, dump_html_VkViewportWScalingNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkReleaseDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
void dump_html_vkAcquireXlibDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const Display*>(dpy, settings, "Display*", "dpy", 1, dump_html_Display);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
void dump_html_vkGetRandROutputDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const Display*>(dpy, settings, "Display*", "dpy", 1, dump_html_Display);
        dump_html_value<const RROutput>(rrOutput, settings, "RROutput", "rrOutput", 1, dump_html_RROutput);
        dump_html_pointer<const VkDisplayKHR>(pDisplay, settings, "VkDisplayKHR*", "pDisplay", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
void dump_html_vkGetPhysicalDeviceSurfaceCapabilities2EXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkSurfaceCapabilities2EXT>(pSurfaceCapabilities, settings, "VkSurfaceCapabilities2EXT*", "pSurfaceCapabilities", 1, dump_html_VkSurfaceCapabilities2EXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDisplayPowerControlEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const VkDisplayPowerInfoEXT>(pDisplayPowerInfo, settings, "const VkDisplayPowerInfoEXT*", "pDisplayPowerInfo", 1, dump_html_VkDisplayPowerInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkRegisterDeviceEventEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceEventInfoEXT>(pDeviceEventInfo, settings, "const VkDeviceEventInfoEXT*", "pDeviceEventInfo", 1, dump_html_VkDeviceEventInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFence>(pFence, settings, "VkFence*", "pFence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkRegisterDisplayEventEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const VkDisplayEventInfoEXT>(pDisplayEventInfo, settings, "const VkDisplayEventInfoEXT*", "pDisplayEventInfo", 1, dump_html_VkDisplayEventInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFence>(pFence, settings, "VkFence*", "pFence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSwapchainCounterEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const VkSurfaceCounterFlagBitsEXT>(counter, settings, "VkSurfaceCounterFlagBitsEXT", "counter", 1, dump_html_VkSurfaceCounterFlagBitsEXT);
        dump_html_pointer<const uint64_t>(pCounterValue, settings, "uint64_t*", "pCounterValue", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRefreshCycleDurationGOOGLE(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkRefreshCycleDurationGOOGLE>(pDisplayTimingProperties, settings, "VkRefreshCycleDurationGOOGLE*", "pDisplayTimingProperties", 1, dump_html_VkRefreshCycleDurationGOOGLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPastPresentationTimingGOOGLE(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const uint32_t>(pPresentationTimingCount, settings, "uint32_t*", "pPresentationTimingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPastPresentationTimingGOOGLE>(pPresentationTimings, *pPresentationTimingCount, settings, "VkPastPresentationTimingGOOGLE*", "VkPastPresentationTimingGOOGLE", "pPresentationTimings", 1, dump_html_VkPastPresentationTimingGOOGLE); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDiscardRectangleEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstDiscardRectangle, settings, "uint32_t", "firstDiscardRectangle", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(discardRectangleCount, settings, "uint32_t", "discardRectangleCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pDiscardRectangles, discardRectangleCount, settings, "const VkRect2D*", "const VkRect2D", "pDiscardRectangles", 1, dump_html_VkRect2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDiscardRectangleEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(discardRectangleEnable, settings, "VkBool32", "discardRectangleEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDiscardRectangleModeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDiscardRectangleModeEXT>(discardRectangleMode, settings, "VkDiscardRectangleModeEXT", "discardRectangleMode", 1, dump_html_VkDiscardRectangleModeEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetHdrMetadataEXT(ApiDumpInstance& dump_inst, VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(swapchainCount, settings, "uint32_t", "swapchainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSwapchainKHR>(pSwapchains, swapchainCount, settings, "const VkSwapchainKHR*", "const VkSwapchainKHR", "pSwapchains", 1, dump_html_VkSwapchainKHR); // ZRZ
        dump_html_array<const VkHdrMetadataEXT>(pMetadata, swapchainCount, settings, "const VkHdrMetadataEXT*", "const VkHdrMetadataEXT", "pMetadata", 1, dump_html_VkHdrMetadataEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateRenderPass2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderPassCreateInfo2>(pCreateInfo, settings, "const VkRenderPassCreateInfo2*", "pCreateInfo", 1, dump_html_VkRenderPassCreateInfo2);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkRenderPass>(pRenderPass, settings, "VkRenderPass*", "pRenderPass", 1, dump_html_VkRenderPass);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginRenderPass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo*      pRenderPassBegin, const VkSubpassBeginInfo*      pSubpassBeginInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderPassBeginInfo>(pRenderPassBegin, settings, "const VkRenderPassBeginInfo*", "pRenderPassBegin", 1, dump_html_VkRenderPassBeginInfo);
        dump_html_pointer<const VkSubpassBeginInfo>(pSubpassBeginInfo, settings, "const VkSubpassBeginInfo*", "pSubpassBeginInfo", 1, dump_html_VkSubpassBeginInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdNextSubpass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassBeginInfo*      pSubpassBeginInfo, const VkSubpassEndInfo*        pSubpassEndInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSubpassBeginInfo>(pSubpassBeginInfo, settings, "const VkSubpassBeginInfo*", "pSubpassBeginInfo", 1, dump_html_VkSubpassBeginInfo);
        dump_html_pointer<const VkSubpassEndInfo>(pSubpassEndInfo, settings, "const VkSubpassEndInfo*", "pSubpassEndInfo", 1, dump_html_VkSubpassEndInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndRenderPass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassEndInfo*        pSubpassEndInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSubpassEndInfo>(pSubpassEndInfo, settings, "const VkSubpassEndInfo*", "pSubpassEndInfo", 1, dump_html_VkSubpassEndInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSwapchainStatusKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceExternalFencePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalFenceInfo>(pExternalFenceInfo, settings, "const VkPhysicalDeviceExternalFenceInfo*", "pExternalFenceInfo", 1, dump_html_VkPhysicalDeviceExternalFenceInfo);
        dump_html_pointer<const VkExternalFenceProperties>(pExternalFenceProperties, settings, "VkExternalFenceProperties*", "pExternalFenceProperties", 1, dump_html_VkExternalFenceProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkImportFenceWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportFenceWin32HandleInfoKHR>(pImportFenceWin32HandleInfo, settings, "const VkImportFenceWin32HandleInfoKHR*", "pImportFenceWin32HandleInfo", 1, dump_html_VkImportFenceWin32HandleInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetFenceWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFenceGetWin32HandleInfoKHR>(pGetWin32HandleInfo, settings, "const VkFenceGetWin32HandleInfoKHR*", "pGetWin32HandleInfo", 1, dump_html_VkFenceGetWin32HandleInfoKHR);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_vkImportFenceFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportFenceFdInfoKHR>(pImportFenceFdInfo, settings, "const VkImportFenceFdInfoKHR*", "pImportFenceFdInfo", 1, dump_html_VkImportFenceFdInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetFenceFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFenceGetFdInfoKHR>(pGetFdInfo, settings, "const VkFenceGetFdInfoKHR*", "pGetFdInfo", 1, dump_html_VkFenceGetFdInfoKHR);
        dump_html_pointer<const int>(pFd, settings, "int*", "pFd", 1, dump_html_int);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const uint32_t>(pCounterCount, settings, "uint32_t*", "pCounterCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPerformanceCounterKHR>(pCounters, *pCounterCount, settings, "VkPerformanceCounterKHR*", "VkPerformanceCounterKHR", "pCounters", 1, dump_html_VkPerformanceCounterKHR); // ZRZ
        dump_html_array<const VkPerformanceCounterDescriptionKHR>(pCounterDescriptions, *pCounterCount, settings, "VkPerformanceCounterDescriptionKHR*", "VkPerformanceCounterDescriptionKHR", "pCounterDescriptions", 1, dump_html_VkPerformanceCounterDescriptionKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkQueryPoolPerformanceCreateInfoKHR>(pPerformanceQueryCreateInfo, settings, "const VkQueryPoolPerformanceCreateInfoKHR*", "pPerformanceQueryCreateInfo", 1, dump_html_VkQueryPoolPerformanceCreateInfoKHR);
        dump_html_pointer<const uint32_t>(pNumPasses, settings, "uint32_t*", "pNumPasses", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAcquireProfilingLockKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAcquireProfilingLockInfoKHR>(pInfo, settings, "const VkAcquireProfilingLockInfoKHR*", "pInfo", 1, dump_html_VkAcquireProfilingLockInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkReleaseProfilingLockKHR(ApiDumpInstance& dump_inst, VkDevice device)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSurfaceCapabilities2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const VkSurfaceCapabilities2KHR>(pSurfaceCapabilities, settings, "VkSurfaceCapabilities2KHR*", "pSurfaceCapabilities", 1, dump_html_VkSurfaceCapabilities2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSurfaceFormats2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const uint32_t>(pSurfaceFormatCount, settings, "uint32_t*", "pSurfaceFormatCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSurfaceFormat2KHR>(pSurfaceFormats, *pSurfaceFormatCount, settings, "VkSurfaceFormat2KHR*", "VkSurfaceFormat2KHR", "pSurfaceFormats", 1, dump_html_VkSurfaceFormat2KHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceDisplayProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayProperties2KHR>(pProperties, *pPropertyCount, settings, "VkDisplayProperties2KHR*", "VkDisplayProperties2KHR", "pProperties", 1, dump_html_VkDisplayProperties2KHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayPlaneProperties2KHR>(pProperties, *pPropertyCount, settings, "VkDisplayPlaneProperties2KHR*", "VkDisplayPlaneProperties2KHR", "pProperties", 1, dump_html_VkDisplayPlaneProperties2KHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDisplayModeProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayModeProperties2KHR>(pProperties, *pPropertyCount, settings, "VkDisplayModeProperties2KHR*", "VkDisplayModeProperties2KHR", "pProperties", 1, dump_html_VkDisplayModeProperties2KHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDisplayPlaneCapabilities2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkDisplayPlaneInfo2KHR>(pDisplayPlaneInfo, settings, "const VkDisplayPlaneInfo2KHR*", "pDisplayPlaneInfo", 1, dump_html_VkDisplayPlaneInfo2KHR);
        dump_html_pointer<const VkDisplayPlaneCapabilities2KHR>(pCapabilities, settings, "VkDisplayPlaneCapabilities2KHR*", "pCapabilities", 1, dump_html_VkDisplayPlaneCapabilities2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
void dump_html_vkCreateIOSSurfaceMVK(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkIOSSurfaceCreateInfoMVK>(pCreateInfo, settings, "const VkIOSSurfaceCreateInfoMVK*", "pCreateInfo", 1, dump_html_VkIOSSurfaceCreateInfoMVK);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_IOS_MVK
#if defined(VK_USE_PLATFORM_MACOS_MVK)
void dump_html_vkCreateMacOSSurfaceMVK(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkMacOSSurfaceCreateInfoMVK>(pCreateInfo, settings, "const VkMacOSSurfaceCreateInfoMVK*", "pCreateInfo", 1, dump_html_VkMacOSSurfaceCreateInfoMVK);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_MACOS_MVK
void dump_html_vkSetDebugUtilsObjectNameEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugUtilsObjectNameInfoEXT>(pNameInfo, settings, "const VkDebugUtilsObjectNameInfoEXT*", "pNameInfo", 1, dump_html_VkDebugUtilsObjectNameInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetDebugUtilsObjectTagEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugUtilsObjectTagInfoEXT>(pTagInfo, settings, "const VkDebugUtilsObjectTagInfoEXT*", "pTagInfo", 1, dump_html_VkDebugUtilsObjectTagInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueBeginDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueEndDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueInsertDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBeginDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEndDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdInsertDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDebugUtilsMessengerEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDebugUtilsMessengerCreateInfoEXT>(pCreateInfo, settings, "const VkDebugUtilsMessengerCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkDebugUtilsMessengerCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDebugUtilsMessengerEXT>(pMessenger, settings, "VkDebugUtilsMessengerEXT*", "pMessenger", 1, dump_html_VkDebugUtilsMessengerEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDebugUtilsMessengerEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugUtilsMessengerEXT>(messenger, settings, "VkDebugUtilsMessengerEXT", "messenger", 1, dump_html_VkDebugUtilsMessengerEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSubmitDebugUtilsMessageEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugUtilsMessageSeverityFlagBitsEXT>(messageSeverity, settings, "VkDebugUtilsMessageSeverityFlagBitsEXT", "messageSeverity", 1, dump_html_VkDebugUtilsMessageSeverityFlagBitsEXT);
        dump_html_value<const VkDebugUtilsMessageTypeFlagsEXT>(messageTypes, settings, "VkDebugUtilsMessageTypeFlagsEXT", "messageTypes", 1, dump_html_VkDebugUtilsMessageTypeFlagsEXT);
        dump_html_pointer<const VkDebugUtilsMessengerCallbackDataEXT>(pCallbackData, settings, "const VkDebugUtilsMessengerCallbackDataEXT*", "pCallbackData", 1, dump_html_VkDebugUtilsMessengerCallbackDataEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_vkGetAndroidHardwareBufferPropertiesANDROID(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const AHardwareBuffer*>(buffer, settings, "const struct AHardwareBuffer*", "buffer", 1, dump_html_AHardwareBuffer);
        dump_html_pointer<const VkAndroidHardwareBufferPropertiesANDROID>(pProperties, settings, "VkAndroidHardwareBufferPropertiesANDROID*", "pProperties", 1, dump_html_VkAndroidHardwareBufferPropertiesANDROID);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
void dump_html_vkGetMemoryAndroidHardwareBufferANDROID(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetAndroidHardwareBufferInfoANDROID>(pInfo, settings, "const VkMemoryGetAndroidHardwareBufferInfoANDROID*", "pInfo", 1, dump_html_VkMemoryGetAndroidHardwareBufferInfoANDROID);
        dump_html_pointer<const AHardwareBuffer*>(pBuffer, settings, "struct AHardwareBuffer**", "pBuffer", 1, dump_html_AHardwareBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkCreateExecutionGraphPipelinesAMDX(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                        device, VkPipelineCache                 pipelineCache, uint32_t                                        createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, const VkAllocationCallbacks*    pAllocator, VkPipeline*               pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkExecutionGraphPipelineCreateInfoAMDX>(pCreateInfos, createInfoCount, settings, "const VkExecutionGraphPipelineCreateInfoAMDX*", "const VkExecutionGraphPipelineCreateInfoAMDX", "pCreateInfos", 1, dump_html_VkExecutionGraphPipelineCreateInfoAMDX); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkGetExecutionGraphPipelineScratchSizeAMDX(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                        device, VkPipeline                                      executionGraph, VkExecutionGraphPipelineScratchSizeAMDX*         pSizeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(executionGraph, settings, "VkPipeline", "executionGraph", 1, dump_html_VkPipeline);
        dump_html_pointer<const VkExecutionGraphPipelineScratchSizeAMDX>(pSizeInfo, settings, "VkExecutionGraphPipelineScratchSizeAMDX*", "pSizeInfo", 1, dump_html_VkExecutionGraphPipelineScratchSizeAMDX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkGetExecutionGraphPipelineNodeIndexAMDX(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                        device, VkPipeline                                      executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX*   pNodeInfo, uint32_t*                                       pNodeIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(executionGraph, settings, "VkPipeline", "executionGraph", 1, dump_html_VkPipeline);
        dump_html_pointer<const VkPipelineShaderStageNodeCreateInfoAMDX>(pNodeInfo, settings, "const VkPipelineShaderStageNodeCreateInfoAMDX*", "pNodeInfo", 1, dump_html_VkPipelineShaderStageNodeCreateInfoAMDX);
        dump_html_pointer<const uint32_t>(pNodeIndex, settings, "uint32_t*", "pNodeIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkCmdInitializeGraphScratchMemoryAMDX(ApiDumpInstance& dump_inst, VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(scratch, settings, "VkDeviceAddress", "scratch", 1, dump_html_VkDeviceAddress);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkCmdDispatchGraphAMDX(ApiDumpInstance& dump_inst, VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch, const VkDispatchGraphCountInfoAMDX*              pCountInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(scratch, settings, "VkDeviceAddress", "scratch", 1, dump_html_VkDeviceAddress);
        dump_html_pointer<const VkDispatchGraphCountInfoAMDX>(pCountInfo, settings, "const VkDispatchGraphCountInfoAMDX*", "pCountInfo", 1, dump_html_VkDispatchGraphCountInfoAMDX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkCmdDispatchGraphIndirectAMDX(ApiDumpInstance& dump_inst, VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch, const VkDispatchGraphCountInfoAMDX*              pCountInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(scratch, settings, "VkDeviceAddress", "scratch", 1, dump_html_VkDeviceAddress);
        dump_html_pointer<const VkDispatchGraphCountInfoAMDX>(pCountInfo, settings, "const VkDispatchGraphCountInfoAMDX*", "pCountInfo", 1, dump_html_VkDispatchGraphCountInfoAMDX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
#if defined(VK_ENABLE_BETA_EXTENSIONS)
void dump_html_vkCmdDispatchGraphIndirectCountAMDX(ApiDumpInstance& dump_inst, VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch, VkDeviceAddress                                 countInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(scratch, settings, "VkDeviceAddress", "scratch", 1, dump_html_VkDeviceAddress);
        dump_html_value<const VkDeviceAddress>(countInfo, settings, "VkDeviceAddress", "countInfo", 1, dump_html_VkDeviceAddress);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_ENABLE_BETA_EXTENSIONS
void dump_html_vkCmdSetSampleLocationsEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSampleLocationsInfoEXT>(pSampleLocationsInfo, settings, "const VkSampleLocationsInfoEXT*", "pSampleLocationsInfo", 1, dump_html_VkSampleLocationsInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceMultisamplePropertiesEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSampleCountFlagBits>(samples, settings, "VkSampleCountFlagBits", "samples", 1, dump_html_VkSampleCountFlagBits);
        dump_html_pointer<const VkMultisamplePropertiesEXT>(pMultisampleProperties, settings, "VkMultisamplePropertiesEXT*", "pMultisampleProperties", 1, dump_html_VkMultisamplePropertiesEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageMemoryRequirementsInfo2>(pInfo, settings, "const VkImageMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferMemoryRequirementsInfo2>(pInfo, settings, "const VkBufferMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkBufferMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageSparseMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageSparseMemoryRequirementsInfo2>(pInfo, settings, "const VkImageSparseMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageSparseMemoryRequirementsInfo2);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements2>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements2*", "VkSparseImageMemoryRequirements2", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateAccelerationStructureKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                           device, const VkAccelerationStructureCreateInfoKHR*        pCreateInfo, const VkAllocationCallbacks*       pAllocator, VkAccelerationStructureKHR*                        pAccelerationStructure)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureCreateInfoKHR>(pCreateInfo, settings, "const VkAccelerationStructureCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkAccelerationStructureCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkAccelerationStructureKHR>(pAccelerationStructure, settings, "VkAccelerationStructureKHR*", "pAccelerationStructure", 1, dump_html_VkAccelerationStructureKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyAccelerationStructureKHR(ApiDumpInstance& dump_inst, VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureKHR>(accelerationStructure, settings, "VkAccelerationStructureKHR", "accelerationStructure", 1, dump_html_VkAccelerationStructureKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBuildAccelerationStructuresKHR(ApiDumpInstance& dump_inst, VkCommandBuffer                                    commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(infoCount, settings, "uint32_t", "infoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureBuildGeometryInfoKHR>(pInfos, infoCount, settings, "const VkAccelerationStructureBuildGeometryInfoKHR*", "const VkAccelerationStructureBuildGeometryInfoKHR", "pInfos", 1, dump_html_VkAccelerationStructureBuildGeometryInfoKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBuildAccelerationStructuresIndirectKHR(ApiDumpInstance& dump_inst, VkCommandBuffer                  commandBuffer, uint32_t                                           infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress*             pIndirectDeviceAddresses, const uint32_t*                    pIndirectStrides, const uint32_t* const*             ppMaxPrimitiveCounts)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(infoCount, settings, "uint32_t", "infoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureBuildGeometryInfoKHR>(pInfos, infoCount, settings, "const VkAccelerationStructureBuildGeometryInfoKHR*", "const VkAccelerationStructureBuildGeometryInfoKHR", "pInfos", 1, dump_html_VkAccelerationStructureBuildGeometryInfoKHR); // ZRZ
        dump_html_array<const VkDeviceAddress>(pIndirectDeviceAddresses, infoCount, settings, "const VkDeviceAddress*", "const VkDeviceAddress", "pIndirectDeviceAddresses", 1, dump_html_VkDeviceAddress); // ZRZ
        dump_html_array<const uint32_t>(pIndirectStrides, infoCount, settings, "const uint32_t*", "const uint32_t", "pIndirectStrides", 1, dump_html_uint32_t); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBuildAccelerationStructuresKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                           device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_value<const uint32_t>(infoCount, settings, "uint32_t", "infoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureBuildGeometryInfoKHR>(pInfos, infoCount, settings, "const VkAccelerationStructureBuildGeometryInfoKHR*", "const VkAccelerationStructureBuildGeometryInfoKHR", "pInfos", 1, dump_html_VkAccelerationStructureBuildGeometryInfoKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyAccelerationStructureKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkCopyAccelerationStructureInfoKHR>(pInfo, settings, "const VkCopyAccelerationStructureInfoKHR*", "pInfo", 1, dump_html_VkCopyAccelerationStructureInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyAccelerationStructureToMemoryKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkCopyAccelerationStructureToMemoryInfoKHR>(pInfo, settings, "const VkCopyAccelerationStructureToMemoryInfoKHR*", "pInfo", 1, dump_html_VkCopyAccelerationStructureToMemoryInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyMemoryToAccelerationStructureKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkCopyMemoryToAccelerationStructureInfoKHR>(pInfo, settings, "const VkCopyMemoryToAccelerationStructureInfoKHR*", "pInfo", 1, dump_html_VkCopyMemoryToAccelerationStructureInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkWriteAccelerationStructuresPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType  queryType, size_t       dataSize, void* pData, size_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureKHR>(pAccelerationStructures, accelerationStructureCount, settings, "const VkAccelerationStructureKHR*", "const VkAccelerationStructureKHR", "pAccelerationStructures", 1, dump_html_VkAccelerationStructureKHR); // ZRZ
        dump_html_value<const VkQueryType>(queryType, settings, "VkQueryType", "queryType", 1, dump_html_VkQueryType);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
        dump_html_value<const size_t>(stride, settings, "size_t", "stride", 1, dump_html_size_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyAccelerationStructureKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyAccelerationStructureInfoKHR>(pInfo, settings, "const VkCopyAccelerationStructureInfoKHR*", "pInfo", 1, dump_html_VkCopyAccelerationStructureInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyAccelerationStructureToMemoryKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyAccelerationStructureToMemoryInfoKHR>(pInfo, settings, "const VkCopyAccelerationStructureToMemoryInfoKHR*", "pInfo", 1, dump_html_VkCopyAccelerationStructureToMemoryInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyMemoryToAccelerationStructureKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyMemoryToAccelerationStructureInfoKHR>(pInfo, settings, "const VkCopyMemoryToAccelerationStructureInfoKHR*", "pInfo", 1, dump_html_VkCopyMemoryToAccelerationStructureInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetAccelerationStructureDeviceAddressKHR(ApiDumpInstance& dump_inst, VkDeviceAddress result, VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceAddress(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureDeviceAddressInfoKHR>(pInfo, settings, "const VkAccelerationStructureDeviceAddressInfoKHR*", "pInfo", 1, dump_html_VkAccelerationStructureDeviceAddressInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteAccelerationStructuresPropertiesKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureKHR>(pAccelerationStructures, accelerationStructureCount, settings, "const VkAccelerationStructureKHR*", "const VkAccelerationStructureKHR", "pAccelerationStructures", 1, dump_html_VkAccelerationStructureKHR); // ZRZ
        dump_html_value<const VkQueryType>(queryType, settings, "VkQueryType", "queryType", 1, dump_html_VkQueryType);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceAccelerationStructureCompatibilityKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureVersionInfoKHR>(pVersionInfo, settings, "const VkAccelerationStructureVersionInfoKHR*", "pVersionInfo", 1, dump_html_VkAccelerationStructureVersionInfoKHR);
        dump_html_pointer<const VkAccelerationStructureCompatibilityKHR>(pCompatibility, settings, "VkAccelerationStructureCompatibilityKHR*", "pCompatibility", 1, dump_html_VkAccelerationStructureCompatibilityKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetAccelerationStructureBuildSizesKHR(ApiDumpInstance& dump_inst, VkDevice                                            device, VkAccelerationStructureBuildTypeKHR                 buildType, const VkAccelerationStructureBuildGeometryInfoKHR*  pBuildInfo, const uint32_t*  pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR*           pSizeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureBuildTypeKHR>(buildType, settings, "VkAccelerationStructureBuildTypeKHR", "buildType", 1, dump_html_VkAccelerationStructureBuildTypeKHR);
        dump_html_pointer<const VkAccelerationStructureBuildGeometryInfoKHR>(pBuildInfo, settings, "const VkAccelerationStructureBuildGeometryInfoKHR*", "pBuildInfo", 1, dump_html_VkAccelerationStructureBuildGeometryInfoKHR);
        dump_html_array<const uint32_t>(pMaxPrimitiveCounts, pBuildInfo->geometryCount, settings, "const uint32_t*", "const uint32_t", "pMaxPrimitiveCounts", 1, dump_html_uint32_t); // ZRZ
        dump_html_pointer<const VkAccelerationStructureBuildSizesInfoKHR>(pSizeInfo, settings, "VkAccelerationStructureBuildSizesInfoKHR*", "pSizeInfo", 1, dump_html_VkAccelerationStructureBuildSizesInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateSamplerYcbcrConversionKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerYcbcrConversionCreateInfo>(pCreateInfo, settings, "const VkSamplerYcbcrConversionCreateInfo*", "pCreateInfo", 1, dump_html_VkSamplerYcbcrConversionCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSamplerYcbcrConversion>(pYcbcrConversion, settings, "VkSamplerYcbcrConversion*", "pYcbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroySamplerYcbcrConversionKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSamplerYcbcrConversion>(ycbcrConversion, settings, "VkSamplerYcbcrConversion", "ycbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindBufferMemory2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindBufferMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindBufferMemoryInfo*", "const VkBindBufferMemoryInfo", "pBindInfos", 1, dump_html_VkBindBufferMemoryInfo); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindImageMemory2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindImageMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindImageMemoryInfo*", "const VkBindImageMemoryInfo", "pBindInfos", 1, dump_html_VkBindImageMemoryInfo); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageDrmFormatModifierPropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkImageDrmFormatModifierPropertiesEXT>(pProperties, settings, "VkImageDrmFormatModifierPropertiesEXT*", "pProperties", 1, dump_html_VkImageDrmFormatModifierPropertiesEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateValidationCacheEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkValidationCacheCreateInfoEXT>(pCreateInfo, settings, "const VkValidationCacheCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkValidationCacheCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkValidationCacheEXT>(pValidationCache, settings, "VkValidationCacheEXT*", "pValidationCache", 1, dump_html_VkValidationCacheEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyValidationCacheEXT(ApiDumpInstance& dump_inst, VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkValidationCacheEXT>(validationCache, settings, "VkValidationCacheEXT", "validationCache", 1, dump_html_VkValidationCacheEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkMergeValidationCachesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkValidationCacheEXT>(dstCache, settings, "VkValidationCacheEXT", "dstCache", 1, dump_html_VkValidationCacheEXT);
        dump_html_value<const uint32_t>(srcCacheCount, settings, "uint32_t", "srcCacheCount", 1, dump_html_uint32_t);
        dump_html_array<const VkValidationCacheEXT>(pSrcCaches, srcCacheCount, settings, "const VkValidationCacheEXT*", "const VkValidationCacheEXT", "pSrcCaches", 1, dump_html_VkValidationCacheEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetValidationCacheDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkValidationCacheEXT>(validationCache, settings, "VkValidationCacheEXT", "validationCache", 1, dump_html_VkValidationCacheEXT);
        dump_html_pointer<const size_t>(pDataSize, settings, "size_t*", "pDataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindShadingRateImageNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImageView>(imageView, settings, "VkImageView", "imageView", 1, dump_html_VkImageView);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewportShadingRatePaletteNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkShadingRatePaletteNV>(pShadingRatePalettes, viewportCount, settings, "const VkShadingRatePaletteNV*", "const VkShadingRatePaletteNV", "pShadingRatePalettes", 1, dump_html_VkShadingRatePaletteNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoarseSampleOrderNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCoarseSampleOrderTypeNV>(sampleOrderType, settings, "VkCoarseSampleOrderTypeNV", "sampleOrderType", 1, dump_html_VkCoarseSampleOrderTypeNV);
        dump_html_value<const uint32_t>(customSampleOrderCount, settings, "uint32_t", "customSampleOrderCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCoarseSampleOrderCustomNV>(pCustomSampleOrders, customSampleOrderCount, settings, "const VkCoarseSampleOrderCustomNV*", "const VkCoarseSampleOrderCustomNV", "pCustomSampleOrders", 1, dump_html_VkCoarseSampleOrderCustomNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateAccelerationStructureNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureCreateInfoNV>(pCreateInfo, settings, "const VkAccelerationStructureCreateInfoNV*", "pCreateInfo", 1, dump_html_VkAccelerationStructureCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkAccelerationStructureNV>(pAccelerationStructure, settings, "VkAccelerationStructureNV*", "pAccelerationStructure", 1, dump_html_VkAccelerationStructureNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyAccelerationStructureNV(ApiDumpInstance& dump_inst, VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureNV>(accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", 1, dump_html_VkAccelerationStructureNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetAccelerationStructureMemoryRequirementsNV(ApiDumpInstance& dump_inst, VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureMemoryRequirementsInfoNV>(pInfo, settings, "const VkAccelerationStructureMemoryRequirementsInfoNV*", "pInfo", 1, dump_html_VkAccelerationStructureMemoryRequirementsInfoNV);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2KHR*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindAccelerationStructureMemoryNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindAccelerationStructureMemoryInfoNV>(pBindInfos, bindInfoCount, settings, "const VkBindAccelerationStructureMemoryInfoNV*", "const VkBindAccelerationStructureMemoryInfoNV", "pBindInfos", 1, dump_html_VkBindAccelerationStructureMemoryInfoNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBuildAccelerationStructureNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkAccelerationStructureInfoNV>(pInfo, settings, "const VkAccelerationStructureInfoNV*", "pInfo", 1, dump_html_VkAccelerationStructureInfoNV);
        dump_html_value<const VkBuffer>(instanceData, settings, "VkBuffer", "instanceData", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(instanceOffset, settings, "VkDeviceSize", "instanceOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBool32>(update, settings, "VkBool32", "update", 1, dump_html_VkBool32);
        dump_html_value<const VkAccelerationStructureNV>(dst, settings, "VkAccelerationStructureNV", "dst", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkAccelerationStructureNV>(src, settings, "VkAccelerationStructureNV", "src", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkBuffer>(scratch, settings, "VkBuffer", "scratch", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(scratchOffset, settings, "VkDeviceSize", "scratchOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyAccelerationStructureNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkAccelerationStructureNV>(dst, settings, "VkAccelerationStructureNV", "dst", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkAccelerationStructureNV>(src, settings, "VkAccelerationStructureNV", "src", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkCopyAccelerationStructureModeKHR>(mode, settings, "VkCopyAccelerationStructureModeKHR", "mode", 1, dump_html_VkCopyAccelerationStructureModeKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdTraceRaysNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(raygenShaderBindingTableBuffer, settings, "VkBuffer", "raygenShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(raygenShaderBindingOffset, settings, "VkDeviceSize", "raygenShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(missShaderBindingTableBuffer, settings, "VkBuffer", "missShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(missShaderBindingOffset, settings, "VkDeviceSize", "missShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(missShaderBindingStride, settings, "VkDeviceSize", "missShaderBindingStride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(hitShaderBindingTableBuffer, settings, "VkBuffer", "hitShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(hitShaderBindingOffset, settings, "VkDeviceSize", "hitShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(hitShaderBindingStride, settings, "VkDeviceSize", "hitShaderBindingStride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(callableShaderBindingTableBuffer, settings, "VkBuffer", "callableShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(callableShaderBindingOffset, settings, "VkDeviceSize", "callableShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(callableShaderBindingStride, settings, "VkDeviceSize", "callableShaderBindingStride", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(width, settings, "uint32_t", "width", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(height, settings, "uint32_t", "height", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(depth, settings, "uint32_t", "depth", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateRayTracingPipelinesNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRayTracingPipelineCreateInfoNV>(pCreateInfos, createInfoCount, settings, "const VkRayTracingPipelineCreateInfoNV*", "const VkRayTracingPipelineCreateInfoNV", "pCreateInfos", 1, dump_html_VkRayTracingPipelineCreateInfoNV); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRayTracingShaderGroupHandlesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(firstGroup, settings, "uint32_t", "firstGroup", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCount, settings, "uint32_t", "groupCount", 1, dump_html_uint32_t);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRayTracingShaderGroupHandlesNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(firstGroup, settings, "uint32_t", "firstGroup", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCount, settings, "uint32_t", "groupCount", 1, dump_html_uint32_t);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetAccelerationStructureHandleNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureNV>(accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteAccelerationStructuresPropertiesNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureNV>(pAccelerationStructures, accelerationStructureCount, settings, "const VkAccelerationStructureNV*", "const VkAccelerationStructureNV", "pAccelerationStructures", 1, dump_html_VkAccelerationStructureNV); // ZRZ
        dump_html_value<const VkQueryType>(queryType, settings, "VkQueryType", "queryType", 1, dump_html_VkQueryType);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCompileDeferredNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, uint32_t shader)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(shader, settings, "uint32_t", "shader", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorSetLayoutSupportKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetLayoutCreateInfo>(pCreateInfo, settings, "const VkDescriptorSetLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorSetLayoutCreateInfo);
        dump_html_pointer<const VkDescriptorSetLayoutSupport>(pSupport, settings, "VkDescriptorSetLayoutSupport*", "pSupport", 1, dump_html_VkDescriptorSetLayoutSupport);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndirectCountKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawIndexedIndirectCountKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetMemoryHostPointerPropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const void*>(pHostPointer, settings, "const void*", "pHostPointer", 1, dump_html_void);
        dump_html_pointer<const VkMemoryHostPointerPropertiesEXT>(pMemoryHostPointerProperties, settings, "VkMemoryHostPointerPropertiesEXT*", "pMemoryHostPointerProperties", 1, dump_html_VkMemoryHostPointerPropertiesEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteBufferMarkerAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlagBits>(pipelineStage, settings, "VkPipelineStageFlagBits", "pipelineStage", 1, dump_html_VkPipelineStageFlagBits);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(marker, settings, "uint32_t", "marker", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pTimeDomainCount, settings, "uint32_t*", "pTimeDomainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkTimeDomainKHR>(pTimeDomains, *pTimeDomainCount, settings, "VkTimeDomainKHR*", "VkTimeDomainKHR", "pTimeDomains", 1, dump_html_VkTimeDomainKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pTimeDomainCount, settings, "uint32_t*", "pTimeDomainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkTimeDomainKHR>(pTimeDomains, *pTimeDomainCount, settings, "VkTimeDomainKHR*", "VkTimeDomainKHR", "pTimeDomains", 1, dump_html_VkTimeDomainKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetCalibratedTimestampsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(timestampCount, settings, "uint32_t", "timestampCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCalibratedTimestampInfoKHR>(pTimestampInfos, timestampCount, settings, "const VkCalibratedTimestampInfoKHR*", "const VkCalibratedTimestampInfoKHR", "pTimestampInfos", 1, dump_html_VkCalibratedTimestampInfoKHR); // ZRZ
        dump_html_array<const uint64_t>(pTimestamps, timestampCount, settings, "uint64_t*", "uint64_t", "pTimestamps", 1, dump_html_uint64_t); // ZRZ
        dump_html_pointer<const uint64_t>(pMaxDeviation, settings, "uint64_t*", "pMaxDeviation", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetCalibratedTimestampsEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(timestampCount, settings, "uint32_t", "timestampCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCalibratedTimestampInfoKHR>(pTimestampInfos, timestampCount, settings, "const VkCalibratedTimestampInfoKHR*", "const VkCalibratedTimestampInfoKHR", "pTimestampInfos", 1, dump_html_VkCalibratedTimestampInfoKHR); // ZRZ
        dump_html_array<const uint64_t>(pTimestamps, timestampCount, settings, "uint64_t*", "uint64_t", "pTimestamps", 1, dump_html_uint64_t); // ZRZ
        dump_html_pointer<const uint64_t>(pMaxDeviation, settings, "uint64_t*", "pMaxDeviation", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMeshTasksNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(taskCount, settings, "uint32_t", "taskCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstTask, settings, "uint32_t", "firstTask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMeshTasksIndirectNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMeshTasksIndirectCountNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetExclusiveScissorEnableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstExclusiveScissor, settings, "uint32_t", "firstExclusiveScissor", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(exclusiveScissorCount, settings, "uint32_t", "exclusiveScissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBool32>(pExclusiveScissorEnables, exclusiveScissorCount, settings, "const VkBool32*", "const VkBool32", "pExclusiveScissorEnables", 1, dump_html_VkBool32); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetExclusiveScissorNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstExclusiveScissor, settings, "uint32_t", "firstExclusiveScissor", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(exclusiveScissorCount, settings, "uint32_t", "exclusiveScissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pExclusiveScissors, exclusiveScissorCount, settings, "const VkRect2D*", "const VkRect2D", "pExclusiveScissors", 1, dump_html_VkRect2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCheckpointNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const void* pCheckpointMarker)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const void*>(pCheckpointMarker, settings, "const void*", "pCheckpointMarker", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetQueueCheckpointDataNV(ApiDumpInstance& dump_inst, VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const uint32_t>(pCheckpointDataCount, settings, "uint32_t*", "pCheckpointDataCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCheckpointDataNV>(pCheckpointData, *pCheckpointDataCount, settings, "VkCheckpointDataNV*", "VkCheckpointDataNV", "pCheckpointData", 1, dump_html_VkCheckpointDataNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSemaphoreCounterValueKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSemaphore semaphore, uint64_t* pValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_pointer<const uint64_t>(pValue, settings, "uint64_t*", "pValue", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkWaitSemaphoresKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreWaitInfo>(pWaitInfo, settings, "const VkSemaphoreWaitInfo*", "pWaitInfo", 1, dump_html_VkSemaphoreWaitInfo);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSignalSemaphoreKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreSignalInfo>(pSignalInfo, settings, "const VkSemaphoreSignalInfo*", "pSignalInfo", 1, dump_html_VkSemaphoreSignalInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkInitializePerformanceApiINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkInitializePerformanceApiInfoINTEL>(pInitializeInfo, settings, "const VkInitializePerformanceApiInfoINTEL*", "pInitializeInfo", 1, dump_html_VkInitializePerformanceApiInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUninitializePerformanceApiINTEL(ApiDumpInstance& dump_inst, VkDevice device)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPerformanceMarkerINTEL(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPerformanceMarkerInfoINTEL>(pMarkerInfo, settings, "const VkPerformanceMarkerInfoINTEL*", "pMarkerInfo", 1, dump_html_VkPerformanceMarkerInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPerformanceStreamMarkerINTEL(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPerformanceStreamMarkerInfoINTEL>(pMarkerInfo, settings, "const VkPerformanceStreamMarkerInfoINTEL*", "pMarkerInfo", 1, dump_html_VkPerformanceStreamMarkerInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPerformanceOverrideINTEL(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPerformanceOverrideInfoINTEL>(pOverrideInfo, settings, "const VkPerformanceOverrideInfoINTEL*", "pOverrideInfo", 1, dump_html_VkPerformanceOverrideInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAcquirePerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPerformanceConfigurationAcquireInfoINTEL>(pAcquireInfo, settings, "const VkPerformanceConfigurationAcquireInfoINTEL*", "pAcquireInfo", 1, dump_html_VkPerformanceConfigurationAcquireInfoINTEL);
        dump_html_pointer<const VkPerformanceConfigurationINTEL>(pConfiguration, settings, "VkPerformanceConfigurationINTEL*", "pConfiguration", 1, dump_html_VkPerformanceConfigurationINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkReleasePerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPerformanceConfigurationINTEL configuration)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPerformanceConfigurationINTEL>(configuration, settings, "VkPerformanceConfigurationINTEL", "configuration", 1, dump_html_VkPerformanceConfigurationINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueSetPerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, VkPerformanceConfigurationINTEL configuration)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const VkPerformanceConfigurationINTEL>(configuration, settings, "VkPerformanceConfigurationINTEL", "configuration", 1, dump_html_VkPerformanceConfigurationINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPerformanceParameterINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPerformanceParameterTypeINTEL>(parameter, settings, "VkPerformanceParameterTypeINTEL", "parameter", 1, dump_html_VkPerformanceParameterTypeINTEL);
        dump_html_pointer<const VkPerformanceValueINTEL>(pValue, settings, "VkPerformanceValueINTEL*", "pValue", 1, dump_html_VkPerformanceValueINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetLocalDimmingAMD(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapChain, settings, "VkSwapchainKHR", "swapChain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const VkBool32>(localDimmingEnable, settings, "VkBool32", "localDimmingEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkCreateImagePipeSurfaceFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkImagePipeSurfaceCreateInfoFUCHSIA>(pCreateInfo, settings, "const VkImagePipeSurfaceCreateInfoFUCHSIA*", "pCreateInfo", 1, dump_html_VkImagePipeSurfaceCreateInfoFUCHSIA);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_vkCreateMetalSurfaceEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkMetalSurfaceCreateInfoEXT>(pCreateInfo, settings, "const VkMetalSurfaceCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkMetalSurfaceCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_vkGetPhysicalDeviceFragmentShadingRatesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pFragmentShadingRateCount, settings, "uint32_t*", "pFragmentShadingRateCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceFragmentShadingRateKHR>(pFragmentShadingRates, *pFragmentShadingRateCount, settings, "VkPhysicalDeviceFragmentShadingRateKHR*", "VkPhysicalDeviceFragmentShadingRateKHR", "pFragmentShadingRates", 1, dump_html_VkPhysicalDeviceFragmentShadingRateKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetFragmentShadingRateKHR(ApiDumpInstance& dump_inst, VkCommandBuffer           commandBuffer, const VkExtent2D*                           pFragmentSize, const VkFragmentShadingRateCombinerOpKHR    combinerOps[2])
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkExtent2D>(pFragmentSize, settings, "const VkExtent2D*", "pFragmentSize", 1, dump_html_VkExtent2D);
        dump_html_array<const VkFragmentShadingRateCombinerOpKHR>(combinerOps, 2, settings, "const VkFragmentShadingRateCombinerOpKHR[2]", "const VkFragmentShadingRateCombinerOpKHR", "combinerOps", 1, dump_html_VkFragmentShadingRateCombinerOpKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRenderingAttachmentLocationsKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfoKHR* pLocationInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderingAttachmentLocationInfoKHR>(pLocationInfo, settings, "const VkRenderingAttachmentLocationInfoKHR*", "pLocationInfo", 1, dump_html_VkRenderingAttachmentLocationInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRenderingInputAttachmentIndicesKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfoKHR* pLocationInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderingInputAttachmentIndexInfoKHR>(pLocationInfo, settings, "const VkRenderingInputAttachmentIndexInfoKHR*", "pLocationInfo", 1, dump_html_VkRenderingInputAttachmentIndexInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferDeviceAddressEXT(ApiDumpInstance& dump_inst, VkDeviceAddress result, VkDevice device, const VkBufferDeviceAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceAddress(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferDeviceAddressInfo>(pInfo, settings, "const VkBufferDeviceAddressInfo*", "pInfo", 1, dump_html_VkBufferDeviceAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceToolPropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pToolCount, settings, "uint32_t*", "pToolCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceToolProperties>(pToolProperties, *pToolCount, settings, "VkPhysicalDeviceToolProperties*", "VkPhysicalDeviceToolProperties", "pToolProperties", 1, dump_html_VkPhysicalDeviceToolProperties); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkWaitForPresentKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const uint64_t>(presentId, settings, "uint64_t", "presentId", 1, dump_html_uint64_t);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCooperativeMatrixPropertiesNV>(pProperties, *pPropertyCount, settings, "VkCooperativeMatrixPropertiesNV*", "VkCooperativeMatrixPropertiesNV", "pProperties", 1, dump_html_VkCooperativeMatrixPropertiesNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pCombinationCount, settings, "uint32_t*", "pCombinationCount", 1, dump_html_uint32_t);
        dump_html_array<const VkFramebufferMixedSamplesCombinationNV>(pCombinations, *pCombinationCount, settings, "VkFramebufferMixedSamplesCombinationNV*", "VkFramebufferMixedSamplesCombinationNV", "pCombinations", 1, dump_html_VkFramebufferMixedSamplesCombinationNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetPhysicalDeviceSurfacePresentModes2EXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const uint32_t>(pPresentModeCount, settings, "uint32_t*", "pPresentModeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPresentModeKHR>(pPresentModes, *pPresentModeCount, settings, "VkPresentModeKHR*", "VkPresentModeKHR", "pPresentModes", 1, dump_html_VkPresentModeKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkAcquireFullScreenExclusiveModeEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkReleaseFullScreenExclusiveModeEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetDeviceGroupSurfacePresentModes2EXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const VkDeviceGroupPresentModeFlagsKHR>(pModes, settings, "VkDeviceGroupPresentModeFlagsKHR*", "pModes", 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
void dump_html_vkCreateHeadlessSurfaceEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkHeadlessSurfaceCreateInfoEXT>(pCreateInfo, settings, "const VkHeadlessSurfaceCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkHeadlessSurfaceCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferDeviceAddressKHR(ApiDumpInstance& dump_inst, VkDeviceAddress result, VkDevice device, const VkBufferDeviceAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceAddress(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferDeviceAddressInfo>(pInfo, settings, "const VkBufferDeviceAddressInfo*", "pInfo", 1, dump_html_VkBufferDeviceAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferOpaqueCaptureAddressKHR(ApiDumpInstance& dump_inst, uint64_t result, VkDevice device, const VkBufferDeviceAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint64_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferDeviceAddressInfo>(pInfo, settings, "const VkBufferDeviceAddressInfo*", "pInfo", 1, dump_html_VkBufferDeviceAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceMemoryOpaqueCaptureAddressKHR(ApiDumpInstance& dump_inst, uint64_t result, VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint64_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceMemoryOpaqueCaptureAddressInfo>(pInfo, settings, "const VkDeviceMemoryOpaqueCaptureAddressInfo*", "pInfo", 1, dump_html_VkDeviceMemoryOpaqueCaptureAddressInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLineStippleKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(lineStippleFactor, settings, "uint32_t", "lineStippleFactor", 1, dump_html_uint32_t);
        dump_html_value<const uint16_t>(lineStipplePattern, settings, "uint16_t", "lineStipplePattern", 1, dump_html_uint16_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLineStippleEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(lineStippleFactor, settings, "uint32_t", "lineStippleFactor", 1, dump_html_uint32_t);
        dump_html_value<const uint16_t>(lineStipplePattern, settings, "uint16_t", "lineStipplePattern", 1, dump_html_uint16_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkResetQueryPoolEXT(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCullModeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCullModeFlags cullMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCullModeFlags>(cullMode, settings, "VkCullModeFlags", "cullMode", 1, dump_html_VkCullModeFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetFrontFaceEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkFrontFace frontFace)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkFrontFace>(frontFace, settings, "VkFrontFace", "frontFace", 1, dump_html_VkFrontFace);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPrimitiveTopologyEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPrimitiveTopology>(primitiveTopology, settings, "VkPrimitiveTopology", "primitiveTopology", 1, dump_html_VkPrimitiveTopology);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewportWithCountEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewport>(pViewports, viewportCount, settings, "const VkViewport*", "const VkViewport", "pViewports", 1, dump_html_VkViewport); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetScissorWithCountEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(scissorCount, settings, "uint32_t", "scissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pScissors, scissorCount, settings, "const VkRect2D*", "const VkRect2D", "pScissors", 1, dump_html_VkRect2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindVertexBuffers2EXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstBinding, settings, "uint32_t", "firstBinding", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(bindingCount, settings, "uint32_t", "bindingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pBuffers, bindingCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", 1, dump_html_VkBuffer); // ZRZ
        dump_html_array<const VkDeviceSize>(pOffsets, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize); // ZRZ
        dump_html_array<const VkDeviceSize>(pSizes, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pSizes", 1, dump_html_VkDeviceSize); // ZRZ
        dump_html_array<const VkDeviceSize>(pStrides, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pStrides", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthTestEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthTestEnable, settings, "VkBool32", "depthTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthWriteEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthWriteEnable, settings, "VkBool32", "depthWriteEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthCompareOpEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCompareOp>(depthCompareOp, settings, "VkCompareOp", "depthCompareOp", 1, dump_html_VkCompareOp);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBoundsTestEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthBoundsTestEnable, settings, "VkBool32", "depthBoundsTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilTestEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(stencilTestEnable, settings, "VkBool32", "stencilTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetStencilOpEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const VkStencilOp>(failOp, settings, "VkStencilOp", "failOp", 1, dump_html_VkStencilOp);
        dump_html_value<const VkStencilOp>(passOp, settings, "VkStencilOp", "passOp", 1, dump_html_VkStencilOp);
        dump_html_value<const VkStencilOp>(depthFailOp, settings, "VkStencilOp", "depthFailOp", 1, dump_html_VkStencilOp);
        dump_html_value<const VkCompareOp>(compareOp, settings, "VkCompareOp", "compareOp", 1, dump_html_VkCompareOp);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateDeferredOperationKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDeferredOperationKHR>(pDeferredOperation, settings, "VkDeferredOperationKHR*", "pDeferredOperation", 1, dump_html_VkDeferredOperationKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyDeferredOperationKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(operation, settings, "VkDeferredOperationKHR", "operation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeferredOperationMaxConcurrencyKHR(ApiDumpInstance& dump_inst, uint32_t result, VkDevice device, VkDeferredOperationKHR operation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint32_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(operation, settings, "VkDeferredOperationKHR", "operation", 1, dump_html_VkDeferredOperationKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeferredOperationResultKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR operation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(operation, settings, "VkDeferredOperationKHR", "operation", 1, dump_html_VkDeferredOperationKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDeferredOperationJoinKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR operation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(operation, settings, "VkDeferredOperationKHR", "operation", 1, dump_html_VkDeferredOperationKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelineExecutablePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                        device, const VkPipelineInfoKHR*        pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineInfoKHR>(pPipelineInfo, settings, "const VkPipelineInfoKHR*", "pPipelineInfo", 1, dump_html_VkPipelineInfoKHR);
        dump_html_pointer<const uint32_t>(pExecutableCount, settings, "uint32_t*", "pExecutableCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineExecutablePropertiesKHR>(pProperties, *pExecutableCount, settings, "VkPipelineExecutablePropertiesKHR*", "VkPipelineExecutablePropertiesKHR", "pProperties", 1, dump_html_VkPipelineExecutablePropertiesKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelineExecutableStatisticsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                        device, const VkPipelineExecutableInfoKHR*  pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineExecutableInfoKHR>(pExecutableInfo, settings, "const VkPipelineExecutableInfoKHR*", "pExecutableInfo", 1, dump_html_VkPipelineExecutableInfoKHR);
        dump_html_pointer<const uint32_t>(pStatisticCount, settings, "uint32_t*", "pStatisticCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineExecutableStatisticKHR>(pStatistics, *pStatisticCount, settings, "VkPipelineExecutableStatisticKHR*", "VkPipelineExecutableStatisticKHR", "pStatistics", 1, dump_html_VkPipelineExecutableStatisticKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelineExecutableInternalRepresentationsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                        device, const VkPipelineExecutableInfoKHR*  pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineExecutableInfoKHR>(pExecutableInfo, settings, "const VkPipelineExecutableInfoKHR*", "pExecutableInfo", 1, dump_html_VkPipelineExecutableInfoKHR);
        dump_html_pointer<const uint32_t>(pInternalRepresentationCount, settings, "uint32_t*", "pInternalRepresentationCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineExecutableInternalRepresentationKHR>(pInternalRepresentations, *pInternalRepresentationCount, settings, "VkPipelineExecutableInternalRepresentationKHR*", "VkPipelineExecutableInternalRepresentationKHR", "pInternalRepresentations", 1, dump_html_VkPipelineExecutableInternalRepresentationKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyMemoryToImageEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCopyMemoryToImageInfoEXT>(pCopyMemoryToImageInfo, settings, "const VkCopyMemoryToImageInfoEXT*", "pCopyMemoryToImageInfo", 1, dump_html_VkCopyMemoryToImageInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyImageToMemoryEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCopyImageToMemoryInfoEXT>(pCopyImageToMemoryInfo, settings, "const VkCopyImageToMemoryInfoEXT*", "pCopyImageToMemoryInfo", 1, dump_html_VkCopyImageToMemoryInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyImageToImageEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCopyImageToImageInfoEXT>(pCopyImageToImageInfo, settings, "const VkCopyImageToImageInfoEXT*", "pCopyImageToImageInfo", 1, dump_html_VkCopyImageToImageInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkTransitionImageLayoutEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT* pTransitions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(transitionCount, settings, "uint32_t", "transitionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkHostImageLayoutTransitionInfoEXT>(pTransitions, transitionCount, settings, "const VkHostImageLayoutTransitionInfoEXT*", "const VkHostImageLayoutTransitionInfoEXT", "pTransitions", 1, dump_html_VkHostImageLayoutTransitionInfoEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageSubresourceLayout2KHR(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkImageSubresource2KHR>(pSubresource, settings, "const VkImageSubresource2KHR*", "pSubresource", 1, dump_html_VkImageSubresource2KHR);
        dump_html_pointer<const VkSubresourceLayout2KHR>(pLayout, settings, "VkSubresourceLayout2KHR*", "pLayout", 1, dump_html_VkSubresourceLayout2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageSubresourceLayout2EXT(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkImageSubresource2KHR>(pSubresource, settings, "const VkImageSubresource2KHR*", "pSubresource", 1, dump_html_VkImageSubresource2KHR);
        dump_html_pointer<const VkSubresourceLayout2KHR>(pLayout, settings, "VkSubresourceLayout2KHR*", "pLayout", 1, dump_html_VkSubresourceLayout2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkMapMemory2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryMapInfoKHR>(pMemoryMapInfo, settings, "const VkMemoryMapInfoKHR*", "pMemoryMapInfo", 1, dump_html_VkMemoryMapInfoKHR);
        dump_html_pointer<const void*>(ppData, settings, "void**", "ppData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkUnmapMemory2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryUnmapInfoKHR>(pMemoryUnmapInfo, settings, "const VkMemoryUnmapInfoKHR*", "pMemoryUnmapInfo", 1, dump_html_VkMemoryUnmapInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkReleaseSwapchainImagesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkReleaseSwapchainImagesInfoEXT>(pReleaseInfo, settings, "const VkReleaseSwapchainImagesInfoEXT*", "pReleaseInfo", 1, dump_html_VkReleaseSwapchainImagesInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetGeneratedCommandsMemoryRequirementsNV(ApiDumpInstance& dump_inst, VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkGeneratedCommandsMemoryRequirementsInfoNV>(pInfo, settings, "const VkGeneratedCommandsMemoryRequirementsInfoNV*", "pInfo", 1, dump_html_VkGeneratedCommandsMemoryRequirementsInfoNV);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPreprocessGeneratedCommandsNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkGeneratedCommandsInfoNV>(pGeneratedCommandsInfo, settings, "const VkGeneratedCommandsInfoNV*", "pGeneratedCommandsInfo", 1, dump_html_VkGeneratedCommandsInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdExecuteGeneratedCommandsNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(isPreprocessed, settings, "VkBool32", "isPreprocessed", 1, dump_html_VkBool32);
        dump_html_pointer<const VkGeneratedCommandsInfoNV>(pGeneratedCommandsInfo, settings, "const VkGeneratedCommandsInfoNV*", "pGeneratedCommandsInfo", 1, dump_html_VkGeneratedCommandsInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindPipelineShaderGroupNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(groupIndex, settings, "uint32_t", "groupIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateIndirectCommandsLayoutNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkIndirectCommandsLayoutCreateInfoNV>(pCreateInfo, settings, "const VkIndirectCommandsLayoutCreateInfoNV*", "pCreateInfo", 1, dump_html_VkIndirectCommandsLayoutCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkIndirectCommandsLayoutNV>(pIndirectCommandsLayout, settings, "VkIndirectCommandsLayoutNV*", "pIndirectCommandsLayout", 1, dump_html_VkIndirectCommandsLayoutNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyIndirectCommandsLayoutNV(ApiDumpInstance& dump_inst, VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkIndirectCommandsLayoutNV>(indirectCommandsLayout, settings, "VkIndirectCommandsLayoutNV", "indirectCommandsLayout", 1, dump_html_VkIndirectCommandsLayoutNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBias2EXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT*         pDepthBiasInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDepthBiasInfoEXT>(pDepthBiasInfo, settings, "const VkDepthBiasInfoEXT*", "pDepthBiasInfo", 1, dump_html_VkDepthBiasInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkAcquireDrmDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const int32_t>(drmFd, settings, "int32_t", "drmFd", 1, dump_html_int32_t);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDrmDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const int32_t>(drmFd, settings, "int32_t", "drmFd", 1, dump_html_int32_t);
        dump_html_value<const uint32_t>(connectorId, settings, "uint32_t", "connectorId", 1, dump_html_uint32_t);
        dump_html_pointer<const VkDisplayKHR>(display, settings, "VkDisplayKHR*", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreatePrivateDataSlotEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPrivateDataSlotCreateInfo>(pCreateInfo, settings, "const VkPrivateDataSlotCreateInfo*", "pCreateInfo", 1, dump_html_VkPrivateDataSlotCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkPrivateDataSlot>(pPrivateDataSlot, settings, "VkPrivateDataSlot*", "pPrivateDataSlot", 1, dump_html_VkPrivateDataSlot);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyPrivateDataSlotEXT(ApiDumpInstance& dump_inst, VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPrivateDataSlot>(privateDataSlot, settings, "VkPrivateDataSlot", "privateDataSlot", 1, dump_html_VkPrivateDataSlot);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetPrivateDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectType>(objectType, settings, "VkObjectType", "objectType", 1, dump_html_VkObjectType);
        dump_html_value<const uint64_t>(objectHandle, settings, "uint64_t", "objectHandle", 1, dump_html_uint64_t);
        dump_html_value<const VkPrivateDataSlot>(privateDataSlot, settings, "VkPrivateDataSlot", "privateDataSlot", 1, dump_html_VkPrivateDataSlot);
        dump_html_value<const uint64_t>(data, settings, "uint64_t", "data", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPrivateDataEXT(ApiDumpInstance& dump_inst, VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectType>(objectType, settings, "VkObjectType", "objectType", 1, dump_html_VkObjectType);
        dump_html_value<const uint64_t>(objectHandle, settings, "uint64_t", "objectHandle", 1, dump_html_uint64_t);
        dump_html_value<const VkPrivateDataSlot>(privateDataSlot, settings, "VkPrivateDataSlot", "privateDataSlot", 1, dump_html_VkPrivateDataSlot);
        dump_html_pointer<const uint64_t>(pData, settings, "uint64_t*", "pData", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>(pQualityLevelInfo, settings, "const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*", "pQualityLevelInfo", 1, dump_html_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR);
        dump_html_pointer<const VkVideoEncodeQualityLevelPropertiesKHR>(pQualityLevelProperties, settings, "VkVideoEncodeQualityLevelPropertiesKHR*", "pQualityLevelProperties", 1, dump_html_VkVideoEncodeQualityLevelPropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetEncodedVideoSessionParametersKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkVideoEncodeSessionParametersGetInfoKHR>(pVideoSessionParametersInfo, settings, "const VkVideoEncodeSessionParametersGetInfoKHR*", "pVideoSessionParametersInfo", 1, dump_html_VkVideoEncodeSessionParametersGetInfoKHR);
        dump_html_pointer<const VkVideoEncodeSessionParametersFeedbackInfoKHR>(pFeedbackInfo, settings, "VkVideoEncodeSessionParametersFeedbackInfoKHR*", "pFeedbackInfo", 1, dump_html_VkVideoEncodeSessionParametersFeedbackInfoKHR);
        dump_html_pointer<const size_t>(pDataSize, settings, "size_t*", "pDataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdEncodeVideoKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR* pEncodeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkVideoEncodeInfoKHR>(pEncodeInfo, settings, "const VkVideoEncodeInfoKHR*", "pEncodeInfo", 1, dump_html_VkVideoEncodeInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateCudaModuleNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCudaModuleCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCudaModuleNV* pModule)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCudaModuleCreateInfoNV>(pCreateInfo, settings, "const VkCudaModuleCreateInfoNV*", "pCreateInfo", 1, dump_html_VkCudaModuleCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkCudaModuleNV>(pModule, settings, "VkCudaModuleNV*", "pModule", 1, dump_html_VkCudaModuleNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetCudaModuleCacheNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkCudaModuleNV module, size_t* pCacheSize, void* pCacheData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCudaModuleNV>(module, settings, "VkCudaModuleNV", "module", 1, dump_html_VkCudaModuleNV);
        dump_html_pointer<const size_t>(pCacheSize, settings, "size_t*", "pCacheSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pCacheData, settings, "void*", "pCacheData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateCudaFunctionNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCudaFunctionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCudaFunctionNV* pFunction)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCudaFunctionCreateInfoNV>(pCreateInfo, settings, "const VkCudaFunctionCreateInfoNV*", "pCreateInfo", 1, dump_html_VkCudaFunctionCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkCudaFunctionNV>(pFunction, settings, "VkCudaFunctionNV*", "pFunction", 1, dump_html_VkCudaFunctionNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyCudaModuleNV(ApiDumpInstance& dump_inst, VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCudaModuleNV>(module, settings, "VkCudaModuleNV", "module", 1, dump_html_VkCudaModuleNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyCudaFunctionNV(ApiDumpInstance& dump_inst, VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCudaFunctionNV>(function, settings, "VkCudaFunctionNV", "function", 1, dump_html_VkCudaFunctionNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCudaLaunchKernelNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV* pLaunchInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCudaLaunchInfoNV>(pLaunchInfo, settings, "const VkCudaLaunchInfoNV*", "pLaunchInfo", 1, dump_html_VkCudaLaunchInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
void dump_html_vkExportMetalObjectsEXT(ApiDumpInstance& dump_inst, VkDevice device, VkExportMetalObjectsInfoEXT* pMetalObjectsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkExportMetalObjectsInfoEXT>(pMetalObjectsInfo, settings, "VkExportMetalObjectsInfoEXT*", "pMetalObjectsInfo", 1, dump_html_VkExportMetalObjectsInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
void dump_html_vkCmdSetEvent2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkEvent                                             event, const VkDependencyInfo*                             pDependencyInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_pointer<const VkDependencyInfo>(pDependencyInfo, settings, "const VkDependencyInfo*", "pDependencyInfo", 1, dump_html_VkDependencyInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResetEvent2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkEvent                                             event, VkPipelineStageFlags2               stageMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags2>(stageMask, settings, "VkPipelineStageFlags2", "stageMask", 1, dump_html_VkPipelineStageFlags2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWaitEvents2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, uint32_t                                            eventCount, const VkEvent*                     pEvents, const VkDependencyInfo*            pDependencyInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(eventCount, settings, "uint32_t", "eventCount", 1, dump_html_uint32_t);
        dump_html_array<const VkEvent>(pEvents, eventCount, settings, "const VkEvent*", "const VkEvent", "pEvents", 1, dump_html_VkEvent); // ZRZ
        dump_html_array<const VkDependencyInfo>(pDependencyInfos, eventCount, settings, "const VkDependencyInfo*", "const VkDependencyInfo", "pDependencyInfos", 1, dump_html_VkDependencyInfo); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPipelineBarrier2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, const VkDependencyInfo*                             pDependencyInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDependencyInfo>(pDependencyInfo, settings, "const VkDependencyInfo*", "pDependencyInfo", 1, dump_html_VkDependencyInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteTimestamp2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkQueryPool                                         queryPool, uint32_t                                            query)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlags2>(stage, settings, "VkPipelineStageFlags2", "stage", 1, dump_html_VkPipelineStageFlags2);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueSubmit2KHR(ApiDumpInstance& dump_inst, VkResult result, VkQueue                           queue, uint32_t                            submitCount, const VkSubmitInfo2*              pSubmits, VkFence           fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const uint32_t>(submitCount, settings, "uint32_t", "submitCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSubmitInfo2>(pSubmits, submitCount, settings, "const VkSubmitInfo2*", "const VkSubmitInfo2", "pSubmits", 1, dump_html_VkSubmitInfo2); // ZRZ
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteBufferMarker2AMD(ApiDumpInstance& dump_inst, VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkBuffer                                            dstBuffer, VkDeviceSize                                        dstOffset, uint32_t                                            marker)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlags2>(stage, settings, "VkPipelineStageFlags2", "stage", 1, dump_html_VkPipelineStageFlags2);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(marker, settings, "uint32_t", "marker", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetQueueCheckpointData2NV(ApiDumpInstance& dump_inst, VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const uint32_t>(pCheckpointDataCount, settings, "uint32_t*", "pCheckpointDataCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCheckpointData2NV>(pCheckpointData, *pCheckpointDataCount, settings, "VkCheckpointData2NV*", "VkCheckpointData2NV", "pCheckpointData", 1, dump_html_VkCheckpointData2NV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorSetLayoutSizeEXT(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSetLayout>(layout, settings, "VkDescriptorSetLayout", "layout", 1, dump_html_VkDescriptorSetLayout);
        dump_html_pointer<const VkDeviceSize>(pLayoutSizeInBytes, settings, "VkDeviceSize*", "pLayoutSizeInBytes", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorSetLayoutBindingOffsetEXT(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSetLayout>(layout, settings, "VkDescriptorSetLayout", "layout", 1, dump_html_VkDescriptorSetLayout);
        dump_html_value<const uint32_t>(binding, settings, "uint32_t", "binding", 1, dump_html_uint32_t);
        dump_html_pointer<const VkDeviceSize>(pOffset, settings, "VkDeviceSize*", "pOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorGetInfoEXT>(pDescriptorInfo, settings, "const VkDescriptorGetInfoEXT*", "pDescriptorInfo", 1, dump_html_VkDescriptorGetInfoEXT);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pDescriptor, settings, "void*", "pDescriptor", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindDescriptorBuffersEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(bufferCount, settings, "uint32_t", "bufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDescriptorBufferBindingInfoEXT>(pBindingInfos, bufferCount, settings, "const VkDescriptorBufferBindingInfoEXT*", "const VkDescriptorBufferBindingInfoEXT", "pBindingInfos", 1, dump_html_VkDescriptorBufferBindingInfoEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDescriptorBufferOffsetsEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(firstSet, settings, "uint32_t", "firstSet", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(setCount, settings, "uint32_t", "setCount", 1, dump_html_uint32_t);
        dump_html_array<const uint32_t>(pBufferIndices, setCount, settings, "const uint32_t*", "const uint32_t", "pBufferIndices", 1, dump_html_uint32_t); // ZRZ
        dump_html_array<const VkDeviceSize>(pOffsets, setCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(set, settings, "uint32_t", "set", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetBufferOpaqueCaptureDescriptorDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferCaptureDescriptorDataInfoEXT>(pInfo, settings, "const VkBufferCaptureDescriptorDataInfoEXT*", "pInfo", 1, dump_html_VkBufferCaptureDescriptorDataInfoEXT);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageOpaqueCaptureDescriptorDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageCaptureDescriptorDataInfoEXT>(pInfo, settings, "const VkImageCaptureDescriptorDataInfoEXT*", "pInfo", 1, dump_html_VkImageCaptureDescriptorDataInfoEXT);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetImageViewOpaqueCaptureDescriptorDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageViewCaptureDescriptorDataInfoEXT>(pInfo, settings, "const VkImageViewCaptureDescriptorDataInfoEXT*", "pInfo", 1, dump_html_VkImageViewCaptureDescriptorDataInfoEXT);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetSamplerOpaqueCaptureDescriptorDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerCaptureDescriptorDataInfoEXT>(pInfo, settings, "const VkSamplerCaptureDescriptorDataInfoEXT*", "pInfo", 1, dump_html_VkSamplerCaptureDescriptorDataInfoEXT);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureCaptureDescriptorDataInfoEXT>(pInfo, settings, "const VkAccelerationStructureCaptureDescriptorDataInfoEXT*", "pInfo", 1, dump_html_VkAccelerationStructureCaptureDescriptorDataInfoEXT);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetFragmentShadingRateEnumNV(ApiDumpInstance& dump_inst, VkCommandBuffer           commandBuffer, VkFragmentShadingRateNV                     shadingRate, const VkFragmentShadingRateCombinerOpKHR    combinerOps[2])
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkFragmentShadingRateNV>(shadingRate, settings, "VkFragmentShadingRateNV", "shadingRate", 1, dump_html_VkFragmentShadingRateNV);
        dump_html_array<const VkFragmentShadingRateCombinerOpKHR>(combinerOps, 2, settings, "const VkFragmentShadingRateCombinerOpKHR[2]", "const VkFragmentShadingRateCombinerOpKHR", "combinerOps", 1, dump_html_VkFragmentShadingRateCombinerOpKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMeshTasksEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMeshTasksIndirectEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMeshTasksIndirectCountEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyBuffer2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyBufferInfo2>(pCopyBufferInfo, settings, "const VkCopyBufferInfo2*", "pCopyBufferInfo", 1, dump_html_VkCopyBufferInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyImage2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyImageInfo2>(pCopyImageInfo, settings, "const VkCopyImageInfo2*", "pCopyImageInfo", 1, dump_html_VkCopyImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyBufferToImage2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyBufferToImageInfo2>(pCopyBufferToImageInfo, settings, "const VkCopyBufferToImageInfo2*", "pCopyBufferToImageInfo", 1, dump_html_VkCopyBufferToImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyImageToBuffer2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyImageToBufferInfo2>(pCopyImageToBufferInfo, settings, "const VkCopyImageToBufferInfo2*", "pCopyImageToBufferInfo", 1, dump_html_VkCopyImageToBufferInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBlitImage2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkBlitImageInfo2>(pBlitImageInfo, settings, "const VkBlitImageInfo2*", "pBlitImageInfo", 1, dump_html_VkBlitImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdResolveImage2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkResolveImageInfo2>(pResolveImageInfo, settings, "const VkResolveImageInfo2*", "pResolveImageInfo", 1, dump_html_VkResolveImageInfo2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceFaultInfoEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceFaultCountsEXT>(pFaultCounts, settings, "VkDeviceFaultCountsEXT*", "pFaultCounts", 1, dump_html_VkDeviceFaultCountsEXT);
        dump_html_pointer<const VkDeviceFaultInfoEXT>(pFaultInfo, settings, "VkDeviceFaultInfoEXT*", "pFaultInfo", 1, dump_html_VkDeviceFaultInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkAcquireWinrtDisplayNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
void dump_html_vkGetWinrtDisplayNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR* pDisplay)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(deviceRelativeId, settings, "uint32_t", "deviceRelativeId", 1, dump_html_uint32_t);
        dump_html_pointer<const VkDisplayKHR>(pDisplay, settings, "VkDisplayKHR*", "pDisplay", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
void dump_html_vkCreateDirectFBSurfaceEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDirectFBSurfaceCreateInfoEXT>(pCreateInfo, settings, "const VkDirectFBSurfaceCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkDirectFBSurfaceCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
void dump_html_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB* dfb)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const IDirectFB>(dfb, settings, "IDirectFB*", "dfb", 1, dump_html_IDirectFB);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT
void dump_html_vkCmdTraceRaysKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pRaygenShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pRaygenShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pMissShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pMissShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pHitShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pHitShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pCallableShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pCallableShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_value<const uint32_t>(width, settings, "uint32_t", "width", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(height, settings, "uint32_t", "height", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(depth, settings, "uint32_t", "depth", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateRayTracingPipelinesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRayTracingPipelineCreateInfoKHR>(pCreateInfos, createInfoCount, settings, "const VkRayTracingPipelineCreateInfoKHR*", "const VkRayTracingPipelineCreateInfoKHR", "pCreateInfos", 1, dump_html_VkRayTracingPipelineCreateInfoKHR); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(firstGroup, settings, "uint32_t", "firstGroup", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCount, settings, "uint32_t", "groupCount", 1, dump_html_uint32_t);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdTraceRaysIndirectKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pRaygenShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pRaygenShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pMissShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pMissShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pHitShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pHitShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_pointer<const VkStridedDeviceAddressRegionKHR>(pCallableShaderBindingTable, settings, "const VkStridedDeviceAddressRegionKHR*", "pCallableShaderBindingTable", 1, dump_html_VkStridedDeviceAddressRegionKHR);
        dump_html_value<const VkDeviceAddress>(indirectDeviceAddress, settings, "VkDeviceAddress", "indirectDeviceAddress", 1, dump_html_VkDeviceAddress);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRayTracingShaderGroupStackSizeKHR(ApiDumpInstance& dump_inst, VkDeviceSize result, VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceSize(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(group, settings, "uint32_t", "group", 1, dump_html_uint32_t);
        dump_html_value<const VkShaderGroupShaderKHR>(groupShader, settings, "VkShaderGroupShaderKHR", "groupShader", 1, dump_html_VkShaderGroupShaderKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRayTracingPipelineStackSizeKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t pipelineStackSize)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(pipelineStackSize, settings, "uint32_t", "pipelineStackSize", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetVertexInputEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(vertexBindingDescriptionCount, settings, "uint32_t", "vertexBindingDescriptionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkVertexInputBindingDescription2EXT>(pVertexBindingDescriptions, vertexBindingDescriptionCount, settings, "const VkVertexInputBindingDescription2EXT*", "const VkVertexInputBindingDescription2EXT", "pVertexBindingDescriptions", 1, dump_html_VkVertexInputBindingDescription2EXT); // ZRZ
        dump_html_value<const uint32_t>(vertexAttributeDescriptionCount, settings, "uint32_t", "vertexAttributeDescriptionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkVertexInputAttributeDescription2EXT>(pVertexAttributeDescriptions, vertexAttributeDescriptionCount, settings, "const VkVertexInputAttributeDescription2EXT*", "const VkVertexInputAttributeDescription2EXT", "pVertexAttributeDescriptions", 1, dump_html_VkVertexInputAttributeDescription2EXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkGetMemoryZirconHandleFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetZirconHandleInfoFUCHSIA>(pGetZirconHandleInfo, settings, "const VkMemoryGetZirconHandleInfoFUCHSIA*", "pGetZirconHandleInfo", 1, dump_html_VkMemoryGetZirconHandleInfoFUCHSIA);
        dump_html_pointer<const zx_handle_t>(pZirconHandle, settings, "zx_handle_t*", "pZirconHandle", 1, dump_html_zx_handle_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkGetMemoryZirconHandlePropertiesFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const zx_handle_t>(zirconHandle, settings, "zx_handle_t", "zirconHandle", 1, dump_html_zx_handle_t);
        dump_html_pointer<const VkMemoryZirconHandlePropertiesFUCHSIA>(pMemoryZirconHandleProperties, settings, "VkMemoryZirconHandlePropertiesFUCHSIA*", "pMemoryZirconHandleProperties", 1, dump_html_VkMemoryZirconHandlePropertiesFUCHSIA);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkImportSemaphoreZirconHandleFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportSemaphoreZirconHandleInfoFUCHSIA>(pImportSemaphoreZirconHandleInfo, settings, "const VkImportSemaphoreZirconHandleInfoFUCHSIA*", "pImportSemaphoreZirconHandleInfo", 1, dump_html_VkImportSemaphoreZirconHandleInfoFUCHSIA);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkGetSemaphoreZirconHandleFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreGetZirconHandleInfoFUCHSIA>(pGetZirconHandleInfo, settings, "const VkSemaphoreGetZirconHandleInfoFUCHSIA*", "pGetZirconHandleInfo", 1, dump_html_VkSemaphoreGetZirconHandleInfoFUCHSIA);
        dump_html_pointer<const zx_handle_t>(pZirconHandle, settings, "zx_handle_t*", "pZirconHandle", 1, dump_html_zx_handle_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkCreateBufferCollectionFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferCollectionFUCHSIA* pCollection)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferCollectionCreateInfoFUCHSIA>(pCreateInfo, settings, "const VkBufferCollectionCreateInfoFUCHSIA*", "pCreateInfo", 1, dump_html_VkBufferCollectionCreateInfoFUCHSIA);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkBufferCollectionFUCHSIA>(pCollection, settings, "VkBufferCollectionFUCHSIA*", "pCollection", 1, dump_html_VkBufferCollectionFUCHSIA);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkSetBufferCollectionImageConstraintsFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBufferCollectionFUCHSIA>(collection, settings, "VkBufferCollectionFUCHSIA", "collection", 1, dump_html_VkBufferCollectionFUCHSIA);
        dump_html_pointer<const VkImageConstraintsInfoFUCHSIA>(pImageConstraintsInfo, settings, "const VkImageConstraintsInfoFUCHSIA*", "pImageConstraintsInfo", 1, dump_html_VkImageConstraintsInfoFUCHSIA);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkSetBufferCollectionBufferConstraintsFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBufferCollectionFUCHSIA>(collection, settings, "VkBufferCollectionFUCHSIA", "collection", 1, dump_html_VkBufferCollectionFUCHSIA);
        dump_html_pointer<const VkBufferConstraintsInfoFUCHSIA>(pBufferConstraintsInfo, settings, "const VkBufferConstraintsInfoFUCHSIA*", "pBufferConstraintsInfo", 1, dump_html_VkBufferConstraintsInfoFUCHSIA);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkDestroyBufferCollectionFUCHSIA(ApiDumpInstance& dump_inst, VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBufferCollectionFUCHSIA>(collection, settings, "VkBufferCollectionFUCHSIA", "collection", 1, dump_html_VkBufferCollectionFUCHSIA);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_FUCHSIA)
void dump_html_vkGetBufferCollectionPropertiesFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBufferCollectionFUCHSIA>(collection, settings, "VkBufferCollectionFUCHSIA", "collection", 1, dump_html_VkBufferCollectionFUCHSIA);
        dump_html_pointer<const VkBufferCollectionPropertiesFUCHSIA>(pProperties, settings, "VkBufferCollectionPropertiesFUCHSIA*", "pProperties", 1, dump_html_VkBufferCollectionPropertiesFUCHSIA);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
void dump_html_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkRenderPass>(renderpass, settings, "VkRenderPass", "renderpass", 1, dump_html_VkRenderPass);
        dump_html_array<const VkExtent2D>(pMaxWorkgroupSize, 1, settings, "VkExtent2D*", "VkExtent2D", "pMaxWorkgroupSize", 1, dump_html_VkExtent2D); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSubpassShadingHUAWEI(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindInvocationMaskHUAWEI(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImageView>(imageView, settings, "VkImageView", "imageView", 1, dump_html_VkImageView);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetMemoryRemoteAddressNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetRemoteAddressInfoNV>(pMemoryGetRemoteAddressInfo, settings, "const VkMemoryGetRemoteAddressInfoNV*", "pMemoryGetRemoteAddressInfo", 1, dump_html_VkMemoryGetRemoteAddressInfoNV);
        dump_html_pointer<const VkRemoteAddressNV>(pAddress, settings, "VkRemoteAddressNV*", "pAddress", 1, dump_html_VkRemoteAddressNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelinePropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineInfoKHR>(pPipelineInfo, settings, "const VkPipelineInfoEXT*", "pPipelineInfo", 1, dump_html_VkPipelineInfoKHR);
        dump_html_pointer<const VkBaseOutStructure>(pPipelineProperties, settings, "VkBaseOutStructure*", "pPipelineProperties", 1, dump_html_VkBaseOutStructure);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPatchControlPointsEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t patchControlPoints)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(patchControlPoints, settings, "uint32_t", "patchControlPoints", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRasterizerDiscardEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(rasterizerDiscardEnable, settings, "VkBool32", "rasterizerDiscardEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthBiasEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthBiasEnable, settings, "VkBool32", "depthBiasEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLogicOpEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkLogicOp logicOp)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkLogicOp>(logicOp, settings, "VkLogicOp", "logicOp", 1, dump_html_VkLogicOp);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPrimitiveRestartEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(primitiveRestartEnable, settings, "VkBool32", "primitiveRestartEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_vkCreateScreenSurfaceQNX(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkScreenSurfaceCreateInfoQNX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkScreenSurfaceCreateInfoQNX>(pCreateInfo, settings, "const VkScreenSurfaceCreateInfoQNX*", "pCreateInfo", 1, dump_html_VkScreenSurfaceCreateInfoQNX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_vkGetPhysicalDeviceScreenPresentationSupportQNX(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window* window)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const _screen_window*>(window, settings, "struct _screen_window*", "window", 1, dump_html__screen_window);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
void dump_html_vkCmdSetColorWriteEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer       commandBuffer, uint32_t                                attachmentCount, const VkBool32*   pColorWriteEnables)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBool32>(pColorWriteEnables, attachmentCount, settings, "const VkBool32*", "const VkBool32", "pColorWriteEnables", 1, dump_html_VkBool32); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdTraceRaysIndirect2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(indirectDeviceAddress, settings, "VkDeviceAddress", "indirectDeviceAddress", 1, dump_html_VkDeviceAddress);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMultiEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMultiDrawInfoEXT>(pVertexInfo, drawCount, settings, "const VkMultiDrawInfoEXT*", "const VkMultiDrawInfoEXT", "pVertexInfo", 1, dump_html_VkMultiDrawInfoEXT); // ZRZ
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawMultiIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMultiDrawIndexedInfoEXT>(pIndexInfo, drawCount, settings, "const VkMultiDrawIndexedInfoEXT*", "const VkMultiDrawIndexedInfoEXT", "pIndexInfo", 1, dump_html_VkMultiDrawIndexedInfoEXT); // ZRZ
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
        dump_html_pointer<const int32_t>(pVertexOffset, settings, "const int32_t*", "pVertexOffset", 1, dump_html_int32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateMicromapEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                           device, const VkMicromapCreateInfoEXT*        pCreateInfo, const VkAllocationCallbacks*       pAllocator, VkMicromapEXT*                        pMicromap)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMicromapCreateInfoEXT>(pCreateInfo, settings, "const VkMicromapCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkMicromapCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkMicromapEXT>(pMicromap, settings, "VkMicromapEXT*", "pMicromap", 1, dump_html_VkMicromapEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyMicromapEXT(ApiDumpInstance& dump_inst, VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkMicromapEXT>(micromap, settings, "VkMicromapEXT", "micromap", 1, dump_html_VkMicromapEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBuildMicromapsEXT(ApiDumpInstance& dump_inst, VkCommandBuffer                                    commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(infoCount, settings, "uint32_t", "infoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMicromapBuildInfoEXT>(pInfos, infoCount, settings, "const VkMicromapBuildInfoEXT*", "const VkMicromapBuildInfoEXT", "pInfos", 1, dump_html_VkMicromapBuildInfoEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBuildMicromapsEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice                                           device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_value<const uint32_t>(infoCount, settings, "uint32_t", "infoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMicromapBuildInfoEXT>(pInfos, infoCount, settings, "const VkMicromapBuildInfoEXT*", "const VkMicromapBuildInfoEXT", "pInfos", 1, dump_html_VkMicromapBuildInfoEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyMicromapEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkCopyMicromapInfoEXT>(pInfo, settings, "const VkCopyMicromapInfoEXT*", "pInfo", 1, dump_html_VkCopyMicromapInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyMicromapToMemoryEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkCopyMicromapToMemoryInfoEXT>(pInfo, settings, "const VkCopyMicromapToMemoryInfoEXT*", "pInfo", 1, dump_html_VkCopyMicromapToMemoryInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCopyMemoryToMicromapEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeferredOperationKHR>(deferredOperation, settings, "VkDeferredOperationKHR", "deferredOperation", 1, dump_html_VkDeferredOperationKHR);
        dump_html_pointer<const VkCopyMemoryToMicromapInfoEXT>(pInfo, settings, "const VkCopyMemoryToMicromapInfoEXT*", "pInfo", 1, dump_html_VkCopyMemoryToMicromapInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkWriteMicromapsPropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType  queryType, size_t       dataSize, void* pData, size_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(micromapCount, settings, "uint32_t", "micromapCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMicromapEXT>(pMicromaps, micromapCount, settings, "const VkMicromapEXT*", "const VkMicromapEXT", "pMicromaps", 1, dump_html_VkMicromapEXT); // ZRZ
        dump_html_value<const VkQueryType>(queryType, settings, "VkQueryType", "queryType", 1, dump_html_VkQueryType);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
        dump_html_value<const size_t>(stride, settings, "size_t", "stride", 1, dump_html_size_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyMicromapEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyMicromapInfoEXT>(pInfo, settings, "const VkCopyMicromapInfoEXT*", "pInfo", 1, dump_html_VkCopyMicromapInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyMicromapToMemoryEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyMicromapToMemoryInfoEXT>(pInfo, settings, "const VkCopyMicromapToMemoryInfoEXT*", "pInfo", 1, dump_html_VkCopyMicromapToMemoryInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyMemoryToMicromapEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCopyMemoryToMicromapInfoEXT>(pInfo, settings, "const VkCopyMemoryToMicromapInfoEXT*", "pInfo", 1, dump_html_VkCopyMemoryToMicromapInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdWriteMicromapsPropertiesEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(micromapCount, settings, "uint32_t", "micromapCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMicromapEXT>(pMicromaps, micromapCount, settings, "const VkMicromapEXT*", "const VkMicromapEXT", "pMicromaps", 1, dump_html_VkMicromapEXT); // ZRZ
        dump_html_value<const VkQueryType>(queryType, settings, "VkQueryType", "queryType", 1, dump_html_VkQueryType);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceMicromapCompatibilityEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMicromapVersionInfoEXT>(pVersionInfo, settings, "const VkMicromapVersionInfoEXT*", "pVersionInfo", 1, dump_html_VkMicromapVersionInfoEXT);
        dump_html_pointer<const VkAccelerationStructureCompatibilityKHR>(pCompatibility, settings, "VkAccelerationStructureCompatibilityKHR*", "pCompatibility", 1, dump_html_VkAccelerationStructureCompatibilityKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetMicromapBuildSizesEXT(ApiDumpInstance& dump_inst, VkDevice                                            device, VkAccelerationStructureBuildTypeKHR                 buildType, const VkMicromapBuildInfoEXT*  pBuildInfo, VkMicromapBuildSizesInfoEXT*           pSizeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureBuildTypeKHR>(buildType, settings, "VkAccelerationStructureBuildTypeKHR", "buildType", 1, dump_html_VkAccelerationStructureBuildTypeKHR);
        dump_html_pointer<const VkMicromapBuildInfoEXT>(pBuildInfo, settings, "const VkMicromapBuildInfoEXT*", "pBuildInfo", 1, dump_html_VkMicromapBuildInfoEXT);
        dump_html_pointer<const VkMicromapBuildSizesInfoEXT>(pSizeInfo, settings, "VkMicromapBuildSizesInfoEXT*", "pSizeInfo", 1, dump_html_VkMicromapBuildSizesInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawClusterHUAWEI(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDrawClusterIndirectHUAWEI(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetDeviceMemoryPriorityEXT(ApiDumpInstance& dump_inst, VkDevice       device, VkDeviceMemory memory, float          priority)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const float>(priority, settings, "float", "priority", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceBufferMemoryRequirementsKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceBufferMemoryRequirements>(pInfo, settings, "const VkDeviceBufferMemoryRequirements*", "pInfo", 1, dump_html_VkDeviceBufferMemoryRequirements);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceImageMemoryRequirementsKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceImageMemoryRequirements>(pInfo, settings, "const VkDeviceImageMemoryRequirements*", "pInfo", 1, dump_html_VkDeviceImageMemoryRequirements);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceImageSparseMemoryRequirementsKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceImageMemoryRequirements>(pInfo, settings, "const VkDeviceImageMemoryRequirements*", "pInfo", 1, dump_html_VkDeviceImageMemoryRequirements);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements2>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements2*", "VkSparseImageMemoryRequirements2", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements2); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorSetLayoutHostMappingInfoVALVE(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetBindingReferenceVALVE>(pBindingReference, settings, "const VkDescriptorSetBindingReferenceVALVE*", "pBindingReference", 1, dump_html_VkDescriptorSetBindingReferenceVALVE);
        dump_html_pointer<const VkDescriptorSetLayoutHostMappingInfoVALVE>(pHostMapping, settings, "VkDescriptorSetLayoutHostMappingInfoVALVE*", "pHostMapping", 1, dump_html_VkDescriptorSetLayoutHostMappingInfoVALVE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDescriptorSetHostMappingVALVE(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, void** ppData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSet>(descriptorSet, settings, "VkDescriptorSet", "descriptorSet", 1, dump_html_VkDescriptorSet);
        dump_html_pointer<const void*>(ppData, settings, "void**", "ppData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyMemoryIndirectNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(copyBufferAddress, settings, "VkDeviceAddress", "copyBufferAddress", 1, dump_html_VkDeviceAddress);
        dump_html_value<const uint32_t>(copyCount, settings, "uint32_t", "copyCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdCopyMemoryToImageIndirectNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(copyBufferAddress, settings, "VkDeviceAddress", "copyBufferAddress", 1, dump_html_VkDeviceAddress);
        dump_html_value<const uint32_t>(copyCount, settings, "uint32_t", "copyCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_array<const VkImageSubresourceLayers>(pImageSubresources, copyCount, settings, "const VkImageSubresourceLayers*", "const VkImageSubresourceLayers", "pImageSubresources", 1, dump_html_VkImageSubresourceLayers); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDecompressMemoryNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(decompressRegionCount, settings, "uint32_t", "decompressRegionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDecompressMemoryRegionNV>(pDecompressMemoryRegions, decompressRegionCount, settings, "const VkDecompressMemoryRegionNV*", "const VkDecompressMemoryRegionNV", "pDecompressMemoryRegions", 1, dump_html_VkDecompressMemoryRegionNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdDecompressMemoryIndirectCountNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDeviceAddress>(indirectCommandsAddress, settings, "VkDeviceAddress", "indirectCommandsAddress", 1, dump_html_VkDeviceAddress);
        dump_html_value<const VkDeviceAddress>(indirectCommandsCountAddress, settings, "VkDeviceAddress", "indirectCommandsCountAddress", 1, dump_html_VkDeviceAddress);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelineIndirectMemoryRequirementsNV(ApiDumpInstance& dump_inst, VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkComputePipelineCreateInfo>(pCreateInfo, settings, "const VkComputePipelineCreateInfo*", "pCreateInfo", 1, dump_html_VkComputePipelineCreateInfo);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdUpdatePipelineIndirectBufferNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint           pipelineBindPoint, VkPipeline                    pipeline)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPipelineIndirectDeviceAddressNV(ApiDumpInstance& dump_inst, VkDeviceAddress result, VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceAddress(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineIndirectDeviceAddressInfoNV>(pInfo, settings, "const VkPipelineIndirectDeviceAddressInfoNV*", "pInfo", 1, dump_html_VkPipelineIndirectDeviceAddressInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthClampEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthClampEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthClampEnable, settings, "VkBool32", "depthClampEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetPolygonModeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPolygonMode polygonMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPolygonMode>(polygonMode, settings, "VkPolygonMode", "polygonMode", 1, dump_html_VkPolygonMode);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRasterizationSamplesEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkSampleCountFlagBits  rasterizationSamples)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkSampleCountFlagBits>(rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", 1, dump_html_VkSampleCountFlagBits);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetSampleMaskEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkSampleCountFlagBits  samples, const VkSampleMask*    pSampleMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkSampleCountFlagBits>(samples, settings, "VkSampleCountFlagBits", "samples", 1, dump_html_VkSampleCountFlagBits);
        dump_html_array<const VkSampleMask>(pSampleMask, (samples + 31) / 32, settings, "const VkSampleMask*", "const VkSampleMask", "pSampleMask", 1, dump_html_VkSampleMask); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetAlphaToCoverageEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(alphaToCoverageEnable, settings, "VkBool32", "alphaToCoverageEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetAlphaToOneEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(alphaToOneEnable, settings, "VkBool32", "alphaToOneEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLogicOpEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 logicOpEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(logicOpEnable, settings, "VkBool32", "logicOpEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetColorBlendEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstAttachment, settings, "uint32_t", "firstAttachment", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBool32>(pColorBlendEnables, attachmentCount, settings, "const VkBool32*", "const VkBool32", "pColorBlendEnables", 1, dump_html_VkBool32); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetColorBlendEquationEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstAttachment, settings, "uint32_t", "firstAttachment", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkColorBlendEquationEXT>(pColorBlendEquations, attachmentCount, settings, "const VkColorBlendEquationEXT*", "const VkColorBlendEquationEXT", "pColorBlendEquations", 1, dump_html_VkColorBlendEquationEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetColorWriteMaskEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstAttachment, settings, "uint32_t", "firstAttachment", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkColorComponentFlags>(pColorWriteMasks, attachmentCount, settings, "const VkColorComponentFlags*", "const VkColorComponentFlags", "pColorWriteMasks", 1, dump_html_VkColorComponentFlags); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetTessellationDomainOriginEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkTessellationDomainOrigin>(domainOrigin, settings, "VkTessellationDomainOrigin", "domainOrigin", 1, dump_html_VkTessellationDomainOrigin);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRasterizationStreamEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t rasterizationStream)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(rasterizationStream, settings, "uint32_t", "rasterizationStream", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetConservativeRasterizationModeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkConservativeRasterizationModeEXT>(conservativeRasterizationMode, settings, "VkConservativeRasterizationModeEXT", "conservativeRasterizationMode", 1, dump_html_VkConservativeRasterizationModeEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetExtraPrimitiveOverestimationSizeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(extraPrimitiveOverestimationSize, settings, "float", "extraPrimitiveOverestimationSize", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthClipEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 depthClipEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(depthClipEnable, settings, "VkBool32", "depthClipEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetSampleLocationsEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(sampleLocationsEnable, settings, "VkBool32", "sampleLocationsEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetColorBlendAdvancedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstAttachment, settings, "uint32_t", "firstAttachment", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkColorBlendAdvancedEXT>(pColorBlendAdvanced, attachmentCount, settings, "const VkColorBlendAdvancedEXT*", "const VkColorBlendAdvancedEXT", "pColorBlendAdvanced", 1, dump_html_VkColorBlendAdvancedEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetProvokingVertexModeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkProvokingVertexModeEXT>(provokingVertexMode, settings, "VkProvokingVertexModeEXT", "provokingVertexMode", 1, dump_html_VkProvokingVertexModeEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLineRasterizationModeEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkLineRasterizationModeKHR>(lineRasterizationMode, settings, "VkLineRasterizationModeEXT", "lineRasterizationMode", 1, dump_html_VkLineRasterizationModeKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetLineStippleEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(stippledLineEnable, settings, "VkBool32", "stippledLineEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDepthClipNegativeOneToOneEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(negativeOneToOne, settings, "VkBool32", "negativeOneToOne", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewportWScalingEnableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(viewportWScalingEnable, settings, "VkBool32", "viewportWScalingEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetViewportSwizzleNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewportSwizzleNV>(pViewportSwizzles, viewportCount, settings, "const VkViewportSwizzleNV*", "const VkViewportSwizzleNV", "pViewportSwizzles", 1, dump_html_VkViewportSwizzleNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoverageToColorEnableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(coverageToColorEnable, settings, "VkBool32", "coverageToColorEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoverageToColorLocationNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(coverageToColorLocation, settings, "uint32_t", "coverageToColorLocation", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoverageModulationModeNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCoverageModulationModeNV>(coverageModulationMode, settings, "VkCoverageModulationModeNV", "coverageModulationMode", 1, dump_html_VkCoverageModulationModeNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoverageModulationTableEnableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(coverageModulationTableEnable, settings, "VkBool32", "coverageModulationTableEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoverageModulationTableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(coverageModulationTableCount, settings, "uint32_t", "coverageModulationTableCount", 1, dump_html_uint32_t);
        dump_html_array<const float>(pCoverageModulationTable, coverageModulationTableCount, settings, "const float*", "const float", "pCoverageModulationTable", 1, dump_html_float); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetShadingRateImageEnableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(shadingRateImageEnable, settings, "VkBool32", "shadingRateImageEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetRepresentativeFragmentTestEnableNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBool32>(representativeFragmentTestEnable, settings, "VkBool32", "representativeFragmentTestEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetCoverageReductionModeNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCoverageReductionModeNV>(coverageReductionMode, settings, "VkCoverageReductionModeNV", "coverageReductionMode", 1, dump_html_VkCoverageReductionModeNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetShaderModuleIdentifierEXT(ApiDumpInstance& dump_inst, VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkShaderModule>(shaderModule, settings, "VkShaderModule", "shaderModule", 1, dump_html_VkShaderModule);
        dump_html_pointer<const VkShaderModuleIdentifierEXT>(pIdentifier, settings, "VkShaderModuleIdentifierEXT*", "pIdentifier", 1, dump_html_VkShaderModuleIdentifierEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetShaderModuleCreateInfoIdentifierEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkShaderModuleCreateInfo>(pCreateInfo, settings, "const VkShaderModuleCreateInfo*", "pCreateInfo", 1, dump_html_VkShaderModuleCreateInfo);
        dump_html_pointer<const VkShaderModuleIdentifierEXT>(pIdentifier, settings, "VkShaderModuleIdentifierEXT*", "pIdentifier", 1, dump_html_VkShaderModuleIdentifierEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkOpticalFlowImageFormatInfoNV>(pOpticalFlowImageFormatInfo, settings, "const VkOpticalFlowImageFormatInfoNV*", "pOpticalFlowImageFormatInfo", 1, dump_html_VkOpticalFlowImageFormatInfoNV);
        dump_html_pointer<const uint32_t>(pFormatCount, settings, "uint32_t*", "pFormatCount", 1, dump_html_uint32_t);
        dump_html_array<const VkOpticalFlowImageFormatPropertiesNV>(pImageFormatProperties, *pFormatCount, settings, "VkOpticalFlowImageFormatPropertiesNV*", "VkOpticalFlowImageFormatPropertiesNV", "pImageFormatProperties", 1, dump_html_VkOpticalFlowImageFormatPropertiesNV); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateOpticalFlowSessionNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkOpticalFlowSessionCreateInfoNV>(pCreateInfo, settings, "const VkOpticalFlowSessionCreateInfoNV*", "pCreateInfo", 1, dump_html_VkOpticalFlowSessionCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkOpticalFlowSessionNV>(pSession, settings, "VkOpticalFlowSessionNV*", "pSession", 1, dump_html_VkOpticalFlowSessionNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyOpticalFlowSessionNV(ApiDumpInstance& dump_inst, VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkOpticalFlowSessionNV>(session, settings, "VkOpticalFlowSessionNV", "session", 1, dump_html_VkOpticalFlowSessionNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkBindOpticalFlowSessionImageNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkOpticalFlowSessionNV>(session, settings, "VkOpticalFlowSessionNV", "session", 1, dump_html_VkOpticalFlowSessionNV);
        dump_html_value<const VkOpticalFlowSessionBindingPointNV>(bindingPoint, settings, "VkOpticalFlowSessionBindingPointNV", "bindingPoint", 1, dump_html_VkOpticalFlowSessionBindingPointNV);
        dump_html_value<const VkImageView>(view, settings, "VkImageView", "view", 1, dump_html_VkImageView);
        dump_html_value<const VkImageLayout>(layout, settings, "VkImageLayout", "layout", 1, dump_html_VkImageLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdOpticalFlowExecuteNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkOpticalFlowSessionNV>(session, settings, "VkOpticalFlowSessionNV", "session", 1, dump_html_VkOpticalFlowSessionNV);
        dump_html_pointer<const VkOpticalFlowExecuteInfoNV>(pExecuteInfo, settings, "const VkOpticalFlowExecuteInfoNV*", "pExecuteInfo", 1, dump_html_VkOpticalFlowExecuteInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindIndexBuffer2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(size, settings, "VkDeviceSize", "size", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkIndexType>(indexType, settings, "VkIndexType", "indexType", 1, dump_html_VkIndexType);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetRenderingAreaGranularityKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderingAreaInfoKHR>(pRenderingAreaInfo, settings, "const VkRenderingAreaInfoKHR*", "pRenderingAreaInfo", 1, dump_html_VkRenderingAreaInfoKHR);
        dump_html_pointer<const VkExtent2D>(pGranularity, settings, "VkExtent2D*", "pGranularity", 1, dump_html_VkExtent2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDeviceImageSubresourceLayoutKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceImageSubresourceInfoKHR>(pInfo, settings, "const VkDeviceImageSubresourceInfoKHR*", "pInfo", 1, dump_html_VkDeviceImageSubresourceInfoKHR);
        dump_html_pointer<const VkSubresourceLayout2KHR>(pLayout, settings, "VkSubresourceLayout2KHR*", "pLayout", 1, dump_html_VkSubresourceLayout2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCreateShadersEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkShaderCreateInfoEXT>(pCreateInfos, createInfoCount, settings, "const VkShaderCreateInfoEXT*", "const VkShaderCreateInfoEXT", "pCreateInfos", 1, dump_html_VkShaderCreateInfoEXT); // ZRZ
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkShaderEXT>(pShaders, createInfoCount, settings, "VkShaderEXT*", "VkShaderEXT", "pShaders", 1, dump_html_VkShaderEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkDestroyShaderEXT(ApiDumpInstance& dump_inst, VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkShaderEXT>(shader, settings, "VkShaderEXT", "shader", 1, dump_html_VkShaderEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetShaderBinaryDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkShaderEXT>(shader, settings, "VkShaderEXT", "shader", 1, dump_html_VkShaderEXT);
        dump_html_pointer<const size_t>(pDataSize, settings, "size_t*", "pDataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindShadersEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(stageCount, settings, "uint32_t", "stageCount", 1, dump_html_uint32_t);
        dump_html_array<const VkShaderStageFlagBits>(pStages, stageCount, settings, "const VkShaderStageFlagBits*", "const VkShaderStageFlagBits", "pStages", 1, dump_html_VkShaderStageFlagBits); // ZRZ
        dump_html_array<const VkShaderEXT>(pShaders, stageCount, settings, "const VkShaderEXT*", "const VkShaderEXT", "pShaders", 1, dump_html_VkShaderEXT); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetFramebufferTilePropertiesQCOM(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFramebuffer>(framebuffer, settings, "VkFramebuffer", "framebuffer", 1, dump_html_VkFramebuffer);
        dump_html_pointer<const uint32_t>(pPropertiesCount, settings, "uint32_t*", "pPropertiesCount", 1, dump_html_uint32_t);
        dump_html_array<const VkTilePropertiesQCOM>(pProperties, *pPropertiesCount, settings, "VkTilePropertiesQCOM*", "VkTilePropertiesQCOM", "pProperties", 1, dump_html_VkTilePropertiesQCOM); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetDynamicRenderingTilePropertiesQCOM(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderingInfo>(pRenderingInfo, settings, "const VkRenderingInfo*", "pRenderingInfo", 1, dump_html_VkRenderingInfo);
        dump_html_pointer<const VkTilePropertiesQCOM>(pProperties, settings, "VkTilePropertiesQCOM*", "pProperties", 1, dump_html_VkTilePropertiesQCOM);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetLatencySleepModeNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV* pSleepModeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkLatencySleepModeInfoNV>(pSleepModeInfo, settings, "const VkLatencySleepModeInfoNV*", "pSleepModeInfo", 1, dump_html_VkLatencySleepModeInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkLatencySleepNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV* pSleepInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkLatencySleepInfoNV>(pSleepInfo, settings, "const VkLatencySleepInfoNV*", "pSleepInfo", 1, dump_html_VkLatencySleepInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkSetLatencyMarkerNV(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkSetLatencyMarkerInfoNV>(pLatencyMarkerInfo, settings, "const VkSetLatencyMarkerInfoNV*", "pLatencyMarkerInfo", 1, dump_html_VkSetLatencyMarkerInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetLatencyTimingsNV(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV* pLatencyMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkGetLatencyMarkerInfoNV>(pLatencyMarkerInfo, settings, "VkGetLatencyMarkerInfoNV*", "pLatencyMarkerInfo", 1, dump_html_VkGetLatencyMarkerInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkQueueNotifyOutOfBandNV(ApiDumpInstance& dump_inst, VkQueue queue, const VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkOutOfBandQueueTypeInfoNV>(pQueueTypeInfo, settings, "const VkOutOfBandQueueTypeInfoNV*", "pQueueTypeInfo", 1, dump_html_VkOutOfBandQueueTypeInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCooperativeMatrixPropertiesKHR>(pProperties, *pPropertyCount, settings, "VkCooperativeMatrixPropertiesKHR*", "VkCooperativeMatrixPropertiesKHR", "pProperties", 1, dump_html_VkCooperativeMatrixPropertiesKHR); // ZRZ
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetAttachmentFeedbackLoopEnableEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImageAspectFlags>(aspectMask, settings, "VkImageAspectFlags", "aspectMask", 1, dump_html_VkImageAspectFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
void dump_html_vkGetScreenBufferPropertiesQNX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const struct _screen_buffer* buffer, VkScreenBufferPropertiesQNX* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const _screen_buffer*>(buffer, settings, "const struct _screen_buffer*", "buffer", 1, dump_html__screen_buffer);
        dump_html_pointer<const VkScreenBufferPropertiesQNX>(pProperties, settings, "VkScreenBufferPropertiesQNX*", "pProperties", 1, dump_html_VkScreenBufferPropertiesQNX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_SCREEN_QNX
void dump_html_vkCmdBindDescriptorSets2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfoKHR* pBindDescriptorSetsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkBindDescriptorSetsInfoKHR>(pBindDescriptorSetsInfo, settings, "const VkBindDescriptorSetsInfoKHR*", "pBindDescriptorSetsInfo", 1, dump_html_VkBindDescriptorSetsInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPushConstants2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkPushConstantsInfoKHR* pPushConstantsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPushConstantsInfoKHR>(pPushConstantsInfo, settings, "const VkPushConstantsInfoKHR*", "pPushConstantsInfo", 1, dump_html_VkPushConstantsInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPushDescriptorSet2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfoKHR* pPushDescriptorSetInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPushDescriptorSetInfoKHR>(pPushDescriptorSetInfo, settings, "const VkPushDescriptorSetInfoKHR*", "pPushDescriptorSetInfo", 1, dump_html_VkPushDescriptorSetInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdPushDescriptorSetWithTemplate2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPushDescriptorSetWithTemplateInfoKHR>(pPushDescriptorSetWithTemplateInfo, settings, "const VkPushDescriptorSetWithTemplateInfoKHR*", "pPushDescriptorSetWithTemplateInfo", 1, dump_html_VkPushDescriptorSetWithTemplateInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdSetDescriptorBufferOffsets2EXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSetDescriptorBufferOffsetsInfoEXT>(pSetDescriptorBufferOffsetsInfo, settings, "const VkSetDescriptorBufferOffsetsInfoEXT*", "pSetDescriptorBufferOffsetsInfo", 1, dump_html_VkSetDescriptorBufferOffsetsInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}
void dump_html_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkBindDescriptorBufferEmbeddedSamplersInfoEXT>(pBindDescriptorBufferEmbeddedSamplersInfo, settings, "const VkBindDescriptorBufferEmbeddedSamplersInfoEXT*", "pBindDescriptorBufferEmbeddedSamplersInfo", 1, dump_html_VkBindDescriptorBufferEmbeddedSamplersInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    settings.stream() << "</details>";
}


