
/* Copyright (c) 2015-2026 Valve Corporation
 * Copyright (c) 2015-2026 LunarG, Inc.
 * Copyright (c) 2015-2017, 2019, 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/*
 * This file is generated from the Khronos Vulkan XML API Registry.
 */

#include "api_dump_handwritten_functions.h"

// Autogen instance functions

VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkDestroyInstance", "instance, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyInstance(api_dump, instance, pAllocator);
        }
    }
    auto dispatch_key = get_dispatch_key(instance);
    instance_dispatch_table(instance)->DestroyInstance(instance, pAllocator);
    destroy_instance_dispatch_table(dispatch_key);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyInstance(api_dump, instance, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkEnumeratePhysicalDevices", "instance, pPhysicalDeviceCount, pPhysicalDevices", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkEnumeratePhysicalDevices(api_dump, instance, pPhysicalDeviceCount, pPhysicalDevices);
        }
    }
    VkResult result = instance_dispatch_table(instance)->EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);

    if (pPhysicalDeviceCount != nullptr && pPhysicalDevices != nullptr) {
        for (uint32_t i = 0; i < *pPhysicalDeviceCount; i++) {
            api_dump.set_vk_instance(pPhysicalDevices[i], instance);
        }
    }
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkEnumeratePhysicalDevices(api_dump, instance, pPhysicalDeviceCount, pPhysicalDevices);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFeatures", "physicalDevice, pFeatures", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFeatures(api_dump, physicalDevice, pFeatures);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFeatures(physicalDevice, pFeatures);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFeatures(api_dump, physicalDevice, pFeatures);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFormatProperties", "physicalDevice, format, pFormatProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFormatProperties(api_dump, physicalDevice, format, pFormatProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFormatProperties(api_dump, physicalDevice, format, pFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceImageFormatProperties", "physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceImageFormatProperties(api_dump, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceImageFormatProperties(api_dump, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceProperties", "physicalDevice, pProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceProperties(api_dump, physicalDevice, pProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceProperties(physicalDevice, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceProperties(api_dump, physicalDevice, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceQueueFamilyProperties", "physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceQueueFamilyProperties(api_dump, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceQueueFamilyProperties(api_dump, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceMemoryProperties", "physicalDevice, pMemoryProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceMemoryProperties(api_dump, physicalDevice, pMemoryProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceMemoryProperties(api_dump, physicalDevice, pMemoryProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSparseImageFormatProperties", "physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSparseImageFormatProperties(api_dump, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSparseImageFormatProperties(api_dump, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkEnumeratePhysicalDeviceGroups", "instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkEnumeratePhysicalDeviceGroups(api_dump, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        }
    }
    VkResult result = instance_dispatch_table(instance)->EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkEnumeratePhysicalDeviceGroups(api_dump, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFeatures2", "physicalDevice, pFeatures", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFeatures2(api_dump, physicalDevice, pFeatures);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFeatures2(api_dump, physicalDevice, pFeatures);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceProperties2", "physicalDevice, pProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceProperties2(api_dump, physicalDevice, pProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceProperties2(physicalDevice, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceProperties2(api_dump, physicalDevice, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFormatProperties2", "physicalDevice, format, pFormatProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFormatProperties2(api_dump, physicalDevice, format, pFormatProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFormatProperties2(api_dump, physicalDevice, format, pFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceImageFormatProperties2", "physicalDevice, pImageFormatInfo, pImageFormatProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceImageFormatProperties2(api_dump, physicalDevice, pImageFormatInfo, pImageFormatProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceImageFormatProperties2(api_dump, physicalDevice, pImageFormatInfo, pImageFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceQueueFamilyProperties2", "physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceQueueFamilyProperties2(api_dump, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceQueueFamilyProperties2(api_dump, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceMemoryProperties2", "physicalDevice, pMemoryProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceMemoryProperties2(api_dump, physicalDevice, pMemoryProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceMemoryProperties2(api_dump, physicalDevice, pMemoryProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSparseImageFormatProperties2", "physicalDevice, pFormatInfo, pPropertyCount, pProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSparseImageFormatProperties2(api_dump, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSparseImageFormatProperties2(api_dump, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalBufferProperties", "physicalDevice, pExternalBufferInfo, pExternalBufferProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalBufferProperties(api_dump, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalBufferProperties(api_dump, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalFenceProperties", "physicalDevice, pExternalFenceInfo, pExternalFenceProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalFenceProperties(api_dump, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalFenceProperties(api_dump, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalSemaphoreProperties", "physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalSemaphoreProperties(api_dump, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalSemaphoreProperties(api_dump, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceToolProperties", "physicalDevice, pToolCount, pToolProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceToolProperties(api_dump, physicalDevice, pToolCount, pToolProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceToolProperties(api_dump, physicalDevice, pToolCount, pToolProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkDestroySurfaceKHR", "instance, surface, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroySurfaceKHR(api_dump, instance, surface, pAllocator);
        }
    }
    instance_dispatch_table(instance)->DestroySurfaceKHR(instance, surface, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroySurfaceKHR(api_dump, instance, surface, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfaceSupportKHR", "physicalDevice, queueFamilyIndex, surface, pSupported", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfaceSupportKHR(api_dump, physicalDevice, queueFamilyIndex, surface, pSupported);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfaceSupportKHR(api_dump, physicalDevice, queueFamilyIndex, surface, pSupported);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", "physicalDevice, surface, pSurfaceCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(api_dump, physicalDevice, surface, pSurfaceCapabilities);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(api_dump, physicalDevice, surface, pSurfaceCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfaceFormatsKHR", "physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfaceFormatsKHR(api_dump, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfaceFormatsKHR(api_dump, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfacePresentModesKHR", "physicalDevice, surface, pPresentModeCount, pPresentModes", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfacePresentModesKHR(api_dump, physicalDevice, surface, pPresentModeCount, pPresentModes);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfacePresentModesKHR(api_dump, physicalDevice, surface, pPresentModeCount, pPresentModes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDevicePresentRectanglesKHR", "physicalDevice, surface, pRectCount, pRects", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDevicePresentRectanglesKHR(api_dump, physicalDevice, surface, pRectCount, pRects);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDevicePresentRectanglesKHR(api_dump, physicalDevice, surface, pRectCount, pRects);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceDisplayPropertiesKHR", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceDisplayPropertiesKHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceDisplayPropertiesKHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetDisplayPlaneSupportedDisplaysKHR", "physicalDevice, planeIndex, pDisplayCount, pDisplays", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDisplayPlaneSupportedDisplaysKHR(api_dump, physicalDevice, planeIndex, pDisplayCount, pDisplays);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDisplayPlaneSupportedDisplaysKHR(api_dump, physicalDevice, planeIndex, pDisplayCount, pDisplays);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetDisplayModePropertiesKHR", "physicalDevice, display, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDisplayModePropertiesKHR(api_dump, physicalDevice, display, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDisplayModePropertiesKHR(api_dump, physicalDevice, display, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateDisplayModeKHR", "physicalDevice, display, pCreateInfo, pAllocator, pMode", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDisplayModeKHR(api_dump, physicalDevice, display, pCreateInfo, pAllocator, pMode);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDisplayModeKHR(api_dump, physicalDevice, display, pCreateInfo, pAllocator, pMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetDisplayPlaneCapabilitiesKHR", "physicalDevice, mode, planeIndex, pCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDisplayPlaneCapabilitiesKHR(api_dump, physicalDevice, mode, planeIndex, pCapabilities);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDisplayPlaneCapabilitiesKHR(api_dump, physicalDevice, mode, planeIndex, pCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateDisplayPlaneSurfaceKHR", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDisplayPlaneSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDisplayPlaneSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateXlibSurfaceKHR", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateXlibSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateXlibSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceXlibPresentationSupportKHR", "physicalDevice, queueFamilyIndex, dpy, visualID", "VkBool32");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceXlibPresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex, dpy, visualID);
        }
    }
    VkBool32 result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkBool32", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceXlibPresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex, dpy, visualID);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateXcbSurfaceKHR", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateXcbSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateXcbSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceXcbPresentationSupportKHR", "physicalDevice, queueFamilyIndex, connection, visual_id", "VkBool32");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceXcbPresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex, connection, visual_id);
        }
    }
    VkBool32 result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkBool32", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceXcbPresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex, connection, visual_id);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateWaylandSurfaceKHR", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateWaylandSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateWaylandSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceWaylandPresentationSupportKHR", "physicalDevice, queueFamilyIndex, display", "VkBool32");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceWaylandPresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex, display);
        }
    }
    VkBool32 result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkBool32", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceWaylandPresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex, display);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateAndroidSurfaceKHR", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateAndroidSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateAndroidSurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateWin32SurfaceKHR", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateWin32SurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateWin32SurfaceKHR(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceWin32PresentationSupportKHR", "physicalDevice, queueFamilyIndex", "VkBool32");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceWin32PresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex);
        }
    }
    VkBool32 result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkBool32", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceWin32PresentationSupportKHR(api_dump, physicalDevice, queueFamilyIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceVideoCapabilitiesKHR", "physicalDevice, pVideoProfile, pCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceVideoCapabilitiesKHR(api_dump, physicalDevice, pVideoProfile, pCapabilities);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceVideoCapabilitiesKHR(api_dump, physicalDevice, pVideoProfile, pCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceVideoFormatPropertiesKHR", "physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceVideoFormatPropertiesKHR(api_dump, physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceVideoFormatPropertiesKHR(api_dump, physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFeatures2KHR", "physicalDevice, pFeatures", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFeatures2KHR(api_dump, physicalDevice, pFeatures);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFeatures2KHR(api_dump, physicalDevice, pFeatures);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceProperties2KHR", "physicalDevice, pProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceProperties2KHR(api_dump, physicalDevice, pProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceProperties2KHR(api_dump, physicalDevice, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFormatProperties2KHR", "physicalDevice, format, pFormatProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFormatProperties2KHR(api_dump, physicalDevice, format, pFormatProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFormatProperties2KHR(api_dump, physicalDevice, format, pFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceImageFormatProperties2KHR", "physicalDevice, pImageFormatInfo, pImageFormatProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceImageFormatProperties2KHR(api_dump, physicalDevice, pImageFormatInfo, pImageFormatProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceImageFormatProperties2KHR(api_dump, physicalDevice, pImageFormatInfo, pImageFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceQueueFamilyProperties2KHR", "physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceQueueFamilyProperties2KHR(api_dump, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceQueueFamilyProperties2KHR(api_dump, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceMemoryProperties2KHR", "physicalDevice, pMemoryProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceMemoryProperties2KHR(api_dump, physicalDevice, pMemoryProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceMemoryProperties2KHR(api_dump, physicalDevice, pMemoryProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", "physicalDevice, pFormatInfo, pPropertyCount, pProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(api_dump, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(api_dump, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkEnumeratePhysicalDeviceGroupsKHR", "instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkEnumeratePhysicalDeviceGroupsKHR(api_dump, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        }
    }
    VkResult result = instance_dispatch_table(instance)->EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkEnumeratePhysicalDeviceGroupsKHR(api_dump, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", "physicalDevice, pExternalBufferInfo, pExternalBufferProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalBufferPropertiesKHR(api_dump, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalBufferPropertiesKHR(api_dump, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", "physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(api_dump, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(api_dump, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalFencePropertiesKHR", "physicalDevice, pExternalFenceInfo, pExternalFenceProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalFencePropertiesKHR(api_dump, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalFencePropertiesKHR(api_dump, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", "physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(api_dump, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(api_dump, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", "physicalDevice, pPerformanceQueryCreateInfo, pNumPasses", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(api_dump, physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(api_dump, physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", "physicalDevice, pSurfaceInfo, pSurfaceCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfaceCapabilities2KHR(api_dump, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfaceCapabilities2KHR(api_dump, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfaceFormats2KHR", "physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfaceFormats2KHR(api_dump, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfaceFormats2KHR(api_dump, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceDisplayProperties2KHR", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceDisplayProperties2KHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceDisplayProperties2KHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetDisplayModeProperties2KHR", "physicalDevice, display, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDisplayModeProperties2KHR(api_dump, physicalDevice, display, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDisplayModeProperties2KHR(api_dump, physicalDevice, display, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetDisplayPlaneCapabilities2KHR", "physicalDevice, pDisplayPlaneInfo, pCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDisplayPlaneCapabilities2KHR(api_dump, physicalDevice, pDisplayPlaneInfo, pCapabilities);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDisplayPlaneCapabilities2KHR(api_dump, physicalDevice, pDisplayPlaneInfo, pCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceFragmentShadingRatesKHR", "physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceFragmentShadingRatesKHR(api_dump, physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceFragmentShadingRatesKHR(api_dump, physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", "physicalDevice, pQualityLevelInfo, pQualityLevelProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(api_dump, physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(api_dump, physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", "physicalDevice, pTimeDomainCount, pTimeDomains", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(api_dump, physicalDevice, pTimeDomainCount, pTimeDomains);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(api_dump, physicalDevice, pTimeDomainCount, pTimeDomains);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateDebugReportCallbackEXT", "instance, pCreateInfo, pAllocator, pCallback", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDebugReportCallbackEXT(api_dump, instance, pCreateInfo, pAllocator, pCallback);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDebugReportCallbackEXT(api_dump, instance, pCreateInfo, pAllocator, pCallback);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkDestroyDebugReportCallbackEXT", "instance, callback, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDebugReportCallbackEXT(api_dump, instance, callback, pAllocator);
        }
    }
    instance_dispatch_table(instance)->DestroyDebugReportCallbackEXT(instance, callback, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDebugReportCallbackEXT(api_dump, instance, callback, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkDebugReportMessageEXT", "instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDebugReportMessageEXT(api_dump, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
        }
    }
    instance_dispatch_table(instance)->DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDebugReportMessageEXT(api_dump, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_GGP)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateStreamDescriptorSurfaceGGP", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateStreamDescriptorSurfaceGGP(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateStreamDescriptorSurfaceGGP(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_GGP
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", "physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(api_dump, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(api_dump, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_VI_NN)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateViSurfaceNN", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateViSurfaceNN(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateViSurfaceNN(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_VI_NN
VKAPI_ATTR VkResult VKAPI_CALL vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkReleaseDisplayEXT", "physicalDevice, display", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleaseDisplayEXT(api_dump, physicalDevice, display);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->ReleaseDisplayEXT(physicalDevice, display);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleaseDisplayEXT(api_dump, physicalDevice, display);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkAcquireXlibDisplayEXT", "physicalDevice, dpy, display", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquireXlibDisplayEXT(api_dump, physicalDevice, dpy, display);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->AcquireXlibDisplayEXT(physicalDevice, dpy, display);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireXlibDisplayEXT(api_dump, physicalDevice, dpy, display);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetRandROutputDisplayEXT", "physicalDevice, dpy, rrOutput, pDisplay", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRandROutputDisplayEXT(api_dump, physicalDevice, dpy, rrOutput, pDisplay);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRandROutputDisplayEXT(api_dump, physicalDevice, dpy, rrOutput, pDisplay);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_XLIB_XRANDR_EXT
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfaceCapabilities2EXT", "physicalDevice, surface, pSurfaceCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfaceCapabilities2EXT(api_dump, physicalDevice, surface, pSurfaceCapabilities);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfaceCapabilities2EXT(api_dump, physicalDevice, surface, pSurfaceCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateIOSSurfaceMVK", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateIOSSurfaceMVK(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateIOSSurfaceMVK(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_IOS_MVK
#if defined(VK_USE_PLATFORM_MACOS_MVK)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateMacOSSurfaceMVK", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateMacOSSurfaceMVK(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateMacOSSurfaceMVK(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_MACOS_MVK
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateDebugUtilsMessengerEXT", "instance, pCreateInfo, pAllocator, pMessenger", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDebugUtilsMessengerEXT(api_dump, instance, pCreateInfo, pAllocator, pMessenger);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDebugUtilsMessengerEXT(api_dump, instance, pCreateInfo, pAllocator, pMessenger);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkDestroyDebugUtilsMessengerEXT", "instance, messenger, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDebugUtilsMessengerEXT(api_dump, instance, messenger, pAllocator);
        }
    }
    instance_dispatch_table(instance)->DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDebugUtilsMessengerEXT(api_dump, instance, messenger, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkSubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkSubmitDebugUtilsMessageEXT", "instance, messageSeverity, messageTypes, pCallbackData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSubmitDebugUtilsMessageEXT(api_dump, instance, messageSeverity, messageTypes, pCallbackData);
        }
    }
    instance_dispatch_table(instance)->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkSubmitDebugUtilsMessageEXT(api_dump, instance, messageSeverity, messageTypes, pCallbackData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkDeviceSize VKAPI_CALL vkGetPhysicalDeviceDescriptorSizeEXT(VkPhysicalDevice physicalDevice, VkDescriptorType descriptorType) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceDescriptorSizeEXT", "physicalDevice, descriptorType", "VkDeviceSize");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceDescriptorSizeEXT(api_dump, physicalDevice, descriptorType);
        }
    }
    VkDeviceSize result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceDescriptorSizeEXT(physicalDevice, descriptorType);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceSize", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceDescriptorSizeEXT(api_dump, physicalDevice, descriptorType);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceMultisamplePropertiesEXT", "physicalDevice, samples, pMultisampleProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceMultisamplePropertiesEXT(api_dump, physicalDevice, samples, pMultisampleProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceMultisamplePropertiesEXT(api_dump, physicalDevice, samples, pMultisampleProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", "physicalDevice, pTimeDomainCount, pTimeDomains", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(api_dump, physicalDevice, pTimeDomainCount, pTimeDomains);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(api_dump, physicalDevice, pTimeDomainCount, pTimeDomains);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateImagePipeSurfaceFUCHSIA", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateImagePipeSurfaceFUCHSIA(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateImagePipeSurfaceFUCHSIA(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_METAL_EXT)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateMetalSurfaceEXT", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateMetalSurfaceEXT(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateMetalSurfaceEXT(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_METAL_EXT
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceToolPropertiesEXT", "physicalDevice, pToolCount, pToolProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceToolPropertiesEXT(api_dump, physicalDevice, pToolCount, pToolProperties);
        }
    }

    static const VkPhysicalDeviceToolPropertiesEXT api_dump_layer_tool_props = {
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT,
        nullptr,
        "API Dump Layer",
        "2",
        VK_TOOL_PURPOSE_PROFILING_BIT_EXT | VK_TOOL_PURPOSE_TRACING_BIT_EXT,
        "The VK_LAYER_LUNARG_api_dump utility layer prints API calls, parameters, and values to the identified output stream.",
        "VK_LAYER_LUNARG_api_dump"};

    auto original_pToolProperties = pToolProperties;
    if (pToolProperties != nullptr) {
        *pToolProperties = api_dump_layer_tool_props;
        pToolProperties = ((*pToolCount > 1) ? &pToolProperties[1] : nullptr);
        (*pToolCount)--;
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
    if (original_pToolProperties != nullptr) {
        pToolProperties = original_pToolProperties;
    }

    (*pToolCount)++;
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceToolPropertiesEXT(api_dump, physicalDevice, pToolCount, pToolProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "physicalDevice, pCombinationCount, pCombinations", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(api_dump, physicalDevice, pCombinationCount, pCombinations);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(api_dump, physicalDevice, pCombinationCount, pCombinations);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceSurfacePresentModes2EXT", "physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceSurfacePresentModes2EXT(api_dump, physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceSurfacePresentModes2EXT(api_dump, physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateHeadlessSurfaceEXT", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateHeadlessSurfaceEXT(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateHeadlessSurfaceEXT(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkAcquireDrmDisplayEXT", "physicalDevice, drmFd, display", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquireDrmDisplayEXT(api_dump, physicalDevice, drmFd, display);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->AcquireDrmDisplayEXT(physicalDevice, drmFd, display);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireDrmDisplayEXT(api_dump, physicalDevice, drmFd, display);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetDrmDisplayEXT", "physicalDevice, drmFd, connectorId, display", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDrmDisplayEXT(api_dump, physicalDevice, drmFd, connectorId, display);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDrmDisplayEXT(api_dump, physicalDevice, drmFd, connectorId, display);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkAcquireWinrtDisplayNV", "physicalDevice, display", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquireWinrtDisplayNV(api_dump, physicalDevice, display);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->AcquireWinrtDisplayNV(physicalDevice, display);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireWinrtDisplayNV(api_dump, physicalDevice, display);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR* pDisplay) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetWinrtDisplayNV", "physicalDevice, deviceRelativeId, pDisplay", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetWinrtDisplayNV(api_dump, physicalDevice, deviceRelativeId, pDisplay);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetWinrtDisplayNV(api_dump, physicalDevice, deviceRelativeId, pDisplay);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateDirectFBSurfaceEXT", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDirectFBSurfaceEXT(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDirectFBSurfaceEXT(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB* dfb) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT", "physicalDevice, queueFamilyIndex, dfb", "VkBool32");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(api_dump, physicalDevice, queueFamilyIndex, dfb);
        }
    }
    VkBool32 result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkBool32", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(api_dump, physicalDevice, queueFamilyIndex, dfb);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_DIRECTFB_EXT
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateScreenSurfaceQNX", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateScreenSurfaceQNX(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateScreenSurfaceQNX(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window* window) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceScreenPresentationSupportQNX", "physicalDevice, queueFamilyIndex, window", "VkBool32");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceScreenPresentationSupportQNX(api_dump, physicalDevice, queueFamilyIndex, window);
        }
    }
    VkBool32 result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkBool32", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceScreenPresentationSupportQNX(api_dump, physicalDevice, queueFamilyIndex, window);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM* pExternalTensorInfo, VkExternalTensorPropertiesARM* pExternalTensorProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceExternalTensorPropertiesARM", "physicalDevice, pExternalTensorInfo, pExternalTensorProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceExternalTensorPropertiesARM(api_dump, physicalDevice, pExternalTensorInfo, pExternalTensorProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo, pExternalTensorProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceExternalTensorPropertiesARM(api_dump, physicalDevice, pExternalTensorInfo, pExternalTensorProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV", "physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(api_dump, physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(api_dump, physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeVectorPropertiesNV* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM* pQueueFamilyDataGraphProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM", "physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(api_dump, physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(api_dump, physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM* pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM* pQueueFamilyDataGraphProcessingEngineProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM", "physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(api_dump, physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties);
        }
    }
    instance_dispatch_table(physicalDevice)->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(api_dump, physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_OHOS)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkCreateSurfaceOHOS", "instance, pCreateInfo, pAllocator, pSurface", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSurfaceOHOS(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        }
    }
    VkResult result = instance_dispatch_table(instance)->CreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSurfaceOHOS(api_dump, instance, pCreateInfo, pAllocator, pSurface);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_OHOS
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", "physicalDevice, pPropertyCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(api_dump, physicalDevice, pPropertyCount, pProperties);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(api_dump, physicalDevice, pPropertyCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterARM* pCounters, VkPerformanceCounterDescriptionARM* pCounterDescriptions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM", "physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM(api_dump, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
        }
    }
    VkResult result = instance_dispatch_table(physicalDevice)->EnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM(api_dump, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}

// Autogen device functions

VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDevice", "device, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDevice(api_dump, device, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDevice(device, pAllocator);
    destroy_device_dispatch_table(get_dispatch_key(device));
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDevice(api_dump, device, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceQueue", "device, queueFamilyIndex, queueIndex, pQueue", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceQueue(api_dump, device, queueFamilyIndex, queueIndex, pQueue);
        }
    }
    device_dispatch_table(device)->GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceQueue(api_dump, device, queueFamilyIndex, queueIndex, pQueue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueSubmit", "queue, submitCount, pSubmits, fence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueSubmit(api_dump, queue, submitCount, pSubmits, fence);
        }
    }
    VkResult result = device_dispatch_table(queue)->QueueSubmit(queue, submitCount, pSubmits, fence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueSubmit(api_dump, queue, submitCount, pSubmits, fence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueueWaitIdle(VkQueue queue) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(queue)->QueueWaitIdle(queue);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkQueueWaitIdle", "queue", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueWaitIdle(api_dump, queue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkDeviceWaitIdle(VkDevice device) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(device)->DeviceWaitIdle(device);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkDeviceWaitIdle", "device", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkDeviceWaitIdle(api_dump, device);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAllocateMemory", "device, pAllocateInfo, pAllocator, pMemory", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAllocateMemory(api_dump, device, pAllocateInfo, pAllocator, pMemory);
        }
    }
    VkResult result = device_dispatch_table(device)->AllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAllocateMemory(api_dump, device, pAllocateInfo, pAllocator, pMemory);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkFreeMemory", "device, memory, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkFreeMemory(api_dump, device, memory, pAllocator);
        }
    }
    device_dispatch_table(device)->FreeMemory(device, memory, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkFreeMemory(api_dump, device, memory, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkMapMemory", "device, memory, offset, size, flags, ppData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkMapMemory(api_dump, device, memory, offset, size, flags, ppData);
        }
    }
    VkResult result = device_dispatch_table(device)->MapMemory(device, memory, offset, size, flags, ppData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkMapMemory(api_dump, device, memory, offset, size, flags, ppData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkUnmapMemory(VkDevice device, VkDeviceMemory memory) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUnmapMemory", "device, memory", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUnmapMemory(api_dump, device, memory);
        }
    }
    device_dispatch_table(device)->UnmapMemory(device, memory);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUnmapMemory(api_dump, device, memory);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkFlushMappedMemoryRanges", "device, memoryRangeCount, pMemoryRanges", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkFlushMappedMemoryRanges(api_dump, device, memoryRangeCount, pMemoryRanges);
        }
    }
    VkResult result = device_dispatch_table(device)->FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkFlushMappedMemoryRanges(api_dump, device, memoryRangeCount, pMemoryRanges);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkInvalidateMappedMemoryRanges", "device, memoryRangeCount, pMemoryRanges", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkInvalidateMappedMemoryRanges(api_dump, device, memoryRangeCount, pMemoryRanges);
        }
    }
    VkResult result = device_dispatch_table(device)->InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkInvalidateMappedMemoryRanges(api_dump, device, memoryRangeCount, pMemoryRanges);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceMemoryCommitment", "device, memory, pCommittedMemoryInBytes", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceMemoryCommitment(api_dump, device, memory, pCommittedMemoryInBytes);
        }
    }
    device_dispatch_table(device)->GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceMemoryCommitment(api_dump, device, memory, pCommittedMemoryInBytes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindBufferMemory", "device, buffer, memory, memoryOffset", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindBufferMemory(api_dump, device, buffer, memory, memoryOffset);
        }
    }
    VkResult result = device_dispatch_table(device)->BindBufferMemory(device, buffer, memory, memoryOffset);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindBufferMemory(api_dump, device, buffer, memory, memoryOffset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindImageMemory", "device, image, memory, memoryOffset", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindImageMemory(api_dump, device, image, memory, memoryOffset);
        }
    }
    VkResult result = device_dispatch_table(device)->BindImageMemory(device, image, memory, memoryOffset);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindImageMemory(api_dump, device, image, memory, memoryOffset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferMemoryRequirements", "device, buffer, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferMemoryRequirements(api_dump, device, buffer, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferMemoryRequirements(api_dump, device, buffer, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageMemoryRequirements", "device, image, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageMemoryRequirements(api_dump, device, image, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetImageMemoryRequirements(device, image, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageMemoryRequirements(api_dump, device, image, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSparseMemoryRequirements", "device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSparseMemoryRequirements(api_dump, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSparseMemoryRequirements(api_dump, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueBindSparse", "queue, bindInfoCount, pBindInfo, fence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueBindSparse(api_dump, queue, bindInfoCount, pBindInfo, fence);
        }
    }
    VkResult result = device_dispatch_table(queue)->QueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueBindSparse(api_dump, queue, bindInfoCount, pBindInfo, fence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateFence(VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateFence", "device, pCreateInfo, pAllocator, pFence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateFence(api_dump, device, pCreateInfo, pAllocator, pFence);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateFence(device, pCreateInfo, pAllocator, pFence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateFence(api_dump, device, pCreateInfo, pAllocator, pFence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyFence", "device, fence, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyFence(api_dump, device, fence, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyFence(device, fence, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyFence(api_dump, device, fence, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetFences", "device, fenceCount, pFences", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetFences(api_dump, device, fenceCount, pFences);
        }
    }
    VkResult result = device_dispatch_table(device)->ResetFences(device, fenceCount, pFences);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetFences(api_dump, device, fenceCount, pFences);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetFenceStatus", "device, fence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetFenceStatus(api_dump, device, fence);
        }
    }
    VkResult result = device_dispatch_table(device)->GetFenceStatus(device, fence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetFenceStatus(api_dump, device, fence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(device)->WaitForFences(device, fenceCount, pFences, waitAll, timeout);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkWaitForFences", "device, fenceCount, pFences, waitAll, timeout", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWaitForFences(api_dump, device, fenceCount, pFences, waitAll, timeout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateSemaphore", "device, pCreateInfo, pAllocator, pSemaphore", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSemaphore(api_dump, device, pCreateInfo, pAllocator, pSemaphore);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSemaphore(api_dump, device, pCreateInfo, pAllocator, pSemaphore);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroySemaphore", "device, semaphore, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroySemaphore(api_dump, device, semaphore, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroySemaphore(device, semaphore, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroySemaphore(api_dump, device, semaphore, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateQueryPool", "device, pCreateInfo, pAllocator, pQueryPool", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateQueryPool(api_dump, device, pCreateInfo, pAllocator, pQueryPool);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateQueryPool(api_dump, device, pCreateInfo, pAllocator, pQueryPool);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyQueryPool", "device, queryPool, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyQueryPool(api_dump, device, queryPool, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyQueryPool(device, queryPool, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyQueryPool(api_dump, device, queryPool, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(device)->GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkGetQueryPoolResults", "device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetQueryPoolResults(api_dump, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateBuffer(VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateBuffer", "device, pCreateInfo, pAllocator, pBuffer", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateBuffer(api_dump, device, pCreateInfo, pAllocator, pBuffer);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateBuffer(api_dump, device, pCreateInfo, pAllocator, pBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyBuffer", "device, buffer, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyBuffer(api_dump, device, buffer, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyBuffer(device, buffer, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyBuffer(api_dump, device, buffer, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateImage(VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateImage", "device, pCreateInfo, pAllocator, pImage", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateImage(api_dump, device, pCreateInfo, pAllocator, pImage);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateImage(device, pCreateInfo, pAllocator, pImage);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateImage(api_dump, device, pCreateInfo, pAllocator, pImage);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyImage", "device, image, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyImage(api_dump, device, image, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyImage(device, image, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyImage(api_dump, device, image, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSubresourceLayout", "device, image, pSubresource, pLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSubresourceLayout(api_dump, device, image, pSubresource, pLayout);
        }
    }
    device_dispatch_table(device)->GetImageSubresourceLayout(device, image, pSubresource, pLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSubresourceLayout(api_dump, device, image, pSubresource, pLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateImageView(VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateImageView", "device, pCreateInfo, pAllocator, pView", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateImageView(api_dump, device, pCreateInfo, pAllocator, pView);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateImageView(device, pCreateInfo, pAllocator, pView);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateImageView(api_dump, device, pCreateInfo, pAllocator, pView);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyImageView", "device, imageView, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyImageView(api_dump, device, imageView, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyImageView(device, imageView, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyImageView(api_dump, device, imageView, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateCommandPool", "device, pCreateInfo, pAllocator, pCommandPool", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateCommandPool(api_dump, device, pCreateInfo, pAllocator, pCommandPool);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateCommandPool(api_dump, device, pCreateInfo, pAllocator, pCommandPool);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyCommandPool", "device, commandPool, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyCommandPool(api_dump, device, commandPool, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyCommandPool(device, commandPool, pAllocator);
    api_dump.eraseCmdBufferPool(device, commandPool);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyCommandPool(api_dump, device, commandPool, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetCommandPool", "device, commandPool, flags", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetCommandPool(api_dump, device, commandPool, flags);
        }
    }
    VkResult result = device_dispatch_table(device)->ResetCommandPool(device, commandPool, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetCommandPool(api_dump, device, commandPool, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAllocateCommandBuffers", "device, pAllocateInfo, pCommandBuffers", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAllocateCommandBuffers(api_dump, device, pAllocateInfo, pCommandBuffers);
        }
    }
    VkResult result = device_dispatch_table(device)->AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
    if (result == VK_SUCCESS)
        api_dump.addCmdBuffers(
            device,
            pAllocateInfo->commandPool,
            std::vector<VkCommandBuffer>(pCommandBuffers, pCommandBuffers + pAllocateInfo->commandBufferCount),
            pAllocateInfo->level);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAllocateCommandBuffers(api_dump, device, pAllocateInfo, pCommandBuffers);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkFreeCommandBuffers", "device, commandPool, commandBufferCount, pCommandBuffers", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkFreeCommandBuffers(api_dump, device, commandPool, commandBufferCount, pCommandBuffers);
        }
    }
    device_dispatch_table(device)->FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
    api_dump.eraseCmdBuffers(device, commandPool, std::vector<VkCommandBuffer>(pCommandBuffers, pCommandBuffers + commandBufferCount));
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkFreeCommandBuffers(api_dump, device, commandPool, commandBufferCount, pCommandBuffers);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBeginCommandBuffer", "commandBuffer, pBeginInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBeginCommandBuffer(api_dump, commandBuffer, pBeginInfo);
        }
    }
    VkResult result = device_dispatch_table(commandBuffer)->BeginCommandBuffer(commandBuffer, pBeginInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBeginCommandBuffer(api_dump, commandBuffer, pBeginInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkEndCommandBuffer(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkEndCommandBuffer", "commandBuffer", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkEndCommandBuffer(api_dump, commandBuffer);
        }
    }
    VkResult result = device_dispatch_table(commandBuffer)->EndCommandBuffer(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkEndCommandBuffer(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetCommandBuffer", "commandBuffer, flags", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetCommandBuffer(api_dump, commandBuffer, flags);
        }
    }
    VkResult result = device_dispatch_table(commandBuffer)->ResetCommandBuffer(commandBuffer, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetCommandBuffer(api_dump, commandBuffer, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyBuffer", "commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyBuffer(api_dump, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyBuffer(api_dump, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyImage", "commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyImage(api_dump, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyImage(api_dump, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyBufferToImage", "commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyBufferToImage(api_dump, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyBufferToImage(api_dump, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyImageToBuffer", "commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyImageToBuffer(api_dump, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyImageToBuffer(api_dump, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdUpdateBuffer", "commandBuffer, dstBuffer, dstOffset, dataSize, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdUpdateBuffer(api_dump, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
        }
    }
    device_dispatch_table(commandBuffer)->CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdUpdateBuffer(api_dump, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdFillBuffer", "commandBuffer, dstBuffer, dstOffset, size, data", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdFillBuffer(api_dump, commandBuffer, dstBuffer, dstOffset, size, data);
        }
    }
    device_dispatch_table(commandBuffer)->CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdFillBuffer(api_dump, commandBuffer, dstBuffer, dstOffset, size, data);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPipelineBarrier", "commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPipelineBarrier(api_dump, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPipelineBarrier(api_dump, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginQuery", "commandBuffer, queryPool, query, flags", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginQuery(api_dump, commandBuffer, queryPool, query, flags);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginQuery(commandBuffer, queryPool, query, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginQuery(api_dump, commandBuffer, queryPool, query, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndQuery", "commandBuffer, queryPool, query", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndQuery(api_dump, commandBuffer, queryPool, query);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndQuery(commandBuffer, queryPool, query);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndQuery(api_dump, commandBuffer, queryPool, query);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResetQueryPool", "commandBuffer, queryPool, firstQuery, queryCount", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResetQueryPool(api_dump, commandBuffer, queryPool, firstQuery, queryCount);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResetQueryPool(api_dump, commandBuffer, queryPool, firstQuery, queryCount);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteTimestamp", "commandBuffer, pipelineStage, queryPool, query", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteTimestamp(api_dump, commandBuffer, pipelineStage, queryPool, query);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteTimestamp(api_dump, commandBuffer, pipelineStage, queryPool, query);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyQueryPoolResults", "commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyQueryPoolResults(api_dump, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyQueryPoolResults(api_dump, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdExecuteCommands", "commandBuffer, commandBufferCount, pCommandBuffers", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdExecuteCommands(api_dump, commandBuffer, commandBufferCount, pCommandBuffers);
        }
    }
    device_dispatch_table(commandBuffer)->CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdExecuteCommands(api_dump, commandBuffer, commandBufferCount, pCommandBuffers);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateEvent(VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateEvent", "device, pCreateInfo, pAllocator, pEvent", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateEvent(api_dump, device, pCreateInfo, pAllocator, pEvent);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateEvent(device, pCreateInfo, pAllocator, pEvent);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateEvent(api_dump, device, pCreateInfo, pAllocator, pEvent);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyEvent", "device, event, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyEvent(api_dump, device, event, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyEvent(device, event, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyEvent(api_dump, device, event, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetEventStatus", "device, event", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetEventStatus(api_dump, device, event);
        }
    }
    VkResult result = device_dispatch_table(device)->GetEventStatus(device, event);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetEventStatus(api_dump, device, event);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetEvent(VkDevice device, VkEvent event) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetEvent", "device, event", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetEvent(api_dump, device, event);
        }
    }
    VkResult result = device_dispatch_table(device)->SetEvent(device, event);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetEvent(api_dump, device, event);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkResetEvent(VkDevice device, VkEvent event) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetEvent", "device, event", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetEvent(api_dump, device, event);
        }
    }
    VkResult result = device_dispatch_table(device)->ResetEvent(device, event);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetEvent(api_dump, device, event);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferView(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateBufferView", "device, pCreateInfo, pAllocator, pView", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateBufferView(api_dump, device, pCreateInfo, pAllocator, pView);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateBufferView(device, pCreateInfo, pAllocator, pView);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateBufferView(api_dump, device, pCreateInfo, pAllocator, pView);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyBufferView", "device, bufferView, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyBufferView(api_dump, device, bufferView, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyBufferView(device, bufferView, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyBufferView(api_dump, device, bufferView, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateShaderModule", "device, pCreateInfo, pAllocator, pShaderModule", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateShaderModule(api_dump, device, pCreateInfo, pAllocator, pShaderModule);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateShaderModule(api_dump, device, pCreateInfo, pAllocator, pShaderModule);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyShaderModule", "device, shaderModule, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyShaderModule(api_dump, device, shaderModule, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyShaderModule(device, shaderModule, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyShaderModule(api_dump, device, shaderModule, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreatePipelineCache", "device, pCreateInfo, pAllocator, pPipelineCache", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreatePipelineCache(api_dump, device, pCreateInfo, pAllocator, pPipelineCache);
        }
    }
    VkResult result = device_dispatch_table(device)->CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreatePipelineCache(api_dump, device, pCreateInfo, pAllocator, pPipelineCache);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyPipelineCache", "device, pipelineCache, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyPipelineCache(api_dump, device, pipelineCache, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyPipelineCache(device, pipelineCache, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyPipelineCache(api_dump, device, pipelineCache, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineCacheData", "device, pipelineCache, pDataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineCacheData(api_dump, device, pipelineCache, pDataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelineCacheData(device, pipelineCache, pDataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineCacheData(api_dump, device, pipelineCache, pDataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkMergePipelineCaches", "device, dstCache, srcCacheCount, pSrcCaches", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkMergePipelineCaches(api_dump, device, dstCache, srcCacheCount, pSrcCaches);
        }
    }
    VkResult result = device_dispatch_table(device)->MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkMergePipelineCaches(api_dump, device, dstCache, srcCacheCount, pSrcCaches);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateComputePipelines", "device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateComputePipelines(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateComputePipelines(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyPipeline", "device, pipeline, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyPipeline(api_dump, device, pipeline, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyPipeline(device, pipeline, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyPipeline(api_dump, device, pipeline, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreatePipelineLayout", "device, pCreateInfo, pAllocator, pPipelineLayout", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreatePipelineLayout(api_dump, device, pCreateInfo, pAllocator, pPipelineLayout);
        }
    }
    VkResult result = device_dispatch_table(device)->CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreatePipelineLayout(api_dump, device, pCreateInfo, pAllocator, pPipelineLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyPipelineLayout", "device, pipelineLayout, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyPipelineLayout(api_dump, device, pipelineLayout, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyPipelineLayout(device, pipelineLayout, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyPipelineLayout(api_dump, device, pipelineLayout, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSampler(VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateSampler", "device, pCreateInfo, pAllocator, pSampler", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSampler(api_dump, device, pCreateInfo, pAllocator, pSampler);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateSampler(device, pCreateInfo, pAllocator, pSampler);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSampler(api_dump, device, pCreateInfo, pAllocator, pSampler);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroySampler", "device, sampler, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroySampler(api_dump, device, sampler, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroySampler(device, sampler, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroySampler(api_dump, device, sampler, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDescriptorSetLayout", "device, pCreateInfo, pAllocator, pSetLayout", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDescriptorSetLayout(api_dump, device, pCreateInfo, pAllocator, pSetLayout);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDescriptorSetLayout(api_dump, device, pCreateInfo, pAllocator, pSetLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDescriptorSetLayout", "device, descriptorSetLayout, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDescriptorSetLayout(api_dump, device, descriptorSetLayout, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDescriptorSetLayout(api_dump, device, descriptorSetLayout, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDescriptorPool", "device, pCreateInfo, pAllocator, pDescriptorPool", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDescriptorPool(api_dump, device, pCreateInfo, pAllocator, pDescriptorPool);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDescriptorPool(api_dump, device, pCreateInfo, pAllocator, pDescriptorPool);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDescriptorPool", "device, descriptorPool, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDescriptorPool(api_dump, device, descriptorPool, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDescriptorPool(device, descriptorPool, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDescriptorPool(api_dump, device, descriptorPool, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetDescriptorPool", "device, descriptorPool, flags", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetDescriptorPool(api_dump, device, descriptorPool, flags);
        }
    }
    VkResult result = device_dispatch_table(device)->ResetDescriptorPool(device, descriptorPool, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetDescriptorPool(api_dump, device, descriptorPool, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAllocateDescriptorSets", "device, pAllocateInfo, pDescriptorSets", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAllocateDescriptorSets(api_dump, device, pAllocateInfo, pDescriptorSets);
        }
    }
    VkResult result = device_dispatch_table(device)->AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAllocateDescriptorSets(api_dump, device, pAllocateInfo, pDescriptorSets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkFreeDescriptorSets", "device, descriptorPool, descriptorSetCount, pDescriptorSets", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkFreeDescriptorSets(api_dump, device, descriptorPool, descriptorSetCount, pDescriptorSets);
        }
    }
    VkResult result = device_dispatch_table(device)->FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkFreeDescriptorSets(api_dump, device, descriptorPool, descriptorSetCount, pDescriptorSets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUpdateDescriptorSets", "device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUpdateDescriptorSets(api_dump, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
        }
    }
    device_dispatch_table(device)->UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUpdateDescriptorSets(api_dump, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindPipeline", "commandBuffer, pipelineBindPoint, pipeline", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindPipeline(api_dump, commandBuffer, pipelineBindPoint, pipeline);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindPipeline(api_dump, commandBuffer, pipelineBindPoint, pipeline);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindDescriptorSets", "commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindDescriptorSets(api_dump, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindDescriptorSets(api_dump, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdClearColorImage", "commandBuffer, image, imageLayout, pColor, rangeCount, pRanges", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdClearColorImage(api_dump, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
        }
    }
    device_dispatch_table(commandBuffer)->CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdClearColorImage(api_dump, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatch", "commandBuffer, groupCountX, groupCountY, groupCountZ", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatch(api_dump, commandBuffer, groupCountX, groupCountY, groupCountZ);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatch(api_dump, commandBuffer, groupCountX, groupCountY, groupCountZ);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchIndirect", "commandBuffer, buffer, offset", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchIndirect(api_dump, commandBuffer, buffer, offset);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchIndirect(commandBuffer, buffer, offset);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchIndirect(api_dump, commandBuffer, buffer, offset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetEvent", "commandBuffer, event, stageMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetEvent(api_dump, commandBuffer, event, stageMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetEvent(commandBuffer, event, stageMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetEvent(api_dump, commandBuffer, event, stageMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResetEvent", "commandBuffer, event, stageMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResetEvent(api_dump, commandBuffer, event, stageMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResetEvent(commandBuffer, event, stageMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResetEvent(api_dump, commandBuffer, event, stageMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWaitEvents", "commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWaitEvents(api_dump, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWaitEvents(api_dump, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushConstants", "commandBuffer, layout, stageFlags, offset, size, pValues", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushConstants(api_dump, commandBuffer, layout, stageFlags, offset, size, pValues);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushConstants(api_dump, commandBuffer, layout, stageFlags, offset, size, pValues);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateGraphicsPipelines", "device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateGraphicsPipelines(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateGraphicsPipelines(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateFramebuffer", "device, pCreateInfo, pAllocator, pFramebuffer", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateFramebuffer(api_dump, device, pCreateInfo, pAllocator, pFramebuffer);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateFramebuffer(api_dump, device, pCreateInfo, pAllocator, pFramebuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyFramebuffer", "device, framebuffer, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyFramebuffer(api_dump, device, framebuffer, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyFramebuffer(device, framebuffer, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyFramebuffer(api_dump, device, framebuffer, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateRenderPass", "device, pCreateInfo, pAllocator, pRenderPass", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateRenderPass(api_dump, device, pCreateInfo, pAllocator, pRenderPass);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateRenderPass(api_dump, device, pCreateInfo, pAllocator, pRenderPass);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyRenderPass", "device, renderPass, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyRenderPass(api_dump, device, renderPass, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyRenderPass(device, renderPass, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyRenderPass(api_dump, device, renderPass, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRenderAreaGranularity", "device, renderPass, pGranularity", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRenderAreaGranularity(api_dump, device, renderPass, pGranularity);
        }
    }
    device_dispatch_table(device)->GetRenderAreaGranularity(device, renderPass, pGranularity);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRenderAreaGranularity(api_dump, device, renderPass, pGranularity);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewport", "commandBuffer, firstViewport, viewportCount, pViewports", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewport(api_dump, commandBuffer, firstViewport, viewportCount, pViewports);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewport(api_dump, commandBuffer, firstViewport, viewportCount, pViewports);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetScissor", "commandBuffer, firstScissor, scissorCount, pScissors", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetScissor(api_dump, commandBuffer, firstScissor, scissorCount, pScissors);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetScissor(api_dump, commandBuffer, firstScissor, scissorCount, pScissors);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLineWidth", "commandBuffer, lineWidth", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLineWidth(api_dump, commandBuffer, lineWidth);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLineWidth(commandBuffer, lineWidth);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLineWidth(api_dump, commandBuffer, lineWidth);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBias", "commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBias(api_dump, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBias(api_dump, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetBlendConstants", "commandBuffer, blendConstants", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetBlendConstants(api_dump, commandBuffer, blendConstants);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetBlendConstants(commandBuffer, blendConstants);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetBlendConstants(api_dump, commandBuffer, blendConstants);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBounds", "commandBuffer, minDepthBounds, maxDepthBounds", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBounds(api_dump, commandBuffer, minDepthBounds, maxDepthBounds);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBounds(api_dump, commandBuffer, minDepthBounds, maxDepthBounds);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilCompareMask", "commandBuffer, faceMask, compareMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilCompareMask(api_dump, commandBuffer, faceMask, compareMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilCompareMask(api_dump, commandBuffer, faceMask, compareMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilWriteMask", "commandBuffer, faceMask, writeMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilWriteMask(api_dump, commandBuffer, faceMask, writeMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilWriteMask(api_dump, commandBuffer, faceMask, writeMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilReference", "commandBuffer, faceMask, reference", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilReference(api_dump, commandBuffer, faceMask, reference);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilReference(commandBuffer, faceMask, reference);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilReference(api_dump, commandBuffer, faceMask, reference);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindIndexBuffer", "commandBuffer, buffer, offset, indexType", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindIndexBuffer(api_dump, commandBuffer, buffer, offset, indexType);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindIndexBuffer(api_dump, commandBuffer, buffer, offset, indexType);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindVertexBuffers", "commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindVertexBuffers(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindVertexBuffers(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDraw", "commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDraw(api_dump, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDraw(api_dump, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndexed", "commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndexed(api_dump, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndexed(api_dump, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndirect", "commandBuffer, buffer, offset, drawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndirect(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndirect(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndexedIndirect", "commandBuffer, buffer, offset, drawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndexedIndirect(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndexedIndirect(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBlitImage", "commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBlitImage(api_dump, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBlitImage(api_dump, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdClearDepthStencilImage", "commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdClearDepthStencilImage(api_dump, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
        }
    }
    device_dispatch_table(commandBuffer)->CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdClearDepthStencilImage(api_dump, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdClearAttachments", "commandBuffer, attachmentCount, pAttachments, rectCount, pRects", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdClearAttachments(api_dump, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
        }
    }
    device_dispatch_table(commandBuffer)->CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdClearAttachments(api_dump, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResolveImage", "commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResolveImage(api_dump, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResolveImage(api_dump, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginRenderPass", "commandBuffer, pRenderPassBegin, contents", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginRenderPass(api_dump, commandBuffer, pRenderPassBegin, contents);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginRenderPass(api_dump, commandBuffer, pRenderPassBegin, contents);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdNextSubpass", "commandBuffer, contents", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdNextSubpass(api_dump, commandBuffer, contents);
        }
    }
    device_dispatch_table(commandBuffer)->CmdNextSubpass(commandBuffer, contents);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdNextSubpass(api_dump, commandBuffer, contents);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRenderPass", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRenderPass(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRenderPass(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRenderPass(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindBufferMemory2", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindBufferMemory2(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindBufferMemory2(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindBufferMemory2(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindImageMemory2", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindImageMemory2(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindImageMemory2(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindImageMemory2(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceGroupPeerMemoryFeatures", "device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceGroupPeerMemoryFeatures(api_dump, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
        }
    }
    device_dispatch_table(device)->GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceGroupPeerMemoryFeatures(api_dump, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDeviceMask", "commandBuffer, deviceMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDeviceMask(api_dump, commandBuffer, deviceMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDeviceMask(commandBuffer, deviceMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDeviceMask(api_dump, commandBuffer, deviceMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageMemoryRequirements2", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageMemoryRequirements2(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageMemoryRequirements2(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferMemoryRequirements2", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferMemoryRequirements2(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferMemoryRequirements2(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSparseMemoryRequirements2", "device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSparseMemoryRequirements2(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSparseMemoryRequirements2(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkTrimCommandPool", "device, commandPool, flags", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkTrimCommandPool(api_dump, device, commandPool, flags);
        }
    }
    device_dispatch_table(device)->TrimCommandPool(device, commandPool, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkTrimCommandPool(api_dump, device, commandPool, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceQueue2", "device, pQueueInfo, pQueue", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceQueue2(api_dump, device, pQueueInfo, pQueue);
        }
    }
    device_dispatch_table(device)->GetDeviceQueue2(device, pQueueInfo, pQueue);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceQueue2(api_dump, device, pQueueInfo, pQueue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchBase", "commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchBase(api_dump, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchBase(api_dump, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDescriptorUpdateTemplate", "device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDescriptorUpdateTemplate(api_dump, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDescriptorUpdateTemplate(api_dump, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDescriptorUpdateTemplate", "device, descriptorUpdateTemplate, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDescriptorUpdateTemplate(api_dump, device, descriptorUpdateTemplate, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDescriptorUpdateTemplate(api_dump, device, descriptorUpdateTemplate, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUpdateDescriptorSetWithTemplate", "device, descriptorSet, descriptorUpdateTemplate, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUpdateDescriptorSetWithTemplate(api_dump, device, descriptorSet, descriptorUpdateTemplate, pData);
        }
    }
    device_dispatch_table(device)->UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUpdateDescriptorSetWithTemplate(api_dump, device, descriptorSet, descriptorUpdateTemplate, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorSetLayoutSupport", "device, pCreateInfo, pSupport", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorSetLayoutSupport(api_dump, device, pCreateInfo, pSupport);
        }
    }
    device_dispatch_table(device)->GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorSetLayoutSupport(api_dump, device, pCreateInfo, pSupport);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateSamplerYcbcrConversion", "device, pCreateInfo, pAllocator, pYcbcrConversion", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSamplerYcbcrConversion(api_dump, device, pCreateInfo, pAllocator, pYcbcrConversion);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSamplerYcbcrConversion(api_dump, device, pCreateInfo, pAllocator, pYcbcrConversion);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroySamplerYcbcrConversion", "device, ycbcrConversion, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroySamplerYcbcrConversion(api_dump, device, ycbcrConversion, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroySamplerYcbcrConversion(api_dump, device, ycbcrConversion, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetQueryPool", "device, queryPool, firstQuery, queryCount", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetQueryPool(api_dump, device, queryPool, firstQuery, queryCount);
        }
    }
    device_dispatch_table(device)->ResetQueryPool(device, queryPool, firstQuery, queryCount);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetQueryPool(api_dump, device, queryPool, firstQuery, queryCount);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t* pValue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSemaphoreCounterValue", "device, semaphore, pValue", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSemaphoreCounterValue(api_dump, device, semaphore, pValue);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSemaphoreCounterValue(device, semaphore, pValue);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSemaphoreCounterValue(api_dump, device, semaphore, pValue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(device)->WaitSemaphores(device, pWaitInfo, timeout);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkWaitSemaphores", "device, pWaitInfo, timeout", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWaitSemaphores(api_dump, device, pWaitInfo, timeout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSignalSemaphore", "device, pSignalInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSignalSemaphore(api_dump, device, pSignalInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SignalSemaphore(device, pSignalInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSignalSemaphore(api_dump, device, pSignalInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkDeviceAddress VKAPI_CALL vkGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferDeviceAddress", "device, pInfo", "VkDeviceAddress");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferDeviceAddress(api_dump, device, pInfo);
        }
    }
    VkDeviceAddress result = device_dispatch_table(device)->GetBufferDeviceAddress(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceAddress", result, dump_return_value_VkDeviceAddress);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferDeviceAddress(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR uint64_t VKAPI_CALL vkGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferOpaqueCaptureAddress", "device, pInfo", "uint64_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferOpaqueCaptureAddress(api_dump, device, pInfo);
        }
    }
    uint64_t result = device_dispatch_table(device)->GetBufferOpaqueCaptureAddress(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint64_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferOpaqueCaptureAddress(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR uint64_t VKAPI_CALL vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceMemoryOpaqueCaptureAddress", "device, pInfo", "uint64_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceMemoryOpaqueCaptureAddress(api_dump, device, pInfo);
        }
    }
    uint64_t result = device_dispatch_table(device)->GetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint64_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceMemoryOpaqueCaptureAddress(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndirectCount", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndirectCount(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndirectCount(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndexedIndirectCount", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndexedIndirectCount(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndexedIndirectCount(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateRenderPass2", "device, pCreateInfo, pAllocator, pRenderPass", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateRenderPass2(api_dump, device, pCreateInfo, pAllocator, pRenderPass);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateRenderPass2(api_dump, device, pCreateInfo, pAllocator, pRenderPass);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginRenderPass2", "commandBuffer, pRenderPassBegin, pSubpassBeginInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginRenderPass2(api_dump, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginRenderPass2(api_dump, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdNextSubpass2", "commandBuffer, pSubpassBeginInfo, pSubpassEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdNextSubpass2(api_dump, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdNextSubpass2(api_dump, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRenderPass2", "commandBuffer, pSubpassEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRenderPass2(api_dump, commandBuffer, pSubpassEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRenderPass2(api_dump, commandBuffer, pSubpassEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreatePrivateDataSlot", "device, pCreateInfo, pAllocator, pPrivateDataSlot", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreatePrivateDataSlot(api_dump, device, pCreateInfo, pAllocator, pPrivateDataSlot);
        }
    }
    VkResult result = device_dispatch_table(device)->CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreatePrivateDataSlot(api_dump, device, pCreateInfo, pAllocator, pPrivateDataSlot);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyPrivateDataSlot", "device, privateDataSlot, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyPrivateDataSlot(api_dump, device, privateDataSlot, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyPrivateDataSlot(api_dump, device, privateDataSlot, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetPrivateData", "device, objectType, objectHandle, privateDataSlot, data", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetPrivateData(api_dump, device, objectType, objectHandle, privateDataSlot, data);
        }
    }
    VkResult result = device_dispatch_table(device)->SetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetPrivateData(api_dump, device, objectType, objectHandle, privateDataSlot, data);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPrivateData", "device, objectType, objectHandle, privateDataSlot, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPrivateData(api_dump, device, objectType, objectHandle, privateDataSlot, pData);
        }
    }
    device_dispatch_table(device)->GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPrivateData(api_dump, device, objectType, objectHandle, privateDataSlot, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPipelineBarrier2", "commandBuffer, pDependencyInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPipelineBarrier2(api_dump, commandBuffer, pDependencyInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPipelineBarrier2(commandBuffer, pDependencyInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPipelineBarrier2(api_dump, commandBuffer, pDependencyInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteTimestamp2", "commandBuffer, stage, queryPool, query", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteTimestamp2(api_dump, commandBuffer, stage, queryPool, query);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteTimestamp2(api_dump, commandBuffer, stage, queryPool, query);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueSubmit2", "queue, submitCount, pSubmits, fence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueSubmit2(api_dump, queue, submitCount, pSubmits, fence);
        }
    }
    VkResult result = device_dispatch_table(queue)->QueueSubmit2(queue, submitCount, pSubmits, fence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueSubmit2(api_dump, queue, submitCount, pSubmits, fence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyBuffer2", "commandBuffer, pCopyBufferInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyBuffer2(api_dump, commandBuffer, pCopyBufferInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyBuffer2(api_dump, commandBuffer, pCopyBufferInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyImage2", "commandBuffer, pCopyImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyImage2(api_dump, commandBuffer, pCopyImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyImage2(commandBuffer, pCopyImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyImage2(api_dump, commandBuffer, pCopyImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyBufferToImage2", "commandBuffer, pCopyBufferToImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyBufferToImage2(api_dump, commandBuffer, pCopyBufferToImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyBufferToImage2(api_dump, commandBuffer, pCopyBufferToImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyImageToBuffer2", "commandBuffer, pCopyImageToBufferInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyImageToBuffer2(api_dump, commandBuffer, pCopyImageToBufferInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyImageToBuffer2(api_dump, commandBuffer, pCopyImageToBufferInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceBufferMemoryRequirements", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceBufferMemoryRequirements(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceBufferMemoryRequirements(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceImageMemoryRequirements", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceImageMemoryRequirements(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceImageMemoryRequirements(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceImageSparseMemoryRequirements", "device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceImageSparseMemoryRequirements(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceImageSparseMemoryRequirements(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetEvent2", "commandBuffer, event, pDependencyInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetEvent2(api_dump, commandBuffer, event, pDependencyInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetEvent2(commandBuffer, event, pDependencyInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetEvent2(api_dump, commandBuffer, event, pDependencyInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResetEvent2", "commandBuffer, event, stageMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResetEvent2(api_dump, commandBuffer, event, stageMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResetEvent2(commandBuffer, event, stageMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResetEvent2(api_dump, commandBuffer, event, stageMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWaitEvents2", "commandBuffer, eventCount, pEvents, pDependencyInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWaitEvents2(api_dump, commandBuffer, eventCount, pEvents, pDependencyInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWaitEvents2(api_dump, commandBuffer, eventCount, pEvents, pDependencyInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBlitImage2", "commandBuffer, pBlitImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBlitImage2(api_dump, commandBuffer, pBlitImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBlitImage2(commandBuffer, pBlitImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBlitImage2(api_dump, commandBuffer, pBlitImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResolveImage2", "commandBuffer, pResolveImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResolveImage2(api_dump, commandBuffer, pResolveImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResolveImage2(commandBuffer, pResolveImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResolveImage2(api_dump, commandBuffer, pResolveImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginRendering", "commandBuffer, pRenderingInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginRendering(api_dump, commandBuffer, pRenderingInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginRendering(commandBuffer, pRenderingInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginRendering(api_dump, commandBuffer, pRenderingInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndRendering(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRendering", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRendering(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRendering(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRendering(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCullMode", "commandBuffer, cullMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCullMode(api_dump, commandBuffer, cullMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCullMode(commandBuffer, cullMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCullMode(api_dump, commandBuffer, cullMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetFrontFace", "commandBuffer, frontFace", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetFrontFace(api_dump, commandBuffer, frontFace);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetFrontFace(commandBuffer, frontFace);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetFrontFace(api_dump, commandBuffer, frontFace);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPrimitiveTopology", "commandBuffer, primitiveTopology", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPrimitiveTopology(api_dump, commandBuffer, primitiveTopology);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPrimitiveTopology(api_dump, commandBuffer, primitiveTopology);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewportWithCount", "commandBuffer, viewportCount, pViewports", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewportWithCount(api_dump, commandBuffer, viewportCount, pViewports);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewportWithCount(api_dump, commandBuffer, viewportCount, pViewports);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetScissorWithCount", "commandBuffer, scissorCount, pScissors", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetScissorWithCount(api_dump, commandBuffer, scissorCount, pScissors);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetScissorWithCount(api_dump, commandBuffer, scissorCount, pScissors);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindVertexBuffers2", "commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindVertexBuffers2(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindVertexBuffers2(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthTestEnable", "commandBuffer, depthTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthTestEnable(api_dump, commandBuffer, depthTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthTestEnable(commandBuffer, depthTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthTestEnable(api_dump, commandBuffer, depthTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthWriteEnable", "commandBuffer, depthWriteEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthWriteEnable(api_dump, commandBuffer, depthWriteEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthWriteEnable(api_dump, commandBuffer, depthWriteEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthCompareOp", "commandBuffer, depthCompareOp", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthCompareOp(api_dump, commandBuffer, depthCompareOp);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthCompareOp(commandBuffer, depthCompareOp);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthCompareOp(api_dump, commandBuffer, depthCompareOp);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBoundsTestEnable", "commandBuffer, depthBoundsTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBoundsTestEnable(api_dump, commandBuffer, depthBoundsTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBoundsTestEnable(api_dump, commandBuffer, depthBoundsTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilTestEnable", "commandBuffer, stencilTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilTestEnable(api_dump, commandBuffer, stencilTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilTestEnable(api_dump, commandBuffer, stencilTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilOp", "commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilOp(api_dump, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilOp(api_dump, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRasterizerDiscardEnable", "commandBuffer, rasterizerDiscardEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRasterizerDiscardEnable(api_dump, commandBuffer, rasterizerDiscardEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRasterizerDiscardEnable(api_dump, commandBuffer, rasterizerDiscardEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBiasEnable", "commandBuffer, depthBiasEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBiasEnable(api_dump, commandBuffer, depthBiasEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBiasEnable(api_dump, commandBuffer, depthBiasEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPrimitiveRestartEnable", "commandBuffer, primitiveRestartEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPrimitiveRestartEnable(api_dump, commandBuffer, primitiveRestartEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPrimitiveRestartEnable(api_dump, commandBuffer, primitiveRestartEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory2(VkDevice device, const VkMemoryMapInfo* pMemoryMapInfo, void** ppData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkMapMemory2", "device, pMemoryMapInfo, ppData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkMapMemory2(api_dump, device, pMemoryMapInfo, ppData);
        }
    }
    VkResult result = device_dispatch_table(device)->MapMemory2(device, pMemoryMapInfo, ppData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkMapMemory2(api_dump, device, pMemoryMapInfo, ppData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkUnmapMemory2(VkDevice device, const VkMemoryUnmapInfo* pMemoryUnmapInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUnmapMemory2", "device, pMemoryUnmapInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUnmapMemory2(api_dump, device, pMemoryUnmapInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->UnmapMemory2(device, pMemoryUnmapInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkUnmapMemory2(api_dump, device, pMemoryUnmapInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSubresourceLayout(VkDevice device, const VkDeviceImageSubresourceInfo* pInfo, VkSubresourceLayout2* pLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceImageSubresourceLayout", "device, pInfo, pLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceImageSubresourceLayout(api_dump, device, pInfo, pLayout);
        }
    }
    device_dispatch_table(device)->GetDeviceImageSubresourceLayout(device, pInfo, pLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceImageSubresourceLayout(api_dump, device, pInfo, pLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource, VkSubresourceLayout2* pLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSubresourceLayout2", "device, image, pSubresource, pLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSubresourceLayout2(api_dump, device, image, pSubresource, pLayout);
        }
    }
    device_dispatch_table(device)->GetImageSubresourceLayout2(device, image, pSubresource, pLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSubresourceLayout2(api_dump, device, image, pSubresource, pLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyMemoryToImage(VkDevice device, const VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyMemoryToImage", "device, pCopyMemoryToImageInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyMemoryToImage(api_dump, device, pCopyMemoryToImageInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyMemoryToImage(device, pCopyMemoryToImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyMemoryToImage(api_dump, device, pCopyMemoryToImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToMemory(VkDevice device, const VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyImageToMemory", "device, pCopyImageToMemoryInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyImageToMemory(api_dump, device, pCopyImageToMemoryInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyImageToMemory(device, pCopyImageToMemoryInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyImageToMemory(api_dump, device, pCopyImageToMemoryInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToImage(VkDevice device, const VkCopyImageToImageInfo* pCopyImageToImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyImageToImage", "device, pCopyImageToImageInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyImageToImage(api_dump, device, pCopyImageToImageInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyImageToImage(device, pCopyImageToImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyImageToImage(api_dump, device, pCopyImageToImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkTransitionImageLayout(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo* pTransitions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkTransitionImageLayout", "device, transitionCount, pTransitions", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkTransitionImageLayout(api_dump, device, transitionCount, pTransitions);
        }
    }
    VkResult result = device_dispatch_table(device)->TransitionImageLayout(device, transitionCount, pTransitions);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkTransitionImageLayout(api_dump, device, transitionCount, pTransitions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSet", "commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSet(api_dump, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSet(api_dump, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplate(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSetWithTemplate", "commandBuffer, descriptorUpdateTemplate, layout, set, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSetWithTemplate(api_dump, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSetWithTemplate(api_dump, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets2(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindDescriptorSets2", "commandBuffer, pBindDescriptorSetsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindDescriptorSets2(api_dump, commandBuffer, pBindDescriptorSetsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindDescriptorSets2(commandBuffer, pBindDescriptorSetsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindDescriptorSets2(api_dump, commandBuffer, pBindDescriptorSetsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants2(VkCommandBuffer commandBuffer, const VkPushConstantsInfo* pPushConstantsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushConstants2", "commandBuffer, pPushConstantsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushConstants2(api_dump, commandBuffer, pPushConstantsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushConstants2(commandBuffer, pPushConstantsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushConstants2(api_dump, commandBuffer, pPushConstantsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSet2(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo* pPushDescriptorSetInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSet2", "commandBuffer, pPushDescriptorSetInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSet2(api_dump, commandBuffer, pPushDescriptorSetInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSet2(commandBuffer, pPushDescriptorSetInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSet2(api_dump, commandBuffer, pPushDescriptorSetInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplate2(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSetWithTemplate2", "commandBuffer, pPushDescriptorSetWithTemplateInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSetWithTemplate2(api_dump, commandBuffer, pPushDescriptorSetWithTemplateInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSetWithTemplate2(commandBuffer, pPushDescriptorSetWithTemplateInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSetWithTemplate2(api_dump, commandBuffer, pPushDescriptorSetWithTemplateInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLineStipple(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLineStipple", "commandBuffer, lineStippleFactor, lineStipplePattern", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLineStipple(api_dump, commandBuffer, lineStippleFactor, lineStipplePattern);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLineStipple(api_dump, commandBuffer, lineStippleFactor, lineStipplePattern);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer2(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindIndexBuffer2", "commandBuffer, buffer, offset, size, indexType", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindIndexBuffer2(api_dump, commandBuffer, buffer, offset, size, indexType);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindIndexBuffer2(commandBuffer, buffer, offset, size, indexType);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindIndexBuffer2(api_dump, commandBuffer, buffer, offset, size, indexType);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetRenderingAreaGranularity(VkDevice device, const VkRenderingAreaInfo* pRenderingAreaInfo, VkExtent2D* pGranularity) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRenderingAreaGranularity", "device, pRenderingAreaInfo, pGranularity", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRenderingAreaGranularity(api_dump, device, pRenderingAreaInfo, pGranularity);
        }
    }
    device_dispatch_table(device)->GetRenderingAreaGranularity(device, pRenderingAreaInfo, pGranularity);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRenderingAreaGranularity(api_dump, device, pRenderingAreaInfo, pGranularity);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingAttachmentLocations(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo* pLocationInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRenderingAttachmentLocations", "commandBuffer, pLocationInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRenderingAttachmentLocations(api_dump, commandBuffer, pLocationInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRenderingAttachmentLocations(commandBuffer, pLocationInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRenderingAttachmentLocations(api_dump, commandBuffer, pLocationInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingInputAttachmentIndices(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRenderingInputAttachmentIndices", "commandBuffer, pInputAttachmentIndexInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRenderingInputAttachmentIndices(api_dump, commandBuffer, pInputAttachmentIndexInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRenderingInputAttachmentIndices(commandBuffer, pInputAttachmentIndexInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRenderingInputAttachmentIndices(api_dump, commandBuffer, pInputAttachmentIndexInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateSwapchainKHR", "device, pCreateInfo, pAllocator, pSwapchain", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSwapchainKHR(api_dump, device, pCreateInfo, pAllocator, pSwapchain);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSwapchainKHR(api_dump, device, pCreateInfo, pAllocator, pSwapchain);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroySwapchainKHR", "device, swapchain, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroySwapchainKHR(api_dump, device, swapchain, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroySwapchainKHR(device, swapchain, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroySwapchainKHR(api_dump, device, swapchain, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSwapchainImagesKHR", "device, swapchain, pSwapchainImageCount, pSwapchainImages", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSwapchainImagesKHR(api_dump, device, swapchain, pSwapchainImageCount, pSwapchainImages);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSwapchainImagesKHR(api_dump, device, swapchain, pSwapchainImageCount, pSwapchainImages);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(device)->AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkAcquireNextImageKHR", "device, swapchain, timeout, semaphore, fence, pImageIndex", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireNextImageKHR(api_dump, device, swapchain, timeout, semaphore, fence, pImageIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR* pPresentInfo) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(queue)->QueuePresentKHR(queue, pPresentInfo);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkQueuePresentKHR", "queue, pPresentInfo", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueuePresentKHR(api_dump, queue, pPresentInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    api_dump.nextFrame();
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceGroupPresentCapabilitiesKHR", "device, pDeviceGroupPresentCapabilities", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceGroupPresentCapabilitiesKHR(api_dump, device, pDeviceGroupPresentCapabilities);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceGroupPresentCapabilitiesKHR(api_dump, device, pDeviceGroupPresentCapabilities);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceGroupSurfacePresentModesKHR", "device, surface, pModes", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceGroupSurfacePresentModesKHR(api_dump, device, surface, pModes);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceGroupSurfacePresentModesKHR(api_dump, device, surface, pModes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAcquireNextImage2KHR", "device, pAcquireInfo, pImageIndex", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquireNextImage2KHR(api_dump, device, pAcquireInfo, pImageIndex);
        }
    }
    VkResult result = device_dispatch_table(device)->AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireNextImage2KHR(api_dump, device, pAcquireInfo, pImageIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateSharedSwapchainsKHR", "device, swapchainCount, pCreateInfos, pAllocator, pSwapchains", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSharedSwapchainsKHR(api_dump, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSharedSwapchainsKHR(api_dump, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateVideoSessionKHR", "device, pCreateInfo, pAllocator, pVideoSession", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateVideoSessionKHR(api_dump, device, pCreateInfo, pAllocator, pVideoSession);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateVideoSessionKHR(api_dump, device, pCreateInfo, pAllocator, pVideoSession);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyVideoSessionKHR", "device, videoSession, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyVideoSessionKHR(api_dump, device, videoSession, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyVideoSessionKHR(device, videoSession, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyVideoSessionKHR(api_dump, device, videoSession, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetVideoSessionMemoryRequirementsKHR", "device, videoSession, pMemoryRequirementsCount, pMemoryRequirements", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetVideoSessionMemoryRequirementsKHR(api_dump, device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
        }
    }
    VkResult result = device_dispatch_table(device)->GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetVideoSessionMemoryRequirementsKHR(api_dump, device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindVideoSessionMemoryKHR", "device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindVideoSessionMemoryKHR(api_dump, device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindVideoSessionMemoryKHR(api_dump, device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateVideoSessionParametersKHR", "device, pCreateInfo, pAllocator, pVideoSessionParameters", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateVideoSessionParametersKHR(api_dump, device, pCreateInfo, pAllocator, pVideoSessionParameters);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateVideoSessionParametersKHR(api_dump, device, pCreateInfo, pAllocator, pVideoSessionParameters);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkUpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUpdateVideoSessionParametersKHR", "device, videoSessionParameters, pUpdateInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUpdateVideoSessionParametersKHR(api_dump, device, videoSessionParameters, pUpdateInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkUpdateVideoSessionParametersKHR(api_dump, device, videoSessionParameters, pUpdateInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyVideoSessionParametersKHR", "device, videoSessionParameters, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyVideoSessionParametersKHR(api_dump, device, videoSessionParameters, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyVideoSessionParametersKHR(api_dump, device, videoSessionParameters, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginVideoCodingKHR", "commandBuffer, pBeginInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginVideoCodingKHR(api_dump, commandBuffer, pBeginInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginVideoCodingKHR(api_dump, commandBuffer, pBeginInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndVideoCodingKHR", "commandBuffer, pEndCodingInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndVideoCodingKHR(api_dump, commandBuffer, pEndCodingInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndVideoCodingKHR(api_dump, commandBuffer, pEndCodingInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdControlVideoCodingKHR", "commandBuffer, pCodingControlInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdControlVideoCodingKHR(api_dump, commandBuffer, pCodingControlInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdControlVideoCodingKHR(api_dump, commandBuffer, pCodingControlInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDecodeVideoKHR", "commandBuffer, pDecodeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDecodeVideoKHR(api_dump, commandBuffer, pDecodeInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDecodeVideoKHR(commandBuffer, pDecodeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDecodeVideoKHR(api_dump, commandBuffer, pDecodeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginRenderingKHR", "commandBuffer, pRenderingInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginRenderingKHR(api_dump, commandBuffer, pRenderingInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginRenderingKHR(commandBuffer, pRenderingInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginRenderingKHR(api_dump, commandBuffer, pRenderingInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderingKHR(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRenderingKHR", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRenderingKHR(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRenderingKHR(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRenderingKHR(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceGroupPeerMemoryFeaturesKHR", "device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceGroupPeerMemoryFeaturesKHR(api_dump, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
        }
    }
    device_dispatch_table(device)->GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceGroupPeerMemoryFeaturesKHR(api_dump, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDeviceMaskKHR", "commandBuffer, deviceMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDeviceMaskKHR(api_dump, commandBuffer, deviceMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDeviceMaskKHR(commandBuffer, deviceMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDeviceMaskKHR(api_dump, commandBuffer, deviceMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchBaseKHR", "commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchBaseKHR(api_dump, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchBaseKHR(api_dump, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkTrimCommandPoolKHR", "device, commandPool, flags", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkTrimCommandPoolKHR(api_dump, device, commandPool, flags);
        }
    }
    device_dispatch_table(device)->TrimCommandPoolKHR(device, commandPool, flags);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkTrimCommandPoolKHR(api_dump, device, commandPool, flags);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryWin32HandleKHR", "device, pGetWin32HandleInfo, pHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryWin32HandleKHR(api_dump, device, pGetWin32HandleInfo, pHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryWin32HandleKHR(api_dump, device, pGetWin32HandleInfo, pHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryWin32HandlePropertiesKHR", "device, handleType, handle, pMemoryWin32HandleProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryWin32HandlePropertiesKHR(api_dump, device, handleType, handle, pMemoryWin32HandleProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryWin32HandlePropertiesKHR(api_dump, device, handleType, handle, pMemoryWin32HandleProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryFdKHR", "device, pGetFdInfo, pFd", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryFdKHR(api_dump, device, pGetFdInfo, pFd);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryFdKHR(device, pGetFdInfo, pFd);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryFdKHR(api_dump, device, pGetFdInfo, pFd);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryFdPropertiesKHR", "device, handleType, fd, pMemoryFdProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryFdPropertiesKHR(api_dump, device, handleType, fd, pMemoryFdProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryFdPropertiesKHR(api_dump, device, handleType, fd, pMemoryFdProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkImportSemaphoreWin32HandleKHR", "device, pImportSemaphoreWin32HandleInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkImportSemaphoreWin32HandleKHR(api_dump, device, pImportSemaphoreWin32HandleInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkImportSemaphoreWin32HandleKHR(api_dump, device, pImportSemaphoreWin32HandleInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSemaphoreWin32HandleKHR", "device, pGetWin32HandleInfo, pHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSemaphoreWin32HandleKHR(api_dump, device, pGetWin32HandleInfo, pHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSemaphoreWin32HandleKHR(api_dump, device, pGetWin32HandleInfo, pHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkImportSemaphoreFdKHR", "device, pImportSemaphoreFdInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkImportSemaphoreFdKHR(api_dump, device, pImportSemaphoreFdInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkImportSemaphoreFdKHR(api_dump, device, pImportSemaphoreFdInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSemaphoreFdKHR", "device, pGetFdInfo, pFd", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSemaphoreFdKHR(api_dump, device, pGetFdInfo, pFd);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSemaphoreFdKHR(device, pGetFdInfo, pFd);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSemaphoreFdKHR(api_dump, device, pGetFdInfo, pFd);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSetKHR", "commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSetKHR(api_dump, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSetKHR(api_dump, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSetWithTemplateKHR", "commandBuffer, descriptorUpdateTemplate, layout, set, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSetWithTemplateKHR(api_dump, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSetWithTemplateKHR(api_dump, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDescriptorUpdateTemplateKHR", "device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDescriptorUpdateTemplateKHR(api_dump, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDescriptorUpdateTemplateKHR(api_dump, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDescriptorUpdateTemplateKHR", "device, descriptorUpdateTemplate, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDescriptorUpdateTemplateKHR(api_dump, device, descriptorUpdateTemplate, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDescriptorUpdateTemplateKHR(api_dump, device, descriptorUpdateTemplate, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUpdateDescriptorSetWithTemplateKHR", "device, descriptorSet, descriptorUpdateTemplate, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUpdateDescriptorSetWithTemplateKHR(api_dump, device, descriptorSet, descriptorUpdateTemplate, pData);
        }
    }
    device_dispatch_table(device)->UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUpdateDescriptorSetWithTemplateKHR(api_dump, device, descriptorSet, descriptorUpdateTemplate, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateRenderPass2KHR", "device, pCreateInfo, pAllocator, pRenderPass", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateRenderPass2KHR(api_dump, device, pCreateInfo, pAllocator, pRenderPass);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateRenderPass2KHR(api_dump, device, pCreateInfo, pAllocator, pRenderPass);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginRenderPass2KHR", "commandBuffer, pRenderPassBegin, pSubpassBeginInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginRenderPass2KHR(api_dump, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginRenderPass2KHR(api_dump, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdNextSubpass2KHR", "commandBuffer, pSubpassBeginInfo, pSubpassEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdNextSubpass2KHR(api_dump, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdNextSubpass2KHR(api_dump, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRenderPass2KHR", "commandBuffer, pSubpassEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRenderPass2KHR(api_dump, commandBuffer, pSubpassEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRenderPass2KHR(api_dump, commandBuffer, pSubpassEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSwapchainStatusKHR", "device, swapchain", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSwapchainStatusKHR(api_dump, device, swapchain);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSwapchainStatusKHR(device, swapchain);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSwapchainStatusKHR(api_dump, device, swapchain);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkImportFenceWin32HandleKHR", "device, pImportFenceWin32HandleInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkImportFenceWin32HandleKHR(api_dump, device, pImportFenceWin32HandleInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkImportFenceWin32HandleKHR(api_dump, device, pImportFenceWin32HandleInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetFenceWin32HandleKHR", "device, pGetWin32HandleInfo, pHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetFenceWin32HandleKHR(api_dump, device, pGetWin32HandleInfo, pHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetFenceWin32HandleKHR(api_dump, device, pGetWin32HandleInfo, pHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkImportFenceFdKHR", "device, pImportFenceFdInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkImportFenceFdKHR(api_dump, device, pImportFenceFdInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ImportFenceFdKHR(device, pImportFenceFdInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkImportFenceFdKHR(api_dump, device, pImportFenceFdInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetFenceFdKHR", "device, pGetFdInfo, pFd", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetFenceFdKHR(api_dump, device, pGetFdInfo, pFd);
        }
    }
    VkResult result = device_dispatch_table(device)->GetFenceFdKHR(device, pGetFdInfo, pFd);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetFenceFdKHR(api_dump, device, pGetFdInfo, pFd);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAcquireProfilingLockKHR", "device, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquireProfilingLockKHR(api_dump, device, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->AcquireProfilingLockKHR(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireProfilingLockKHR(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkReleaseProfilingLockKHR(VkDevice device) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkReleaseProfilingLockKHR", "device", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleaseProfilingLockKHR(api_dump, device);
        }
    }
    device_dispatch_table(device)->ReleaseProfilingLockKHR(device);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleaseProfilingLockKHR(api_dump, device);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageMemoryRequirements2KHR", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageMemoryRequirements2KHR(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageMemoryRequirements2KHR(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferMemoryRequirements2KHR", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferMemoryRequirements2KHR(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferMemoryRequirements2KHR(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSparseMemoryRequirements2KHR", "device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSparseMemoryRequirements2KHR(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSparseMemoryRequirements2KHR(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateSamplerYcbcrConversionKHR", "device, pCreateInfo, pAllocator, pYcbcrConversion", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateSamplerYcbcrConversionKHR(api_dump, device, pCreateInfo, pAllocator, pYcbcrConversion);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateSamplerYcbcrConversionKHR(api_dump, device, pCreateInfo, pAllocator, pYcbcrConversion);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroySamplerYcbcrConversionKHR", "device, ycbcrConversion, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroySamplerYcbcrConversionKHR(api_dump, device, ycbcrConversion, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroySamplerYcbcrConversionKHR(api_dump, device, ycbcrConversion, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindBufferMemory2KHR", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindBufferMemory2KHR(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindBufferMemory2KHR(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindImageMemory2KHR", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindImageMemory2KHR(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindImageMemory2KHR(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindImageMemory2KHR(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorSetLayoutSupportKHR", "device, pCreateInfo, pSupport", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorSetLayoutSupportKHR(api_dump, device, pCreateInfo, pSupport);
        }
    }
    device_dispatch_table(device)->GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorSetLayoutSupportKHR(api_dump, device, pCreateInfo, pSupport);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndirectCountKHR", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndirectCountKHR(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndirectCountKHR(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndexedIndirectCountKHR", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndexedIndirectCountKHR(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndexedIndirectCountKHR(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t* pValue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSemaphoreCounterValueKHR", "device, semaphore, pValue", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSemaphoreCounterValueKHR(api_dump, device, semaphore, pValue);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSemaphoreCounterValueKHR(device, semaphore, pValue);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSemaphoreCounterValueKHR(api_dump, device, semaphore, pValue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {
    auto& api_dump = ApiDumpInstance::current();
    VkResult result = device_dispatch_table(device)->WaitSemaphoresKHR(device, pWaitInfo, timeout);
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    dump_function_head(api_dump, "vkWaitSemaphoresKHR", "device, pWaitInfo, timeout", "VkResult");
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWaitSemaphoresKHR(api_dump, device, pWaitInfo, timeout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSignalSemaphoreKHR", "device, pSignalInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSignalSemaphoreKHR(api_dump, device, pSignalInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SignalSemaphoreKHR(device, pSignalInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSignalSemaphoreKHR(api_dump, device, pSignalInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetFragmentShadingRateKHR", "commandBuffer, pFragmentSize, combinerOps", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetFragmentShadingRateKHR(api_dump, commandBuffer, pFragmentSize, combinerOps);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetFragmentShadingRateKHR(api_dump, commandBuffer, pFragmentSize, combinerOps);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo* pLocationInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRenderingAttachmentLocationsKHR", "commandBuffer, pLocationInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRenderingAttachmentLocationsKHR(api_dump, commandBuffer, pLocationInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRenderingAttachmentLocationsKHR(api_dump, commandBuffer, pLocationInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRenderingInputAttachmentIndicesKHR", "commandBuffer, pInputAttachmentIndexInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRenderingInputAttachmentIndicesKHR(api_dump, commandBuffer, pInputAttachmentIndexInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRenderingInputAttachmentIndicesKHR(api_dump, commandBuffer, pInputAttachmentIndexInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkWaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkWaitForPresentKHR", "device, swapchain, presentId, timeout", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkWaitForPresentKHR(api_dump, device, swapchain, presentId, timeout);
        }
    }
    VkResult result = device_dispatch_table(device)->WaitForPresentKHR(device, swapchain, presentId, timeout);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWaitForPresentKHR(api_dump, device, swapchain, presentId, timeout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkDeviceAddress VKAPI_CALL vkGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferDeviceAddressKHR", "device, pInfo", "VkDeviceAddress");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferDeviceAddressKHR(api_dump, device, pInfo);
        }
    }
    VkDeviceAddress result = device_dispatch_table(device)->GetBufferDeviceAddressKHR(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceAddress", result, dump_return_value_VkDeviceAddress);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferDeviceAddressKHR(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR uint64_t VKAPI_CALL vkGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferOpaqueCaptureAddressKHR", "device, pInfo", "uint64_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferOpaqueCaptureAddressKHR(api_dump, device, pInfo);
        }
    }
    uint64_t result = device_dispatch_table(device)->GetBufferOpaqueCaptureAddressKHR(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint64_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferOpaqueCaptureAddressKHR(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR uint64_t VKAPI_CALL vkGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceMemoryOpaqueCaptureAddressKHR", "device, pInfo", "uint64_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceMemoryOpaqueCaptureAddressKHR(api_dump, device, pInfo);
        }
    }
    uint64_t result = device_dispatch_table(device)->GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint64_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceMemoryOpaqueCaptureAddressKHR(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDeferredOperationKHR", "device, pAllocator, pDeferredOperation", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDeferredOperationKHR(api_dump, device, pAllocator, pDeferredOperation);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDeferredOperationKHR(api_dump, device, pAllocator, pDeferredOperation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDeferredOperationKHR", "device, operation, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDeferredOperationKHR(api_dump, device, operation, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDeferredOperationKHR(device, operation, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDeferredOperationKHR(api_dump, device, operation, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR uint32_t VKAPI_CALL vkGetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeferredOperationMaxConcurrencyKHR", "device, operation", "uint32_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeferredOperationMaxConcurrencyKHR(api_dump, device, operation);
        }
    }
    uint32_t result = device_dispatch_table(device)->GetDeferredOperationMaxConcurrencyKHR(device, operation);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint32_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeferredOperationMaxConcurrencyKHR(api_dump, device, operation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeferredOperationResultKHR", "device, operation", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeferredOperationResultKHR(api_dump, device, operation);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDeferredOperationResultKHR(device, operation);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeferredOperationResultKHR(api_dump, device, operation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkDeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDeferredOperationJoinKHR", "device, operation", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDeferredOperationJoinKHR(api_dump, device, operation);
        }
    }
    VkResult result = device_dispatch_table(device)->DeferredOperationJoinKHR(device, operation);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkDeferredOperationJoinKHR(api_dump, device, operation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineExecutablePropertiesKHR", "device, pPipelineInfo, pExecutableCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineExecutablePropertiesKHR(api_dump, device, pPipelineInfo, pExecutableCount, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineExecutablePropertiesKHR(api_dump, device, pPipelineInfo, pExecutableCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineExecutableStatisticsKHR", "device, pExecutableInfo, pStatisticCount, pStatistics", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineExecutableStatisticsKHR(api_dump, device, pExecutableInfo, pStatisticCount, pStatistics);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineExecutableStatisticsKHR(api_dump, device, pExecutableInfo, pStatisticCount, pStatistics);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineExecutableInternalRepresentationsKHR", "device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineExecutableInternalRepresentationsKHR(api_dump, device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineExecutableInternalRepresentationsKHR(api_dump, device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory2KHR(VkDevice device, const VkMemoryMapInfo* pMemoryMapInfo, void** ppData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkMapMemory2KHR", "device, pMemoryMapInfo, ppData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkMapMemory2KHR(api_dump, device, pMemoryMapInfo, ppData);
        }
    }
    VkResult result = device_dispatch_table(device)->MapMemory2KHR(device, pMemoryMapInfo, ppData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkMapMemory2KHR(api_dump, device, pMemoryMapInfo, ppData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo* pMemoryUnmapInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUnmapMemory2KHR", "device, pMemoryUnmapInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUnmapMemory2KHR(api_dump, device, pMemoryUnmapInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->UnmapMemory2KHR(device, pMemoryUnmapInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkUnmapMemory2KHR(api_dump, device, pMemoryUnmapInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetEncodedVideoSessionParametersKHR", "device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetEncodedVideoSessionParametersKHR(api_dump, device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetEncodedVideoSessionParametersKHR(api_dump, device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR* pEncodeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEncodeVideoKHR", "commandBuffer, pEncodeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEncodeVideoKHR(api_dump, commandBuffer, pEncodeInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEncodeVideoKHR(commandBuffer, pEncodeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEncodeVideoKHR(api_dump, commandBuffer, pEncodeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetEvent2KHR", "commandBuffer, event, pDependencyInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetEvent2KHR(api_dump, commandBuffer, event, pDependencyInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetEvent2KHR(api_dump, commandBuffer, event, pDependencyInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResetEvent2KHR", "commandBuffer, event, stageMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResetEvent2KHR(api_dump, commandBuffer, event, stageMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResetEvent2KHR(commandBuffer, event, stageMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResetEvent2KHR(api_dump, commandBuffer, event, stageMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWaitEvents2KHR", "commandBuffer, eventCount, pEvents, pDependencyInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWaitEvents2KHR(api_dump, commandBuffer, eventCount, pEvents, pDependencyInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWaitEvents2KHR(api_dump, commandBuffer, eventCount, pEvents, pDependencyInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPipelineBarrier2KHR", "commandBuffer, pDependencyInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPipelineBarrier2KHR(api_dump, commandBuffer, pDependencyInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPipelineBarrier2KHR(api_dump, commandBuffer, pDependencyInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteTimestamp2KHR", "commandBuffer, stage, queryPool, query", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteTimestamp2KHR(api_dump, commandBuffer, stage, queryPool, query);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteTimestamp2KHR(api_dump, commandBuffer, stage, queryPool, query);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueSubmit2KHR", "queue, submitCount, pSubmits, fence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueSubmit2KHR(api_dump, queue, submitCount, pSubmits, fence);
        }
    }
    VkResult result = device_dispatch_table(queue)->QueueSubmit2KHR(queue, submitCount, pSubmits, fence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueSubmit2KHR(api_dump, queue, submitCount, pSubmits, fence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyBuffer2KHR", "commandBuffer, pCopyBufferInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyBuffer2KHR(api_dump, commandBuffer, pCopyBufferInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyBuffer2KHR(api_dump, commandBuffer, pCopyBufferInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyImage2KHR", "commandBuffer, pCopyImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyImage2KHR(api_dump, commandBuffer, pCopyImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyImage2KHR(api_dump, commandBuffer, pCopyImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyBufferToImage2KHR", "commandBuffer, pCopyBufferToImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyBufferToImage2KHR(api_dump, commandBuffer, pCopyBufferToImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyBufferToImage2KHR(api_dump, commandBuffer, pCopyBufferToImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyImageToBuffer2KHR", "commandBuffer, pCopyImageToBufferInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyImageToBuffer2KHR(api_dump, commandBuffer, pCopyImageToBufferInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyImageToBuffer2KHR(api_dump, commandBuffer, pCopyImageToBufferInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBlitImage2KHR", "commandBuffer, pBlitImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBlitImage2KHR(api_dump, commandBuffer, pBlitImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBlitImage2KHR(api_dump, commandBuffer, pBlitImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdResolveImage2KHR", "commandBuffer, pResolveImageInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdResolveImage2KHR(api_dump, commandBuffer, pResolveImageInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdResolveImage2KHR(api_dump, commandBuffer, pResolveImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdTraceRaysIndirect2KHR", "commandBuffer, indirectDeviceAddress", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdTraceRaysIndirect2KHR(api_dump, commandBuffer, indirectDeviceAddress);
        }
    }
    device_dispatch_table(commandBuffer)->CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdTraceRaysIndirect2KHR(api_dump, commandBuffer, indirectDeviceAddress);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceBufferMemoryRequirementsKHR", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceBufferMemoryRequirementsKHR(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceBufferMemoryRequirementsKHR(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceImageMemoryRequirementsKHR", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceImageMemoryRequirementsKHR(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceImageMemoryRequirementsKHR(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceImageSparseMemoryRequirementsKHR", "device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceImageSparseMemoryRequirementsKHR(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceImageSparseMemoryRequirementsKHR(api_dump, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindIndexBuffer2KHR", "commandBuffer, buffer, offset, size, indexType", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindIndexBuffer2KHR(api_dump, commandBuffer, buffer, offset, size, indexType);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindIndexBuffer2KHR(api_dump, commandBuffer, buffer, offset, size, indexType);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo* pRenderingAreaInfo, VkExtent2D* pGranularity) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRenderingAreaGranularityKHR", "device, pRenderingAreaInfo, pGranularity", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRenderingAreaGranularityKHR(api_dump, device, pRenderingAreaInfo, pGranularity);
        }
    }
    device_dispatch_table(device)->GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRenderingAreaGranularityKHR(api_dump, device, pRenderingAreaInfo, pGranularity);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo* pInfo, VkSubresourceLayout2* pLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceImageSubresourceLayoutKHR", "device, pInfo, pLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceImageSubresourceLayoutKHR(api_dump, device, pInfo, pLayout);
        }
    }
    device_dispatch_table(device)->GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceImageSubresourceLayoutKHR(api_dump, device, pInfo, pLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource, VkSubresourceLayout2* pLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSubresourceLayout2KHR", "device, image, pSubresource, pLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSubresourceLayout2KHR(api_dump, device, image, pSubresource, pLayout);
        }
    }
    device_dispatch_table(device)->GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSubresourceLayout2KHR(api_dump, device, image, pSubresource, pLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkWaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR* pPresentWait2Info) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkWaitForPresent2KHR", "device, swapchain, pPresentWait2Info", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkWaitForPresent2KHR(api_dump, device, swapchain, pPresentWait2Info);
        }
    }
    VkResult result = device_dispatch_table(device)->WaitForPresent2KHR(device, swapchain, pPresentWait2Info);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWaitForPresent2KHR(api_dump, device, swapchain, pPresentWait2Info);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineBinaryHandlesInfoKHR* pBinaries) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreatePipelineBinariesKHR", "device, pCreateInfo, pAllocator, pBinaries", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreatePipelineBinariesKHR(api_dump, device, pCreateInfo, pAllocator, pBinaries);
        }
    }
    VkResult result = device_dispatch_table(device)->CreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, pBinaries);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreatePipelineBinariesKHR(api_dump, device, pCreateInfo, pAllocator, pBinaries);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyPipelineBinaryKHR", "device, pipelineBinary, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyPipelineBinaryKHR(api_dump, device, pipelineBinary, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyPipelineBinaryKHR(api_dump, device, pipelineBinary, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR* pPipelineCreateInfo, VkPipelineBinaryKeyKHR* pPipelineKey) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineKeyKHR", "device, pPipelineCreateInfo, pPipelineKey", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineKeyKHR(api_dump, device, pPipelineCreateInfo, pPipelineKey);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelineKeyKHR(device, pPipelineCreateInfo, pPipelineKey);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineKeyKHR(api_dump, device, pPipelineCreateInfo, pPipelineKey);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR* pInfo, VkPipelineBinaryKeyKHR* pPipelineBinaryKey, size_t* pPipelineBinaryDataSize, void* pPipelineBinaryData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineBinaryDataKHR", "device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineBinaryDataKHR(api_dump, device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelineBinaryDataKHR(device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineBinaryDataKHR(api_dump, device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR* pInfo, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkReleaseCapturedPipelineDataKHR", "device, pInfo, pAllocator", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleaseCapturedPipelineDataKHR(api_dump, device, pInfo, pAllocator);
        }
    }
    VkResult result = device_dispatch_table(device)->ReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleaseCapturedPipelineDataKHR(api_dump, device, pInfo, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR* pReleaseInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkReleaseSwapchainImagesKHR", "device, pReleaseInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleaseSwapchainImagesKHR(api_dump, device, pReleaseInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ReleaseSwapchainImagesKHR(device, pReleaseInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleaseSwapchainImagesKHR(api_dump, device, pReleaseInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLineStippleKHR", "commandBuffer, lineStippleFactor, lineStipplePattern", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLineStippleKHR(api_dump, commandBuffer, lineStippleFactor, lineStipplePattern);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLineStippleKHR(api_dump, commandBuffer, lineStippleFactor, lineStipplePattern);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetCalibratedTimestampsKHR", "device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetCalibratedTimestampsKHR(api_dump, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
        }
    }
    VkResult result = device_dispatch_table(device)->GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetCalibratedTimestampsKHR(api_dump, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindDescriptorSets2KHR", "commandBuffer, pBindDescriptorSetsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindDescriptorSets2KHR(api_dump, commandBuffer, pBindDescriptorSetsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindDescriptorSets2KHR(api_dump, commandBuffer, pBindDescriptorSetsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo* pPushConstantsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushConstants2KHR", "commandBuffer, pPushConstantsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushConstants2KHR(api_dump, commandBuffer, pPushConstantsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushConstants2KHR(api_dump, commandBuffer, pPushConstantsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo* pPushDescriptorSetInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSet2KHR", "commandBuffer, pPushDescriptorSetInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSet2KHR(api_dump, commandBuffer, pPushDescriptorSetInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSet2KHR(api_dump, commandBuffer, pPushDescriptorSetInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDescriptorSetWithTemplate2KHR", "commandBuffer, pPushDescriptorSetWithTemplateInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDescriptorSetWithTemplate2KHR(api_dump, commandBuffer, pPushDescriptorSetWithTemplateInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDescriptorSetWithTemplate2KHR(api_dump, commandBuffer, pPushDescriptorSetWithTemplateInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDescriptorBufferOffsets2EXT", "commandBuffer, pSetDescriptorBufferOffsetsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDescriptorBufferOffsets2EXT(api_dump, commandBuffer, pSetDescriptorBufferOffsetsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDescriptorBufferOffsets2EXT(api_dump, commandBuffer, pSetDescriptorBufferOffsetsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT", "commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(api_dump, commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(api_dump, commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMemoryIndirectKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryIndirectInfoKHR* pCopyMemoryIndirectInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMemoryIndirectKHR", "commandBuffer, pCopyMemoryIndirectInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMemoryIndirectKHR(api_dump, commandBuffer, pCopyMemoryIndirectInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMemoryIndirectKHR(commandBuffer, pCopyMemoryIndirectInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMemoryIndirectKHR(api_dump, commandBuffer, pCopyMemoryIndirectInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMemoryToImageIndirectKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToImageIndirectInfoKHR* pCopyMemoryToImageIndirectInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMemoryToImageIndirectKHR", "commandBuffer, pCopyMemoryToImageIndirectInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMemoryToImageIndirectKHR(api_dump, commandBuffer, pCopyMemoryToImageIndirectInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMemoryToImageIndirectKHR(commandBuffer, pCopyMemoryToImageIndirectInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMemoryToImageIndirectKHR(api_dump, commandBuffer, pCopyMemoryToImageIndirectInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndRendering2KHR(VkCommandBuffer commandBuffer, const VkRenderingEndInfoKHR* pRenderingEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRendering2KHR", "commandBuffer, pRenderingEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRendering2KHR(api_dump, commandBuffer, pRenderingEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRendering2KHR(commandBuffer, pRenderingEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRendering2KHR(api_dump, commandBuffer, pRenderingEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDebugMarkerSetObjectTagEXT", "device, pTagInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDebugMarkerSetObjectTagEXT(api_dump, device, pTagInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->DebugMarkerSetObjectTagEXT(device, pTagInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkDebugMarkerSetObjectTagEXT(api_dump, device, pTagInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    api_dump.update_object_name_map(pNameInfo);

    dump_function_head(api_dump, "vkDebugMarkerSetObjectNameEXT", "device, pNameInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDebugMarkerSetObjectNameEXT(api_dump, device, pNameInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->DebugMarkerSetObjectNameEXT(device, pNameInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkDebugMarkerSetObjectNameEXT(api_dump, device, pNameInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDebugMarkerBeginEXT", "commandBuffer, pMarkerInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDebugMarkerBeginEXT(api_dump, commandBuffer, pMarkerInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDebugMarkerBeginEXT(api_dump, commandBuffer, pMarkerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDebugMarkerEndEXT", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDebugMarkerEndEXT(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDebugMarkerEndEXT(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDebugMarkerEndEXT(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDebugMarkerInsertEXT", "commandBuffer, pMarkerInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDebugMarkerInsertEXT(api_dump, commandBuffer, pMarkerInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDebugMarkerInsertEXT(api_dump, commandBuffer, pMarkerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindTransformFeedbackBuffersEXT", "commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindTransformFeedbackBuffersEXT(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindTransformFeedbackBuffersEXT(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginTransformFeedbackEXT", "commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginTransformFeedbackEXT(api_dump, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginTransformFeedbackEXT(api_dump, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndTransformFeedbackEXT", "commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndTransformFeedbackEXT(api_dump, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndTransformFeedbackEXT(api_dump, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginQueryIndexedEXT", "commandBuffer, queryPool, query, flags, index", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginQueryIndexedEXT(api_dump, commandBuffer, queryPool, query, flags, index);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginQueryIndexedEXT(api_dump, commandBuffer, queryPool, query, flags, index);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndQueryIndexedEXT", "commandBuffer, queryPool, query, index", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndQueryIndexedEXT(api_dump, commandBuffer, queryPool, query, index);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndQueryIndexedEXT(api_dump, commandBuffer, queryPool, query, index);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndirectByteCountEXT", "commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndirectByteCountEXT(api_dump, commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndirectByteCountEXT(api_dump, commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateCuModuleNVX(VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateCuModuleNVX", "device, pCreateInfo, pAllocator, pModule", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateCuModuleNVX(api_dump, device, pCreateInfo, pAllocator, pModule);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateCuModuleNVX(device, pCreateInfo, pAllocator, pModule);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateCuModuleNVX(api_dump, device, pCreateInfo, pAllocator, pModule);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateCuFunctionNVX(VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateCuFunctionNVX", "device, pCreateInfo, pAllocator, pFunction", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateCuFunctionNVX(api_dump, device, pCreateInfo, pAllocator, pFunction);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateCuFunctionNVX(device, pCreateInfo, pAllocator, pFunction);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateCuFunctionNVX(api_dump, device, pCreateInfo, pAllocator, pFunction);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyCuModuleNVX", "device, module, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyCuModuleNVX(api_dump, device, module, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyCuModuleNVX(device, module, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyCuModuleNVX(api_dump, device, module, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkDestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyCuFunctionNVX", "device, function, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyCuFunctionNVX(api_dump, device, function, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyCuFunctionNVX(device, function, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyCuFunctionNVX(api_dump, device, function, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCuLaunchKernelNVX", "commandBuffer, pLaunchInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCuLaunchKernelNVX(api_dump, commandBuffer, pLaunchInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCuLaunchKernelNVX(commandBuffer, pLaunchInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCuLaunchKernelNVX(api_dump, commandBuffer, pLaunchInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR uint32_t VKAPI_CALL vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageViewHandleNVX", "device, pInfo", "uint32_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageViewHandleNVX(api_dump, device, pInfo);
        }
    }
    uint32_t result = device_dispatch_table(device)->GetImageViewHandleNVX(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint32_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageViewHandleNVX(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR uint64_t VKAPI_CALL vkGetImageViewHandle64NVX(VkDevice device, const VkImageViewHandleInfoNVX* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageViewHandle64NVX", "device, pInfo", "uint64_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageViewHandle64NVX(api_dump, device, pInfo);
        }
    }
    uint64_t result = device_dispatch_table(device)->GetImageViewHandle64NVX(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint64_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageViewHandle64NVX(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetImageViewAddressNVX(VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageViewAddressNVX", "device, imageView, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageViewAddressNVX(api_dump, device, imageView, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetImageViewAddressNVX(device, imageView, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageViewAddressNVX(api_dump, device, imageView, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR uint64_t VKAPI_CALL vkGetDeviceCombinedImageSamplerIndexNVX(VkDevice device, uint64_t imageViewIndex, uint64_t samplerIndex) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceCombinedImageSamplerIndexNVX", "device, imageViewIndex, samplerIndex", "uint64_t");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceCombinedImageSamplerIndexNVX(api_dump, device, imageViewIndex, samplerIndex);
        }
    }
    uint64_t result = device_dispatch_table(device)->GetDeviceCombinedImageSamplerIndexNVX(device, imageViewIndex, samplerIndex);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "uint64_t", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceCombinedImageSamplerIndexNVX(api_dump, device, imageViewIndex, samplerIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndirectCountAMD", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndirectCountAMD(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndirectCountAMD(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawIndexedIndirectCountAMD", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawIndexedIndirectCountAMD(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawIndexedIndirectCountAMD(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetShaderInfoAMD", "device, pipeline, shaderStage, infoType, pInfoSize, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetShaderInfoAMD(api_dump, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetShaderInfoAMD(api_dump, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryWin32HandleNV", "device, memory, handleType, pHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryWin32HandleNV(api_dump, device, memory, handleType, pHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryWin32HandleNV(device, memory, handleType, pHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryWin32HandleNV(api_dump, device, memory, handleType, pHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR void VKAPI_CALL vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginConditionalRenderingEXT", "commandBuffer, pConditionalRenderingBegin", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginConditionalRenderingEXT(api_dump, commandBuffer, pConditionalRenderingBegin);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginConditionalRenderingEXT(api_dump, commandBuffer, pConditionalRenderingBegin);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndConditionalRenderingEXT", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndConditionalRenderingEXT(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndConditionalRenderingEXT(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndConditionalRenderingEXT(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewportWScalingNV", "commandBuffer, firstViewport, viewportCount, pViewportWScalings", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewportWScalingNV(api_dump, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewportWScalingNV(api_dump, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDisplayPowerControlEXT", "device, display, pDisplayPowerInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDisplayPowerControlEXT(api_dump, device, display, pDisplayPowerInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->DisplayPowerControlEXT(device, display, pDisplayPowerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkDisplayPowerControlEXT(api_dump, device, display, pDisplayPowerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkRegisterDeviceEventEXT", "device, pDeviceEventInfo, pAllocator, pFence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkRegisterDeviceEventEXT(api_dump, device, pDeviceEventInfo, pAllocator, pFence);
        }
    }
    VkResult result = device_dispatch_table(device)->RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkRegisterDeviceEventEXT(api_dump, device, pDeviceEventInfo, pAllocator, pFence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkRegisterDisplayEventEXT", "device, display, pDisplayEventInfo, pAllocator, pFence", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkRegisterDisplayEventEXT(api_dump, device, display, pDisplayEventInfo, pAllocator, pFence);
        }
    }
    VkResult result = device_dispatch_table(device)->RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkRegisterDisplayEventEXT(api_dump, device, display, pDisplayEventInfo, pAllocator, pFence);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSwapchainCounterEXT", "device, swapchain, counter, pCounterValue", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSwapchainCounterEXT(api_dump, device, swapchain, counter, pCounterValue);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSwapchainCounterEXT(api_dump, device, swapchain, counter, pCounterValue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRefreshCycleDurationGOOGLE", "device, swapchain, pDisplayTimingProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRefreshCycleDurationGOOGLE(api_dump, device, swapchain, pDisplayTimingProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRefreshCycleDurationGOOGLE(api_dump, device, swapchain, pDisplayTimingProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPastPresentationTimingGOOGLE", "device, swapchain, pPresentationTimingCount, pPresentationTimings", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPastPresentationTimingGOOGLE(api_dump, device, swapchain, pPresentationTimingCount, pPresentationTimings);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPastPresentationTimingGOOGLE(api_dump, device, swapchain, pPresentationTimingCount, pPresentationTimings);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDiscardRectangleEXT", "commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDiscardRectangleEXT(api_dump, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDiscardRectangleEXT(api_dump, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDiscardRectangleEnableEXT", "commandBuffer, discardRectangleEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDiscardRectangleEnableEXT(api_dump, commandBuffer, discardRectangleEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDiscardRectangleEnableEXT(api_dump, commandBuffer, discardRectangleEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDiscardRectangleModeEXT", "commandBuffer, discardRectangleMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDiscardRectangleModeEXT(api_dump, commandBuffer, discardRectangleMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDiscardRectangleModeEXT(api_dump, commandBuffer, discardRectangleMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetHdrMetadataEXT", "device, swapchainCount, pSwapchains, pMetadata", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetHdrMetadataEXT(api_dump, device, swapchainCount, pSwapchains, pMetadata);
        }
    }
    device_dispatch_table(device)->SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetHdrMetadataEXT(api_dump, device, swapchainCount, pSwapchains, pMetadata);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());
    api_dump.update_object_name_map(pNameInfo);

    dump_function_head(api_dump, "vkSetDebugUtilsObjectNameEXT", "device, pNameInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetDebugUtilsObjectNameEXT(api_dump, device, pNameInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SetDebugUtilsObjectNameEXT(device, pNameInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetDebugUtilsObjectNameEXT(api_dump, device, pNameInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetDebugUtilsObjectTagEXT", "device, pTagInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetDebugUtilsObjectTagEXT(api_dump, device, pTagInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SetDebugUtilsObjectTagEXT(device, pTagInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetDebugUtilsObjectTagEXT(api_dump, device, pTagInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkQueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueBeginDebugUtilsLabelEXT", "queue, pLabelInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueBeginDebugUtilsLabelEXT(api_dump, queue, pLabelInfo);
        }
    }
    device_dispatch_table(queue)->QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueBeginDebugUtilsLabelEXT(api_dump, queue, pLabelInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkQueueEndDebugUtilsLabelEXT(VkQueue queue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueEndDebugUtilsLabelEXT", "queue", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueEndDebugUtilsLabelEXT(api_dump, queue);
        }
    }
    device_dispatch_table(queue)->QueueEndDebugUtilsLabelEXT(queue);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueEndDebugUtilsLabelEXT(api_dump, queue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkQueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueInsertDebugUtilsLabelEXT", "queue, pLabelInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueInsertDebugUtilsLabelEXT(api_dump, queue, pLabelInfo);
        }
    }
    device_dispatch_table(queue)->QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueInsertDebugUtilsLabelEXT(api_dump, queue, pLabelInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginDebugUtilsLabelEXT", "commandBuffer, pLabelInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginDebugUtilsLabelEXT(api_dump, commandBuffer, pLabelInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginDebugUtilsLabelEXT(api_dump, commandBuffer, pLabelInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndDebugUtilsLabelEXT", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndDebugUtilsLabelEXT(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndDebugUtilsLabelEXT(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndDebugUtilsLabelEXT(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdInsertDebugUtilsLabelEXT", "commandBuffer, pLabelInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdInsertDebugUtilsLabelEXT(api_dump, commandBuffer, pLabelInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdInsertDebugUtilsLabelEXT(api_dump, commandBuffer, pLabelInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkGetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetAndroidHardwareBufferPropertiesANDROID", "device, buffer, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetAndroidHardwareBufferPropertiesANDROID(api_dump, device, buffer, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetAndroidHardwareBufferPropertiesANDROID(api_dump, device, buffer, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryAndroidHardwareBufferANDROID", "device, pInfo, pBuffer", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryAndroidHardwareBufferANDROID(api_dump, device, pInfo, pBuffer);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryAndroidHardwareBufferANDROID(api_dump, device, pInfo, pBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateExecutionGraphPipelinesAMDX", "device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateExecutionGraphPipelinesAMDX(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateExecutionGraphPipelinesAMDX(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetExecutionGraphPipelineScratchSizeAMDX", "device, executionGraph, pSizeInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetExecutionGraphPipelineScratchSizeAMDX(api_dump, device, executionGraph, pSizeInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetExecutionGraphPipelineScratchSizeAMDX(api_dump, device, executionGraph, pSizeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint32_t* pNodeIndex) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetExecutionGraphPipelineNodeIndexAMDX", "device, executionGraph, pNodeInfo, pNodeIndex", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetExecutionGraphPipelineNodeIndexAMDX(api_dump, device, executionGraph, pNodeInfo, pNodeIndex);
        }
    }
    VkResult result = device_dispatch_table(device)->GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetExecutionGraphPipelineNodeIndexAMDX(api_dump, device, executionGraph, pNodeInfo, pNodeIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdInitializeGraphScratchMemoryAMDX", "commandBuffer, executionGraph, scratch, scratchSize", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdInitializeGraphScratchMemoryAMDX(api_dump, commandBuffer, executionGraph, scratch, scratchSize);
        }
    }
    device_dispatch_table(commandBuffer)->CmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdInitializeGraphScratchMemoryAMDX(api_dump, commandBuffer, executionGraph, scratch, scratchSize);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX* pCountInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchGraphAMDX", "commandBuffer, scratch, scratchSize, pCountInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchGraphAMDX(api_dump, commandBuffer, scratch, scratchSize, pCountInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, pCountInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchGraphAMDX(api_dump, commandBuffer, scratch, scratchSize, pCountInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX* pCountInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchGraphIndirectAMDX", "commandBuffer, scratch, scratchSize, pCountInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchGraphIndirectAMDX(api_dump, commandBuffer, scratch, scratchSize, pCountInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, pCountInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchGraphIndirectAMDX(api_dump, commandBuffer, scratch, scratchSize, pCountInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchGraphIndirectCountAMDX", "commandBuffer, scratch, scratchSize, countInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchGraphIndirectCountAMDX(api_dump, commandBuffer, scratch, scratchSize, countInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchGraphIndirectCountAMDX(api_dump, commandBuffer, scratch, scratchSize, countInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#endif  // VK_ENABLE_BETA_EXTENSIONS
VKAPI_ATTR VkResult VKAPI_CALL vkWriteSamplerDescriptorsEXT(VkDevice device, uint32_t samplerCount, const VkSamplerCreateInfo* pSamplers, const VkHostAddressRangeEXT* pDescriptors) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkWriteSamplerDescriptorsEXT", "device, samplerCount, pSamplers, pDescriptors", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkWriteSamplerDescriptorsEXT(api_dump, device, samplerCount, pSamplers, pDescriptors);
        }
    }
    VkResult result = device_dispatch_table(device)->WriteSamplerDescriptorsEXT(device, samplerCount, pSamplers, pDescriptors);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWriteSamplerDescriptorsEXT(api_dump, device, samplerCount, pSamplers, pDescriptors);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkWriteResourceDescriptorsEXT(VkDevice device, uint32_t resourceCount, const VkResourceDescriptorInfoEXT* pResources, const VkHostAddressRangeEXT* pDescriptors) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkWriteResourceDescriptorsEXT", "device, resourceCount, pResources, pDescriptors", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkWriteResourceDescriptorsEXT(api_dump, device, resourceCount, pResources, pDescriptors);
        }
    }
    VkResult result = device_dispatch_table(device)->WriteResourceDescriptorsEXT(device, resourceCount, pResources, pDescriptors);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWriteResourceDescriptorsEXT(api_dump, device, resourceCount, pResources, pDescriptors);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindSamplerHeapEXT(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT* pBindInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindSamplerHeapEXT", "commandBuffer, pBindInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindSamplerHeapEXT(api_dump, commandBuffer, pBindInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindSamplerHeapEXT(commandBuffer, pBindInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindSamplerHeapEXT(api_dump, commandBuffer, pBindInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindResourceHeapEXT(VkCommandBuffer commandBuffer, const VkBindHeapInfoEXT* pBindInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindResourceHeapEXT", "commandBuffer, pBindInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindResourceHeapEXT(api_dump, commandBuffer, pBindInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindResourceHeapEXT(commandBuffer, pBindInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindResourceHeapEXT(api_dump, commandBuffer, pBindInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDataEXT(VkCommandBuffer commandBuffer, const VkPushDataInfoEXT* pPushDataInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPushDataEXT", "commandBuffer, pPushDataInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPushDataEXT(api_dump, commandBuffer, pPushDataInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPushDataEXT(commandBuffer, pPushDataInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPushDataEXT(api_dump, commandBuffer, pPushDataInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetImageOpaqueCaptureDataEXT(VkDevice device, uint32_t imageCount, const VkImage* pImages, VkHostAddressRangeEXT* pDatas) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageOpaqueCaptureDataEXT", "device, imageCount, pImages, pDatas", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageOpaqueCaptureDataEXT(api_dump, device, imageCount, pImages, pDatas);
        }
    }
    VkResult result = device_dispatch_table(device)->GetImageOpaqueCaptureDataEXT(device, imageCount, pImages, pDatas);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageOpaqueCaptureDataEXT(api_dump, device, imageCount, pImages, pDatas);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkRegisterCustomBorderColorEXT(VkDevice device, const VkSamplerCustomBorderColorCreateInfoEXT* pBorderColor, VkBool32 requestIndex, uint32_t* pIndex) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkRegisterCustomBorderColorEXT", "device, pBorderColor, requestIndex, pIndex", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkRegisterCustomBorderColorEXT(api_dump, device, pBorderColor, requestIndex, pIndex);
        }
    }
    VkResult result = device_dispatch_table(device)->RegisterCustomBorderColorEXT(device, pBorderColor, requestIndex, pIndex);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkRegisterCustomBorderColorEXT(api_dump, device, pBorderColor, requestIndex, pIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkUnregisterCustomBorderColorEXT(VkDevice device, uint32_t index) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUnregisterCustomBorderColorEXT", "device, index", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUnregisterCustomBorderColorEXT(api_dump, device, index);
        }
    }
    device_dispatch_table(device)->UnregisterCustomBorderColorEXT(device, index);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUnregisterCustomBorderColorEXT(api_dump, device, index);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetTensorOpaqueCaptureDataARM(VkDevice device, uint32_t tensorCount, const VkTensorARM* pTensors, VkHostAddressRangeEXT* pDatas) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetTensorOpaqueCaptureDataARM", "device, tensorCount, pTensors, pDatas", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetTensorOpaqueCaptureDataARM(api_dump, device, tensorCount, pTensors, pDatas);
        }
    }
    VkResult result = device_dispatch_table(device)->GetTensorOpaqueCaptureDataARM(device, tensorCount, pTensors, pDatas);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetTensorOpaqueCaptureDataARM(api_dump, device, tensorCount, pTensors, pDatas);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetSampleLocationsEXT", "commandBuffer, pSampleLocationsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetSampleLocationsEXT(api_dump, commandBuffer, pSampleLocationsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetSampleLocationsEXT(api_dump, commandBuffer, pSampleLocationsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageDrmFormatModifierPropertiesEXT", "device, image, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageDrmFormatModifierPropertiesEXT(api_dump, device, image, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageDrmFormatModifierPropertiesEXT(api_dump, device, image, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateValidationCacheEXT", "device, pCreateInfo, pAllocator, pValidationCache", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateValidationCacheEXT(api_dump, device, pCreateInfo, pAllocator, pValidationCache);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateValidationCacheEXT(api_dump, device, pCreateInfo, pAllocator, pValidationCache);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyValidationCacheEXT", "device, validationCache, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyValidationCacheEXT(api_dump, device, validationCache, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyValidationCacheEXT(device, validationCache, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyValidationCacheEXT(api_dump, device, validationCache, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkMergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkMergeValidationCachesEXT", "device, dstCache, srcCacheCount, pSrcCaches", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkMergeValidationCachesEXT(api_dump, device, dstCache, srcCacheCount, pSrcCaches);
        }
    }
    VkResult result = device_dispatch_table(device)->MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkMergeValidationCachesEXT(api_dump, device, dstCache, srcCacheCount, pSrcCaches);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetValidationCacheDataEXT", "device, validationCache, pDataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetValidationCacheDataEXT(api_dump, device, validationCache, pDataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetValidationCacheDataEXT(api_dump, device, validationCache, pDataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindShadingRateImageNV", "commandBuffer, imageView, imageLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindShadingRateImageNV(api_dump, commandBuffer, imageView, imageLayout);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindShadingRateImageNV(api_dump, commandBuffer, imageView, imageLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewportShadingRatePaletteNV", "commandBuffer, firstViewport, viewportCount, pShadingRatePalettes", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewportShadingRatePaletteNV(api_dump, commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewportShadingRatePaletteNV(api_dump, commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoarseSampleOrderNV", "commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoarseSampleOrderNV(api_dump, commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoarseSampleOrderNV(api_dump, commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateAccelerationStructureNV", "device, pCreateInfo, pAllocator, pAccelerationStructure", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateAccelerationStructureNV(api_dump, device, pCreateInfo, pAllocator, pAccelerationStructure);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateAccelerationStructureNV(api_dump, device, pCreateInfo, pAllocator, pAccelerationStructure);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyAccelerationStructureNV", "device, accelerationStructure, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyAccelerationStructureNV(api_dump, device, accelerationStructure, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyAccelerationStructureNV(api_dump, device, accelerationStructure, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetAccelerationStructureMemoryRequirementsNV", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetAccelerationStructureMemoryRequirementsNV(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetAccelerationStructureMemoryRequirementsNV(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindAccelerationStructureMemoryNV", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindAccelerationStructureMemoryNV(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindAccelerationStructureMemoryNV(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBuildAccelerationStructureNV", "commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBuildAccelerationStructureNV(api_dump, commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBuildAccelerationStructureNV(api_dump, commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyAccelerationStructureNV", "commandBuffer, dst, src, mode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyAccelerationStructureNV(api_dump, commandBuffer, dst, src, mode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyAccelerationStructureNV(api_dump, commandBuffer, dst, src, mode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdTraceRaysNV", "commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdTraceRaysNV(api_dump, commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
        }
    }
    device_dispatch_table(commandBuffer)->CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdTraceRaysNV(api_dump, commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateRayTracingPipelinesNV", "device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateRayTracingPipelinesNV(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateRayTracingPipelinesNV(api_dump, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRayTracingShaderGroupHandlesKHR", "device, pipeline, firstGroup, groupCount, dataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRayTracingShaderGroupHandlesKHR(api_dump, device, pipeline, firstGroup, groupCount, dataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRayTracingShaderGroupHandlesKHR(api_dump, device, pipeline, firstGroup, groupCount, dataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRayTracingShaderGroupHandlesNV", "device, pipeline, firstGroup, groupCount, dataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRayTracingShaderGroupHandlesNV(api_dump, device, pipeline, firstGroup, groupCount, dataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRayTracingShaderGroupHandlesNV(api_dump, device, pipeline, firstGroup, groupCount, dataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetAccelerationStructureHandleNV", "device, accelerationStructure, dataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetAccelerationStructureHandleNV(api_dump, device, accelerationStructure, dataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetAccelerationStructureHandleNV(api_dump, device, accelerationStructure, dataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteAccelerationStructuresPropertiesNV", "commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteAccelerationStructuresPropertiesNV(api_dump, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteAccelerationStructuresPropertiesNV(api_dump, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCompileDeferredNV", "device, pipeline, shader", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCompileDeferredNV(api_dump, device, pipeline, shader);
        }
    }
    VkResult result = device_dispatch_table(device)->CompileDeferredNV(device, pipeline, shader);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCompileDeferredNV(api_dump, device, pipeline, shader);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryHostPointerPropertiesEXT", "device, handleType, pHostPointer, pMemoryHostPointerProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryHostPointerPropertiesEXT(api_dump, device, handleType, pHostPointer, pMemoryHostPointerProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryHostPointerPropertiesEXT(api_dump, device, handleType, pHostPointer, pMemoryHostPointerProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteBufferMarkerAMD", "commandBuffer, pipelineStage, dstBuffer, dstOffset, marker", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteBufferMarkerAMD(api_dump, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteBufferMarkerAMD(api_dump, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteBufferMarker2AMD", "commandBuffer, stage, dstBuffer, dstOffset, marker", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteBufferMarker2AMD(api_dump, commandBuffer, stage, dstBuffer, dstOffset, marker);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteBufferMarker2AMD(api_dump, commandBuffer, stage, dstBuffer, dstOffset, marker);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetCalibratedTimestampsEXT", "device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetCalibratedTimestampsEXT(api_dump, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
        }
    }
    VkResult result = device_dispatch_table(device)->GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetCalibratedTimestampsEXT(api_dump, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMeshTasksNV", "commandBuffer, taskCount, firstTask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMeshTasksNV(api_dump, commandBuffer, taskCount, firstTask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMeshTasksNV(api_dump, commandBuffer, taskCount, firstTask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMeshTasksIndirectNV", "commandBuffer, buffer, offset, drawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMeshTasksIndirectNV(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMeshTasksIndirectNV(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMeshTasksIndirectCountNV", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMeshTasksIndirectCountNV(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMeshTasksIndirectCountNV(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetExclusiveScissorEnableNV", "commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetExclusiveScissorEnableNV(api_dump, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetExclusiveScissorEnableNV(api_dump, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetExclusiveScissorNV", "commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetExclusiveScissorNV(api_dump, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetExclusiveScissorNV(api_dump, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void* pCheckpointMarker) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCheckpointNV", "commandBuffer, pCheckpointMarker", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCheckpointNV(api_dump, commandBuffer, pCheckpointMarker);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCheckpointNV(api_dump, commandBuffer, pCheckpointMarker);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointDataNV(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetQueueCheckpointDataNV", "queue, pCheckpointDataCount, pCheckpointData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetQueueCheckpointDataNV(api_dump, queue, pCheckpointDataCount, pCheckpointData);
        }
    }
    device_dispatch_table(queue)->GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetQueueCheckpointDataNV(api_dump, queue, pCheckpointDataCount, pCheckpointData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetQueueCheckpointData2NV(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetQueueCheckpointData2NV", "queue, pCheckpointDataCount, pCheckpointData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetQueueCheckpointData2NV(api_dump, queue, pCheckpointDataCount, pCheckpointData);
        }
    }
    device_dispatch_table(queue)->GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetQueueCheckpointData2NV(api_dump, queue, pCheckpointDataCount, pCheckpointData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetSwapchainPresentTimingQueueSizeEXT(VkDevice device, VkSwapchainKHR swapchain, uint32_t size) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetSwapchainPresentTimingQueueSizeEXT", "device, swapchain, size", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetSwapchainPresentTimingQueueSizeEXT(api_dump, device, swapchain, size);
        }
    }
    VkResult result = device_dispatch_table(device)->SetSwapchainPresentTimingQueueSizeEXT(device, swapchain, size);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetSwapchainPresentTimingQueueSizeEXT(api_dump, device, swapchain, size);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainTimingPropertiesEXT(VkDevice device, VkSwapchainKHR swapchain, VkSwapchainTimingPropertiesEXT* pSwapchainTimingProperties, uint64_t* pSwapchainTimingPropertiesCounter) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSwapchainTimingPropertiesEXT", "device, swapchain, pSwapchainTimingProperties, pSwapchainTimingPropertiesCounter", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSwapchainTimingPropertiesEXT(api_dump, device, swapchain, pSwapchainTimingProperties, pSwapchainTimingPropertiesCounter);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSwapchainTimingPropertiesEXT(device, swapchain, pSwapchainTimingProperties, pSwapchainTimingPropertiesCounter);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSwapchainTimingPropertiesEXT(api_dump, device, swapchain, pSwapchainTimingProperties, pSwapchainTimingPropertiesCounter);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainTimeDomainPropertiesEXT(VkDevice device, VkSwapchainKHR swapchain, VkSwapchainTimeDomainPropertiesEXT* pSwapchainTimeDomainProperties, uint64_t* pTimeDomainsCounter) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSwapchainTimeDomainPropertiesEXT", "device, swapchain, pSwapchainTimeDomainProperties, pTimeDomainsCounter", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSwapchainTimeDomainPropertiesEXT(api_dump, device, swapchain, pSwapchainTimeDomainProperties, pTimeDomainsCounter);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSwapchainTimeDomainPropertiesEXT(device, swapchain, pSwapchainTimeDomainProperties, pTimeDomainsCounter);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSwapchainTimeDomainPropertiesEXT(api_dump, device, swapchain, pSwapchainTimeDomainProperties, pTimeDomainsCounter);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPastPresentationTimingEXT(VkDevice device, const VkPastPresentationTimingInfoEXT* pPastPresentationTimingInfo, VkPastPresentationTimingPropertiesEXT* pPastPresentationTimingProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPastPresentationTimingEXT", "device, pPastPresentationTimingInfo, pPastPresentationTimingProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPastPresentationTimingEXT(api_dump, device, pPastPresentationTimingInfo, pPastPresentationTimingProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPastPresentationTimingEXT(device, pPastPresentationTimingInfo, pPastPresentationTimingProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPastPresentationTimingEXT(api_dump, device, pPastPresentationTimingInfo, pPastPresentationTimingProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkInitializePerformanceApiINTEL", "device, pInitializeInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkInitializePerformanceApiINTEL(api_dump, device, pInitializeInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->InitializePerformanceApiINTEL(device, pInitializeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkInitializePerformanceApiINTEL(api_dump, device, pInitializeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkUninitializePerformanceApiINTEL(VkDevice device) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUninitializePerformanceApiINTEL", "device", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUninitializePerformanceApiINTEL(api_dump, device);
        }
    }
    device_dispatch_table(device)->UninitializePerformanceApiINTEL(device);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUninitializePerformanceApiINTEL(api_dump, device);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPerformanceMarkerINTEL", "commandBuffer, pMarkerInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPerformanceMarkerINTEL(api_dump, commandBuffer, pMarkerInfo);
        }
    }
    VkResult result = device_dispatch_table(commandBuffer)->CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPerformanceMarkerINTEL(api_dump, commandBuffer, pMarkerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPerformanceStreamMarkerINTEL", "commandBuffer, pMarkerInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPerformanceStreamMarkerINTEL(api_dump, commandBuffer, pMarkerInfo);
        }
    }
    VkResult result = device_dispatch_table(commandBuffer)->CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPerformanceStreamMarkerINTEL(api_dump, commandBuffer, pMarkerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPerformanceOverrideINTEL", "commandBuffer, pOverrideInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPerformanceOverrideINTEL(api_dump, commandBuffer, pOverrideInfo);
        }
    }
    VkResult result = device_dispatch_table(commandBuffer)->CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPerformanceOverrideINTEL(api_dump, commandBuffer, pOverrideInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkAcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAcquirePerformanceConfigurationINTEL", "device, pAcquireInfo, pConfiguration", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquirePerformanceConfigurationINTEL(api_dump, device, pAcquireInfo, pConfiguration);
        }
    }
    VkResult result = device_dispatch_table(device)->AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquirePerformanceConfigurationINTEL(api_dump, device, pAcquireInfo, pConfiguration);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkReleasePerformanceConfigurationINTEL", "device, configuration", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleasePerformanceConfigurationINTEL(api_dump, device, configuration);
        }
    }
    VkResult result = device_dispatch_table(device)->ReleasePerformanceConfigurationINTEL(device, configuration);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleasePerformanceConfigurationINTEL(api_dump, device, configuration);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueSetPerformanceConfigurationINTEL", "queue, configuration", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueSetPerformanceConfigurationINTEL(api_dump, queue, configuration);
        }
    }
    VkResult result = device_dispatch_table(queue)->QueueSetPerformanceConfigurationINTEL(queue, configuration);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueSetPerformanceConfigurationINTEL(api_dump, queue, configuration);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPerformanceParameterINTEL", "device, parameter, pValue", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPerformanceParameterINTEL(api_dump, device, parameter, pValue);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPerformanceParameterINTEL(device, parameter, pValue);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPerformanceParameterINTEL(api_dump, device, parameter, pValue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetLocalDimmingAMD", "device, swapChain, localDimmingEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetLocalDimmingAMD(api_dump, device, swapChain, localDimmingEnable);
        }
    }
    device_dispatch_table(device)->SetLocalDimmingAMD(device, swapChain, localDimmingEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetLocalDimmingAMD(api_dump, device, swapChain, localDimmingEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkDeviceAddress VKAPI_CALL vkGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferDeviceAddressEXT", "device, pInfo", "VkDeviceAddress");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferDeviceAddressEXT(api_dump, device, pInfo);
        }
    }
    VkDeviceAddress result = device_dispatch_table(device)->GetBufferDeviceAddressEXT(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceAddress", result, dump_return_value_VkDeviceAddress);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferDeviceAddressEXT(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
VKAPI_ATTR VkResult VKAPI_CALL vkAcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAcquireFullScreenExclusiveModeEXT", "device, swapchain", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAcquireFullScreenExclusiveModeEXT(api_dump, device, swapchain);
        }
    }
    VkResult result = device_dispatch_table(device)->AcquireFullScreenExclusiveModeEXT(device, swapchain);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkAcquireFullScreenExclusiveModeEXT(api_dump, device, swapchain);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkReleaseFullScreenExclusiveModeEXT", "device, swapchain", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleaseFullScreenExclusiveModeEXT(api_dump, device, swapchain);
        }
    }
    VkResult result = device_dispatch_table(device)->ReleaseFullScreenExclusiveModeEXT(device, swapchain);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleaseFullScreenExclusiveModeEXT(api_dump, device, swapchain);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR* pModes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceGroupSurfacePresentModes2EXT", "device, pSurfaceInfo, pModes", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceGroupSurfacePresentModes2EXT(api_dump, device, pSurfaceInfo, pModes);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceGroupSurfacePresentModes2EXT(api_dump, device, pSurfaceInfo, pModes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR
VKAPI_ATTR void VKAPI_CALL vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLineStippleEXT", "commandBuffer, lineStippleFactor, lineStipplePattern", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLineStippleEXT(api_dump, commandBuffer, lineStippleFactor, lineStipplePattern);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLineStippleEXT(api_dump, commandBuffer, lineStippleFactor, lineStipplePattern);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkResetQueryPoolEXT", "device, queryPool, firstQuery, queryCount", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkResetQueryPoolEXT(api_dump, device, queryPool, firstQuery, queryCount);
        }
    }
    device_dispatch_table(device)->ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkResetQueryPoolEXT(api_dump, device, queryPool, firstQuery, queryCount);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCullModeEXT", "commandBuffer, cullMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCullModeEXT(api_dump, commandBuffer, cullMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCullModeEXT(commandBuffer, cullMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCullModeEXT(api_dump, commandBuffer, cullMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetFrontFaceEXT", "commandBuffer, frontFace", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetFrontFaceEXT(api_dump, commandBuffer, frontFace);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetFrontFaceEXT(commandBuffer, frontFace);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetFrontFaceEXT(api_dump, commandBuffer, frontFace);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPrimitiveTopologyEXT", "commandBuffer, primitiveTopology", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPrimitiveTopologyEXT(api_dump, commandBuffer, primitiveTopology);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPrimitiveTopologyEXT(api_dump, commandBuffer, primitiveTopology);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewportWithCountEXT", "commandBuffer, viewportCount, pViewports", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewportWithCountEXT(api_dump, commandBuffer, viewportCount, pViewports);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewportWithCountEXT(api_dump, commandBuffer, viewportCount, pViewports);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetScissorWithCountEXT", "commandBuffer, scissorCount, pScissors", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetScissorWithCountEXT(api_dump, commandBuffer, scissorCount, pScissors);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetScissorWithCountEXT(api_dump, commandBuffer, scissorCount, pScissors);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindVertexBuffers2EXT", "commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindVertexBuffers2EXT(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindVertexBuffers2EXT(api_dump, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthTestEnableEXT", "commandBuffer, depthTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthTestEnableEXT(api_dump, commandBuffer, depthTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthTestEnableEXT(api_dump, commandBuffer, depthTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthWriteEnableEXT", "commandBuffer, depthWriteEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthWriteEnableEXT(api_dump, commandBuffer, depthWriteEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthWriteEnableEXT(api_dump, commandBuffer, depthWriteEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthCompareOpEXT", "commandBuffer, depthCompareOp", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthCompareOpEXT(api_dump, commandBuffer, depthCompareOp);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthCompareOpEXT(api_dump, commandBuffer, depthCompareOp);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBoundsTestEnableEXT", "commandBuffer, depthBoundsTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBoundsTestEnableEXT(api_dump, commandBuffer, depthBoundsTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBoundsTestEnableEXT(api_dump, commandBuffer, depthBoundsTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilTestEnableEXT", "commandBuffer, stencilTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilTestEnableEXT(api_dump, commandBuffer, stencilTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilTestEnableEXT(api_dump, commandBuffer, stencilTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetStencilOpEXT", "commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetStencilOpEXT(api_dump, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetStencilOpEXT(api_dump, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyMemoryToImageEXT", "device, pCopyMemoryToImageInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyMemoryToImageEXT(api_dump, device, pCopyMemoryToImageInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyMemoryToImageEXT(api_dump, device, pCopyMemoryToImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyImageToMemoryEXT", "device, pCopyImageToMemoryInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyImageToMemoryEXT(api_dump, device, pCopyImageToMemoryInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyImageToMemoryEXT(api_dump, device, pCopyImageToMemoryInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo* pCopyImageToImageInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyImageToImageEXT", "device, pCopyImageToImageInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyImageToImageEXT(api_dump, device, pCopyImageToImageInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyImageToImageEXT(device, pCopyImageToImageInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyImageToImageEXT(api_dump, device, pCopyImageToImageInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo* pTransitions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkTransitionImageLayoutEXT", "device, transitionCount, pTransitions", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkTransitionImageLayoutEXT(api_dump, device, transitionCount, pTransitions);
        }
    }
    VkResult result = device_dispatch_table(device)->TransitionImageLayoutEXT(device, transitionCount, pTransitions);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkTransitionImageLayoutEXT(api_dump, device, transitionCount, pTransitions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource, VkSubresourceLayout2* pLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageSubresourceLayout2EXT", "device, image, pSubresource, pLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageSubresourceLayout2EXT(api_dump, device, image, pSubresource, pLayout);
        }
    }
    device_dispatch_table(device)->GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageSubresourceLayout2EXT(api_dump, device, image, pSubresource, pLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR* pReleaseInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkReleaseSwapchainImagesEXT", "device, pReleaseInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkReleaseSwapchainImagesEXT(api_dump, device, pReleaseInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ReleaseSwapchainImagesEXT(device, pReleaseInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkReleaseSwapchainImagesEXT(api_dump, device, pReleaseInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetGeneratedCommandsMemoryRequirementsNV", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetGeneratedCommandsMemoryRequirementsNV(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetGeneratedCommandsMemoryRequirementsNV(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPreprocessGeneratedCommandsNV", "commandBuffer, pGeneratedCommandsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPreprocessGeneratedCommandsNV(api_dump, commandBuffer, pGeneratedCommandsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPreprocessGeneratedCommandsNV(api_dump, commandBuffer, pGeneratedCommandsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdExecuteGeneratedCommandsNV", "commandBuffer, isPreprocessed, pGeneratedCommandsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdExecuteGeneratedCommandsNV(api_dump, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdExecuteGeneratedCommandsNV(api_dump, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindPipelineShaderGroupNV", "commandBuffer, pipelineBindPoint, pipeline, groupIndex", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindPipelineShaderGroupNV(api_dump, commandBuffer, pipelineBindPoint, pipeline, groupIndex);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindPipelineShaderGroupNV(api_dump, commandBuffer, pipelineBindPoint, pipeline, groupIndex);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateIndirectCommandsLayoutNV", "device, pCreateInfo, pAllocator, pIndirectCommandsLayout", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateIndirectCommandsLayoutNV(api_dump, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateIndirectCommandsLayoutNV(api_dump, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyIndirectCommandsLayoutNV", "device, indirectCommandsLayout, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyIndirectCommandsLayoutNV(api_dump, device, indirectCommandsLayout, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyIndirectCommandsLayoutNV(api_dump, device, indirectCommandsLayout, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT* pDepthBiasInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBias2EXT", "commandBuffer, pDepthBiasInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBias2EXT(api_dump, commandBuffer, pDepthBiasInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBias2EXT(api_dump, commandBuffer, pDepthBiasInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreatePrivateDataSlotEXT", "device, pCreateInfo, pAllocator, pPrivateDataSlot", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreatePrivateDataSlotEXT(api_dump, device, pCreateInfo, pAllocator, pPrivateDataSlot);
        }
    }
    VkResult result = device_dispatch_table(device)->CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreatePrivateDataSlotEXT(api_dump, device, pCreateInfo, pAllocator, pPrivateDataSlot);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyPrivateDataSlotEXT", "device, privateDataSlot, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyPrivateDataSlotEXT(api_dump, device, privateDataSlot, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyPrivateDataSlotEXT(api_dump, device, privateDataSlot, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetPrivateDataEXT", "device, objectType, objectHandle, privateDataSlot, data", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetPrivateDataEXT(api_dump, device, objectType, objectHandle, privateDataSlot, data);
        }
    }
    VkResult result = device_dispatch_table(device)->SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetPrivateDataEXT(api_dump, device, objectType, objectHandle, privateDataSlot, data);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPrivateDataEXT", "device, objectType, objectHandle, privateDataSlot, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPrivateDataEXT(api_dump, device, objectType, objectHandle, privateDataSlot, pData);
        }
    }
    device_dispatch_table(device)->GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPrivateDataEXT(api_dump, device, objectType, objectHandle, privateDataSlot, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
VKAPI_ATTR VkResult VKAPI_CALL vkCreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCudaModuleNV* pModule) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateCudaModuleNV", "device, pCreateInfo, pAllocator, pModule", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateCudaModuleNV(api_dump, device, pCreateInfo, pAllocator, pModule);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateCudaModuleNV(api_dump, device, pCreateInfo, pAllocator, pModule);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t* pCacheSize, void* pCacheData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetCudaModuleCacheNV", "device, module, pCacheSize, pCacheData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetCudaModuleCacheNV(api_dump, device, module, pCacheSize, pCacheData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetCudaModuleCacheNV(api_dump, device, module, pCacheSize, pCacheData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCudaFunctionNV* pFunction) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateCudaFunctionNV", "device, pCreateInfo, pAllocator, pFunction", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateCudaFunctionNV(api_dump, device, pCreateInfo, pAllocator, pFunction);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateCudaFunctionNV(api_dump, device, pCreateInfo, pAllocator, pFunction);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyCudaModuleNV", "device, module, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyCudaModuleNV(api_dump, device, module, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyCudaModuleNV(device, module, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyCudaModuleNV(api_dump, device, module, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyCudaFunctionNV", "device, function, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyCudaFunctionNV(api_dump, device, function, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyCudaFunctionNV(device, function, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyCudaFunctionNV(api_dump, device, function, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV* pLaunchInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCudaLaunchKernelNV", "commandBuffer, pLaunchInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCudaLaunchKernelNV(api_dump, commandBuffer, pLaunchInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCudaLaunchKernelNV(api_dump, commandBuffer, pLaunchInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#endif  // VK_ENABLE_BETA_EXTENSIONS
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM* pDispatchTileInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchTileQCOM", "commandBuffer, pDispatchTileInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchTileQCOM(api_dump, commandBuffer, pDispatchTileInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchTileQCOM(commandBuffer, pDispatchTileInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchTileQCOM(api_dump, commandBuffer, pDispatchTileInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM* pPerTileBeginInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginPerTileExecutionQCOM", "commandBuffer, pPerTileBeginInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginPerTileExecutionQCOM(api_dump, commandBuffer, pPerTileBeginInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginPerTileExecutionQCOM(commandBuffer, pPerTileBeginInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginPerTileExecutionQCOM(api_dump, commandBuffer, pPerTileBeginInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM* pPerTileEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndPerTileExecutionQCOM", "commandBuffer, pPerTileEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndPerTileExecutionQCOM(api_dump, commandBuffer, pPerTileEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndPerTileExecutionQCOM(commandBuffer, pPerTileEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndPerTileExecutionQCOM(api_dump, commandBuffer, pPerTileEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
VKAPI_ATTR void VKAPI_CALL vkExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT* pMetalObjectsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkExportMetalObjectsEXT", "device, pMetalObjectsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkExportMetalObjectsEXT(api_dump, device, pMetalObjectsInfo);
        }
    }
    device_dispatch_table(device)->ExportMetalObjectsEXT(device, pMetalObjectsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkExportMetalObjectsEXT(api_dump, device, pMetalObjectsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#endif  // VK_USE_PLATFORM_METAL_EXT
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorSetLayoutSizeEXT", "device, layout, pLayoutSizeInBytes", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorSetLayoutSizeEXT(api_dump, device, layout, pLayoutSizeInBytes);
        }
    }
    device_dispatch_table(device)->GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorSetLayoutSizeEXT(api_dump, device, layout, pLayoutSizeInBytes);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorSetLayoutBindingOffsetEXT", "device, layout, binding, pOffset", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorSetLayoutBindingOffsetEXT(api_dump, device, layout, binding, pOffset);
        }
    }
    device_dispatch_table(device)->GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorSetLayoutBindingOffsetEXT(api_dump, device, layout, binding, pOffset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorEXT", "device, pDescriptorInfo, dataSize, pDescriptor", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorEXT(api_dump, device, pDescriptorInfo, dataSize, pDescriptor);
        }
    }
    device_dispatch_table(device)->GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorEXT(api_dump, device, pDescriptorInfo, dataSize, pDescriptor);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindDescriptorBuffersEXT", "commandBuffer, bufferCount, pBindingInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindDescriptorBuffersEXT(api_dump, commandBuffer, bufferCount, pBindingInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindDescriptorBuffersEXT(api_dump, commandBuffer, bufferCount, pBindingInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDescriptorBufferOffsetsEXT", "commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDescriptorBufferOffsetsEXT(api_dump, commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDescriptorBufferOffsetsEXT(api_dump, commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT", "commandBuffer, pipelineBindPoint, layout, set", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(api_dump, commandBuffer, pipelineBindPoint, layout, set);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(api_dump, commandBuffer, pipelineBindPoint, layout, set);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferOpaqueCaptureDescriptorDataEXT", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageOpaqueCaptureDescriptorDataEXT", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetImageViewOpaqueCaptureDescriptorDataEXT", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetImageViewOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetImageViewOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSamplerOpaqueCaptureDescriptorDataEXT", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSamplerOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSamplerOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetFragmentShadingRateEnumNV", "commandBuffer, shadingRate, combinerOps", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetFragmentShadingRateEnumNV(api_dump, commandBuffer, shadingRate, combinerOps);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetFragmentShadingRateEnumNV(api_dump, commandBuffer, shadingRate, combinerOps);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceFaultInfoEXT", "device, pFaultCounts, pFaultInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceFaultInfoEXT(api_dump, device, pFaultCounts, pFaultInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceFaultInfoEXT(api_dump, device, pFaultCounts, pFaultInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetVertexInputEXT", "commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetVertexInputEXT(api_dump, commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetVertexInputEXT(api_dump, commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryZirconHandleFUCHSIA", "device, pGetZirconHandleInfo, pZirconHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryZirconHandleFUCHSIA(api_dump, device, pGetZirconHandleInfo, pZirconHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryZirconHandleFUCHSIA(api_dump, device, pGetZirconHandleInfo, pZirconHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryZirconHandlePropertiesFUCHSIA", "device, handleType, zirconHandle, pMemoryZirconHandleProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryZirconHandlePropertiesFUCHSIA(api_dump, device, handleType, zirconHandle, pMemoryZirconHandleProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryZirconHandlePropertiesFUCHSIA(api_dump, device, handleType, zirconHandle, pMemoryZirconHandleProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkImportSemaphoreZirconHandleFUCHSIA", "device, pImportSemaphoreZirconHandleInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkImportSemaphoreZirconHandleFUCHSIA(api_dump, device, pImportSemaphoreZirconHandleInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkImportSemaphoreZirconHandleFUCHSIA(api_dump, device, pImportSemaphoreZirconHandleInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetSemaphoreZirconHandleFUCHSIA", "device, pGetZirconHandleInfo, pZirconHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetSemaphoreZirconHandleFUCHSIA(api_dump, device, pGetZirconHandleInfo, pZirconHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetSemaphoreZirconHandleFUCHSIA(api_dump, device, pGetZirconHandleInfo, pZirconHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferCollectionFUCHSIA* pCollection) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateBufferCollectionFUCHSIA", "device, pCreateInfo, pAllocator, pCollection", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateBufferCollectionFUCHSIA(api_dump, device, pCreateInfo, pAllocator, pCollection);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateBufferCollectionFUCHSIA(api_dump, device, pCreateInfo, pAllocator, pCollection);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetBufferCollectionImageConstraintsFUCHSIA", "device, collection, pImageConstraintsInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetBufferCollectionImageConstraintsFUCHSIA(api_dump, device, collection, pImageConstraintsInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetBufferCollectionImageConstraintsFUCHSIA(api_dump, device, collection, pImageConstraintsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetBufferCollectionBufferConstraintsFUCHSIA", "device, collection, pBufferConstraintsInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetBufferCollectionBufferConstraintsFUCHSIA(api_dump, device, collection, pBufferConstraintsInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetBufferCollectionBufferConstraintsFUCHSIA(api_dump, device, collection, pBufferConstraintsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyBufferCollectionFUCHSIA", "device, collection, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyBufferCollectionFUCHSIA(api_dump, device, collection, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyBufferCollectionFUCHSIA(device, collection, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyBufferCollectionFUCHSIA(api_dump, device, collection, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetBufferCollectionPropertiesFUCHSIA", "device, collection, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetBufferCollectionPropertiesFUCHSIA(api_dump, device, collection, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetBufferCollectionPropertiesFUCHSIA(api_dump, device, collection, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_FUCHSIA
VKAPI_ATTR VkResult VKAPI_CALL vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", "device, renderpass, pMaxWorkgroupSize", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(api_dump, device, renderpass, pMaxWorkgroupSize);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(api_dump, device, renderpass, pMaxWorkgroupSize);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSubpassShadingHUAWEI", "commandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSubpassShadingHUAWEI(api_dump, commandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSubpassShadingHUAWEI(commandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSubpassShadingHUAWEI(api_dump, commandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindInvocationMaskHUAWEI", "commandBuffer, imageView, imageLayout", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindInvocationMaskHUAWEI(api_dump, commandBuffer, imageView, imageLayout);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindInvocationMaskHUAWEI(api_dump, commandBuffer, imageView, imageLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryRemoteAddressNV", "device, pMemoryGetRemoteAddressInfo, pAddress", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryRemoteAddressNV(api_dump, device, pMemoryGetRemoteAddressInfo, pAddress);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryRemoteAddressNV(api_dump, device, pMemoryGetRemoteAddressInfo, pAddress);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelinePropertiesEXT", "device, pPipelineInfo, pPipelineProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelinePropertiesEXT(api_dump, device, pPipelineInfo, pPipelineProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelinePropertiesEXT(api_dump, device, pPipelineInfo, pPipelineProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPatchControlPointsEXT", "commandBuffer, patchControlPoints", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPatchControlPointsEXT(api_dump, commandBuffer, patchControlPoints);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPatchControlPointsEXT(api_dump, commandBuffer, patchControlPoints);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRasterizerDiscardEnableEXT", "commandBuffer, rasterizerDiscardEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRasterizerDiscardEnableEXT(api_dump, commandBuffer, rasterizerDiscardEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRasterizerDiscardEnableEXT(api_dump, commandBuffer, rasterizerDiscardEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthBiasEnableEXT", "commandBuffer, depthBiasEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthBiasEnableEXT(api_dump, commandBuffer, depthBiasEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthBiasEnableEXT(api_dump, commandBuffer, depthBiasEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLogicOpEXT", "commandBuffer, logicOp", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLogicOpEXT(api_dump, commandBuffer, logicOp);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLogicOpEXT(commandBuffer, logicOp);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLogicOpEXT(api_dump, commandBuffer, logicOp);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPrimitiveRestartEnableEXT", "commandBuffer, primitiveRestartEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPrimitiveRestartEnableEXT(api_dump, commandBuffer, primitiveRestartEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPrimitiveRestartEnableEXT(api_dump, commandBuffer, primitiveRestartEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetColorWriteEnableEXT", "commandBuffer, attachmentCount, pColorWriteEnables", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetColorWriteEnableEXT(api_dump, commandBuffer, attachmentCount, pColorWriteEnables);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetColorWriteEnableEXT(api_dump, commandBuffer, attachmentCount, pColorWriteEnables);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMultiEXT", "commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMultiEXT(api_dump, commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMultiEXT(api_dump, commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMultiIndexedEXT", "commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMultiIndexedEXT(api_dump, commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMultiIndexedEXT(api_dump, commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateMicromapEXT", "device, pCreateInfo, pAllocator, pMicromap", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateMicromapEXT(api_dump, device, pCreateInfo, pAllocator, pMicromap);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateMicromapEXT(api_dump, device, pCreateInfo, pAllocator, pMicromap);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyMicromapEXT", "device, micromap, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyMicromapEXT(api_dump, device, micromap, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyMicromapEXT(device, micromap, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyMicromapEXT(api_dump, device, micromap, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBuildMicromapsEXT", "commandBuffer, infoCount, pInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBuildMicromapsEXT(api_dump, commandBuffer, infoCount, pInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBuildMicromapsEXT(api_dump, commandBuffer, infoCount, pInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBuildMicromapsEXT", "device, deferredOperation, infoCount, pInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBuildMicromapsEXT(api_dump, device, deferredOperation, infoCount, pInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBuildMicromapsEXT(api_dump, device, deferredOperation, infoCount, pInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyMicromapEXT", "device, deferredOperation, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyMicromapEXT(api_dump, device, deferredOperation, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyMicromapEXT(device, deferredOperation, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyMicromapEXT(api_dump, device, deferredOperation, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyMicromapToMemoryEXT", "device, deferredOperation, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyMicromapToMemoryEXT(api_dump, device, deferredOperation, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyMicromapToMemoryEXT(device, deferredOperation, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyMicromapToMemoryEXT(api_dump, device, deferredOperation, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyMemoryToMicromapEXT", "device, deferredOperation, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyMemoryToMicromapEXT(api_dump, device, deferredOperation, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyMemoryToMicromapEXT(device, deferredOperation, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyMemoryToMicromapEXT(api_dump, device, deferredOperation, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, size_t dataSize, void* pData, size_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkWriteMicromapsPropertiesEXT", "device, micromapCount, pMicromaps, queryType, dataSize, pData, stride", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkWriteMicromapsPropertiesEXT(api_dump, device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
        }
    }
    VkResult result = device_dispatch_table(device)->WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWriteMicromapsPropertiesEXT(api_dump, device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMicromapEXT", "commandBuffer, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMicromapEXT(api_dump, commandBuffer, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMicromapEXT(commandBuffer, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMicromapEXT(api_dump, commandBuffer, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMicromapToMemoryEXT", "commandBuffer, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMicromapToMemoryEXT(api_dump, commandBuffer, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMicromapToMemoryEXT(api_dump, commandBuffer, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMemoryToMicromapEXT", "commandBuffer, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMemoryToMicromapEXT(api_dump, commandBuffer, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMemoryToMicromapEXT(api_dump, commandBuffer, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteMicromapsPropertiesEXT", "commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteMicromapsPropertiesEXT(api_dump, commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteMicromapsPropertiesEXT(api_dump, commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceMicromapCompatibilityEXT", "device, pVersionInfo, pCompatibility", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceMicromapCompatibilityEXT(api_dump, device, pVersionInfo, pCompatibility);
        }
    }
    device_dispatch_table(device)->GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceMicromapCompatibilityEXT(api_dump, device, pVersionInfo, pCompatibility);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT* pBuildInfo, VkMicromapBuildSizesInfoEXT* pSizeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMicromapBuildSizesEXT", "device, buildType, pBuildInfo, pSizeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMicromapBuildSizesEXT(api_dump, device, buildType, pBuildInfo, pSizeInfo);
        }
    }
    device_dispatch_table(device)->GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMicromapBuildSizesEXT(api_dump, device, buildType, pBuildInfo, pSizeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawClusterHUAWEI", "commandBuffer, groupCountX, groupCountY, groupCountZ", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawClusterHUAWEI(api_dump, commandBuffer, groupCountX, groupCountY, groupCountZ);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawClusterHUAWEI(api_dump, commandBuffer, groupCountX, groupCountY, groupCountZ);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawClusterIndirectHUAWEI", "commandBuffer, buffer, offset", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawClusterIndirectHUAWEI(api_dump, commandBuffer, buffer, offset);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawClusterIndirectHUAWEI(api_dump, commandBuffer, buffer, offset);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetDeviceMemoryPriorityEXT", "device, memory, priority", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetDeviceMemoryPriorityEXT(api_dump, device, memory, priority);
        }
    }
    device_dispatch_table(device)->SetDeviceMemoryPriorityEXT(device, memory, priority);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetDeviceMemoryPriorityEXT(api_dump, device, memory, priority);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorSetLayoutHostMappingInfoVALVE", "device, pBindingReference, pHostMapping", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorSetLayoutHostMappingInfoVALVE(api_dump, device, pBindingReference, pHostMapping);
        }
    }
    device_dispatch_table(device)->GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorSetLayoutHostMappingInfoVALVE(api_dump, device, pBindingReference, pHostMapping);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void** ppData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDescriptorSetHostMappingVALVE", "device, descriptorSet, ppData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDescriptorSetHostMappingVALVE(api_dump, device, descriptorSet, ppData);
        }
    }
    device_dispatch_table(device)->GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDescriptorSetHostMappingVALVE(api_dump, device, descriptorSet, ppData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMemoryIndirectNV", "commandBuffer, copyBufferAddress, copyCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMemoryIndirectNV(api_dump, commandBuffer, copyBufferAddress, copyCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMemoryIndirectNV(api_dump, commandBuffer, copyBufferAddress, copyCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMemoryToImageIndirectNV", "commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMemoryToImageIndirectNV(api_dump, commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMemoryToImageIndirectNV(api_dump, commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDecompressMemoryNV", "commandBuffer, decompressRegionCount, pDecompressMemoryRegions", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDecompressMemoryNV(api_dump, commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDecompressMemoryNV(api_dump, commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDecompressMemoryIndirectCountNV", "commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDecompressMemoryIndirectCountNV(api_dump, commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDecompressMemoryIndirectCountNV(api_dump, commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineIndirectMemoryRequirementsNV", "device, pCreateInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineIndirectMemoryRequirementsNV(api_dump, device, pCreateInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineIndirectMemoryRequirementsNV(api_dump, device, pCreateInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdUpdatePipelineIndirectBufferNV", "commandBuffer, pipelineBindPoint, pipeline", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdUpdatePipelineIndirectBufferNV(api_dump, commandBuffer, pipelineBindPoint, pipeline);
        }
    }
    device_dispatch_table(commandBuffer)->CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdUpdatePipelineIndirectBufferNV(api_dump, commandBuffer, pipelineBindPoint, pipeline);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkDeviceAddress VKAPI_CALL vkGetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPipelineIndirectDeviceAddressNV", "device, pInfo", "VkDeviceAddress");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPipelineIndirectDeviceAddressNV(api_dump, device, pInfo);
        }
    }
    VkDeviceAddress result = device_dispatch_table(device)->GetPipelineIndirectDeviceAddressNV(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceAddress", result, dump_return_value_VkDeviceAddress);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPipelineIndirectDeviceAddressNV(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#if defined(VK_USE_PLATFORM_OHOS)
VKAPI_ATTR VkResult VKAPI_CALL vkGetNativeBufferPropertiesOHOS(VkDevice device, const struct OH_NativeBuffer* buffer, VkNativeBufferPropertiesOHOS* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetNativeBufferPropertiesOHOS", "device, buffer, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetNativeBufferPropertiesOHOS(api_dump, device, buffer, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetNativeBufferPropertiesOHOS(device, buffer, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetNativeBufferPropertiesOHOS(api_dump, device, buffer, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryNativeBufferOHOS(VkDevice device, const VkMemoryGetNativeBufferInfoOHOS* pInfo, struct OH_NativeBuffer** pBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryNativeBufferOHOS", "device, pInfo, pBuffer", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryNativeBufferOHOS(api_dump, device, pInfo, pBuffer);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryNativeBufferOHOS(device, pInfo, pBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryNativeBufferOHOS(api_dump, device, pInfo, pBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_OHOS
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthClampEnableEXT", "commandBuffer, depthClampEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthClampEnableEXT(api_dump, commandBuffer, depthClampEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthClampEnableEXT(api_dump, commandBuffer, depthClampEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetPolygonModeEXT", "commandBuffer, polygonMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetPolygonModeEXT(api_dump, commandBuffer, polygonMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetPolygonModeEXT(commandBuffer, polygonMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetPolygonModeEXT(api_dump, commandBuffer, polygonMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRasterizationSamplesEXT", "commandBuffer, rasterizationSamples", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRasterizationSamplesEXT(api_dump, commandBuffer, rasterizationSamples);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRasterizationSamplesEXT(api_dump, commandBuffer, rasterizationSamples);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask* pSampleMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetSampleMaskEXT", "commandBuffer, samples, pSampleMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetSampleMaskEXT(api_dump, commandBuffer, samples, pSampleMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetSampleMaskEXT(api_dump, commandBuffer, samples, pSampleMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetAlphaToCoverageEnableEXT", "commandBuffer, alphaToCoverageEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetAlphaToCoverageEnableEXT(api_dump, commandBuffer, alphaToCoverageEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetAlphaToCoverageEnableEXT(api_dump, commandBuffer, alphaToCoverageEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetAlphaToOneEnableEXT", "commandBuffer, alphaToOneEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetAlphaToOneEnableEXT(api_dump, commandBuffer, alphaToOneEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetAlphaToOneEnableEXT(api_dump, commandBuffer, alphaToOneEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLogicOpEnableEXT", "commandBuffer, logicOpEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLogicOpEnableEXT(api_dump, commandBuffer, logicOpEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLogicOpEnableEXT(api_dump, commandBuffer, logicOpEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetColorBlendEnableEXT", "commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetColorBlendEnableEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetColorBlendEnableEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetColorBlendEquationEXT", "commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetColorBlendEquationEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetColorBlendEquationEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetColorWriteMaskEXT", "commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetColorWriteMaskEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetColorWriteMaskEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetTessellationDomainOriginEXT", "commandBuffer, domainOrigin", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetTessellationDomainOriginEXT(api_dump, commandBuffer, domainOrigin);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetTessellationDomainOriginEXT(api_dump, commandBuffer, domainOrigin);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRasterizationStreamEXT", "commandBuffer, rasterizationStream", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRasterizationStreamEXT(api_dump, commandBuffer, rasterizationStream);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRasterizationStreamEXT(api_dump, commandBuffer, rasterizationStream);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetConservativeRasterizationModeEXT", "commandBuffer, conservativeRasterizationMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetConservativeRasterizationModeEXT(api_dump, commandBuffer, conservativeRasterizationMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetConservativeRasterizationModeEXT(api_dump, commandBuffer, conservativeRasterizationMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetExtraPrimitiveOverestimationSizeEXT", "commandBuffer, extraPrimitiveOverestimationSize", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetExtraPrimitiveOverestimationSizeEXT(api_dump, commandBuffer, extraPrimitiveOverestimationSize);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetExtraPrimitiveOverestimationSizeEXT(api_dump, commandBuffer, extraPrimitiveOverestimationSize);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthClipEnableEXT", "commandBuffer, depthClipEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthClipEnableEXT(api_dump, commandBuffer, depthClipEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthClipEnableEXT(api_dump, commandBuffer, depthClipEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetSampleLocationsEnableEXT", "commandBuffer, sampleLocationsEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetSampleLocationsEnableEXT(api_dump, commandBuffer, sampleLocationsEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetSampleLocationsEnableEXT(api_dump, commandBuffer, sampleLocationsEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetColorBlendAdvancedEXT", "commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetColorBlendAdvancedEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetColorBlendAdvancedEXT(api_dump, commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetProvokingVertexModeEXT", "commandBuffer, provokingVertexMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetProvokingVertexModeEXT(api_dump, commandBuffer, provokingVertexMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetProvokingVertexModeEXT(api_dump, commandBuffer, provokingVertexMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLineRasterizationModeEXT", "commandBuffer, lineRasterizationMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLineRasterizationModeEXT(api_dump, commandBuffer, lineRasterizationMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLineRasterizationModeEXT(api_dump, commandBuffer, lineRasterizationMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetLineStippleEnableEXT", "commandBuffer, stippledLineEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetLineStippleEnableEXT(api_dump, commandBuffer, stippledLineEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetLineStippleEnableEXT(api_dump, commandBuffer, stippledLineEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthClipNegativeOneToOneEXT", "commandBuffer, negativeOneToOne", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthClipNegativeOneToOneEXT(api_dump, commandBuffer, negativeOneToOne);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthClipNegativeOneToOneEXT(api_dump, commandBuffer, negativeOneToOne);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewportWScalingEnableNV", "commandBuffer, viewportWScalingEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewportWScalingEnableNV(api_dump, commandBuffer, viewportWScalingEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewportWScalingEnableNV(api_dump, commandBuffer, viewportWScalingEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetViewportSwizzleNV", "commandBuffer, firstViewport, viewportCount, pViewportSwizzles", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetViewportSwizzleNV(api_dump, commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetViewportSwizzleNV(api_dump, commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoverageToColorEnableNV", "commandBuffer, coverageToColorEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoverageToColorEnableNV(api_dump, commandBuffer, coverageToColorEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoverageToColorEnableNV(api_dump, commandBuffer, coverageToColorEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoverageToColorLocationNV", "commandBuffer, coverageToColorLocation", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoverageToColorLocationNV(api_dump, commandBuffer, coverageToColorLocation);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoverageToColorLocationNV(api_dump, commandBuffer, coverageToColorLocation);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoverageModulationModeNV", "commandBuffer, coverageModulationMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoverageModulationModeNV(api_dump, commandBuffer, coverageModulationMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoverageModulationModeNV(api_dump, commandBuffer, coverageModulationMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoverageModulationTableEnableNV", "commandBuffer, coverageModulationTableEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoverageModulationTableEnableNV(api_dump, commandBuffer, coverageModulationTableEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoverageModulationTableEnableNV(api_dump, commandBuffer, coverageModulationTableEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoverageModulationTableNV", "commandBuffer, coverageModulationTableCount, pCoverageModulationTable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoverageModulationTableNV(api_dump, commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoverageModulationTableNV(api_dump, commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetShadingRateImageEnableNV", "commandBuffer, shadingRateImageEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetShadingRateImageEnableNV(api_dump, commandBuffer, shadingRateImageEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetShadingRateImageEnableNV(api_dump, commandBuffer, shadingRateImageEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRepresentativeFragmentTestEnableNV", "commandBuffer, representativeFragmentTestEnable", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRepresentativeFragmentTestEnableNV(api_dump, commandBuffer, representativeFragmentTestEnable);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRepresentativeFragmentTestEnableNV(api_dump, commandBuffer, representativeFragmentTestEnable);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetCoverageReductionModeNV", "commandBuffer, coverageReductionMode", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetCoverageReductionModeNV(api_dump, commandBuffer, coverageReductionMode);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetCoverageReductionModeNV(api_dump, commandBuffer, coverageReductionMode);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateTensorARM(VkDevice device, const VkTensorCreateInfoARM* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkTensorARM* pTensor) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateTensorARM", "device, pCreateInfo, pAllocator, pTensor", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateTensorARM(api_dump, device, pCreateInfo, pAllocator, pTensor);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateTensorARM(device, pCreateInfo, pAllocator, pTensor);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateTensorARM(api_dump, device, pCreateInfo, pAllocator, pTensor);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyTensorARM", "device, tensor, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyTensorARM(api_dump, device, tensor, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyTensorARM(device, tensor, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyTensorARM(api_dump, device, tensor, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkTensorViewARM* pView) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateTensorViewARM", "device, pCreateInfo, pAllocator, pView", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateTensorViewARM(api_dump, device, pCreateInfo, pAllocator, pView);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateTensorViewARM(device, pCreateInfo, pAllocator, pView);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateTensorViewARM(api_dump, device, pCreateInfo, pAllocator, pView);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyTensorViewARM", "device, tensorView, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyTensorViewARM(api_dump, device, tensorView, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyTensorViewARM(device, tensorView, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyTensorViewARM(api_dump, device, tensorView, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetTensorMemoryRequirementsARM", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetTensorMemoryRequirementsARM(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetTensorMemoryRequirementsARM(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindTensorMemoryARM", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindTensorMemoryARM(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindTensorMemoryARM(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindTensorMemoryARM(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceTensorMemoryRequirementsARM", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceTensorMemoryRequirementsARM(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDeviceTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceTensorMemoryRequirementsARM(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM* pCopyTensorInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyTensorARM", "commandBuffer, pCopyTensorInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyTensorARM(api_dump, commandBuffer, pCopyTensorInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyTensorARM(commandBuffer, pCopyTensorInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyTensorARM(api_dump, commandBuffer, pCopyTensorInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetTensorOpaqueCaptureDescriptorDataARM", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetTensorOpaqueCaptureDescriptorDataARM(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetTensorOpaqueCaptureDescriptorDataARM(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetTensorOpaqueCaptureDescriptorDataARM(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM* pInfo, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetTensorViewOpaqueCaptureDescriptorDataARM", "device, pInfo, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetTensorViewOpaqueCaptureDescriptorDataARM(api_dump, device, pInfo, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetTensorViewOpaqueCaptureDescriptorDataARM(device, pInfo, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetTensorViewOpaqueCaptureDescriptorDataARM(api_dump, device, pInfo, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetShaderModuleIdentifierEXT", "device, shaderModule, pIdentifier", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetShaderModuleIdentifierEXT(api_dump, device, shaderModule, pIdentifier);
        }
    }
    device_dispatch_table(device)->GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetShaderModuleIdentifierEXT(api_dump, device, shaderModule, pIdentifier);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetShaderModuleCreateInfoIdentifierEXT", "device, pCreateInfo, pIdentifier", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetShaderModuleCreateInfoIdentifierEXT(api_dump, device, pCreateInfo, pIdentifier);
        }
    }
    device_dispatch_table(device)->GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetShaderModuleCreateInfoIdentifierEXT(api_dump, device, pCreateInfo, pIdentifier);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateOpticalFlowSessionNV", "device, pCreateInfo, pAllocator, pSession", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateOpticalFlowSessionNV(api_dump, device, pCreateInfo, pAllocator, pSession);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateOpticalFlowSessionNV(api_dump, device, pCreateInfo, pAllocator, pSession);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyOpticalFlowSessionNV", "device, session, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyOpticalFlowSessionNV(api_dump, device, session, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyOpticalFlowSessionNV(device, session, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyOpticalFlowSessionNV(api_dump, device, session, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindOpticalFlowSessionImageNV", "device, session, bindingPoint, view, layout", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindOpticalFlowSessionImageNV(api_dump, device, session, bindingPoint, view, layout);
        }
    }
    VkResult result = device_dispatch_table(device)->BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindOpticalFlowSessionImageNV(api_dump, device, session, bindingPoint, view, layout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdOpticalFlowExecuteNV", "commandBuffer, session, pExecuteInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdOpticalFlowExecuteNV(api_dump, commandBuffer, session, pExecuteInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdOpticalFlowExecuteNV(api_dump, commandBuffer, session, pExecuteInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkAntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkAntiLagUpdateAMD", "device, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkAntiLagUpdateAMD(api_dump, device, pData);
        }
    }
    device_dispatch_table(device)->AntiLagUpdateAMD(device, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkAntiLagUpdateAMD(api_dump, device, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateShadersEXT", "device, createInfoCount, pCreateInfos, pAllocator, pShaders", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateShadersEXT(api_dump, device, createInfoCount, pCreateInfos, pAllocator, pShaders);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateShadersEXT(api_dump, device, createInfoCount, pCreateInfos, pAllocator, pShaders);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyShaderEXT", "device, shader, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyShaderEXT(api_dump, device, shader, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyShaderEXT(device, shader, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyShaderEXT(api_dump, device, shader, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetShaderBinaryDataEXT", "device, shader, pDataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetShaderBinaryDataEXT(api_dump, device, shader, pDataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetShaderBinaryDataEXT(device, shader, pDataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetShaderBinaryDataEXT(api_dump, device, shader, pDataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindShadersEXT", "commandBuffer, stageCount, pStages, pShaders", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindShadersEXT(api_dump, commandBuffer, stageCount, pStages, pShaders);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindShadersEXT(api_dump, commandBuffer, stageCount, pStages, pShaders);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT* pDepthClampRange) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetDepthClampRangeEXT", "commandBuffer, depthClampMode, pDepthClampRange", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetDepthClampRangeEXT(api_dump, commandBuffer, depthClampMode, pDepthClampRange);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetDepthClampRangeEXT(api_dump, commandBuffer, depthClampMode, pDepthClampRange);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetFramebufferTilePropertiesQCOM", "device, framebuffer, pPropertiesCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetFramebufferTilePropertiesQCOM(api_dump, device, framebuffer, pPropertiesCount, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetFramebufferTilePropertiesQCOM(api_dump, device, framebuffer, pPropertiesCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDynamicRenderingTilePropertiesQCOM", "device, pRenderingInfo, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDynamicRenderingTilePropertiesQCOM(api_dump, device, pRenderingInfo, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDynamicRenderingTilePropertiesQCOM(api_dump, device, pRenderingInfo, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkConvertCooperativeVectorMatrixNV", "device, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkConvertCooperativeVectorMatrixNV(api_dump, device, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->ConvertCooperativeVectorMatrixNV(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkConvertCooperativeVectorMatrixNV(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV* pInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdConvertCooperativeVectorMatrixNV", "commandBuffer, infoCount, pInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdConvertCooperativeVectorMatrixNV(api_dump, commandBuffer, infoCount, pInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdConvertCooperativeVectorMatrixNV(api_dump, commandBuffer, infoCount, pInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV* pSleepModeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetLatencySleepModeNV", "device, swapchain, pSleepModeInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetLatencySleepModeNV(api_dump, device, swapchain, pSleepModeInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->SetLatencySleepModeNV(device, swapchain, pSleepModeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetLatencySleepModeNV(api_dump, device, swapchain, pSleepModeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV* pSleepInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkLatencySleepNV", "device, swapchain, pSleepInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkLatencySleepNV(api_dump, device, swapchain, pSleepInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->LatencySleepNV(device, swapchain, pSleepInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkLatencySleepNV(api_dump, device, swapchain, pSleepInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkSetLatencyMarkerNV", "device, swapchain, pLatencyMarkerInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkSetLatencyMarkerNV(api_dump, device, swapchain, pLatencyMarkerInfo);
        }
    }
    device_dispatch_table(device)->SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkSetLatencyMarkerNV(api_dump, device, swapchain, pLatencyMarkerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV* pLatencyMarkerInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetLatencyTimingsNV", "device, swapchain, pLatencyMarkerInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetLatencyTimingsNV(api_dump, device, swapchain, pLatencyMarkerInfo);
        }
    }
    device_dispatch_table(device)->GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetLatencyTimingsNV(api_dump, device, swapchain, pLatencyMarkerInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkQueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkQueueNotifyOutOfBandNV", "queue, pQueueTypeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkQueueNotifyOutOfBandNV(api_dump, queue, pQueueTypeInfo);
        }
    }
    device_dispatch_table(queue)->QueueNotifyOutOfBandNV(queue, pQueueTypeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkQueueNotifyOutOfBandNV(api_dump, queue, pQueueTypeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDataGraphPipelinesARM", "device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDataGraphPipelinesARM(api_dump, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDataGraphPipelinesARM(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDataGraphPipelinesARM(api_dump, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDataGraphPipelineSessionARM* pSession) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateDataGraphPipelineSessionARM", "device, pCreateInfo, pAllocator, pSession", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateDataGraphPipelineSessionARM(api_dump, device, pCreateInfo, pAllocator, pSession);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateDataGraphPipelineSessionARM(device, pCreateInfo, pAllocator, pSession);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateDataGraphPipelineSessionARM(api_dump, device, pCreateInfo, pAllocator, pSession);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM* pInfo, uint32_t* pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM* pBindPointRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDataGraphPipelineSessionBindPointRequirementsARM", "device, pInfo, pBindPointRequirementCount, pBindPointRequirements", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDataGraphPipelineSessionBindPointRequirementsARM(api_dump, device, pInfo, pBindPointRequirementCount, pBindPointRequirements);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDataGraphPipelineSessionBindPointRequirementsARM(device, pInfo, pBindPointRequirementCount, pBindPointRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDataGraphPipelineSessionBindPointRequirementsARM(api_dump, device, pInfo, pBindPointRequirementCount, pBindPointRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkGetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDataGraphPipelineSessionMemoryRequirementsARM", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDataGraphPipelineSessionMemoryRequirementsARM(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetDataGraphPipelineSessionMemoryRequirementsARM(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDataGraphPipelineSessionMemoryRequirementsARM(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM* pBindInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBindDataGraphPipelineSessionMemoryARM", "device, bindInfoCount, pBindInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBindDataGraphPipelineSessionMemoryARM(api_dump, device, bindInfoCount, pBindInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BindDataGraphPipelineSessionMemoryARM(device, bindInfoCount, pBindInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBindDataGraphPipelineSessionMemoryARM(api_dump, device, bindInfoCount, pBindInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyDataGraphPipelineSessionARM", "device, session, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyDataGraphPipelineSessionARM(api_dump, device, session, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyDataGraphPipelineSessionARM(device, session, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyDataGraphPipelineSessionARM(api_dump, device, session, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDispatchDataGraphARM", "commandBuffer, session, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDispatchDataGraphARM(api_dump, commandBuffer, session, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDispatchDataGraphARM(commandBuffer, session, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDispatchDataGraphARM(api_dump, commandBuffer, session, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM* pPipelineInfo, uint32_t* pPropertiesCount, VkDataGraphPipelinePropertyARM* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDataGraphPipelineAvailablePropertiesARM", "device, pPipelineInfo, pPropertiesCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDataGraphPipelineAvailablePropertiesARM(api_dump, device, pPipelineInfo, pPropertiesCount, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDataGraphPipelineAvailablePropertiesARM(device, pPipelineInfo, pPropertiesCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDataGraphPipelineAvailablePropertiesARM(api_dump, device, pPipelineInfo, pPropertiesCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM* pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDataGraphPipelinePropertiesARM", "device, pPipelineInfo, propertiesCount, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDataGraphPipelinePropertiesARM(api_dump, device, pPipelineInfo, propertiesCount, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetDataGraphPipelinePropertiesARM(device, pPipelineInfo, propertiesCount, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDataGraphPipelinePropertiesARM(api_dump, device, pPipelineInfo, propertiesCount, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetAttachmentFeedbackLoopEnableEXT", "commandBuffer, aspectMask", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetAttachmentFeedbackLoopEnableEXT(api_dump, commandBuffer, aspectMask);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetAttachmentFeedbackLoopEnableEXT(api_dump, commandBuffer, aspectMask);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
VKAPI_ATTR VkResult VKAPI_CALL vkGetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer* buffer, VkScreenBufferPropertiesQNX* pProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetScreenBufferPropertiesQNX", "device, buffer, pProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetScreenBufferPropertiesQNX(api_dump, device, buffer, pProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetScreenBufferPropertiesQNX(device, buffer, pProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetScreenBufferPropertiesQNX(api_dump, device, buffer, pProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX
VKAPI_ATTR void VKAPI_CALL vkCmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM* pTileMemoryBindInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBindTileMemoryQCOM", "commandBuffer, pTileMemoryBindInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBindTileMemoryQCOM(api_dump, commandBuffer, pTileMemoryBindInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBindTileMemoryQCOM(commandBuffer, pTileMemoryBindInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBindTileMemoryQCOM(api_dump, commandBuffer, pTileMemoryBindInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDecompressMemoryEXT(VkCommandBuffer commandBuffer, const VkDecompressMemoryInfoEXT* pDecompressMemoryInfoEXT) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDecompressMemoryEXT", "commandBuffer, pDecompressMemoryInfoEXT", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDecompressMemoryEXT(api_dump, commandBuffer, pDecompressMemoryInfoEXT);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDecompressMemoryEXT(commandBuffer, pDecompressMemoryInfoEXT);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDecompressMemoryEXT(api_dump, commandBuffer, pDecompressMemoryInfoEXT);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDecompressMemoryIndirectCountEXT(VkCommandBuffer commandBuffer, VkMemoryDecompressionMethodFlagsEXT decompressionMethod, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t maxDecompressionCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDecompressMemoryIndirectCountEXT", "commandBuffer, decompressionMethod, indirectCommandsAddress, indirectCommandsCountAddress, maxDecompressionCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDecompressMemoryIndirectCountEXT(api_dump, commandBuffer, decompressionMethod, indirectCommandsAddress, indirectCommandsCountAddress, maxDecompressionCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDecompressMemoryIndirectCountEXT(commandBuffer, decompressionMethod, indirectCommandsAddress, indirectCommandsCountAddress, maxDecompressionCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDecompressMemoryIndirectCountEXT(api_dump, commandBuffer, decompressionMethod, indirectCommandsAddress, indirectCommandsCountAddress, maxDecompressionCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkExternalComputeQueueNV* pExternalQueue) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateExternalComputeQueueNV", "device, pCreateInfo, pAllocator, pExternalQueue", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateExternalComputeQueueNV(api_dump, device, pCreateInfo, pAllocator, pExternalQueue);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateExternalComputeQueueNV(device, pCreateInfo, pAllocator, pExternalQueue);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateExternalComputeQueueNV(api_dump, device, pCreateInfo, pAllocator, pExternalQueue);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyExternalComputeQueueNV", "device, externalQueue, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyExternalComputeQueueNV(api_dump, device, externalQueue, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyExternalComputeQueueNV(device, externalQueue, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyExternalComputeQueueNV(api_dump, device, externalQueue, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV* params, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetExternalComputeQueueDataNV", "externalQueue, params, pData", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetExternalComputeQueueDataNV(api_dump, externalQueue, params, pData);
        }
    }
    device_dispatch_table(externalQueue)->GetExternalComputeQueueDataNV(externalQueue, params, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetExternalComputeQueueDataNV(api_dump, externalQueue, params, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV* pInfo, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetClusterAccelerationStructureBuildSizesNV", "device, pInfo, pSizeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetClusterAccelerationStructureBuildSizesNV(api_dump, device, pInfo, pSizeInfo);
        }
    }
    device_dispatch_table(device)->GetClusterAccelerationStructureBuildSizesNV(device, pInfo, pSizeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetClusterAccelerationStructureBuildSizesNV(api_dump, device, pInfo, pSizeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV* pCommandInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBuildClusterAccelerationStructureIndirectNV", "commandBuffer, pCommandInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBuildClusterAccelerationStructureIndirectNV(api_dump, commandBuffer, pCommandInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBuildClusterAccelerationStructureIndirectNV(commandBuffer, pCommandInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBuildClusterAccelerationStructureIndirectNV(api_dump, commandBuffer, pCommandInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV* pInfo, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetPartitionedAccelerationStructuresBuildSizesNV", "device, pInfo, pSizeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetPartitionedAccelerationStructuresBuildSizesNV(api_dump, device, pInfo, pSizeInfo);
        }
    }
    device_dispatch_table(device)->GetPartitionedAccelerationStructuresBuildSizesNV(device, pInfo, pSizeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetPartitionedAccelerationStructuresBuildSizesNV(api_dump, device, pInfo, pSizeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV* pBuildInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBuildPartitionedAccelerationStructuresNV", "commandBuffer, pBuildInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBuildPartitionedAccelerationStructuresNV(api_dump, commandBuffer, pBuildInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBuildPartitionedAccelerationStructuresNV(commandBuffer, pBuildInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBuildPartitionedAccelerationStructuresNV(api_dump, commandBuffer, pBuildInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetGeneratedCommandsMemoryRequirementsEXT", "device, pInfo, pMemoryRequirements", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetGeneratedCommandsMemoryRequirementsEXT(api_dump, device, pInfo, pMemoryRequirements);
        }
    }
    device_dispatch_table(device)->GetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, pMemoryRequirements);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetGeneratedCommandsMemoryRequirementsEXT(api_dump, device, pInfo, pMemoryRequirements);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdPreprocessGeneratedCommandsEXT", "commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdPreprocessGeneratedCommandsEXT(api_dump, commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
        }
    }
    device_dispatch_table(commandBuffer)->CmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdPreprocessGeneratedCommandsEXT(api_dump, commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdExecuteGeneratedCommandsEXT", "commandBuffer, isPreprocessed, pGeneratedCommandsInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdExecuteGeneratedCommandsEXT(api_dump, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdExecuteGeneratedCommandsEXT(api_dump, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutEXT* pIndirectCommandsLayout) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateIndirectCommandsLayoutEXT", "device, pCreateInfo, pAllocator, pIndirectCommandsLayout", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateIndirectCommandsLayoutEXT(api_dump, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateIndirectCommandsLayoutEXT(api_dump, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyIndirectCommandsLayoutEXT", "device, indirectCommandsLayout, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyIndirectCommandsLayoutEXT(api_dump, device, indirectCommandsLayout, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyIndirectCommandsLayoutEXT(api_dump, device, indirectCommandsLayout, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectExecutionSetEXT* pIndirectExecutionSet) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateIndirectExecutionSetEXT", "device, pCreateInfo, pAllocator, pIndirectExecutionSet", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateIndirectExecutionSetEXT(api_dump, device, pCreateInfo, pAllocator, pIndirectExecutionSet);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateIndirectExecutionSetEXT(api_dump, device, pCreateInfo, pAllocator, pIndirectExecutionSet);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyIndirectExecutionSetEXT", "device, indirectExecutionSet, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyIndirectExecutionSetEXT(api_dump, device, indirectExecutionSet, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyIndirectExecutionSetEXT(api_dump, device, indirectExecutionSet, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkUpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUpdateIndirectExecutionSetPipelineEXT", "device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUpdateIndirectExecutionSetPipelineEXT(api_dump, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
        }
    }
    device_dispatch_table(device)->UpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUpdateIndirectExecutionSetPipelineEXT(api_dump, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkUpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkUpdateIndirectExecutionSetShaderEXT", "device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkUpdateIndirectExecutionSetShaderEXT(api_dump, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
        }
    }
    device_dispatch_table(device)->UpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkUpdateIndirectExecutionSetShaderEXT(api_dump, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT* pGetMetalHandleInfo, void** pHandle) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryMetalHandleEXT", "device, pGetMetalHandleInfo, pHandle", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryMetalHandleEXT(api_dump, device, pGetMetalHandleInfo, pHandle);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryMetalHandleEXT(device, pGetMetalHandleInfo, pHandle);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryMetalHandleEXT(api_dump, device, pGetMetalHandleInfo, pHandle);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHandle, VkMemoryMetalHandlePropertiesEXT* pMemoryMetalHandleProperties) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetMemoryMetalHandlePropertiesEXT", "device, handleType, pHandle, pMemoryMetalHandleProperties", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetMemoryMetalHandlePropertiesEXT(api_dump, device, handleType, pHandle, pMemoryMetalHandleProperties);
        }
    }
    VkResult result = device_dispatch_table(device)->GetMemoryMetalHandlePropertiesEXT(device, handleType, pHandle, pMemoryMetalHandleProperties);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetMemoryMetalHandlePropertiesEXT(api_dump, device, handleType, pHandle, pMemoryMetalHandleProperties);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
#endif  // VK_USE_PLATFORM_METAL_EXT
VKAPI_ATTR void VKAPI_CALL vkCmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoKHR* pRenderingEndInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdEndRendering2EXT", "commandBuffer, pRenderingEndInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdEndRendering2EXT(api_dump, commandBuffer, pRenderingEndInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdEndRendering2EXT(commandBuffer, pRenderingEndInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdEndRendering2EXT(api_dump, commandBuffer, pRenderingEndInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBeginCustomResolveEXT(VkCommandBuffer commandBuffer, const VkBeginCustomResolveInfoEXT* pBeginCustomResolveInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBeginCustomResolveEXT", "commandBuffer, pBeginCustomResolveInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBeginCustomResolveEXT(api_dump, commandBuffer, pBeginCustomResolveInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBeginCustomResolveEXT(commandBuffer, pBeginCustomResolveInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBeginCustomResolveEXT(api_dump, commandBuffer, pBeginCustomResolveInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetComputeOccupancyPriorityNV(VkCommandBuffer commandBuffer, const VkComputeOccupancyPriorityParametersNV* pParameters) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetComputeOccupancyPriorityNV", "commandBuffer, pParameters", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetComputeOccupancyPriorityNV(api_dump, commandBuffer, pParameters);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetComputeOccupancyPriorityNV(commandBuffer, pParameters);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetComputeOccupancyPriorityNV(api_dump, commandBuffer, pParameters);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureKHR* pAccelerationStructure) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateAccelerationStructureKHR", "device, pCreateInfo, pAllocator, pAccelerationStructure", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateAccelerationStructureKHR(api_dump, device, pCreateInfo, pAllocator, pAccelerationStructure);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateAccelerationStructureKHR(api_dump, device, pCreateInfo, pAllocator, pAccelerationStructure);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkDestroyAccelerationStructureKHR", "device, accelerationStructure, pAllocator", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkDestroyAccelerationStructureKHR(api_dump, device, accelerationStructure, pAllocator);
        }
    }
    device_dispatch_table(device)->DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkDestroyAccelerationStructureKHR(api_dump, device, accelerationStructure, pAllocator);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBuildAccelerationStructuresKHR", "commandBuffer, infoCount, pInfos, ppBuildRangeInfos", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBuildAccelerationStructuresKHR(api_dump, commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBuildAccelerationStructuresKHR(api_dump, commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdBuildAccelerationStructuresIndirectKHR", "commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdBuildAccelerationStructuresIndirectKHR(api_dump, commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
        }
    }
    device_dispatch_table(commandBuffer)->CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdBuildAccelerationStructuresIndirectKHR(api_dump, commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkBuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkBuildAccelerationStructuresKHR", "device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkBuildAccelerationStructuresKHR(api_dump, device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
        }
    }
    VkResult result = device_dispatch_table(device)->BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkBuildAccelerationStructuresKHR(api_dump, device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyAccelerationStructureKHR", "device, deferredOperation, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyAccelerationStructureKHR(api_dump, device, deferredOperation, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyAccelerationStructureKHR(device, deferredOperation, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyAccelerationStructureKHR(api_dump, device, deferredOperation, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyAccelerationStructureToMemoryKHR", "device, deferredOperation, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyAccelerationStructureToMemoryKHR(api_dump, device, deferredOperation, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyAccelerationStructureToMemoryKHR(api_dump, device, deferredOperation, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCopyMemoryToAccelerationStructureKHR", "device, deferredOperation, pInfo", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCopyMemoryToAccelerationStructureKHR(api_dump, device, deferredOperation, pInfo);
        }
    }
    VkResult result = device_dispatch_table(device)->CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCopyMemoryToAccelerationStructureKHR(api_dump, device, deferredOperation, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, size_t dataSize, void* pData, size_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkWriteAccelerationStructuresPropertiesKHR", "device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkWriteAccelerationStructuresPropertiesKHR(api_dump, device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
        }
    }
    VkResult result = device_dispatch_table(device)->WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkWriteAccelerationStructuresPropertiesKHR(api_dump, device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyAccelerationStructureKHR", "commandBuffer, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyAccelerationStructureKHR(api_dump, commandBuffer, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyAccelerationStructureKHR(commandBuffer, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyAccelerationStructureKHR(api_dump, commandBuffer, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyAccelerationStructureToMemoryKHR", "commandBuffer, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyAccelerationStructureToMemoryKHR(api_dump, commandBuffer, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyAccelerationStructureToMemoryKHR(api_dump, commandBuffer, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdCopyMemoryToAccelerationStructureKHR", "commandBuffer, pInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdCopyMemoryToAccelerationStructureKHR(api_dump, commandBuffer, pInfo);
        }
    }
    device_dispatch_table(commandBuffer)->CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdCopyMemoryToAccelerationStructureKHR(api_dump, commandBuffer, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkDeviceAddress VKAPI_CALL vkGetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetAccelerationStructureDeviceAddressKHR", "device, pInfo", "VkDeviceAddress");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetAccelerationStructureDeviceAddressKHR(api_dump, device, pInfo);
        }
    }
    VkDeviceAddress result = device_dispatch_table(device)->GetAccelerationStructureDeviceAddressKHR(device, pInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceAddress", result, dump_return_value_VkDeviceAddress);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetAccelerationStructureDeviceAddressKHR(api_dump, device, pInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdWriteAccelerationStructuresPropertiesKHR", "commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdWriteAccelerationStructuresPropertiesKHR(api_dump, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
        }
    }
    device_dispatch_table(commandBuffer)->CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdWriteAccelerationStructuresPropertiesKHR(api_dump, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetDeviceAccelerationStructureCompatibilityKHR", "device, pVersionInfo, pCompatibility", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetDeviceAccelerationStructureCompatibilityKHR(api_dump, device, pVersionInfo, pCompatibility);
        }
    }
    device_dispatch_table(device)->GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetDeviceAccelerationStructureCompatibilityKHR(api_dump, device, pVersionInfo, pCompatibility);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkGetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, const uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetAccelerationStructureBuildSizesKHR", "device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetAccelerationStructureBuildSizesKHR(api_dump, device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
        }
    }
    device_dispatch_table(device)->GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetAccelerationStructureBuildSizesKHR(api_dump, device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdTraceRaysKHR", "commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdTraceRaysKHR(api_dump, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
        }
    }
    device_dispatch_table(commandBuffer)->CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdTraceRaysKHR(api_dump, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCreateRayTracingPipelinesKHR", "device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCreateRayTracingPipelinesKHR(api_dump, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        }
    }
    VkResult result = device_dispatch_table(device)->CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkCreateRayTracingPipelinesKHR(api_dump, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", "device, pipeline, firstGroup, groupCount, dataSize, pData", "VkResult");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(api_dump, device, pipeline, firstGroup, groupCount, dataSize, pData);
        }
    }
    VkResult result = device_dispatch_table(device)->GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkResult", result, dump_return_value_VkResult);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(api_dump, device, pipeline, firstGroup, groupCount, dataSize, pData);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdTraceRaysIndirectKHR", "commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdTraceRaysIndirectKHR(api_dump, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
        }
    }
    device_dispatch_table(commandBuffer)->CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdTraceRaysIndirectKHR(api_dump, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR VkDeviceSize VKAPI_CALL vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkGetRayTracingShaderGroupStackSizeKHR", "device, pipeline, group, groupShader", "VkDeviceSize");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkGetRayTracingShaderGroupStackSizeKHR(api_dump, device, pipeline, group, groupShader);
        }
    }
    VkDeviceSize result = device_dispatch_table(device)->GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader);
    if (api_dump.shouldDumpOutput()) {
        dump_return_value(api_dump, "VkDeviceSize", result);
        dump_pre_function_formatting(api_dump);
        dump_params_vkGetRayTracingShaderGroupStackSizeKHR(api_dump, device, pipeline, group, groupShader);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
    return result;
}
VKAPI_ATTR void VKAPI_CALL vkCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdSetRayTracingPipelineStackSizeKHR", "commandBuffer, pipelineStackSize", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdSetRayTracingPipelineStackSizeKHR(api_dump, commandBuffer, pipelineStackSize);
        }
    }
    device_dispatch_table(commandBuffer)->CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdSetRayTracingPipelineStackSizeKHR(api_dump, commandBuffer, pipelineStackSize);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMeshTasksEXT", "commandBuffer, groupCountX, groupCountY, groupCountZ", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMeshTasksEXT(api_dump, commandBuffer, groupCountX, groupCountY, groupCountZ);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMeshTasksEXT(api_dump, commandBuffer, groupCountX, groupCountY, groupCountZ);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMeshTasksIndirectEXT", "commandBuffer, buffer, offset, drawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMeshTasksIndirectEXT(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMeshTasksIndirectEXT(api_dump, commandBuffer, buffer, offset, drawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto& api_dump = ApiDumpInstance::current();
    std::lock_guard<std::mutex> lg(api_dump.outputMutex());

    dump_function_head(api_dump, "vkCmdDrawMeshTasksIndirectCountEXT", "commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride", "void");
    if (api_dump.settings().format() == ApiDumpFormat::Text) {
        if (api_dump.settings().shouldPreDump() && api_dump.shouldDumpOutput()) {
            dump_before_pre_dump_formatting(api_dump);
            dump_params_vkCmdDrawMeshTasksIndirectCountEXT(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        }
    }
    device_dispatch_table(commandBuffer)->CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
    if (api_dump.shouldDumpOutput()) {
        dump_pre_function_formatting(api_dump);
        dump_params_vkCmdDrawMeshTasksIndirectCountEXT(api_dump, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        dump_post_function_formatting(api_dump);
        api_dump.settings().flush();
    }
}
VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL api_dump_known_instance_functions(VkInstance instance, const char* pName) {
    if (strcmp(pName, "vkCreateInstance") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateInstance);
    if (strcmp(pName, "vkDestroyInstance") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyInstance);
    if (strcmp(pName, "vkEnumeratePhysicalDevices") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumeratePhysicalDevices);
    if (strcmp(pName, "vkGetPhysicalDeviceFeatures") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFeatures);
    if (strcmp(pName, "vkGetPhysicalDeviceFormatProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFormatProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceImageFormatProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceImageFormatProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceQueueFamilyProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceQueueFamilyProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceMemoryProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceMemoryProperties);
    if (strcmp(pName, "vkGetInstanceProcAddr") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetInstanceProcAddr);
    if (strcmp(pName, "vkCreateDevice") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDevice);
    if (strcmp(pName, "vkEnumerateInstanceExtensionProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumerateInstanceExtensionProperties);
    if (strcmp(pName, "vkEnumerateInstanceLayerProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumerateInstanceLayerProperties);
    if (strcmp(pName, "vkEnumerateDeviceLayerProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumerateDeviceLayerProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceSparseImageFormatProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSparseImageFormatProperties);
    if (strcmp(pName, "vkEnumeratePhysicalDeviceGroups") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumeratePhysicalDeviceGroups);
    if (strcmp(pName, "vkGetPhysicalDeviceFeatures2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFeatures2);
    if (strcmp(pName, "vkGetPhysicalDeviceProperties2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceProperties2);
    if (strcmp(pName, "vkGetPhysicalDeviceFormatProperties2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFormatProperties2);
    if (strcmp(pName, "vkGetPhysicalDeviceImageFormatProperties2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceImageFormatProperties2);
    if (strcmp(pName, "vkGetPhysicalDeviceQueueFamilyProperties2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceQueueFamilyProperties2);
    if (strcmp(pName, "vkGetPhysicalDeviceMemoryProperties2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceMemoryProperties2);
    if (strcmp(pName, "vkGetPhysicalDeviceSparseImageFormatProperties2") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSparseImageFormatProperties2);
    if (strcmp(pName, "vkGetPhysicalDeviceExternalBufferProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalBufferProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceExternalFenceProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalFenceProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceExternalSemaphoreProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalSemaphoreProperties);
    if (strcmp(pName, "vkGetPhysicalDeviceToolProperties") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceToolProperties);
    if (strcmp(pName, "vkDestroySurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroySurfaceKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSurfaceSupportKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfaceSupportKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSurfaceFormatsKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfaceFormatsKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSurfacePresentModesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfacePresentModesKHR);
    if (strcmp(pName, "vkGetPhysicalDevicePresentRectanglesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDevicePresentRectanglesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceDisplayPropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceDisplayPropertiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceDisplayPlanePropertiesKHR);
    if (strcmp(pName, "vkGetDisplayPlaneSupportedDisplaysKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDisplayPlaneSupportedDisplaysKHR);
    if (strcmp(pName, "vkGetDisplayModePropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDisplayModePropertiesKHR);
    if (strcmp(pName, "vkCreateDisplayModeKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDisplayModeKHR);
    if (strcmp(pName, "vkGetDisplayPlaneCapabilitiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDisplayPlaneCapabilitiesKHR);
    if (strcmp(pName, "vkCreateDisplayPlaneSurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDisplayPlaneSurfaceKHR);
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    if (strcmp(pName, "vkCreateXlibSurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateXlibSurfaceKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceXlibPresentationSupportKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceXlibPresentationSupportKHR);
#endif  // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
    if (strcmp(pName, "vkCreateXcbSurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateXcbSurfaceKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceXcbPresentationSupportKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceXcbPresentationSupportKHR);
#endif  // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    if (strcmp(pName, "vkCreateWaylandSurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateWaylandSurfaceKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceWaylandPresentationSupportKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
#endif  // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if (strcmp(pName, "vkCreateAndroidSurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateAndroidSurfaceKHR);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkCreateWin32SurfaceKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateWin32SurfaceKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceWin32PresentationSupportKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceWin32PresentationSupportKHR);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkGetPhysicalDeviceVideoCapabilitiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceVideoCapabilitiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceVideoFormatPropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceVideoFormatPropertiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceFeatures2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFeatures2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceProperties2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceFormatProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFormatProperties2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceImageFormatProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceImageFormatProperties2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceQueueFamilyProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceQueueFamilyProperties2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceMemoryProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceMemoryProperties2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSparseImageFormatProperties2KHR);
    if (strcmp(pName, "vkEnumeratePhysicalDeviceGroupsKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumeratePhysicalDeviceGroupsKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceExternalBufferPropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalBufferPropertiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalSemaphorePropertiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceExternalFencePropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalFencePropertiesKHR);
    if (strcmp(pName, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSurfaceCapabilities2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceSurfaceFormats2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfaceFormats2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceDisplayProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceDisplayProperties2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceDisplayPlaneProperties2KHR);
    if (strcmp(pName, "vkGetDisplayModeProperties2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDisplayModeProperties2KHR);
    if (strcmp(pName, "vkGetDisplayPlaneCapabilities2KHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDisplayPlaneCapabilities2KHR);
    if (strcmp(pName, "vkGetPhysicalDeviceFragmentShadingRatesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceFragmentShadingRatesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR);
    if (strcmp(pName, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceCalibrateableTimeDomainsKHR);
    if (strcmp(pName, "vkCreateDebugReportCallbackEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDebugReportCallbackEXT);
    if (strcmp(pName, "vkDestroyDebugReportCallbackEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDebugReportCallbackEXT);
    if (strcmp(pName, "vkDebugReportMessageEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkDebugReportMessageEXT);
#if defined(VK_USE_PLATFORM_GGP)
    if (strcmp(pName, "vkCreateStreamDescriptorSurfaceGGP") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateStreamDescriptorSurfaceGGP);
#endif  // VK_USE_PLATFORM_GGP
    if (strcmp(pName, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalImageFormatPropertiesNV);
#if defined(VK_USE_PLATFORM_VI_NN)
    if (strcmp(pName, "vkCreateViSurfaceNN") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateViSurfaceNN);
#endif  // VK_USE_PLATFORM_VI_NN
    if (strcmp(pName, "vkReleaseDisplayEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleaseDisplayEXT);
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    if (strcmp(pName, "vkAcquireXlibDisplayEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireXlibDisplayEXT);
    if (strcmp(pName, "vkGetRandROutputDisplayEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRandROutputDisplayEXT);
#endif  // VK_USE_PLATFORM_XLIB_XRANDR_EXT
    if (strcmp(pName, "vkGetPhysicalDeviceSurfaceCapabilities2EXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfaceCapabilities2EXT);
#if defined(VK_USE_PLATFORM_IOS_MVK)
    if (strcmp(pName, "vkCreateIOSSurfaceMVK") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateIOSSurfaceMVK);
#endif  // VK_USE_PLATFORM_IOS_MVK
#if defined(VK_USE_PLATFORM_MACOS_MVK)
    if (strcmp(pName, "vkCreateMacOSSurfaceMVK") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateMacOSSurfaceMVK);
#endif  // VK_USE_PLATFORM_MACOS_MVK
    if (strcmp(pName, "vkSetDebugUtilsObjectNameEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetDebugUtilsObjectNameEXT);
    if (strcmp(pName, "vkSetDebugUtilsObjectTagEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetDebugUtilsObjectTagEXT);
    if (strcmp(pName, "vkQueueBeginDebugUtilsLabelEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueBeginDebugUtilsLabelEXT);
    if (strcmp(pName, "vkQueueEndDebugUtilsLabelEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueEndDebugUtilsLabelEXT);
    if (strcmp(pName, "vkQueueInsertDebugUtilsLabelEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueInsertDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCmdBeginDebugUtilsLabelEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCmdEndDebugUtilsLabelEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCmdInsertDebugUtilsLabelEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdInsertDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCreateDebugUtilsMessengerEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDebugUtilsMessengerEXT);
    if (strcmp(pName, "vkDestroyDebugUtilsMessengerEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDebugUtilsMessengerEXT);
    if (strcmp(pName, "vkSubmitDebugUtilsMessageEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkSubmitDebugUtilsMessageEXT);
    if (strcmp(pName, "vkGetPhysicalDeviceDescriptorSizeEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceDescriptorSizeEXT);
    if (strcmp(pName, "vkGetPhysicalDeviceMultisamplePropertiesEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceMultisamplePropertiesEXT);
    if (strcmp(pName, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT);
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if (strcmp(pName, "vkCreateImagePipeSurfaceFUCHSIA") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateImagePipeSurfaceFUCHSIA);
#endif  // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_METAL_EXT)
    if (strcmp(pName, "vkCreateMetalSurfaceEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateMetalSurfaceEXT);
#endif  // VK_USE_PLATFORM_METAL_EXT
    if (strcmp(pName, "vkGetPhysicalDeviceToolPropertiesEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceToolPropertiesEXT);
    if (strcmp(pName, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV);
    if (strcmp(pName, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkGetPhysicalDeviceSurfacePresentModes2EXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceSurfacePresentModes2EXT);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkCreateHeadlessSurfaceEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateHeadlessSurfaceEXT);
    if (strcmp(pName, "vkAcquireDrmDisplayEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireDrmDisplayEXT);
    if (strcmp(pName, "vkGetDrmDisplayEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDrmDisplayEXT);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkAcquireWinrtDisplayNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireWinrtDisplayNV);
    if (strcmp(pName, "vkGetWinrtDisplayNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetWinrtDisplayNV);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    if (strcmp(pName, "vkCreateDirectFBSurfaceEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDirectFBSurfaceEXT);
    if (strcmp(pName, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceDirectFBPresentationSupportEXT);
#endif  // VK_USE_PLATFORM_DIRECTFB_EXT
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    if (strcmp(pName, "vkCreateScreenSurfaceQNX") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateScreenSurfaceQNX);
    if (strcmp(pName, "vkGetPhysicalDeviceScreenPresentationSupportQNX") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceScreenPresentationSupportQNX);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
    if (strcmp(pName, "vkGetPhysicalDeviceExternalTensorPropertiesARM") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceExternalTensorPropertiesARM);
    if (strcmp(pName, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceOpticalFlowImageFormatsNV);
    if (strcmp(pName, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceCooperativeVectorPropertiesNV);
    if (strcmp(pName, "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM);
    if (strcmp(pName, "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM);
#if defined(VK_USE_PLATFORM_OHOS)
    if (strcmp(pName, "vkCreateSurfaceOHOS") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSurfaceOHOS);
#endif  // VK_USE_PLATFORM_OHOS
    if (strcmp(pName, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV);
    if (strcmp(pName, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM") == 0)
        return reinterpret_cast<PFN_vkVoidFunction>(vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM);

    return nullptr;
}
VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL api_dump_known_device_functions(VkDevice device, const char* pName) {
    if (strcmp(pName, "vkGetDeviceProcAddr") == 0 && (!device || device_dispatch_table(device)->GetDeviceProcAddr))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceProcAddr);
    if (strcmp(pName, "vkDestroyDevice") == 0 && (!device || device_dispatch_table(device)->DestroyDevice))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDevice);
    if (strcmp(pName, "vkGetDeviceQueue") == 0 && (!device || device_dispatch_table(device)->GetDeviceQueue))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceQueue);
    if (strcmp(pName, "vkQueueSubmit") == 0 && (!device || device_dispatch_table(device)->QueueSubmit))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueSubmit);
    if (strcmp(pName, "vkQueueWaitIdle") == 0 && (!device || device_dispatch_table(device)->QueueWaitIdle))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueWaitIdle);
    if (strcmp(pName, "vkDeviceWaitIdle") == 0 && (!device || device_dispatch_table(device)->DeviceWaitIdle))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDeviceWaitIdle);
    if (strcmp(pName, "vkAllocateMemory") == 0 && (!device || device_dispatch_table(device)->AllocateMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAllocateMemory);
    if (strcmp(pName, "vkFreeMemory") == 0 && (!device || device_dispatch_table(device)->FreeMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkFreeMemory);
    if (strcmp(pName, "vkMapMemory") == 0 && (!device || device_dispatch_table(device)->MapMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkMapMemory);
    if (strcmp(pName, "vkUnmapMemory") == 0 && (!device || device_dispatch_table(device)->UnmapMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUnmapMemory);
    if (strcmp(pName, "vkFlushMappedMemoryRanges") == 0 && (!device || device_dispatch_table(device)->FlushMappedMemoryRanges))
        return reinterpret_cast<PFN_vkVoidFunction>(vkFlushMappedMemoryRanges);
    if (strcmp(pName, "vkInvalidateMappedMemoryRanges") == 0 && (!device || device_dispatch_table(device)->InvalidateMappedMemoryRanges))
        return reinterpret_cast<PFN_vkVoidFunction>(vkInvalidateMappedMemoryRanges);
    if (strcmp(pName, "vkGetDeviceMemoryCommitment") == 0 && (!device || device_dispatch_table(device)->GetDeviceMemoryCommitment))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceMemoryCommitment);
    if (strcmp(pName, "vkBindBufferMemory") == 0 && (!device || device_dispatch_table(device)->BindBufferMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindBufferMemory);
    if (strcmp(pName, "vkBindImageMemory") == 0 && (!device || device_dispatch_table(device)->BindImageMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindImageMemory);
    if (strcmp(pName, "vkGetBufferMemoryRequirements") == 0 && (!device || device_dispatch_table(device)->GetBufferMemoryRequirements))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferMemoryRequirements);
    if (strcmp(pName, "vkGetImageMemoryRequirements") == 0 && (!device || device_dispatch_table(device)->GetImageMemoryRequirements))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageMemoryRequirements);
    if (strcmp(pName, "vkGetImageSparseMemoryRequirements") == 0 && (!device || device_dispatch_table(device)->GetImageSparseMemoryRequirements))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSparseMemoryRequirements);
    if (strcmp(pName, "vkQueueBindSparse") == 0 && (!device || device_dispatch_table(device)->QueueBindSparse))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueBindSparse);
    if (strcmp(pName, "vkCreateFence") == 0 && (!device || device_dispatch_table(device)->CreateFence))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateFence);
    if (strcmp(pName, "vkDestroyFence") == 0 && (!device || device_dispatch_table(device)->DestroyFence))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyFence);
    if (strcmp(pName, "vkResetFences") == 0 && (!device || device_dispatch_table(device)->ResetFences))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetFences);
    if (strcmp(pName, "vkGetFenceStatus") == 0 && (!device || device_dispatch_table(device)->GetFenceStatus))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetFenceStatus);
    if (strcmp(pName, "vkWaitForFences") == 0 && (!device || device_dispatch_table(device)->WaitForFences))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWaitForFences);
    if (strcmp(pName, "vkCreateSemaphore") == 0 && (!device || device_dispatch_table(device)->CreateSemaphore))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSemaphore);
    if (strcmp(pName, "vkDestroySemaphore") == 0 && (!device || device_dispatch_table(device)->DestroySemaphore))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroySemaphore);
    if (strcmp(pName, "vkCreateQueryPool") == 0 && (!device || device_dispatch_table(device)->CreateQueryPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateQueryPool);
    if (strcmp(pName, "vkDestroyQueryPool") == 0 && (!device || device_dispatch_table(device)->DestroyQueryPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyQueryPool);
    if (strcmp(pName, "vkGetQueryPoolResults") == 0 && (!device || device_dispatch_table(device)->GetQueryPoolResults))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetQueryPoolResults);
    if (strcmp(pName, "vkCreateBuffer") == 0 && (!device || device_dispatch_table(device)->CreateBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateBuffer);
    if (strcmp(pName, "vkDestroyBuffer") == 0 && (!device || device_dispatch_table(device)->DestroyBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyBuffer);
    if (strcmp(pName, "vkCreateImage") == 0 && (!device || device_dispatch_table(device)->CreateImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateImage);
    if (strcmp(pName, "vkDestroyImage") == 0 && (!device || device_dispatch_table(device)->DestroyImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyImage);
    if (strcmp(pName, "vkGetImageSubresourceLayout") == 0 && (!device || device_dispatch_table(device)->GetImageSubresourceLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSubresourceLayout);
    if (strcmp(pName, "vkCreateImageView") == 0 && (!device || device_dispatch_table(device)->CreateImageView))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateImageView);
    if (strcmp(pName, "vkDestroyImageView") == 0 && (!device || device_dispatch_table(device)->DestroyImageView))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyImageView);
    if (strcmp(pName, "vkCreateCommandPool") == 0 && (!device || device_dispatch_table(device)->CreateCommandPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateCommandPool);
    if (strcmp(pName, "vkDestroyCommandPool") == 0 && (!device || device_dispatch_table(device)->DestroyCommandPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyCommandPool);
    if (strcmp(pName, "vkResetCommandPool") == 0 && (!device || device_dispatch_table(device)->ResetCommandPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetCommandPool);
    if (strcmp(pName, "vkAllocateCommandBuffers") == 0 && (!device || device_dispatch_table(device)->AllocateCommandBuffers))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAllocateCommandBuffers);
    if (strcmp(pName, "vkFreeCommandBuffers") == 0 && (!device || device_dispatch_table(device)->FreeCommandBuffers))
        return reinterpret_cast<PFN_vkVoidFunction>(vkFreeCommandBuffers);
    if (strcmp(pName, "vkBeginCommandBuffer") == 0 && (!device || device_dispatch_table(device)->BeginCommandBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBeginCommandBuffer);
    if (strcmp(pName, "vkEndCommandBuffer") == 0 && (!device || device_dispatch_table(device)->EndCommandBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkEndCommandBuffer);
    if (strcmp(pName, "vkResetCommandBuffer") == 0 && (!device || device_dispatch_table(device)->ResetCommandBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetCommandBuffer);
    if (strcmp(pName, "vkCmdCopyBuffer") == 0 && (!device || device_dispatch_table(device)->CmdCopyBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyBuffer);
    if (strcmp(pName, "vkCmdCopyImage") == 0 && (!device || device_dispatch_table(device)->CmdCopyImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyImage);
    if (strcmp(pName, "vkCmdCopyBufferToImage") == 0 && (!device || device_dispatch_table(device)->CmdCopyBufferToImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyBufferToImage);
    if (strcmp(pName, "vkCmdCopyImageToBuffer") == 0 && (!device || device_dispatch_table(device)->CmdCopyImageToBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyImageToBuffer);
    if (strcmp(pName, "vkCmdUpdateBuffer") == 0 && (!device || device_dispatch_table(device)->CmdUpdateBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdUpdateBuffer);
    if (strcmp(pName, "vkCmdFillBuffer") == 0 && (!device || device_dispatch_table(device)->CmdFillBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdFillBuffer);
    if (strcmp(pName, "vkCmdPipelineBarrier") == 0 && (!device || device_dispatch_table(device)->CmdPipelineBarrier))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPipelineBarrier);
    if (strcmp(pName, "vkCmdBeginQuery") == 0 && (!device || device_dispatch_table(device)->CmdBeginQuery))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginQuery);
    if (strcmp(pName, "vkCmdEndQuery") == 0 && (!device || device_dispatch_table(device)->CmdEndQuery))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndQuery);
    if (strcmp(pName, "vkCmdResetQueryPool") == 0 && (!device || device_dispatch_table(device)->CmdResetQueryPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResetQueryPool);
    if (strcmp(pName, "vkCmdWriteTimestamp") == 0 && (!device || device_dispatch_table(device)->CmdWriteTimestamp))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteTimestamp);
    if (strcmp(pName, "vkCmdCopyQueryPoolResults") == 0 && (!device || device_dispatch_table(device)->CmdCopyQueryPoolResults))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyQueryPoolResults);
    if (strcmp(pName, "vkCmdExecuteCommands") == 0 && (!device || device_dispatch_table(device)->CmdExecuteCommands))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdExecuteCommands);
    if (strcmp(pName, "vkCreateEvent") == 0 && (!device || device_dispatch_table(device)->CreateEvent))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateEvent);
    if (strcmp(pName, "vkDestroyEvent") == 0 && (!device || device_dispatch_table(device)->DestroyEvent))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyEvent);
    if (strcmp(pName, "vkGetEventStatus") == 0 && (!device || device_dispatch_table(device)->GetEventStatus))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetEventStatus);
    if (strcmp(pName, "vkSetEvent") == 0 && (!device || device_dispatch_table(device)->SetEvent))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetEvent);
    if (strcmp(pName, "vkResetEvent") == 0 && (!device || device_dispatch_table(device)->ResetEvent))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetEvent);
    if (strcmp(pName, "vkCreateBufferView") == 0 && (!device || device_dispatch_table(device)->CreateBufferView))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateBufferView);
    if (strcmp(pName, "vkDestroyBufferView") == 0 && (!device || device_dispatch_table(device)->DestroyBufferView))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyBufferView);
    if (strcmp(pName, "vkCreateShaderModule") == 0 && (!device || device_dispatch_table(device)->CreateShaderModule))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateShaderModule);
    if (strcmp(pName, "vkDestroyShaderModule") == 0 && (!device || device_dispatch_table(device)->DestroyShaderModule))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyShaderModule);
    if (strcmp(pName, "vkCreatePipelineCache") == 0 && (!device || device_dispatch_table(device)->CreatePipelineCache))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreatePipelineCache);
    if (strcmp(pName, "vkDestroyPipelineCache") == 0 && (!device || device_dispatch_table(device)->DestroyPipelineCache))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyPipelineCache);
    if (strcmp(pName, "vkGetPipelineCacheData") == 0 && (!device || device_dispatch_table(device)->GetPipelineCacheData))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineCacheData);
    if (strcmp(pName, "vkMergePipelineCaches") == 0 && (!device || device_dispatch_table(device)->MergePipelineCaches))
        return reinterpret_cast<PFN_vkVoidFunction>(vkMergePipelineCaches);
    if (strcmp(pName, "vkCreateComputePipelines") == 0 && (!device || device_dispatch_table(device)->CreateComputePipelines))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateComputePipelines);
    if (strcmp(pName, "vkDestroyPipeline") == 0 && (!device || device_dispatch_table(device)->DestroyPipeline))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyPipeline);
    if (strcmp(pName, "vkCreatePipelineLayout") == 0 && (!device || device_dispatch_table(device)->CreatePipelineLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreatePipelineLayout);
    if (strcmp(pName, "vkDestroyPipelineLayout") == 0 && (!device || device_dispatch_table(device)->DestroyPipelineLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyPipelineLayout);
    if (strcmp(pName, "vkCreateSampler") == 0 && (!device || device_dispatch_table(device)->CreateSampler))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSampler);
    if (strcmp(pName, "vkDestroySampler") == 0 && (!device || device_dispatch_table(device)->DestroySampler))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroySampler);
    if (strcmp(pName, "vkCreateDescriptorSetLayout") == 0 && (!device || device_dispatch_table(device)->CreateDescriptorSetLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDescriptorSetLayout);
    if (strcmp(pName, "vkDestroyDescriptorSetLayout") == 0 && (!device || device_dispatch_table(device)->DestroyDescriptorSetLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDescriptorSetLayout);
    if (strcmp(pName, "vkCreateDescriptorPool") == 0 && (!device || device_dispatch_table(device)->CreateDescriptorPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDescriptorPool);
    if (strcmp(pName, "vkDestroyDescriptorPool") == 0 && (!device || device_dispatch_table(device)->DestroyDescriptorPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDescriptorPool);
    if (strcmp(pName, "vkResetDescriptorPool") == 0 && (!device || device_dispatch_table(device)->ResetDescriptorPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetDescriptorPool);
    if (strcmp(pName, "vkAllocateDescriptorSets") == 0 && (!device || device_dispatch_table(device)->AllocateDescriptorSets))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAllocateDescriptorSets);
    if (strcmp(pName, "vkFreeDescriptorSets") == 0 && (!device || device_dispatch_table(device)->FreeDescriptorSets))
        return reinterpret_cast<PFN_vkVoidFunction>(vkFreeDescriptorSets);
    if (strcmp(pName, "vkUpdateDescriptorSets") == 0 && (!device || device_dispatch_table(device)->UpdateDescriptorSets))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUpdateDescriptorSets);
    if (strcmp(pName, "vkCmdBindPipeline") == 0 && (!device || device_dispatch_table(device)->CmdBindPipeline))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindPipeline);
    if (strcmp(pName, "vkCmdBindDescriptorSets") == 0 && (!device || device_dispatch_table(device)->CmdBindDescriptorSets))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindDescriptorSets);
    if (strcmp(pName, "vkCmdClearColorImage") == 0 && (!device || device_dispatch_table(device)->CmdClearColorImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdClearColorImage);
    if (strcmp(pName, "vkCmdDispatch") == 0 && (!device || device_dispatch_table(device)->CmdDispatch))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatch);
    if (strcmp(pName, "vkCmdDispatchIndirect") == 0 && (!device || device_dispatch_table(device)->CmdDispatchIndirect))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchIndirect);
    if (strcmp(pName, "vkCmdSetEvent") == 0 && (!device || device_dispatch_table(device)->CmdSetEvent))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetEvent);
    if (strcmp(pName, "vkCmdResetEvent") == 0 && (!device || device_dispatch_table(device)->CmdResetEvent))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResetEvent);
    if (strcmp(pName, "vkCmdWaitEvents") == 0 && (!device || device_dispatch_table(device)->CmdWaitEvents))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWaitEvents);
    if (strcmp(pName, "vkCmdPushConstants") == 0 && (!device || device_dispatch_table(device)->CmdPushConstants))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushConstants);
    if (strcmp(pName, "vkCreateGraphicsPipelines") == 0 && (!device || device_dispatch_table(device)->CreateGraphicsPipelines))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateGraphicsPipelines);
    if (strcmp(pName, "vkCreateFramebuffer") == 0 && (!device || device_dispatch_table(device)->CreateFramebuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateFramebuffer);
    if (strcmp(pName, "vkDestroyFramebuffer") == 0 && (!device || device_dispatch_table(device)->DestroyFramebuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyFramebuffer);
    if (strcmp(pName, "vkCreateRenderPass") == 0 && (!device || device_dispatch_table(device)->CreateRenderPass))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateRenderPass);
    if (strcmp(pName, "vkDestroyRenderPass") == 0 && (!device || device_dispatch_table(device)->DestroyRenderPass))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyRenderPass);
    if (strcmp(pName, "vkGetRenderAreaGranularity") == 0 && (!device || device_dispatch_table(device)->GetRenderAreaGranularity))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRenderAreaGranularity);
    if (strcmp(pName, "vkCmdSetViewport") == 0 && (!device || device_dispatch_table(device)->CmdSetViewport))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewport);
    if (strcmp(pName, "vkCmdSetScissor") == 0 && (!device || device_dispatch_table(device)->CmdSetScissor))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetScissor);
    if (strcmp(pName, "vkCmdSetLineWidth") == 0 && (!device || device_dispatch_table(device)->CmdSetLineWidth))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLineWidth);
    if (strcmp(pName, "vkCmdSetDepthBias") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBias))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBias);
    if (strcmp(pName, "vkCmdSetBlendConstants") == 0 && (!device || device_dispatch_table(device)->CmdSetBlendConstants))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetBlendConstants);
    if (strcmp(pName, "vkCmdSetDepthBounds") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBounds))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBounds);
    if (strcmp(pName, "vkCmdSetStencilCompareMask") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilCompareMask))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilCompareMask);
    if (strcmp(pName, "vkCmdSetStencilWriteMask") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilWriteMask))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilWriteMask);
    if (strcmp(pName, "vkCmdSetStencilReference") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilReference))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilReference);
    if (strcmp(pName, "vkCmdBindIndexBuffer") == 0 && (!device || device_dispatch_table(device)->CmdBindIndexBuffer))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindIndexBuffer);
    if (strcmp(pName, "vkCmdBindVertexBuffers") == 0 && (!device || device_dispatch_table(device)->CmdBindVertexBuffers))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindVertexBuffers);
    if (strcmp(pName, "vkCmdDraw") == 0 && (!device || device_dispatch_table(device)->CmdDraw))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDraw);
    if (strcmp(pName, "vkCmdDrawIndexed") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndexed))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndexed);
    if (strcmp(pName, "vkCmdDrawIndirect") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndirect))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndirect);
    if (strcmp(pName, "vkCmdDrawIndexedIndirect") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndexedIndirect))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndexedIndirect);
    if (strcmp(pName, "vkCmdBlitImage") == 0 && (!device || device_dispatch_table(device)->CmdBlitImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBlitImage);
    if (strcmp(pName, "vkCmdClearDepthStencilImage") == 0 && (!device || device_dispatch_table(device)->CmdClearDepthStencilImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdClearDepthStencilImage);
    if (strcmp(pName, "vkCmdClearAttachments") == 0 && (!device || device_dispatch_table(device)->CmdClearAttachments))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdClearAttachments);
    if (strcmp(pName, "vkCmdResolveImage") == 0 && (!device || device_dispatch_table(device)->CmdResolveImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResolveImage);
    if (strcmp(pName, "vkCmdBeginRenderPass") == 0 && (!device || device_dispatch_table(device)->CmdBeginRenderPass))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginRenderPass);
    if (strcmp(pName, "vkCmdNextSubpass") == 0 && (!device || device_dispatch_table(device)->CmdNextSubpass))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdNextSubpass);
    if (strcmp(pName, "vkCmdEndRenderPass") == 0 && (!device || device_dispatch_table(device)->CmdEndRenderPass))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRenderPass);
    if (strcmp(pName, "vkBindBufferMemory2") == 0 && (!device || device_dispatch_table(device)->BindBufferMemory2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindBufferMemory2);
    if (strcmp(pName, "vkBindImageMemory2") == 0 && (!device || device_dispatch_table(device)->BindImageMemory2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindImageMemory2);
    if (strcmp(pName, "vkGetDeviceGroupPeerMemoryFeatures") == 0 && (!device || device_dispatch_table(device)->GetDeviceGroupPeerMemoryFeatures))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceGroupPeerMemoryFeatures);
    if (strcmp(pName, "vkCmdSetDeviceMask") == 0 && (!device || device_dispatch_table(device)->CmdSetDeviceMask))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDeviceMask);
    if (strcmp(pName, "vkGetImageMemoryRequirements2") == 0 && (!device || device_dispatch_table(device)->GetImageMemoryRequirements2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageMemoryRequirements2);
    if (strcmp(pName, "vkGetBufferMemoryRequirements2") == 0 && (!device || device_dispatch_table(device)->GetBufferMemoryRequirements2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferMemoryRequirements2);
    if (strcmp(pName, "vkGetImageSparseMemoryRequirements2") == 0 && (!device || device_dispatch_table(device)->GetImageSparseMemoryRequirements2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSparseMemoryRequirements2);
    if (strcmp(pName, "vkTrimCommandPool") == 0 && (!device || device_dispatch_table(device)->TrimCommandPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkTrimCommandPool);
    if (strcmp(pName, "vkGetDeviceQueue2") == 0 && (!device || device_dispatch_table(device)->GetDeviceQueue2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceQueue2);
    if (strcmp(pName, "vkCmdDispatchBase") == 0 && (!device || device_dispatch_table(device)->CmdDispatchBase))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchBase);
    if (strcmp(pName, "vkCreateDescriptorUpdateTemplate") == 0 && (!device || device_dispatch_table(device)->CreateDescriptorUpdateTemplate))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDescriptorUpdateTemplate);
    if (strcmp(pName, "vkDestroyDescriptorUpdateTemplate") == 0 && (!device || device_dispatch_table(device)->DestroyDescriptorUpdateTemplate))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDescriptorUpdateTemplate);
    if (strcmp(pName, "vkUpdateDescriptorSetWithTemplate") == 0 && (!device || device_dispatch_table(device)->UpdateDescriptorSetWithTemplate))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUpdateDescriptorSetWithTemplate);
    if (strcmp(pName, "vkGetDescriptorSetLayoutSupport") == 0 && (!device || device_dispatch_table(device)->GetDescriptorSetLayoutSupport))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorSetLayoutSupport);
    if (strcmp(pName, "vkCreateSamplerYcbcrConversion") == 0 && (!device || device_dispatch_table(device)->CreateSamplerYcbcrConversion))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSamplerYcbcrConversion);
    if (strcmp(pName, "vkDestroySamplerYcbcrConversion") == 0 && (!device || device_dispatch_table(device)->DestroySamplerYcbcrConversion))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroySamplerYcbcrConversion);
    if (strcmp(pName, "vkResetQueryPool") == 0 && (!device || device_dispatch_table(device)->ResetQueryPool))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetQueryPool);
    if (strcmp(pName, "vkGetSemaphoreCounterValue") == 0 && (!device || device_dispatch_table(device)->GetSemaphoreCounterValue))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSemaphoreCounterValue);
    if (strcmp(pName, "vkWaitSemaphores") == 0 && (!device || device_dispatch_table(device)->WaitSemaphores))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWaitSemaphores);
    if (strcmp(pName, "vkSignalSemaphore") == 0 && (!device || device_dispatch_table(device)->SignalSemaphore))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSignalSemaphore);
    if (strcmp(pName, "vkGetBufferDeviceAddress") == 0 && (!device || device_dispatch_table(device)->GetBufferDeviceAddress))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferDeviceAddress);
    if (strcmp(pName, "vkGetBufferOpaqueCaptureAddress") == 0 && (!device || device_dispatch_table(device)->GetBufferOpaqueCaptureAddress))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferOpaqueCaptureAddress);
    if (strcmp(pName, "vkGetDeviceMemoryOpaqueCaptureAddress") == 0 && (!device || device_dispatch_table(device)->GetDeviceMemoryOpaqueCaptureAddress))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceMemoryOpaqueCaptureAddress);
    if (strcmp(pName, "vkCmdDrawIndirectCount") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndirectCount))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndirectCount);
    if (strcmp(pName, "vkCmdDrawIndexedIndirectCount") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndexedIndirectCount))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndexedIndirectCount);
    if (strcmp(pName, "vkCreateRenderPass2") == 0 && (!device || device_dispatch_table(device)->CreateRenderPass2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateRenderPass2);
    if (strcmp(pName, "vkCmdBeginRenderPass2") == 0 && (!device || device_dispatch_table(device)->CmdBeginRenderPass2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginRenderPass2);
    if (strcmp(pName, "vkCmdNextSubpass2") == 0 && (!device || device_dispatch_table(device)->CmdNextSubpass2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdNextSubpass2);
    if (strcmp(pName, "vkCmdEndRenderPass2") == 0 && (!device || device_dispatch_table(device)->CmdEndRenderPass2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRenderPass2);
    if (strcmp(pName, "vkCreatePrivateDataSlot") == 0 && (!device || device_dispatch_table(device)->CreatePrivateDataSlot))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreatePrivateDataSlot);
    if (strcmp(pName, "vkDestroyPrivateDataSlot") == 0 && (!device || device_dispatch_table(device)->DestroyPrivateDataSlot))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyPrivateDataSlot);
    if (strcmp(pName, "vkSetPrivateData") == 0 && (!device || device_dispatch_table(device)->SetPrivateData))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetPrivateData);
    if (strcmp(pName, "vkGetPrivateData") == 0 && (!device || device_dispatch_table(device)->GetPrivateData))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPrivateData);
    if (strcmp(pName, "vkCmdPipelineBarrier2") == 0 && (!device || device_dispatch_table(device)->CmdPipelineBarrier2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPipelineBarrier2);
    if (strcmp(pName, "vkCmdWriteTimestamp2") == 0 && (!device || device_dispatch_table(device)->CmdWriteTimestamp2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteTimestamp2);
    if (strcmp(pName, "vkQueueSubmit2") == 0 && (!device || device_dispatch_table(device)->QueueSubmit2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueSubmit2);
    if (strcmp(pName, "vkCmdCopyBuffer2") == 0 && (!device || device_dispatch_table(device)->CmdCopyBuffer2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyBuffer2);
    if (strcmp(pName, "vkCmdCopyImage2") == 0 && (!device || device_dispatch_table(device)->CmdCopyImage2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyImage2);
    if (strcmp(pName, "vkCmdCopyBufferToImage2") == 0 && (!device || device_dispatch_table(device)->CmdCopyBufferToImage2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyBufferToImage2);
    if (strcmp(pName, "vkCmdCopyImageToBuffer2") == 0 && (!device || device_dispatch_table(device)->CmdCopyImageToBuffer2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyImageToBuffer2);
    if (strcmp(pName, "vkGetDeviceBufferMemoryRequirements") == 0 && (!device || device_dispatch_table(device)->GetDeviceBufferMemoryRequirements))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceBufferMemoryRequirements);
    if (strcmp(pName, "vkGetDeviceImageMemoryRequirements") == 0 && (!device || device_dispatch_table(device)->GetDeviceImageMemoryRequirements))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceImageMemoryRequirements);
    if (strcmp(pName, "vkGetDeviceImageSparseMemoryRequirements") == 0 && (!device || device_dispatch_table(device)->GetDeviceImageSparseMemoryRequirements))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceImageSparseMemoryRequirements);
    if (strcmp(pName, "vkCmdSetEvent2") == 0 && (!device || device_dispatch_table(device)->CmdSetEvent2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetEvent2);
    if (strcmp(pName, "vkCmdResetEvent2") == 0 && (!device || device_dispatch_table(device)->CmdResetEvent2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResetEvent2);
    if (strcmp(pName, "vkCmdWaitEvents2") == 0 && (!device || device_dispatch_table(device)->CmdWaitEvents2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWaitEvents2);
    if (strcmp(pName, "vkCmdBlitImage2") == 0 && (!device || device_dispatch_table(device)->CmdBlitImage2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBlitImage2);
    if (strcmp(pName, "vkCmdResolveImage2") == 0 && (!device || device_dispatch_table(device)->CmdResolveImage2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResolveImage2);
    if (strcmp(pName, "vkCmdBeginRendering") == 0 && (!device || device_dispatch_table(device)->CmdBeginRendering))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginRendering);
    if (strcmp(pName, "vkCmdEndRendering") == 0 && (!device || device_dispatch_table(device)->CmdEndRendering))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRendering);
    if (strcmp(pName, "vkCmdSetCullMode") == 0 && (!device || device_dispatch_table(device)->CmdSetCullMode))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCullMode);
    if (strcmp(pName, "vkCmdSetFrontFace") == 0 && (!device || device_dispatch_table(device)->CmdSetFrontFace))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetFrontFace);
    if (strcmp(pName, "vkCmdSetPrimitiveTopology") == 0 && (!device || device_dispatch_table(device)->CmdSetPrimitiveTopology))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPrimitiveTopology);
    if (strcmp(pName, "vkCmdSetViewportWithCount") == 0 && (!device || device_dispatch_table(device)->CmdSetViewportWithCount))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewportWithCount);
    if (strcmp(pName, "vkCmdSetScissorWithCount") == 0 && (!device || device_dispatch_table(device)->CmdSetScissorWithCount))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetScissorWithCount);
    if (strcmp(pName, "vkCmdBindVertexBuffers2") == 0 && (!device || device_dispatch_table(device)->CmdBindVertexBuffers2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindVertexBuffers2);
    if (strcmp(pName, "vkCmdSetDepthTestEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthTestEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthTestEnable);
    if (strcmp(pName, "vkCmdSetDepthWriteEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthWriteEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthWriteEnable);
    if (strcmp(pName, "vkCmdSetDepthCompareOp") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthCompareOp))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthCompareOp);
    if (strcmp(pName, "vkCmdSetDepthBoundsTestEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBoundsTestEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBoundsTestEnable);
    if (strcmp(pName, "vkCmdSetStencilTestEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilTestEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilTestEnable);
    if (strcmp(pName, "vkCmdSetStencilOp") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilOp))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilOp);
    if (strcmp(pName, "vkCmdSetRasterizerDiscardEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetRasterizerDiscardEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRasterizerDiscardEnable);
    if (strcmp(pName, "vkCmdSetDepthBiasEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBiasEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBiasEnable);
    if (strcmp(pName, "vkCmdSetPrimitiveRestartEnable") == 0 && (!device || device_dispatch_table(device)->CmdSetPrimitiveRestartEnable))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPrimitiveRestartEnable);
    if (strcmp(pName, "vkMapMemory2") == 0 && (!device || device_dispatch_table(device)->MapMemory2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkMapMemory2);
    if (strcmp(pName, "vkUnmapMemory2") == 0 && (!device || device_dispatch_table(device)->UnmapMemory2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUnmapMemory2);
    if (strcmp(pName, "vkGetDeviceImageSubresourceLayout") == 0 && (!device || device_dispatch_table(device)->GetDeviceImageSubresourceLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceImageSubresourceLayout);
    if (strcmp(pName, "vkGetImageSubresourceLayout2") == 0 && (!device || device_dispatch_table(device)->GetImageSubresourceLayout2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSubresourceLayout2);
    if (strcmp(pName, "vkCopyMemoryToImage") == 0 && (!device || device_dispatch_table(device)->CopyMemoryToImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyMemoryToImage);
    if (strcmp(pName, "vkCopyImageToMemory") == 0 && (!device || device_dispatch_table(device)->CopyImageToMemory))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyImageToMemory);
    if (strcmp(pName, "vkCopyImageToImage") == 0 && (!device || device_dispatch_table(device)->CopyImageToImage))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyImageToImage);
    if (strcmp(pName, "vkTransitionImageLayout") == 0 && (!device || device_dispatch_table(device)->TransitionImageLayout))
        return reinterpret_cast<PFN_vkVoidFunction>(vkTransitionImageLayout);
    if (strcmp(pName, "vkCmdPushDescriptorSet") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSet))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSet);
    if (strcmp(pName, "vkCmdPushDescriptorSetWithTemplate") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSetWithTemplate))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSetWithTemplate);
    if (strcmp(pName, "vkCmdBindDescriptorSets2") == 0 && (!device || device_dispatch_table(device)->CmdBindDescriptorSets2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindDescriptorSets2);
    if (strcmp(pName, "vkCmdPushConstants2") == 0 && (!device || device_dispatch_table(device)->CmdPushConstants2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushConstants2);
    if (strcmp(pName, "vkCmdPushDescriptorSet2") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSet2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSet2);
    if (strcmp(pName, "vkCmdPushDescriptorSetWithTemplate2") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSetWithTemplate2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSetWithTemplate2);
    if (strcmp(pName, "vkCmdSetLineStipple") == 0 && (!device || device_dispatch_table(device)->CmdSetLineStipple))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLineStipple);
    if (strcmp(pName, "vkCmdBindIndexBuffer2") == 0 && (!device || device_dispatch_table(device)->CmdBindIndexBuffer2))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindIndexBuffer2);
    if (strcmp(pName, "vkGetRenderingAreaGranularity") == 0 && (!device || device_dispatch_table(device)->GetRenderingAreaGranularity))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRenderingAreaGranularity);
    if (strcmp(pName, "vkCmdSetRenderingAttachmentLocations") == 0 && (!device || device_dispatch_table(device)->CmdSetRenderingAttachmentLocations))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRenderingAttachmentLocations);
    if (strcmp(pName, "vkCmdSetRenderingInputAttachmentIndices") == 0 && (!device || device_dispatch_table(device)->CmdSetRenderingInputAttachmentIndices))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRenderingInputAttachmentIndices);
    if (strcmp(pName, "vkCreateSwapchainKHR") == 0 && (!device || device_dispatch_table(device)->CreateSwapchainKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSwapchainKHR);
    if (strcmp(pName, "vkDestroySwapchainKHR") == 0 && (!device || device_dispatch_table(device)->DestroySwapchainKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroySwapchainKHR);
    if (strcmp(pName, "vkGetSwapchainImagesKHR") == 0 && (!device || device_dispatch_table(device)->GetSwapchainImagesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSwapchainImagesKHR);
    if (strcmp(pName, "vkAcquireNextImageKHR") == 0 && (!device || device_dispatch_table(device)->AcquireNextImageKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireNextImageKHR);
    if (strcmp(pName, "vkQueuePresentKHR") == 0 && (!device || device_dispatch_table(device)->QueuePresentKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueuePresentKHR);
    if (strcmp(pName, "vkGetDeviceGroupPresentCapabilitiesKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceGroupPresentCapabilitiesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceGroupPresentCapabilitiesKHR);
    if (strcmp(pName, "vkGetDeviceGroupSurfacePresentModesKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceGroupSurfacePresentModesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceGroupSurfacePresentModesKHR);
    if (strcmp(pName, "vkAcquireNextImage2KHR") == 0 && (!device || device_dispatch_table(device)->AcquireNextImage2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireNextImage2KHR);
    if (strcmp(pName, "vkCreateSharedSwapchainsKHR") == 0 && (!device || device_dispatch_table(device)->CreateSharedSwapchainsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSharedSwapchainsKHR);
    if (strcmp(pName, "vkCreateVideoSessionKHR") == 0 && (!device || device_dispatch_table(device)->CreateVideoSessionKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateVideoSessionKHR);
    if (strcmp(pName, "vkDestroyVideoSessionKHR") == 0 && (!device || device_dispatch_table(device)->DestroyVideoSessionKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyVideoSessionKHR);
    if (strcmp(pName, "vkGetVideoSessionMemoryRequirementsKHR") == 0 && (!device || device_dispatch_table(device)->GetVideoSessionMemoryRequirementsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetVideoSessionMemoryRequirementsKHR);
    if (strcmp(pName, "vkBindVideoSessionMemoryKHR") == 0 && (!device || device_dispatch_table(device)->BindVideoSessionMemoryKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindVideoSessionMemoryKHR);
    if (strcmp(pName, "vkCreateVideoSessionParametersKHR") == 0 && (!device || device_dispatch_table(device)->CreateVideoSessionParametersKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateVideoSessionParametersKHR);
    if (strcmp(pName, "vkUpdateVideoSessionParametersKHR") == 0 && (!device || device_dispatch_table(device)->UpdateVideoSessionParametersKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUpdateVideoSessionParametersKHR);
    if (strcmp(pName, "vkDestroyVideoSessionParametersKHR") == 0 && (!device || device_dispatch_table(device)->DestroyVideoSessionParametersKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyVideoSessionParametersKHR);
    if (strcmp(pName, "vkCmdBeginVideoCodingKHR") == 0 && (!device || device_dispatch_table(device)->CmdBeginVideoCodingKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginVideoCodingKHR);
    if (strcmp(pName, "vkCmdEndVideoCodingKHR") == 0 && (!device || device_dispatch_table(device)->CmdEndVideoCodingKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndVideoCodingKHR);
    if (strcmp(pName, "vkCmdControlVideoCodingKHR") == 0 && (!device || device_dispatch_table(device)->CmdControlVideoCodingKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdControlVideoCodingKHR);
    if (strcmp(pName, "vkCmdDecodeVideoKHR") == 0 && (!device || device_dispatch_table(device)->CmdDecodeVideoKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDecodeVideoKHR);
    if (strcmp(pName, "vkCmdBeginRenderingKHR") == 0 && (!device || device_dispatch_table(device)->CmdBeginRenderingKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginRenderingKHR);
    if (strcmp(pName, "vkCmdEndRenderingKHR") == 0 && (!device || device_dispatch_table(device)->CmdEndRenderingKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRenderingKHR);
    if (strcmp(pName, "vkGetDeviceGroupPeerMemoryFeaturesKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceGroupPeerMemoryFeaturesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceGroupPeerMemoryFeaturesKHR);
    if (strcmp(pName, "vkCmdSetDeviceMaskKHR") == 0 && (!device || device_dispatch_table(device)->CmdSetDeviceMaskKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDeviceMaskKHR);
    if (strcmp(pName, "vkCmdDispatchBaseKHR") == 0 && (!device || device_dispatch_table(device)->CmdDispatchBaseKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchBaseKHR);
    if (strcmp(pName, "vkTrimCommandPoolKHR") == 0 && (!device || device_dispatch_table(device)->TrimCommandPoolKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkTrimCommandPoolKHR);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkGetMemoryWin32HandleKHR") == 0 && (!device || device_dispatch_table(device)->GetMemoryWin32HandleKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryWin32HandleKHR);
    if (strcmp(pName, "vkGetMemoryWin32HandlePropertiesKHR") == 0 && (!device || device_dispatch_table(device)->GetMemoryWin32HandlePropertiesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryWin32HandlePropertiesKHR);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkGetMemoryFdKHR") == 0 && (!device || device_dispatch_table(device)->GetMemoryFdKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryFdKHR);
    if (strcmp(pName, "vkGetMemoryFdPropertiesKHR") == 0 && (!device || device_dispatch_table(device)->GetMemoryFdPropertiesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryFdPropertiesKHR);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkImportSemaphoreWin32HandleKHR") == 0 && (!device || device_dispatch_table(device)->ImportSemaphoreWin32HandleKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkImportSemaphoreWin32HandleKHR);
    if (strcmp(pName, "vkGetSemaphoreWin32HandleKHR") == 0 && (!device || device_dispatch_table(device)->GetSemaphoreWin32HandleKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSemaphoreWin32HandleKHR);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkImportSemaphoreFdKHR") == 0 && (!device || device_dispatch_table(device)->ImportSemaphoreFdKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkImportSemaphoreFdKHR);
    if (strcmp(pName, "vkGetSemaphoreFdKHR") == 0 && (!device || device_dispatch_table(device)->GetSemaphoreFdKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSemaphoreFdKHR);
    if (strcmp(pName, "vkCmdPushDescriptorSetKHR") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSetKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSetKHR);
    if (strcmp(pName, "vkCmdPushDescriptorSetWithTemplateKHR") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSetWithTemplateKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSetWithTemplateKHR);
    if (strcmp(pName, "vkCreateDescriptorUpdateTemplateKHR") == 0 && (!device || device_dispatch_table(device)->CreateDescriptorUpdateTemplateKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDescriptorUpdateTemplateKHR);
    if (strcmp(pName, "vkDestroyDescriptorUpdateTemplateKHR") == 0 && (!device || device_dispatch_table(device)->DestroyDescriptorUpdateTemplateKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDescriptorUpdateTemplateKHR);
    if (strcmp(pName, "vkUpdateDescriptorSetWithTemplateKHR") == 0 && (!device || device_dispatch_table(device)->UpdateDescriptorSetWithTemplateKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUpdateDescriptorSetWithTemplateKHR);
    if (strcmp(pName, "vkCreateRenderPass2KHR") == 0 && (!device || device_dispatch_table(device)->CreateRenderPass2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateRenderPass2KHR);
    if (strcmp(pName, "vkCmdBeginRenderPass2KHR") == 0 && (!device || device_dispatch_table(device)->CmdBeginRenderPass2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginRenderPass2KHR);
    if (strcmp(pName, "vkCmdNextSubpass2KHR") == 0 && (!device || device_dispatch_table(device)->CmdNextSubpass2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdNextSubpass2KHR);
    if (strcmp(pName, "vkCmdEndRenderPass2KHR") == 0 && (!device || device_dispatch_table(device)->CmdEndRenderPass2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRenderPass2KHR);
    if (strcmp(pName, "vkGetSwapchainStatusKHR") == 0 && (!device || device_dispatch_table(device)->GetSwapchainStatusKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSwapchainStatusKHR);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkImportFenceWin32HandleKHR") == 0 && (!device || device_dispatch_table(device)->ImportFenceWin32HandleKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkImportFenceWin32HandleKHR);
    if (strcmp(pName, "vkGetFenceWin32HandleKHR") == 0 && (!device || device_dispatch_table(device)->GetFenceWin32HandleKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetFenceWin32HandleKHR);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkImportFenceFdKHR") == 0 && (!device || device_dispatch_table(device)->ImportFenceFdKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkImportFenceFdKHR);
    if (strcmp(pName, "vkGetFenceFdKHR") == 0 && (!device || device_dispatch_table(device)->GetFenceFdKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetFenceFdKHR);
    if (strcmp(pName, "vkAcquireProfilingLockKHR") == 0 && (!device || device_dispatch_table(device)->AcquireProfilingLockKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireProfilingLockKHR);
    if (strcmp(pName, "vkReleaseProfilingLockKHR") == 0 && (!device || device_dispatch_table(device)->ReleaseProfilingLockKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleaseProfilingLockKHR);
    if (strcmp(pName, "vkGetImageMemoryRequirements2KHR") == 0 && (!device || device_dispatch_table(device)->GetImageMemoryRequirements2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageMemoryRequirements2KHR);
    if (strcmp(pName, "vkGetBufferMemoryRequirements2KHR") == 0 && (!device || device_dispatch_table(device)->GetBufferMemoryRequirements2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferMemoryRequirements2KHR);
    if (strcmp(pName, "vkGetImageSparseMemoryRequirements2KHR") == 0 && (!device || device_dispatch_table(device)->GetImageSparseMemoryRequirements2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSparseMemoryRequirements2KHR);
    if (strcmp(pName, "vkCreateSamplerYcbcrConversionKHR") == 0 && (!device || device_dispatch_table(device)->CreateSamplerYcbcrConversionKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateSamplerYcbcrConversionKHR);
    if (strcmp(pName, "vkDestroySamplerYcbcrConversionKHR") == 0 && (!device || device_dispatch_table(device)->DestroySamplerYcbcrConversionKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroySamplerYcbcrConversionKHR);
    if (strcmp(pName, "vkBindBufferMemory2KHR") == 0 && (!device || device_dispatch_table(device)->BindBufferMemory2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindBufferMemory2KHR);
    if (strcmp(pName, "vkBindImageMemory2KHR") == 0 && (!device || device_dispatch_table(device)->BindImageMemory2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindImageMemory2KHR);
    if (strcmp(pName, "vkGetDescriptorSetLayoutSupportKHR") == 0 && (!device || device_dispatch_table(device)->GetDescriptorSetLayoutSupportKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorSetLayoutSupportKHR);
    if (strcmp(pName, "vkCmdDrawIndirectCountKHR") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndirectCountKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndirectCountKHR);
    if (strcmp(pName, "vkCmdDrawIndexedIndirectCountKHR") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndexedIndirectCountKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndexedIndirectCountKHR);
    if (strcmp(pName, "vkGetSemaphoreCounterValueKHR") == 0 && (!device || device_dispatch_table(device)->GetSemaphoreCounterValueKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSemaphoreCounterValueKHR);
    if (strcmp(pName, "vkWaitSemaphoresKHR") == 0 && (!device || device_dispatch_table(device)->WaitSemaphoresKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWaitSemaphoresKHR);
    if (strcmp(pName, "vkSignalSemaphoreKHR") == 0 && (!device || device_dispatch_table(device)->SignalSemaphoreKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSignalSemaphoreKHR);
    if (strcmp(pName, "vkCmdSetFragmentShadingRateKHR") == 0 && (!device || device_dispatch_table(device)->CmdSetFragmentShadingRateKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetFragmentShadingRateKHR);
    if (strcmp(pName, "vkCmdSetRenderingAttachmentLocationsKHR") == 0 && (!device || device_dispatch_table(device)->CmdSetRenderingAttachmentLocationsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRenderingAttachmentLocationsKHR);
    if (strcmp(pName, "vkCmdSetRenderingInputAttachmentIndicesKHR") == 0 && (!device || device_dispatch_table(device)->CmdSetRenderingInputAttachmentIndicesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRenderingInputAttachmentIndicesKHR);
    if (strcmp(pName, "vkWaitForPresentKHR") == 0 && (!device || device_dispatch_table(device)->WaitForPresentKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWaitForPresentKHR);
    if (strcmp(pName, "vkGetBufferDeviceAddressKHR") == 0 && (!device || device_dispatch_table(device)->GetBufferDeviceAddressKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferDeviceAddressKHR);
    if (strcmp(pName, "vkGetBufferOpaqueCaptureAddressKHR") == 0 && (!device || device_dispatch_table(device)->GetBufferOpaqueCaptureAddressKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferOpaqueCaptureAddressKHR);
    if (strcmp(pName, "vkGetDeviceMemoryOpaqueCaptureAddressKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceMemoryOpaqueCaptureAddressKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceMemoryOpaqueCaptureAddressKHR);
    if (strcmp(pName, "vkCreateDeferredOperationKHR") == 0 && (!device || device_dispatch_table(device)->CreateDeferredOperationKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDeferredOperationKHR);
    if (strcmp(pName, "vkDestroyDeferredOperationKHR") == 0 && (!device || device_dispatch_table(device)->DestroyDeferredOperationKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDeferredOperationKHR);
    if (strcmp(pName, "vkGetDeferredOperationMaxConcurrencyKHR") == 0 && (!device || device_dispatch_table(device)->GetDeferredOperationMaxConcurrencyKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeferredOperationMaxConcurrencyKHR);
    if (strcmp(pName, "vkGetDeferredOperationResultKHR") == 0 && (!device || device_dispatch_table(device)->GetDeferredOperationResultKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeferredOperationResultKHR);
    if (strcmp(pName, "vkDeferredOperationJoinKHR") == 0 && (!device || device_dispatch_table(device)->DeferredOperationJoinKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDeferredOperationJoinKHR);
    if (strcmp(pName, "vkGetPipelineExecutablePropertiesKHR") == 0 && (!device || device_dispatch_table(device)->GetPipelineExecutablePropertiesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineExecutablePropertiesKHR);
    if (strcmp(pName, "vkGetPipelineExecutableStatisticsKHR") == 0 && (!device || device_dispatch_table(device)->GetPipelineExecutableStatisticsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineExecutableStatisticsKHR);
    if (strcmp(pName, "vkGetPipelineExecutableInternalRepresentationsKHR") == 0 && (!device || device_dispatch_table(device)->GetPipelineExecutableInternalRepresentationsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineExecutableInternalRepresentationsKHR);
    if (strcmp(pName, "vkMapMemory2KHR") == 0 && (!device || device_dispatch_table(device)->MapMemory2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkMapMemory2KHR);
    if (strcmp(pName, "vkUnmapMemory2KHR") == 0 && (!device || device_dispatch_table(device)->UnmapMemory2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUnmapMemory2KHR);
    if (strcmp(pName, "vkGetEncodedVideoSessionParametersKHR") == 0 && (!device || device_dispatch_table(device)->GetEncodedVideoSessionParametersKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetEncodedVideoSessionParametersKHR);
    if (strcmp(pName, "vkCmdEncodeVideoKHR") == 0 && (!device || device_dispatch_table(device)->CmdEncodeVideoKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEncodeVideoKHR);
    if (strcmp(pName, "vkCmdSetEvent2KHR") == 0 && (!device || device_dispatch_table(device)->CmdSetEvent2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetEvent2KHR);
    if (strcmp(pName, "vkCmdResetEvent2KHR") == 0 && (!device || device_dispatch_table(device)->CmdResetEvent2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResetEvent2KHR);
    if (strcmp(pName, "vkCmdWaitEvents2KHR") == 0 && (!device || device_dispatch_table(device)->CmdWaitEvents2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWaitEvents2KHR);
    if (strcmp(pName, "vkCmdPipelineBarrier2KHR") == 0 && (!device || device_dispatch_table(device)->CmdPipelineBarrier2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPipelineBarrier2KHR);
    if (strcmp(pName, "vkCmdWriteTimestamp2KHR") == 0 && (!device || device_dispatch_table(device)->CmdWriteTimestamp2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteTimestamp2KHR);
    if (strcmp(pName, "vkQueueSubmit2KHR") == 0 && (!device || device_dispatch_table(device)->QueueSubmit2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueSubmit2KHR);
    if (strcmp(pName, "vkCmdCopyBuffer2KHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyBuffer2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyBuffer2KHR);
    if (strcmp(pName, "vkCmdCopyImage2KHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyImage2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyImage2KHR);
    if (strcmp(pName, "vkCmdCopyBufferToImage2KHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyBufferToImage2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyBufferToImage2KHR);
    if (strcmp(pName, "vkCmdCopyImageToBuffer2KHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyImageToBuffer2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyImageToBuffer2KHR);
    if (strcmp(pName, "vkCmdBlitImage2KHR") == 0 && (!device || device_dispatch_table(device)->CmdBlitImage2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBlitImage2KHR);
    if (strcmp(pName, "vkCmdResolveImage2KHR") == 0 && (!device || device_dispatch_table(device)->CmdResolveImage2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdResolveImage2KHR);
    if (strcmp(pName, "vkCmdTraceRaysIndirect2KHR") == 0 && (!device || device_dispatch_table(device)->CmdTraceRaysIndirect2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdTraceRaysIndirect2KHR);
    if (strcmp(pName, "vkGetDeviceBufferMemoryRequirementsKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceBufferMemoryRequirementsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceBufferMemoryRequirementsKHR);
    if (strcmp(pName, "vkGetDeviceImageMemoryRequirementsKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceImageMemoryRequirementsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceImageMemoryRequirementsKHR);
    if (strcmp(pName, "vkGetDeviceImageSparseMemoryRequirementsKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceImageSparseMemoryRequirementsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceImageSparseMemoryRequirementsKHR);
    if (strcmp(pName, "vkCmdBindIndexBuffer2KHR") == 0 && (!device || device_dispatch_table(device)->CmdBindIndexBuffer2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindIndexBuffer2KHR);
    if (strcmp(pName, "vkGetRenderingAreaGranularityKHR") == 0 && (!device || device_dispatch_table(device)->GetRenderingAreaGranularityKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRenderingAreaGranularityKHR);
    if (strcmp(pName, "vkGetDeviceImageSubresourceLayoutKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceImageSubresourceLayoutKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceImageSubresourceLayoutKHR);
    if (strcmp(pName, "vkGetImageSubresourceLayout2KHR") == 0 && (!device || device_dispatch_table(device)->GetImageSubresourceLayout2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSubresourceLayout2KHR);
    if (strcmp(pName, "vkWaitForPresent2KHR") == 0 && (!device || device_dispatch_table(device)->WaitForPresent2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWaitForPresent2KHR);
    if (strcmp(pName, "vkCreatePipelineBinariesKHR") == 0 && (!device || device_dispatch_table(device)->CreatePipelineBinariesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreatePipelineBinariesKHR);
    if (strcmp(pName, "vkDestroyPipelineBinaryKHR") == 0 && (!device || device_dispatch_table(device)->DestroyPipelineBinaryKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyPipelineBinaryKHR);
    if (strcmp(pName, "vkGetPipelineKeyKHR") == 0 && (!device || device_dispatch_table(device)->GetPipelineKeyKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineKeyKHR);
    if (strcmp(pName, "vkGetPipelineBinaryDataKHR") == 0 && (!device || device_dispatch_table(device)->GetPipelineBinaryDataKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineBinaryDataKHR);
    if (strcmp(pName, "vkReleaseCapturedPipelineDataKHR") == 0 && (!device || device_dispatch_table(device)->ReleaseCapturedPipelineDataKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleaseCapturedPipelineDataKHR);
    if (strcmp(pName, "vkReleaseSwapchainImagesKHR") == 0 && (!device || device_dispatch_table(device)->ReleaseSwapchainImagesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleaseSwapchainImagesKHR);
    if (strcmp(pName, "vkCmdSetLineStippleKHR") == 0 && (!device || device_dispatch_table(device)->CmdSetLineStippleKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLineStippleKHR);
    if (strcmp(pName, "vkGetCalibratedTimestampsKHR") == 0 && (!device || device_dispatch_table(device)->GetCalibratedTimestampsKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetCalibratedTimestampsKHR);
    if (strcmp(pName, "vkCmdBindDescriptorSets2KHR") == 0 && (!device || device_dispatch_table(device)->CmdBindDescriptorSets2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindDescriptorSets2KHR);
    if (strcmp(pName, "vkCmdPushConstants2KHR") == 0 && (!device || device_dispatch_table(device)->CmdPushConstants2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushConstants2KHR);
    if (strcmp(pName, "vkCmdPushDescriptorSet2KHR") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSet2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSet2KHR);
    if (strcmp(pName, "vkCmdPushDescriptorSetWithTemplate2KHR") == 0 && (!device || device_dispatch_table(device)->CmdPushDescriptorSetWithTemplate2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDescriptorSetWithTemplate2KHR);
    if (strcmp(pName, "vkCmdSetDescriptorBufferOffsets2EXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDescriptorBufferOffsets2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDescriptorBufferOffsets2EXT);
    if (strcmp(pName, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT") == 0 && (!device || device_dispatch_table(device)->CmdBindDescriptorBufferEmbeddedSamplers2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindDescriptorBufferEmbeddedSamplers2EXT);
    if (strcmp(pName, "vkCmdCopyMemoryIndirectKHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyMemoryIndirectKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMemoryIndirectKHR);
    if (strcmp(pName, "vkCmdCopyMemoryToImageIndirectKHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyMemoryToImageIndirectKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMemoryToImageIndirectKHR);
    if (strcmp(pName, "vkCmdEndRendering2KHR") == 0 && (!device || device_dispatch_table(device)->CmdEndRendering2KHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRendering2KHR);
    if (strcmp(pName, "vkDebugMarkerSetObjectTagEXT") == 0 && (!device || device_dispatch_table(device)->DebugMarkerSetObjectTagEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDebugMarkerSetObjectTagEXT);
    if (strcmp(pName, "vkDebugMarkerSetObjectNameEXT") == 0 && (!device || device_dispatch_table(device)->DebugMarkerSetObjectNameEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDebugMarkerSetObjectNameEXT);
    if (strcmp(pName, "vkCmdDebugMarkerBeginEXT") == 0 && (!device || device_dispatch_table(device)->CmdDebugMarkerBeginEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDebugMarkerBeginEXT);
    if (strcmp(pName, "vkCmdDebugMarkerEndEXT") == 0 && (!device || device_dispatch_table(device)->CmdDebugMarkerEndEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDebugMarkerEndEXT);
    if (strcmp(pName, "vkCmdDebugMarkerInsertEXT") == 0 && (!device || device_dispatch_table(device)->CmdDebugMarkerInsertEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDebugMarkerInsertEXT);
    if (strcmp(pName, "vkCmdBindTransformFeedbackBuffersEXT") == 0 && (!device || device_dispatch_table(device)->CmdBindTransformFeedbackBuffersEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindTransformFeedbackBuffersEXT);
    if (strcmp(pName, "vkCmdBeginTransformFeedbackEXT") == 0 && (!device || device_dispatch_table(device)->CmdBeginTransformFeedbackEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginTransformFeedbackEXT);
    if (strcmp(pName, "vkCmdEndTransformFeedbackEXT") == 0 && (!device || device_dispatch_table(device)->CmdEndTransformFeedbackEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndTransformFeedbackEXT);
    if (strcmp(pName, "vkCmdBeginQueryIndexedEXT") == 0 && (!device || device_dispatch_table(device)->CmdBeginQueryIndexedEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginQueryIndexedEXT);
    if (strcmp(pName, "vkCmdEndQueryIndexedEXT") == 0 && (!device || device_dispatch_table(device)->CmdEndQueryIndexedEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndQueryIndexedEXT);
    if (strcmp(pName, "vkCmdDrawIndirectByteCountEXT") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndirectByteCountEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndirectByteCountEXT);
    if (strcmp(pName, "vkCreateCuModuleNVX") == 0 && (!device || device_dispatch_table(device)->CreateCuModuleNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateCuModuleNVX);
    if (strcmp(pName, "vkCreateCuFunctionNVX") == 0 && (!device || device_dispatch_table(device)->CreateCuFunctionNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateCuFunctionNVX);
    if (strcmp(pName, "vkDestroyCuModuleNVX") == 0 && (!device || device_dispatch_table(device)->DestroyCuModuleNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyCuModuleNVX);
    if (strcmp(pName, "vkDestroyCuFunctionNVX") == 0 && (!device || device_dispatch_table(device)->DestroyCuFunctionNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyCuFunctionNVX);
    if (strcmp(pName, "vkCmdCuLaunchKernelNVX") == 0 && (!device || device_dispatch_table(device)->CmdCuLaunchKernelNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCuLaunchKernelNVX);
    if (strcmp(pName, "vkGetImageViewHandleNVX") == 0 && (!device || device_dispatch_table(device)->GetImageViewHandleNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageViewHandleNVX);
    if (strcmp(pName, "vkGetImageViewHandle64NVX") == 0 && (!device || device_dispatch_table(device)->GetImageViewHandle64NVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageViewHandle64NVX);
    if (strcmp(pName, "vkGetImageViewAddressNVX") == 0 && (!device || device_dispatch_table(device)->GetImageViewAddressNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageViewAddressNVX);
    if (strcmp(pName, "vkGetDeviceCombinedImageSamplerIndexNVX") == 0 && (!device || device_dispatch_table(device)->GetDeviceCombinedImageSamplerIndexNVX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceCombinedImageSamplerIndexNVX);
    if (strcmp(pName, "vkCmdDrawIndirectCountAMD") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndirectCountAMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndirectCountAMD);
    if (strcmp(pName, "vkCmdDrawIndexedIndirectCountAMD") == 0 && (!device || device_dispatch_table(device)->CmdDrawIndexedIndirectCountAMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawIndexedIndirectCountAMD);
    if (strcmp(pName, "vkGetShaderInfoAMD") == 0 && (!device || device_dispatch_table(device)->GetShaderInfoAMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetShaderInfoAMD);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkGetMemoryWin32HandleNV") == 0 && (!device || device_dispatch_table(device)->GetMemoryWin32HandleNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryWin32HandleNV);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkCmdBeginConditionalRenderingEXT") == 0 && (!device || device_dispatch_table(device)->CmdBeginConditionalRenderingEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginConditionalRenderingEXT);
    if (strcmp(pName, "vkCmdEndConditionalRenderingEXT") == 0 && (!device || device_dispatch_table(device)->CmdEndConditionalRenderingEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndConditionalRenderingEXT);
    if (strcmp(pName, "vkCmdSetViewportWScalingNV") == 0 && (!device || device_dispatch_table(device)->CmdSetViewportWScalingNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewportWScalingNV);
    if (strcmp(pName, "vkDisplayPowerControlEXT") == 0 && (!device || device_dispatch_table(device)->DisplayPowerControlEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDisplayPowerControlEXT);
    if (strcmp(pName, "vkRegisterDeviceEventEXT") == 0 && (!device || device_dispatch_table(device)->RegisterDeviceEventEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkRegisterDeviceEventEXT);
    if (strcmp(pName, "vkRegisterDisplayEventEXT") == 0 && (!device || device_dispatch_table(device)->RegisterDisplayEventEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkRegisterDisplayEventEXT);
    if (strcmp(pName, "vkGetSwapchainCounterEXT") == 0 && (!device || device_dispatch_table(device)->GetSwapchainCounterEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSwapchainCounterEXT);
    if (strcmp(pName, "vkGetRefreshCycleDurationGOOGLE") == 0 && (!device || device_dispatch_table(device)->GetRefreshCycleDurationGOOGLE))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRefreshCycleDurationGOOGLE);
    if (strcmp(pName, "vkGetPastPresentationTimingGOOGLE") == 0 && (!device || device_dispatch_table(device)->GetPastPresentationTimingGOOGLE))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPastPresentationTimingGOOGLE);
    if (strcmp(pName, "vkCmdSetDiscardRectangleEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDiscardRectangleEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDiscardRectangleEXT);
    if (strcmp(pName, "vkCmdSetDiscardRectangleEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDiscardRectangleEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDiscardRectangleEnableEXT);
    if (strcmp(pName, "vkCmdSetDiscardRectangleModeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDiscardRectangleModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDiscardRectangleModeEXT);
    if (strcmp(pName, "vkSetHdrMetadataEXT") == 0 && (!device || device_dispatch_table(device)->SetHdrMetadataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetHdrMetadataEXT);
    if (strcmp(pName, "vkSetDebugUtilsObjectNameEXT") == 0 && (!device || device_dispatch_table(device)->SetDebugUtilsObjectNameEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetDebugUtilsObjectNameEXT);
    if (strcmp(pName, "vkSetDebugUtilsObjectTagEXT") == 0 && (!device || device_dispatch_table(device)->SetDebugUtilsObjectTagEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetDebugUtilsObjectTagEXT);
    if (strcmp(pName, "vkQueueBeginDebugUtilsLabelEXT") == 0 && (!device || device_dispatch_table(device)->QueueBeginDebugUtilsLabelEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueBeginDebugUtilsLabelEXT);
    if (strcmp(pName, "vkQueueEndDebugUtilsLabelEXT") == 0 && (!device || device_dispatch_table(device)->QueueEndDebugUtilsLabelEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueEndDebugUtilsLabelEXT);
    if (strcmp(pName, "vkQueueInsertDebugUtilsLabelEXT") == 0 && (!device || device_dispatch_table(device)->QueueInsertDebugUtilsLabelEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueInsertDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCmdBeginDebugUtilsLabelEXT") == 0 && (!device || device_dispatch_table(device)->CmdBeginDebugUtilsLabelEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCmdEndDebugUtilsLabelEXT") == 0 && (!device || device_dispatch_table(device)->CmdEndDebugUtilsLabelEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndDebugUtilsLabelEXT);
    if (strcmp(pName, "vkCmdInsertDebugUtilsLabelEXT") == 0 && (!device || device_dispatch_table(device)->CmdInsertDebugUtilsLabelEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdInsertDebugUtilsLabelEXT);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    if (strcmp(pName, "vkGetAndroidHardwareBufferPropertiesANDROID") == 0 && (!device || device_dispatch_table(device)->GetAndroidHardwareBufferPropertiesANDROID))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetAndroidHardwareBufferPropertiesANDROID);
    if (strcmp(pName, "vkGetMemoryAndroidHardwareBufferANDROID") == 0 && (!device || device_dispatch_table(device)->GetMemoryAndroidHardwareBufferANDROID))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryAndroidHardwareBufferANDROID);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if (strcmp(pName, "vkCreateExecutionGraphPipelinesAMDX") == 0 && (!device || device_dispatch_table(device)->CreateExecutionGraphPipelinesAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateExecutionGraphPipelinesAMDX);
    if (strcmp(pName, "vkGetExecutionGraphPipelineScratchSizeAMDX") == 0 && (!device || device_dispatch_table(device)->GetExecutionGraphPipelineScratchSizeAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetExecutionGraphPipelineScratchSizeAMDX);
    if (strcmp(pName, "vkGetExecutionGraphPipelineNodeIndexAMDX") == 0 && (!device || device_dispatch_table(device)->GetExecutionGraphPipelineNodeIndexAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetExecutionGraphPipelineNodeIndexAMDX);
    if (strcmp(pName, "vkCmdInitializeGraphScratchMemoryAMDX") == 0 && (!device || device_dispatch_table(device)->CmdInitializeGraphScratchMemoryAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdInitializeGraphScratchMemoryAMDX);
    if (strcmp(pName, "vkCmdDispatchGraphAMDX") == 0 && (!device || device_dispatch_table(device)->CmdDispatchGraphAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchGraphAMDX);
    if (strcmp(pName, "vkCmdDispatchGraphIndirectAMDX") == 0 && (!device || device_dispatch_table(device)->CmdDispatchGraphIndirectAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchGraphIndirectAMDX);
    if (strcmp(pName, "vkCmdDispatchGraphIndirectCountAMDX") == 0 && (!device || device_dispatch_table(device)->CmdDispatchGraphIndirectCountAMDX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchGraphIndirectCountAMDX);
#endif  // VK_ENABLE_BETA_EXTENSIONS
    if (strcmp(pName, "vkWriteSamplerDescriptorsEXT") == 0 && (!device || device_dispatch_table(device)->WriteSamplerDescriptorsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWriteSamplerDescriptorsEXT);
    if (strcmp(pName, "vkWriteResourceDescriptorsEXT") == 0 && (!device || device_dispatch_table(device)->WriteResourceDescriptorsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWriteResourceDescriptorsEXT);
    if (strcmp(pName, "vkCmdBindSamplerHeapEXT") == 0 && (!device || device_dispatch_table(device)->CmdBindSamplerHeapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindSamplerHeapEXT);
    if (strcmp(pName, "vkCmdBindResourceHeapEXT") == 0 && (!device || device_dispatch_table(device)->CmdBindResourceHeapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindResourceHeapEXT);
    if (strcmp(pName, "vkCmdPushDataEXT") == 0 && (!device || device_dispatch_table(device)->CmdPushDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPushDataEXT);
    if (strcmp(pName, "vkGetImageOpaqueCaptureDataEXT") == 0 && (!device || device_dispatch_table(device)->GetImageOpaqueCaptureDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageOpaqueCaptureDataEXT);
    if (strcmp(pName, "vkRegisterCustomBorderColorEXT") == 0 && (!device || device_dispatch_table(device)->RegisterCustomBorderColorEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkRegisterCustomBorderColorEXT);
    if (strcmp(pName, "vkUnregisterCustomBorderColorEXT") == 0 && (!device || device_dispatch_table(device)->UnregisterCustomBorderColorEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUnregisterCustomBorderColorEXT);
    if (strcmp(pName, "vkGetTensorOpaqueCaptureDataARM") == 0 && (!device || device_dispatch_table(device)->GetTensorOpaqueCaptureDataARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetTensorOpaqueCaptureDataARM);
    if (strcmp(pName, "vkCmdSetSampleLocationsEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetSampleLocationsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetSampleLocationsEXT);
    if (strcmp(pName, "vkGetImageDrmFormatModifierPropertiesEXT") == 0 && (!device || device_dispatch_table(device)->GetImageDrmFormatModifierPropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageDrmFormatModifierPropertiesEXT);
    if (strcmp(pName, "vkCreateValidationCacheEXT") == 0 && (!device || device_dispatch_table(device)->CreateValidationCacheEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateValidationCacheEXT);
    if (strcmp(pName, "vkDestroyValidationCacheEXT") == 0 && (!device || device_dispatch_table(device)->DestroyValidationCacheEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyValidationCacheEXT);
    if (strcmp(pName, "vkMergeValidationCachesEXT") == 0 && (!device || device_dispatch_table(device)->MergeValidationCachesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkMergeValidationCachesEXT);
    if (strcmp(pName, "vkGetValidationCacheDataEXT") == 0 && (!device || device_dispatch_table(device)->GetValidationCacheDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetValidationCacheDataEXT);
    if (strcmp(pName, "vkCmdBindShadingRateImageNV") == 0 && (!device || device_dispatch_table(device)->CmdBindShadingRateImageNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindShadingRateImageNV);
    if (strcmp(pName, "vkCmdSetViewportShadingRatePaletteNV") == 0 && (!device || device_dispatch_table(device)->CmdSetViewportShadingRatePaletteNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewportShadingRatePaletteNV);
    if (strcmp(pName, "vkCmdSetCoarseSampleOrderNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoarseSampleOrderNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoarseSampleOrderNV);
    if (strcmp(pName, "vkCreateAccelerationStructureNV") == 0 && (!device || device_dispatch_table(device)->CreateAccelerationStructureNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateAccelerationStructureNV);
    if (strcmp(pName, "vkDestroyAccelerationStructureNV") == 0 && (!device || device_dispatch_table(device)->DestroyAccelerationStructureNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyAccelerationStructureNV);
    if (strcmp(pName, "vkGetAccelerationStructureMemoryRequirementsNV") == 0 && (!device || device_dispatch_table(device)->GetAccelerationStructureMemoryRequirementsNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetAccelerationStructureMemoryRequirementsNV);
    if (strcmp(pName, "vkBindAccelerationStructureMemoryNV") == 0 && (!device || device_dispatch_table(device)->BindAccelerationStructureMemoryNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindAccelerationStructureMemoryNV);
    if (strcmp(pName, "vkCmdBuildAccelerationStructureNV") == 0 && (!device || device_dispatch_table(device)->CmdBuildAccelerationStructureNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBuildAccelerationStructureNV);
    if (strcmp(pName, "vkCmdCopyAccelerationStructureNV") == 0 && (!device || device_dispatch_table(device)->CmdCopyAccelerationStructureNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyAccelerationStructureNV);
    if (strcmp(pName, "vkCmdTraceRaysNV") == 0 && (!device || device_dispatch_table(device)->CmdTraceRaysNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdTraceRaysNV);
    if (strcmp(pName, "vkCreateRayTracingPipelinesNV") == 0 && (!device || device_dispatch_table(device)->CreateRayTracingPipelinesNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateRayTracingPipelinesNV);
    if (strcmp(pName, "vkGetRayTracingShaderGroupHandlesKHR") == 0 && (!device || device_dispatch_table(device)->GetRayTracingShaderGroupHandlesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRayTracingShaderGroupHandlesKHR);
    if (strcmp(pName, "vkGetRayTracingShaderGroupHandlesNV") == 0 && (!device || device_dispatch_table(device)->GetRayTracingShaderGroupHandlesNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRayTracingShaderGroupHandlesNV);
    if (strcmp(pName, "vkGetAccelerationStructureHandleNV") == 0 && (!device || device_dispatch_table(device)->GetAccelerationStructureHandleNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetAccelerationStructureHandleNV);
    if (strcmp(pName, "vkCmdWriteAccelerationStructuresPropertiesNV") == 0 && (!device || device_dispatch_table(device)->CmdWriteAccelerationStructuresPropertiesNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteAccelerationStructuresPropertiesNV);
    if (strcmp(pName, "vkCompileDeferredNV") == 0 && (!device || device_dispatch_table(device)->CompileDeferredNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCompileDeferredNV);
    if (strcmp(pName, "vkGetMemoryHostPointerPropertiesEXT") == 0 && (!device || device_dispatch_table(device)->GetMemoryHostPointerPropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryHostPointerPropertiesEXT);
    if (strcmp(pName, "vkCmdWriteBufferMarkerAMD") == 0 && (!device || device_dispatch_table(device)->CmdWriteBufferMarkerAMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteBufferMarkerAMD);
    if (strcmp(pName, "vkCmdWriteBufferMarker2AMD") == 0 && (!device || device_dispatch_table(device)->CmdWriteBufferMarker2AMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteBufferMarker2AMD);
    if (strcmp(pName, "vkGetCalibratedTimestampsEXT") == 0 && (!device || device_dispatch_table(device)->GetCalibratedTimestampsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetCalibratedTimestampsEXT);
    if (strcmp(pName, "vkCmdDrawMeshTasksNV") == 0 && (!device || device_dispatch_table(device)->CmdDrawMeshTasksNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMeshTasksNV);
    if (strcmp(pName, "vkCmdDrawMeshTasksIndirectNV") == 0 && (!device || device_dispatch_table(device)->CmdDrawMeshTasksIndirectNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMeshTasksIndirectNV);
    if (strcmp(pName, "vkCmdDrawMeshTasksIndirectCountNV") == 0 && (!device || device_dispatch_table(device)->CmdDrawMeshTasksIndirectCountNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMeshTasksIndirectCountNV);
    if (strcmp(pName, "vkCmdSetExclusiveScissorEnableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetExclusiveScissorEnableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetExclusiveScissorEnableNV);
    if (strcmp(pName, "vkCmdSetExclusiveScissorNV") == 0 && (!device || device_dispatch_table(device)->CmdSetExclusiveScissorNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetExclusiveScissorNV);
    if (strcmp(pName, "vkCmdSetCheckpointNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCheckpointNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCheckpointNV);
    if (strcmp(pName, "vkGetQueueCheckpointDataNV") == 0 && (!device || device_dispatch_table(device)->GetQueueCheckpointDataNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetQueueCheckpointDataNV);
    if (strcmp(pName, "vkGetQueueCheckpointData2NV") == 0 && (!device || device_dispatch_table(device)->GetQueueCheckpointData2NV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetQueueCheckpointData2NV);
    if (strcmp(pName, "vkSetSwapchainPresentTimingQueueSizeEXT") == 0 && (!device || device_dispatch_table(device)->SetSwapchainPresentTimingQueueSizeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetSwapchainPresentTimingQueueSizeEXT);
    if (strcmp(pName, "vkGetSwapchainTimingPropertiesEXT") == 0 && (!device || device_dispatch_table(device)->GetSwapchainTimingPropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSwapchainTimingPropertiesEXT);
    if (strcmp(pName, "vkGetSwapchainTimeDomainPropertiesEXT") == 0 && (!device || device_dispatch_table(device)->GetSwapchainTimeDomainPropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSwapchainTimeDomainPropertiesEXT);
    if (strcmp(pName, "vkGetPastPresentationTimingEXT") == 0 && (!device || device_dispatch_table(device)->GetPastPresentationTimingEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPastPresentationTimingEXT);
    if (strcmp(pName, "vkInitializePerformanceApiINTEL") == 0 && (!device || device_dispatch_table(device)->InitializePerformanceApiINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkInitializePerformanceApiINTEL);
    if (strcmp(pName, "vkUninitializePerformanceApiINTEL") == 0 && (!device || device_dispatch_table(device)->UninitializePerformanceApiINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUninitializePerformanceApiINTEL);
    if (strcmp(pName, "vkCmdSetPerformanceMarkerINTEL") == 0 && (!device || device_dispatch_table(device)->CmdSetPerformanceMarkerINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPerformanceMarkerINTEL);
    if (strcmp(pName, "vkCmdSetPerformanceStreamMarkerINTEL") == 0 && (!device || device_dispatch_table(device)->CmdSetPerformanceStreamMarkerINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPerformanceStreamMarkerINTEL);
    if (strcmp(pName, "vkCmdSetPerformanceOverrideINTEL") == 0 && (!device || device_dispatch_table(device)->CmdSetPerformanceOverrideINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPerformanceOverrideINTEL);
    if (strcmp(pName, "vkAcquirePerformanceConfigurationINTEL") == 0 && (!device || device_dispatch_table(device)->AcquirePerformanceConfigurationINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquirePerformanceConfigurationINTEL);
    if (strcmp(pName, "vkReleasePerformanceConfigurationINTEL") == 0 && (!device || device_dispatch_table(device)->ReleasePerformanceConfigurationINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleasePerformanceConfigurationINTEL);
    if (strcmp(pName, "vkQueueSetPerformanceConfigurationINTEL") == 0 && (!device || device_dispatch_table(device)->QueueSetPerformanceConfigurationINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueSetPerformanceConfigurationINTEL);
    if (strcmp(pName, "vkGetPerformanceParameterINTEL") == 0 && (!device || device_dispatch_table(device)->GetPerformanceParameterINTEL))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPerformanceParameterINTEL);
    if (strcmp(pName, "vkSetLocalDimmingAMD") == 0 && (!device || device_dispatch_table(device)->SetLocalDimmingAMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetLocalDimmingAMD);
    if (strcmp(pName, "vkGetBufferDeviceAddressEXT") == 0 && (!device || device_dispatch_table(device)->GetBufferDeviceAddressEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferDeviceAddressEXT);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    if (strcmp(pName, "vkAcquireFullScreenExclusiveModeEXT") == 0 && (!device || device_dispatch_table(device)->AcquireFullScreenExclusiveModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAcquireFullScreenExclusiveModeEXT);
    if (strcmp(pName, "vkReleaseFullScreenExclusiveModeEXT") == 0 && (!device || device_dispatch_table(device)->ReleaseFullScreenExclusiveModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleaseFullScreenExclusiveModeEXT);
    if (strcmp(pName, "vkGetDeviceGroupSurfacePresentModes2EXT") == 0 && (!device || device_dispatch_table(device)->GetDeviceGroupSurfacePresentModes2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceGroupSurfacePresentModes2EXT);
#endif  // VK_USE_PLATFORM_WIN32_KHR
    if (strcmp(pName, "vkCmdSetLineStippleEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetLineStippleEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLineStippleEXT);
    if (strcmp(pName, "vkResetQueryPoolEXT") == 0 && (!device || device_dispatch_table(device)->ResetQueryPoolEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkResetQueryPoolEXT);
    if (strcmp(pName, "vkCmdSetCullModeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetCullModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCullModeEXT);
    if (strcmp(pName, "vkCmdSetFrontFaceEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetFrontFaceEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetFrontFaceEXT);
    if (strcmp(pName, "vkCmdSetPrimitiveTopologyEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetPrimitiveTopologyEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPrimitiveTopologyEXT);
    if (strcmp(pName, "vkCmdSetViewportWithCountEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetViewportWithCountEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewportWithCountEXT);
    if (strcmp(pName, "vkCmdSetScissorWithCountEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetScissorWithCountEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetScissorWithCountEXT);
    if (strcmp(pName, "vkCmdBindVertexBuffers2EXT") == 0 && (!device || device_dispatch_table(device)->CmdBindVertexBuffers2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindVertexBuffers2EXT);
    if (strcmp(pName, "vkCmdSetDepthTestEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthTestEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthTestEnableEXT);
    if (strcmp(pName, "vkCmdSetDepthWriteEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthWriteEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthWriteEnableEXT);
    if (strcmp(pName, "vkCmdSetDepthCompareOpEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthCompareOpEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthCompareOpEXT);
    if (strcmp(pName, "vkCmdSetDepthBoundsTestEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBoundsTestEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBoundsTestEnableEXT);
    if (strcmp(pName, "vkCmdSetStencilTestEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilTestEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilTestEnableEXT);
    if (strcmp(pName, "vkCmdSetStencilOpEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetStencilOpEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetStencilOpEXT);
    if (strcmp(pName, "vkCopyMemoryToImageEXT") == 0 && (!device || device_dispatch_table(device)->CopyMemoryToImageEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyMemoryToImageEXT);
    if (strcmp(pName, "vkCopyImageToMemoryEXT") == 0 && (!device || device_dispatch_table(device)->CopyImageToMemoryEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyImageToMemoryEXT);
    if (strcmp(pName, "vkCopyImageToImageEXT") == 0 && (!device || device_dispatch_table(device)->CopyImageToImageEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyImageToImageEXT);
    if (strcmp(pName, "vkTransitionImageLayoutEXT") == 0 && (!device || device_dispatch_table(device)->TransitionImageLayoutEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkTransitionImageLayoutEXT);
    if (strcmp(pName, "vkGetImageSubresourceLayout2EXT") == 0 && (!device || device_dispatch_table(device)->GetImageSubresourceLayout2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageSubresourceLayout2EXT);
    if (strcmp(pName, "vkReleaseSwapchainImagesEXT") == 0 && (!device || device_dispatch_table(device)->ReleaseSwapchainImagesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkReleaseSwapchainImagesEXT);
    if (strcmp(pName, "vkGetGeneratedCommandsMemoryRequirementsNV") == 0 && (!device || device_dispatch_table(device)->GetGeneratedCommandsMemoryRequirementsNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetGeneratedCommandsMemoryRequirementsNV);
    if (strcmp(pName, "vkCmdPreprocessGeneratedCommandsNV") == 0 && (!device || device_dispatch_table(device)->CmdPreprocessGeneratedCommandsNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPreprocessGeneratedCommandsNV);
    if (strcmp(pName, "vkCmdExecuteGeneratedCommandsNV") == 0 && (!device || device_dispatch_table(device)->CmdExecuteGeneratedCommandsNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdExecuteGeneratedCommandsNV);
    if (strcmp(pName, "vkCmdBindPipelineShaderGroupNV") == 0 && (!device || device_dispatch_table(device)->CmdBindPipelineShaderGroupNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindPipelineShaderGroupNV);
    if (strcmp(pName, "vkCreateIndirectCommandsLayoutNV") == 0 && (!device || device_dispatch_table(device)->CreateIndirectCommandsLayoutNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateIndirectCommandsLayoutNV);
    if (strcmp(pName, "vkDestroyIndirectCommandsLayoutNV") == 0 && (!device || device_dispatch_table(device)->DestroyIndirectCommandsLayoutNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyIndirectCommandsLayoutNV);
    if (strcmp(pName, "vkCmdSetDepthBias2EXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBias2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBias2EXT);
    if (strcmp(pName, "vkCreatePrivateDataSlotEXT") == 0 && (!device || device_dispatch_table(device)->CreatePrivateDataSlotEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreatePrivateDataSlotEXT);
    if (strcmp(pName, "vkDestroyPrivateDataSlotEXT") == 0 && (!device || device_dispatch_table(device)->DestroyPrivateDataSlotEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyPrivateDataSlotEXT);
    if (strcmp(pName, "vkSetPrivateDataEXT") == 0 && (!device || device_dispatch_table(device)->SetPrivateDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetPrivateDataEXT);
    if (strcmp(pName, "vkGetPrivateDataEXT") == 0 && (!device || device_dispatch_table(device)->GetPrivateDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPrivateDataEXT);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    if (strcmp(pName, "vkCreateCudaModuleNV") == 0 && (!device || device_dispatch_table(device)->CreateCudaModuleNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateCudaModuleNV);
    if (strcmp(pName, "vkGetCudaModuleCacheNV") == 0 && (!device || device_dispatch_table(device)->GetCudaModuleCacheNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetCudaModuleCacheNV);
    if (strcmp(pName, "vkCreateCudaFunctionNV") == 0 && (!device || device_dispatch_table(device)->CreateCudaFunctionNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateCudaFunctionNV);
    if (strcmp(pName, "vkDestroyCudaModuleNV") == 0 && (!device || device_dispatch_table(device)->DestroyCudaModuleNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyCudaModuleNV);
    if (strcmp(pName, "vkDestroyCudaFunctionNV") == 0 && (!device || device_dispatch_table(device)->DestroyCudaFunctionNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyCudaFunctionNV);
    if (strcmp(pName, "vkCmdCudaLaunchKernelNV") == 0 && (!device || device_dispatch_table(device)->CmdCudaLaunchKernelNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCudaLaunchKernelNV);
#endif  // VK_ENABLE_BETA_EXTENSIONS
    if (strcmp(pName, "vkCmdDispatchTileQCOM") == 0 && (!device || device_dispatch_table(device)->CmdDispatchTileQCOM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchTileQCOM);
    if (strcmp(pName, "vkCmdBeginPerTileExecutionQCOM") == 0 && (!device || device_dispatch_table(device)->CmdBeginPerTileExecutionQCOM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginPerTileExecutionQCOM);
    if (strcmp(pName, "vkCmdEndPerTileExecutionQCOM") == 0 && (!device || device_dispatch_table(device)->CmdEndPerTileExecutionQCOM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndPerTileExecutionQCOM);
#if defined(VK_USE_PLATFORM_METAL_EXT)
    if (strcmp(pName, "vkExportMetalObjectsEXT") == 0 && (!device || device_dispatch_table(device)->ExportMetalObjectsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkExportMetalObjectsEXT);
#endif  // VK_USE_PLATFORM_METAL_EXT
    if (strcmp(pName, "vkGetDescriptorSetLayoutSizeEXT") == 0 && (!device || device_dispatch_table(device)->GetDescriptorSetLayoutSizeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorSetLayoutSizeEXT);
    if (strcmp(pName, "vkGetDescriptorSetLayoutBindingOffsetEXT") == 0 && (!device || device_dispatch_table(device)->GetDescriptorSetLayoutBindingOffsetEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorSetLayoutBindingOffsetEXT);
    if (strcmp(pName, "vkGetDescriptorEXT") == 0 && (!device || device_dispatch_table(device)->GetDescriptorEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorEXT);
    if (strcmp(pName, "vkCmdBindDescriptorBuffersEXT") == 0 && (!device || device_dispatch_table(device)->CmdBindDescriptorBuffersEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindDescriptorBuffersEXT);
    if (strcmp(pName, "vkCmdSetDescriptorBufferOffsetsEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDescriptorBufferOffsetsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDescriptorBufferOffsetsEXT);
    if (strcmp(pName, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT") == 0 && (!device || device_dispatch_table(device)->CmdBindDescriptorBufferEmbeddedSamplersEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindDescriptorBufferEmbeddedSamplersEXT);
    if (strcmp(pName, "vkGetBufferOpaqueCaptureDescriptorDataEXT") == 0 && (!device || device_dispatch_table(device)->GetBufferOpaqueCaptureDescriptorDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferOpaqueCaptureDescriptorDataEXT);
    if (strcmp(pName, "vkGetImageOpaqueCaptureDescriptorDataEXT") == 0 && (!device || device_dispatch_table(device)->GetImageOpaqueCaptureDescriptorDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageOpaqueCaptureDescriptorDataEXT);
    if (strcmp(pName, "vkGetImageViewOpaqueCaptureDescriptorDataEXT") == 0 && (!device || device_dispatch_table(device)->GetImageViewOpaqueCaptureDescriptorDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetImageViewOpaqueCaptureDescriptorDataEXT);
    if (strcmp(pName, "vkGetSamplerOpaqueCaptureDescriptorDataEXT") == 0 && (!device || device_dispatch_table(device)->GetSamplerOpaqueCaptureDescriptorDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSamplerOpaqueCaptureDescriptorDataEXT);
    if (strcmp(pName, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT") == 0 && (!device || device_dispatch_table(device)->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT);
    if (strcmp(pName, "vkCmdSetFragmentShadingRateEnumNV") == 0 && (!device || device_dispatch_table(device)->CmdSetFragmentShadingRateEnumNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetFragmentShadingRateEnumNV);
    if (strcmp(pName, "vkGetDeviceFaultInfoEXT") == 0 && (!device || device_dispatch_table(device)->GetDeviceFaultInfoEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceFaultInfoEXT);
    if (strcmp(pName, "vkCmdSetVertexInputEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetVertexInputEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetVertexInputEXT);
#if defined(VK_USE_PLATFORM_FUCHSIA)
    if (strcmp(pName, "vkGetMemoryZirconHandleFUCHSIA") == 0 && (!device || device_dispatch_table(device)->GetMemoryZirconHandleFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryZirconHandleFUCHSIA);
    if (strcmp(pName, "vkGetMemoryZirconHandlePropertiesFUCHSIA") == 0 && (!device || device_dispatch_table(device)->GetMemoryZirconHandlePropertiesFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryZirconHandlePropertiesFUCHSIA);
    if (strcmp(pName, "vkImportSemaphoreZirconHandleFUCHSIA") == 0 && (!device || device_dispatch_table(device)->ImportSemaphoreZirconHandleFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkImportSemaphoreZirconHandleFUCHSIA);
    if (strcmp(pName, "vkGetSemaphoreZirconHandleFUCHSIA") == 0 && (!device || device_dispatch_table(device)->GetSemaphoreZirconHandleFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetSemaphoreZirconHandleFUCHSIA);
    if (strcmp(pName, "vkCreateBufferCollectionFUCHSIA") == 0 && (!device || device_dispatch_table(device)->CreateBufferCollectionFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateBufferCollectionFUCHSIA);
    if (strcmp(pName, "vkSetBufferCollectionImageConstraintsFUCHSIA") == 0 && (!device || device_dispatch_table(device)->SetBufferCollectionImageConstraintsFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetBufferCollectionImageConstraintsFUCHSIA);
    if (strcmp(pName, "vkSetBufferCollectionBufferConstraintsFUCHSIA") == 0 && (!device || device_dispatch_table(device)->SetBufferCollectionBufferConstraintsFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetBufferCollectionBufferConstraintsFUCHSIA);
    if (strcmp(pName, "vkDestroyBufferCollectionFUCHSIA") == 0 && (!device || device_dispatch_table(device)->DestroyBufferCollectionFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyBufferCollectionFUCHSIA);
    if (strcmp(pName, "vkGetBufferCollectionPropertiesFUCHSIA") == 0 && (!device || device_dispatch_table(device)->GetBufferCollectionPropertiesFUCHSIA))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetBufferCollectionPropertiesFUCHSIA);
#endif  // VK_USE_PLATFORM_FUCHSIA
    if (strcmp(pName, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI") == 0 && (!device || device_dispatch_table(device)->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI);
    if (strcmp(pName, "vkCmdSubpassShadingHUAWEI") == 0 && (!device || device_dispatch_table(device)->CmdSubpassShadingHUAWEI))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSubpassShadingHUAWEI);
    if (strcmp(pName, "vkCmdBindInvocationMaskHUAWEI") == 0 && (!device || device_dispatch_table(device)->CmdBindInvocationMaskHUAWEI))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindInvocationMaskHUAWEI);
    if (strcmp(pName, "vkGetMemoryRemoteAddressNV") == 0 && (!device || device_dispatch_table(device)->GetMemoryRemoteAddressNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryRemoteAddressNV);
    if (strcmp(pName, "vkGetPipelinePropertiesEXT") == 0 && (!device || device_dispatch_table(device)->GetPipelinePropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelinePropertiesEXT);
    if (strcmp(pName, "vkCmdSetPatchControlPointsEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetPatchControlPointsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPatchControlPointsEXT);
    if (strcmp(pName, "vkCmdSetRasterizerDiscardEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetRasterizerDiscardEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRasterizerDiscardEnableEXT);
    if (strcmp(pName, "vkCmdSetDepthBiasEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthBiasEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthBiasEnableEXT);
    if (strcmp(pName, "vkCmdSetLogicOpEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetLogicOpEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLogicOpEXT);
    if (strcmp(pName, "vkCmdSetPrimitiveRestartEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetPrimitiveRestartEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPrimitiveRestartEnableEXT);
    if (strcmp(pName, "vkCmdSetColorWriteEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetColorWriteEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetColorWriteEnableEXT);
    if (strcmp(pName, "vkCmdDrawMultiEXT") == 0 && (!device || device_dispatch_table(device)->CmdDrawMultiEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMultiEXT);
    if (strcmp(pName, "vkCmdDrawMultiIndexedEXT") == 0 && (!device || device_dispatch_table(device)->CmdDrawMultiIndexedEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMultiIndexedEXT);
    if (strcmp(pName, "vkCreateMicromapEXT") == 0 && (!device || device_dispatch_table(device)->CreateMicromapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateMicromapEXT);
    if (strcmp(pName, "vkDestroyMicromapEXT") == 0 && (!device || device_dispatch_table(device)->DestroyMicromapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyMicromapEXT);
    if (strcmp(pName, "vkCmdBuildMicromapsEXT") == 0 && (!device || device_dispatch_table(device)->CmdBuildMicromapsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBuildMicromapsEXT);
    if (strcmp(pName, "vkBuildMicromapsEXT") == 0 && (!device || device_dispatch_table(device)->BuildMicromapsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBuildMicromapsEXT);
    if (strcmp(pName, "vkCopyMicromapEXT") == 0 && (!device || device_dispatch_table(device)->CopyMicromapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyMicromapEXT);
    if (strcmp(pName, "vkCopyMicromapToMemoryEXT") == 0 && (!device || device_dispatch_table(device)->CopyMicromapToMemoryEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyMicromapToMemoryEXT);
    if (strcmp(pName, "vkCopyMemoryToMicromapEXT") == 0 && (!device || device_dispatch_table(device)->CopyMemoryToMicromapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyMemoryToMicromapEXT);
    if (strcmp(pName, "vkWriteMicromapsPropertiesEXT") == 0 && (!device || device_dispatch_table(device)->WriteMicromapsPropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWriteMicromapsPropertiesEXT);
    if (strcmp(pName, "vkCmdCopyMicromapEXT") == 0 && (!device || device_dispatch_table(device)->CmdCopyMicromapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMicromapEXT);
    if (strcmp(pName, "vkCmdCopyMicromapToMemoryEXT") == 0 && (!device || device_dispatch_table(device)->CmdCopyMicromapToMemoryEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMicromapToMemoryEXT);
    if (strcmp(pName, "vkCmdCopyMemoryToMicromapEXT") == 0 && (!device || device_dispatch_table(device)->CmdCopyMemoryToMicromapEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMemoryToMicromapEXT);
    if (strcmp(pName, "vkCmdWriteMicromapsPropertiesEXT") == 0 && (!device || device_dispatch_table(device)->CmdWriteMicromapsPropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteMicromapsPropertiesEXT);
    if (strcmp(pName, "vkGetDeviceMicromapCompatibilityEXT") == 0 && (!device || device_dispatch_table(device)->GetDeviceMicromapCompatibilityEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceMicromapCompatibilityEXT);
    if (strcmp(pName, "vkGetMicromapBuildSizesEXT") == 0 && (!device || device_dispatch_table(device)->GetMicromapBuildSizesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMicromapBuildSizesEXT);
    if (strcmp(pName, "vkCmdDrawClusterHUAWEI") == 0 && (!device || device_dispatch_table(device)->CmdDrawClusterHUAWEI))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawClusterHUAWEI);
    if (strcmp(pName, "vkCmdDrawClusterIndirectHUAWEI") == 0 && (!device || device_dispatch_table(device)->CmdDrawClusterIndirectHUAWEI))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawClusterIndirectHUAWEI);
    if (strcmp(pName, "vkSetDeviceMemoryPriorityEXT") == 0 && (!device || device_dispatch_table(device)->SetDeviceMemoryPriorityEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetDeviceMemoryPriorityEXT);
    if (strcmp(pName, "vkGetDescriptorSetLayoutHostMappingInfoVALVE") == 0 && (!device || device_dispatch_table(device)->GetDescriptorSetLayoutHostMappingInfoVALVE))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorSetLayoutHostMappingInfoVALVE);
    if (strcmp(pName, "vkGetDescriptorSetHostMappingVALVE") == 0 && (!device || device_dispatch_table(device)->GetDescriptorSetHostMappingVALVE))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDescriptorSetHostMappingVALVE);
    if (strcmp(pName, "vkCmdCopyMemoryIndirectNV") == 0 && (!device || device_dispatch_table(device)->CmdCopyMemoryIndirectNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMemoryIndirectNV);
    if (strcmp(pName, "vkCmdCopyMemoryToImageIndirectNV") == 0 && (!device || device_dispatch_table(device)->CmdCopyMemoryToImageIndirectNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMemoryToImageIndirectNV);
    if (strcmp(pName, "vkCmdDecompressMemoryNV") == 0 && (!device || device_dispatch_table(device)->CmdDecompressMemoryNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDecompressMemoryNV);
    if (strcmp(pName, "vkCmdDecompressMemoryIndirectCountNV") == 0 && (!device || device_dispatch_table(device)->CmdDecompressMemoryIndirectCountNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDecompressMemoryIndirectCountNV);
    if (strcmp(pName, "vkGetPipelineIndirectMemoryRequirementsNV") == 0 && (!device || device_dispatch_table(device)->GetPipelineIndirectMemoryRequirementsNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineIndirectMemoryRequirementsNV);
    if (strcmp(pName, "vkCmdUpdatePipelineIndirectBufferNV") == 0 && (!device || device_dispatch_table(device)->CmdUpdatePipelineIndirectBufferNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdUpdatePipelineIndirectBufferNV);
    if (strcmp(pName, "vkGetPipelineIndirectDeviceAddressNV") == 0 && (!device || device_dispatch_table(device)->GetPipelineIndirectDeviceAddressNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPipelineIndirectDeviceAddressNV);
#if defined(VK_USE_PLATFORM_OHOS)
    if (strcmp(pName, "vkGetNativeBufferPropertiesOHOS") == 0 && (!device || device_dispatch_table(device)->GetNativeBufferPropertiesOHOS))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetNativeBufferPropertiesOHOS);
    if (strcmp(pName, "vkGetMemoryNativeBufferOHOS") == 0 && (!device || device_dispatch_table(device)->GetMemoryNativeBufferOHOS))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryNativeBufferOHOS);
#endif  // VK_USE_PLATFORM_OHOS
    if (strcmp(pName, "vkCmdSetDepthClampEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthClampEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthClampEnableEXT);
    if (strcmp(pName, "vkCmdSetPolygonModeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetPolygonModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetPolygonModeEXT);
    if (strcmp(pName, "vkCmdSetRasterizationSamplesEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetRasterizationSamplesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRasterizationSamplesEXT);
    if (strcmp(pName, "vkCmdSetSampleMaskEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetSampleMaskEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetSampleMaskEXT);
    if (strcmp(pName, "vkCmdSetAlphaToCoverageEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetAlphaToCoverageEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetAlphaToCoverageEnableEXT);
    if (strcmp(pName, "vkCmdSetAlphaToOneEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetAlphaToOneEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetAlphaToOneEnableEXT);
    if (strcmp(pName, "vkCmdSetLogicOpEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetLogicOpEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLogicOpEnableEXT);
    if (strcmp(pName, "vkCmdSetColorBlendEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetColorBlendEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetColorBlendEnableEXT);
    if (strcmp(pName, "vkCmdSetColorBlendEquationEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetColorBlendEquationEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetColorBlendEquationEXT);
    if (strcmp(pName, "vkCmdSetColorWriteMaskEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetColorWriteMaskEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetColorWriteMaskEXT);
    if (strcmp(pName, "vkCmdSetTessellationDomainOriginEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetTessellationDomainOriginEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetTessellationDomainOriginEXT);
    if (strcmp(pName, "vkCmdSetRasterizationStreamEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetRasterizationStreamEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRasterizationStreamEXT);
    if (strcmp(pName, "vkCmdSetConservativeRasterizationModeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetConservativeRasterizationModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetConservativeRasterizationModeEXT);
    if (strcmp(pName, "vkCmdSetExtraPrimitiveOverestimationSizeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetExtraPrimitiveOverestimationSizeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetExtraPrimitiveOverestimationSizeEXT);
    if (strcmp(pName, "vkCmdSetDepthClipEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthClipEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthClipEnableEXT);
    if (strcmp(pName, "vkCmdSetSampleLocationsEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetSampleLocationsEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetSampleLocationsEnableEXT);
    if (strcmp(pName, "vkCmdSetColorBlendAdvancedEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetColorBlendAdvancedEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetColorBlendAdvancedEXT);
    if (strcmp(pName, "vkCmdSetProvokingVertexModeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetProvokingVertexModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetProvokingVertexModeEXT);
    if (strcmp(pName, "vkCmdSetLineRasterizationModeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetLineRasterizationModeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLineRasterizationModeEXT);
    if (strcmp(pName, "vkCmdSetLineStippleEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetLineStippleEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetLineStippleEnableEXT);
    if (strcmp(pName, "vkCmdSetDepthClipNegativeOneToOneEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthClipNegativeOneToOneEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthClipNegativeOneToOneEXT);
    if (strcmp(pName, "vkCmdSetViewportWScalingEnableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetViewportWScalingEnableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewportWScalingEnableNV);
    if (strcmp(pName, "vkCmdSetViewportSwizzleNV") == 0 && (!device || device_dispatch_table(device)->CmdSetViewportSwizzleNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetViewportSwizzleNV);
    if (strcmp(pName, "vkCmdSetCoverageToColorEnableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoverageToColorEnableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoverageToColorEnableNV);
    if (strcmp(pName, "vkCmdSetCoverageToColorLocationNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoverageToColorLocationNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoverageToColorLocationNV);
    if (strcmp(pName, "vkCmdSetCoverageModulationModeNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoverageModulationModeNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoverageModulationModeNV);
    if (strcmp(pName, "vkCmdSetCoverageModulationTableEnableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoverageModulationTableEnableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoverageModulationTableEnableNV);
    if (strcmp(pName, "vkCmdSetCoverageModulationTableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoverageModulationTableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoverageModulationTableNV);
    if (strcmp(pName, "vkCmdSetShadingRateImageEnableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetShadingRateImageEnableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetShadingRateImageEnableNV);
    if (strcmp(pName, "vkCmdSetRepresentativeFragmentTestEnableNV") == 0 && (!device || device_dispatch_table(device)->CmdSetRepresentativeFragmentTestEnableNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRepresentativeFragmentTestEnableNV);
    if (strcmp(pName, "vkCmdSetCoverageReductionModeNV") == 0 && (!device || device_dispatch_table(device)->CmdSetCoverageReductionModeNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetCoverageReductionModeNV);
    if (strcmp(pName, "vkCreateTensorARM") == 0 && (!device || device_dispatch_table(device)->CreateTensorARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateTensorARM);
    if (strcmp(pName, "vkDestroyTensorARM") == 0 && (!device || device_dispatch_table(device)->DestroyTensorARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyTensorARM);
    if (strcmp(pName, "vkCreateTensorViewARM") == 0 && (!device || device_dispatch_table(device)->CreateTensorViewARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateTensorViewARM);
    if (strcmp(pName, "vkDestroyTensorViewARM") == 0 && (!device || device_dispatch_table(device)->DestroyTensorViewARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyTensorViewARM);
    if (strcmp(pName, "vkGetTensorMemoryRequirementsARM") == 0 && (!device || device_dispatch_table(device)->GetTensorMemoryRequirementsARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetTensorMemoryRequirementsARM);
    if (strcmp(pName, "vkBindTensorMemoryARM") == 0 && (!device || device_dispatch_table(device)->BindTensorMemoryARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindTensorMemoryARM);
    if (strcmp(pName, "vkGetDeviceTensorMemoryRequirementsARM") == 0 && (!device || device_dispatch_table(device)->GetDeviceTensorMemoryRequirementsARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceTensorMemoryRequirementsARM);
    if (strcmp(pName, "vkCmdCopyTensorARM") == 0 && (!device || device_dispatch_table(device)->CmdCopyTensorARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyTensorARM);
    if (strcmp(pName, "vkGetTensorOpaqueCaptureDescriptorDataARM") == 0 && (!device || device_dispatch_table(device)->GetTensorOpaqueCaptureDescriptorDataARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetTensorOpaqueCaptureDescriptorDataARM);
    if (strcmp(pName, "vkGetTensorViewOpaqueCaptureDescriptorDataARM") == 0 && (!device || device_dispatch_table(device)->GetTensorViewOpaqueCaptureDescriptorDataARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetTensorViewOpaqueCaptureDescriptorDataARM);
    if (strcmp(pName, "vkGetShaderModuleIdentifierEXT") == 0 && (!device || device_dispatch_table(device)->GetShaderModuleIdentifierEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetShaderModuleIdentifierEXT);
    if (strcmp(pName, "vkGetShaderModuleCreateInfoIdentifierEXT") == 0 && (!device || device_dispatch_table(device)->GetShaderModuleCreateInfoIdentifierEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetShaderModuleCreateInfoIdentifierEXT);
    if (strcmp(pName, "vkCreateOpticalFlowSessionNV") == 0 && (!device || device_dispatch_table(device)->CreateOpticalFlowSessionNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateOpticalFlowSessionNV);
    if (strcmp(pName, "vkDestroyOpticalFlowSessionNV") == 0 && (!device || device_dispatch_table(device)->DestroyOpticalFlowSessionNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyOpticalFlowSessionNV);
    if (strcmp(pName, "vkBindOpticalFlowSessionImageNV") == 0 && (!device || device_dispatch_table(device)->BindOpticalFlowSessionImageNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindOpticalFlowSessionImageNV);
    if (strcmp(pName, "vkCmdOpticalFlowExecuteNV") == 0 && (!device || device_dispatch_table(device)->CmdOpticalFlowExecuteNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdOpticalFlowExecuteNV);
    if (strcmp(pName, "vkAntiLagUpdateAMD") == 0 && (!device || device_dispatch_table(device)->AntiLagUpdateAMD))
        return reinterpret_cast<PFN_vkVoidFunction>(vkAntiLagUpdateAMD);
    if (strcmp(pName, "vkCreateShadersEXT") == 0 && (!device || device_dispatch_table(device)->CreateShadersEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateShadersEXT);
    if (strcmp(pName, "vkDestroyShaderEXT") == 0 && (!device || device_dispatch_table(device)->DestroyShaderEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyShaderEXT);
    if (strcmp(pName, "vkGetShaderBinaryDataEXT") == 0 && (!device || device_dispatch_table(device)->GetShaderBinaryDataEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetShaderBinaryDataEXT);
    if (strcmp(pName, "vkCmdBindShadersEXT") == 0 && (!device || device_dispatch_table(device)->CmdBindShadersEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindShadersEXT);
    if (strcmp(pName, "vkCmdSetDepthClampRangeEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetDepthClampRangeEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetDepthClampRangeEXT);
    if (strcmp(pName, "vkGetFramebufferTilePropertiesQCOM") == 0 && (!device || device_dispatch_table(device)->GetFramebufferTilePropertiesQCOM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetFramebufferTilePropertiesQCOM);
    if (strcmp(pName, "vkGetDynamicRenderingTilePropertiesQCOM") == 0 && (!device || device_dispatch_table(device)->GetDynamicRenderingTilePropertiesQCOM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDynamicRenderingTilePropertiesQCOM);
    if (strcmp(pName, "vkConvertCooperativeVectorMatrixNV") == 0 && (!device || device_dispatch_table(device)->ConvertCooperativeVectorMatrixNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkConvertCooperativeVectorMatrixNV);
    if (strcmp(pName, "vkCmdConvertCooperativeVectorMatrixNV") == 0 && (!device || device_dispatch_table(device)->CmdConvertCooperativeVectorMatrixNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdConvertCooperativeVectorMatrixNV);
    if (strcmp(pName, "vkSetLatencySleepModeNV") == 0 && (!device || device_dispatch_table(device)->SetLatencySleepModeNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetLatencySleepModeNV);
    if (strcmp(pName, "vkLatencySleepNV") == 0 && (!device || device_dispatch_table(device)->LatencySleepNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkLatencySleepNV);
    if (strcmp(pName, "vkSetLatencyMarkerNV") == 0 && (!device || device_dispatch_table(device)->SetLatencyMarkerNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkSetLatencyMarkerNV);
    if (strcmp(pName, "vkGetLatencyTimingsNV") == 0 && (!device || device_dispatch_table(device)->GetLatencyTimingsNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetLatencyTimingsNV);
    if (strcmp(pName, "vkQueueNotifyOutOfBandNV") == 0 && (!device || device_dispatch_table(device)->QueueNotifyOutOfBandNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkQueueNotifyOutOfBandNV);
    if (strcmp(pName, "vkCreateDataGraphPipelinesARM") == 0 && (!device || device_dispatch_table(device)->CreateDataGraphPipelinesARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDataGraphPipelinesARM);
    if (strcmp(pName, "vkCreateDataGraphPipelineSessionARM") == 0 && (!device || device_dispatch_table(device)->CreateDataGraphPipelineSessionARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateDataGraphPipelineSessionARM);
    if (strcmp(pName, "vkGetDataGraphPipelineSessionBindPointRequirementsARM") == 0 && (!device || device_dispatch_table(device)->GetDataGraphPipelineSessionBindPointRequirementsARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDataGraphPipelineSessionBindPointRequirementsARM);
    if (strcmp(pName, "vkGetDataGraphPipelineSessionMemoryRequirementsARM") == 0 && (!device || device_dispatch_table(device)->GetDataGraphPipelineSessionMemoryRequirementsARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDataGraphPipelineSessionMemoryRequirementsARM);
    if (strcmp(pName, "vkBindDataGraphPipelineSessionMemoryARM") == 0 && (!device || device_dispatch_table(device)->BindDataGraphPipelineSessionMemoryARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBindDataGraphPipelineSessionMemoryARM);
    if (strcmp(pName, "vkDestroyDataGraphPipelineSessionARM") == 0 && (!device || device_dispatch_table(device)->DestroyDataGraphPipelineSessionARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyDataGraphPipelineSessionARM);
    if (strcmp(pName, "vkCmdDispatchDataGraphARM") == 0 && (!device || device_dispatch_table(device)->CmdDispatchDataGraphARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDispatchDataGraphARM);
    if (strcmp(pName, "vkGetDataGraphPipelineAvailablePropertiesARM") == 0 && (!device || device_dispatch_table(device)->GetDataGraphPipelineAvailablePropertiesARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDataGraphPipelineAvailablePropertiesARM);
    if (strcmp(pName, "vkGetDataGraphPipelinePropertiesARM") == 0 && (!device || device_dispatch_table(device)->GetDataGraphPipelinePropertiesARM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDataGraphPipelinePropertiesARM);
    if (strcmp(pName, "vkCmdSetAttachmentFeedbackLoopEnableEXT") == 0 && (!device || device_dispatch_table(device)->CmdSetAttachmentFeedbackLoopEnableEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetAttachmentFeedbackLoopEnableEXT);
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
    if (strcmp(pName, "vkGetScreenBufferPropertiesQNX") == 0 && (!device || device_dispatch_table(device)->GetScreenBufferPropertiesQNX))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetScreenBufferPropertiesQNX);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
    if (strcmp(pName, "vkCmdBindTileMemoryQCOM") == 0 && (!device || device_dispatch_table(device)->CmdBindTileMemoryQCOM))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBindTileMemoryQCOM);
    if (strcmp(pName, "vkCmdDecompressMemoryEXT") == 0 && (!device || device_dispatch_table(device)->CmdDecompressMemoryEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDecompressMemoryEXT);
    if (strcmp(pName, "vkCmdDecompressMemoryIndirectCountEXT") == 0 && (!device || device_dispatch_table(device)->CmdDecompressMemoryIndirectCountEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDecompressMemoryIndirectCountEXT);
    if (strcmp(pName, "vkCreateExternalComputeQueueNV") == 0 && (!device || device_dispatch_table(device)->CreateExternalComputeQueueNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateExternalComputeQueueNV);
    if (strcmp(pName, "vkDestroyExternalComputeQueueNV") == 0 && (!device || device_dispatch_table(device)->DestroyExternalComputeQueueNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyExternalComputeQueueNV);
    if (strcmp(pName, "vkGetExternalComputeQueueDataNV") == 0 && (!device || device_dispatch_table(device)->GetExternalComputeQueueDataNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetExternalComputeQueueDataNV);
    if (strcmp(pName, "vkGetClusterAccelerationStructureBuildSizesNV") == 0 && (!device || device_dispatch_table(device)->GetClusterAccelerationStructureBuildSizesNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetClusterAccelerationStructureBuildSizesNV);
    if (strcmp(pName, "vkCmdBuildClusterAccelerationStructureIndirectNV") == 0 && (!device || device_dispatch_table(device)->CmdBuildClusterAccelerationStructureIndirectNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBuildClusterAccelerationStructureIndirectNV);
    if (strcmp(pName, "vkGetPartitionedAccelerationStructuresBuildSizesNV") == 0 && (!device || device_dispatch_table(device)->GetPartitionedAccelerationStructuresBuildSizesNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetPartitionedAccelerationStructuresBuildSizesNV);
    if (strcmp(pName, "vkCmdBuildPartitionedAccelerationStructuresNV") == 0 && (!device || device_dispatch_table(device)->CmdBuildPartitionedAccelerationStructuresNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBuildPartitionedAccelerationStructuresNV);
    if (strcmp(pName, "vkGetGeneratedCommandsMemoryRequirementsEXT") == 0 && (!device || device_dispatch_table(device)->GetGeneratedCommandsMemoryRequirementsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetGeneratedCommandsMemoryRequirementsEXT);
    if (strcmp(pName, "vkCmdPreprocessGeneratedCommandsEXT") == 0 && (!device || device_dispatch_table(device)->CmdPreprocessGeneratedCommandsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdPreprocessGeneratedCommandsEXT);
    if (strcmp(pName, "vkCmdExecuteGeneratedCommandsEXT") == 0 && (!device || device_dispatch_table(device)->CmdExecuteGeneratedCommandsEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdExecuteGeneratedCommandsEXT);
    if (strcmp(pName, "vkCreateIndirectCommandsLayoutEXT") == 0 && (!device || device_dispatch_table(device)->CreateIndirectCommandsLayoutEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateIndirectCommandsLayoutEXT);
    if (strcmp(pName, "vkDestroyIndirectCommandsLayoutEXT") == 0 && (!device || device_dispatch_table(device)->DestroyIndirectCommandsLayoutEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyIndirectCommandsLayoutEXT);
    if (strcmp(pName, "vkCreateIndirectExecutionSetEXT") == 0 && (!device || device_dispatch_table(device)->CreateIndirectExecutionSetEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateIndirectExecutionSetEXT);
    if (strcmp(pName, "vkDestroyIndirectExecutionSetEXT") == 0 && (!device || device_dispatch_table(device)->DestroyIndirectExecutionSetEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyIndirectExecutionSetEXT);
    if (strcmp(pName, "vkUpdateIndirectExecutionSetPipelineEXT") == 0 && (!device || device_dispatch_table(device)->UpdateIndirectExecutionSetPipelineEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUpdateIndirectExecutionSetPipelineEXT);
    if (strcmp(pName, "vkUpdateIndirectExecutionSetShaderEXT") == 0 && (!device || device_dispatch_table(device)->UpdateIndirectExecutionSetShaderEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkUpdateIndirectExecutionSetShaderEXT);
#if defined(VK_USE_PLATFORM_METAL_EXT)
    if (strcmp(pName, "vkGetMemoryMetalHandleEXT") == 0 && (!device || device_dispatch_table(device)->GetMemoryMetalHandleEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryMetalHandleEXT);
    if (strcmp(pName, "vkGetMemoryMetalHandlePropertiesEXT") == 0 && (!device || device_dispatch_table(device)->GetMemoryMetalHandlePropertiesEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetMemoryMetalHandlePropertiesEXT);
#endif  // VK_USE_PLATFORM_METAL_EXT
    if (strcmp(pName, "vkCmdEndRendering2EXT") == 0 && (!device || device_dispatch_table(device)->CmdEndRendering2EXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdEndRendering2EXT);
    if (strcmp(pName, "vkCmdBeginCustomResolveEXT") == 0 && (!device || device_dispatch_table(device)->CmdBeginCustomResolveEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBeginCustomResolveEXT);
    if (strcmp(pName, "vkCmdSetComputeOccupancyPriorityNV") == 0 && (!device || device_dispatch_table(device)->CmdSetComputeOccupancyPriorityNV))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetComputeOccupancyPriorityNV);
    if (strcmp(pName, "vkCreateAccelerationStructureKHR") == 0 && (!device || device_dispatch_table(device)->CreateAccelerationStructureKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateAccelerationStructureKHR);
    if (strcmp(pName, "vkDestroyAccelerationStructureKHR") == 0 && (!device || device_dispatch_table(device)->DestroyAccelerationStructureKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkDestroyAccelerationStructureKHR);
    if (strcmp(pName, "vkCmdBuildAccelerationStructuresKHR") == 0 && (!device || device_dispatch_table(device)->CmdBuildAccelerationStructuresKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBuildAccelerationStructuresKHR);
    if (strcmp(pName, "vkCmdBuildAccelerationStructuresIndirectKHR") == 0 && (!device || device_dispatch_table(device)->CmdBuildAccelerationStructuresIndirectKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdBuildAccelerationStructuresIndirectKHR);
    if (strcmp(pName, "vkBuildAccelerationStructuresKHR") == 0 && (!device || device_dispatch_table(device)->BuildAccelerationStructuresKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkBuildAccelerationStructuresKHR);
    if (strcmp(pName, "vkCopyAccelerationStructureKHR") == 0 && (!device || device_dispatch_table(device)->CopyAccelerationStructureKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyAccelerationStructureKHR);
    if (strcmp(pName, "vkCopyAccelerationStructureToMemoryKHR") == 0 && (!device || device_dispatch_table(device)->CopyAccelerationStructureToMemoryKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyAccelerationStructureToMemoryKHR);
    if (strcmp(pName, "vkCopyMemoryToAccelerationStructureKHR") == 0 && (!device || device_dispatch_table(device)->CopyMemoryToAccelerationStructureKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCopyMemoryToAccelerationStructureKHR);
    if (strcmp(pName, "vkWriteAccelerationStructuresPropertiesKHR") == 0 && (!device || device_dispatch_table(device)->WriteAccelerationStructuresPropertiesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkWriteAccelerationStructuresPropertiesKHR);
    if (strcmp(pName, "vkCmdCopyAccelerationStructureKHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyAccelerationStructureKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyAccelerationStructureKHR);
    if (strcmp(pName, "vkCmdCopyAccelerationStructureToMemoryKHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyAccelerationStructureToMemoryKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyAccelerationStructureToMemoryKHR);
    if (strcmp(pName, "vkCmdCopyMemoryToAccelerationStructureKHR") == 0 && (!device || device_dispatch_table(device)->CmdCopyMemoryToAccelerationStructureKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdCopyMemoryToAccelerationStructureKHR);
    if (strcmp(pName, "vkGetAccelerationStructureDeviceAddressKHR") == 0 && (!device || device_dispatch_table(device)->GetAccelerationStructureDeviceAddressKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetAccelerationStructureDeviceAddressKHR);
    if (strcmp(pName, "vkCmdWriteAccelerationStructuresPropertiesKHR") == 0 && (!device || device_dispatch_table(device)->CmdWriteAccelerationStructuresPropertiesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdWriteAccelerationStructuresPropertiesKHR);
    if (strcmp(pName, "vkGetDeviceAccelerationStructureCompatibilityKHR") == 0 && (!device || device_dispatch_table(device)->GetDeviceAccelerationStructureCompatibilityKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetDeviceAccelerationStructureCompatibilityKHR);
    if (strcmp(pName, "vkGetAccelerationStructureBuildSizesKHR") == 0 && (!device || device_dispatch_table(device)->GetAccelerationStructureBuildSizesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetAccelerationStructureBuildSizesKHR);
    if (strcmp(pName, "vkCmdTraceRaysKHR") == 0 && (!device || device_dispatch_table(device)->CmdTraceRaysKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdTraceRaysKHR);
    if (strcmp(pName, "vkCreateRayTracingPipelinesKHR") == 0 && (!device || device_dispatch_table(device)->CreateRayTracingPipelinesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCreateRayTracingPipelinesKHR);
    if (strcmp(pName, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR") == 0 && (!device || device_dispatch_table(device)->GetRayTracingCaptureReplayShaderGroupHandlesKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRayTracingCaptureReplayShaderGroupHandlesKHR);
    if (strcmp(pName, "vkCmdTraceRaysIndirectKHR") == 0 && (!device || device_dispatch_table(device)->CmdTraceRaysIndirectKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdTraceRaysIndirectKHR);
    if (strcmp(pName, "vkGetRayTracingShaderGroupStackSizeKHR") == 0 && (!device || device_dispatch_table(device)->GetRayTracingShaderGroupStackSizeKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkGetRayTracingShaderGroupStackSizeKHR);
    if (strcmp(pName, "vkCmdSetRayTracingPipelineStackSizeKHR") == 0 && (!device || device_dispatch_table(device)->CmdSetRayTracingPipelineStackSizeKHR))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdSetRayTracingPipelineStackSizeKHR);
    if (strcmp(pName, "vkCmdDrawMeshTasksEXT") == 0 && (!device || device_dispatch_table(device)->CmdDrawMeshTasksEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMeshTasksEXT);
    if (strcmp(pName, "vkCmdDrawMeshTasksIndirectEXT") == 0 && (!device || device_dispatch_table(device)->CmdDrawMeshTasksIndirectEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMeshTasksIndirectEXT);
    if (strcmp(pName, "vkCmdDrawMeshTasksIndirectCountEXT") == 0 && (!device || device_dispatch_table(device)->CmdDrawMeshTasksIndirectCountEXT))
        return reinterpret_cast<PFN_vkVoidFunction>(vkCmdDrawMeshTasksIndirectCountEXT);

    return nullptr;
}
