/*
 * Copyright (c) 2020-2025 Valve Corporation
 * Copyright (c) 2020-2025 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Authors:
 * - Christophe Riccio <christophe@lunarg.com>
 */

#include "generate_layers_settings_hpp.h"
#include "vulkan_util.h"
#include "setting_flags.h"
#include "layer.h"
#include "configuration.h"

std::string GenerateSettingsHPP::operator()(const LayerManager& layers, const Configuration* configuration) const {
    std::string text;

    text +=
        "/*\n"
        " * Copyright (c) 2020-2025 Valve Corporation\n"
        " * Copyright (c) 2020-2025 LunarG, Inc.\n"
        " *\n"
        " * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
        " * you may not use this file except in compliance with the License.\n"
        " * You may obtain a copy of the License at\n"
        " *\n"
        " *    http://www.apache.org/licenses/LICENSE-2.0\n"
        " *\n"
        " * Unless required by applicable law or agreed to in writing, software\n"
        " * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
        " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
        " * See the License for the specific language governing permissions and\n"
        " * limitations under the License.\n"
        " *\n"
        " * This code was generated by Vulkan Configurator\n"
        " */\n";

    text += "\n";
    text += "#pragma once\n";
    text += "\n";
    text += "#include <vector>\n";
    text += "#include <string>\n";
    text += "\n";
    text += "#include <vulkan/vulkan.h>\n";
    text += "\n";
    text += "struct LayerSettings;\n";
    text += "\n";

    for (std::size_t parameter_index = 0, parameter_count = configuration->parameters.size(); parameter_index < parameter_count;
         ++parameter_index) {
        const Parameter& parameter = configuration->parameters[parameter_index];
        if (parameter.settings.empty()) {
            continue;
        }

        if (!parameter.override_settings) {
            continue;
        }

        if (parameter.builtin == LAYER_BUILTIN_UNORDERED) {
            continue;
        }

        if (parameter.control == LAYER_CONTROL_OFF || parameter.control == LAYER_CONTROL_DISCARD) {
            continue;
        }

        const Layer* layer = layers.FindFromManifest(parameter.manifest);
        if (layer == nullptr) {
            continue;
        }

        for (std::size_t setting_index = 0, setting_count = parameter.settings.size(); setting_index < setting_count;
             ++setting_index) {
            SettingData* setting = parameter.settings[setting_index];
            if (setting->type != SETTING_FLAGS && setting->type != SETTING_ENUM) {
                continue;
            }

            text += setting->Export(EXPORT_MODE_CPP_DECLARATION_VALUES).c_str();
        }

        std::string platforms = " (" + Merge(::GetPlatformTokens(layer->platforms), ", ") + ")";
        text += format("//%s%s\n", layer->description.c_str(), platforms.c_str()).c_str();
        std::string status;
        if (layer->status != STATUS_STABLE) {
            status = format(" (%s)", ::GetToken(layer->status));
        }
        text += format("// `%s` settings for version %s%s\n", layer->key.c_str(), layer->api_version.str().c_str(), status.c_str())
                    .c_str();

        if (!layer->introduction.empty()) {
            text += format("/*\n%s\n*/\n", layer->introduction.c_str()).c_str();
        }

        if (!layer->url.Empty()) {
            text += format("// For more information about the layer: %s\n",
                           ConvertStandardSeparators(layer->url.AbsolutePath()).c_str())
                        .c_str();
        }

        text += format("struct %s {\n", ::GetCodeType(parameter.key).c_str()).c_str();
        text += format("\tstatic const uint32_t VERSION = VK_MAKE_API_VERSION(%d, %d, %d, %d);\n\n", layer->api_version.GetMajor(),
                       layer->api_version.GetMinor(), layer->api_version.GetPatch(), layer->api_version.GetRevision())
                    .c_str();

        for (std::size_t setting_index = 0, setting_count = parameter.settings.size(); setting_index < setting_count;
             ++setting_index) {
            SettingData* setting = parameter.settings[setting_index];
            if (setting->type == SETTING_GROUP) {
                continue;
            }

            const SettingMeta* meta = ::FindSetting(layer->settings, setting->key.c_str());

            if (meta->view == SETTING_VIEW_HIDDEN) {
                continue;
            }

            std::string platforms = " (" + ::Merge(::GetPlatformTokens(layer->platforms), ", ") + ")";

            std::string status;
            if (meta->status != STATUS_STABLE) {
                status = format(" (%s)", ::GetToken(meta->status));
            }

            text += format("\t// %s%s%s\n", meta->label.c_str(), status.c_str(), platforms.c_str()).c_str();

            if (!meta->detailed.empty()) {
                text += format("\t// %s\n", meta->detailed.c_str());
            }

            if (!layer->url.Empty()) {
                text += format("\t// Layer setting documentation: %s#%s\n",
                               ConvertStandardSeparators(layer->url.AbsolutePath()).c_str(), meta->key.c_str());
            }

            if (!meta->url.Empty()) {
                text += format("\t// For more information about the feature: %s\n",
                               ConvertStandardSeparators(meta->url.AbsolutePath()).c_str());
            }

            if (meta->status == STATUS_DEPRECATED && !meta->deprecated_by_key.empty()) {
                const SettingMeta* replaced_setting = FindSetting(layer->settings, meta->deprecated_by_key.c_str());
                text += format("\t// This setting was deprecated and replaced by '%s' (%s) setting.\n",
                               replaced_setting->label.c_str(), replaced_setting->key.c_str());
            }

            if (!meta->dependence.empty()) {
                text +=
                    std::string("\t// This setting requires ") + ::GetToken(meta->dependence_mode) + " of the following values:\n";
                for (std::size_t i = 0, n = meta->dependence.size(); i < n; ++i) {
                    const SettingData* data = meta->dependence[i];
                    text += "\t// - " + data->Export(EXPORT_MODE_CPP_DECLARATION_AND_INIT);
                }
            }

            text += "\t" + setting->Export(EXPORT_MODE_CPP_DECLARATION_AND_INIT);
            text += "\n";
        }

        text += "private:\n";
        text += "\tfriend struct LayerSettings;\n";
        text += "\n";

        for (std::size_t setting_index = 0, setting_count = parameter.settings.size(); setting_index < setting_count;
             ++setting_index) {
            SettingData* setting = parameter.settings[setting_index];
            if (setting->type != SETTING_LIST && setting->type != SETTING_FLAGS) {
                continue;
            }

            text += format("\tstd::vector<const char*> %s_info;\n", setting->key.c_str()).c_str();
        }

        text += "\tvoid init() {\n";
        for (std::size_t setting_index = 0, setting_count = parameter.settings.size(); setting_index < setting_count;
             ++setting_index) {
            SettingData* setting = parameter.settings[setting_index];
            if (setting->type != SETTING_LIST && setting->type != SETTING_FLAGS) {
                continue;
            }

            text += format("\t\tthis->%s_info.resize(this->%s.size());\n", setting->key.c_str(), setting->key.c_str()).c_str();
            text += format("\t\tfor (std::size_t i = 0, n = %s_info.size(); i < n; ++i) {\n", setting->key.c_str()).c_str();
            text += format("\t\t\tthis->%s_info[i] = this->%s[i].c_str();\n", setting->key.c_str(), setting->key.c_str()).c_str();
            text += "\t\t}\n";
        }
        text += "\t}\n";

        text += "};\n\n";
    }

    text += "// `LayerSettings` allows initializing layer settings from Vulkan application code.\n";
    text += "struct LayerSettings {\n";
    for (std::size_t parameter_index = 0, parameter_count = configuration->parameters.size(); parameter_index < parameter_count;
         ++parameter_index) {
        const Parameter& parameter = configuration->parameters[parameter_index];
        if (parameter.settings.empty()) {
            continue;
        }

        if (!parameter.override_settings) {
            continue;
        }

        if (parameter.builtin == LAYER_BUILTIN_UNORDERED) {
            continue;
        }

        if (parameter.control == LAYER_CONTROL_DISCARD || parameter.control == LAYER_CONTROL_OFF) {
            continue;
        }

        const Layer* layer = layers.FindFromManifest(parameter.manifest);
        if (layer == nullptr) {
            continue;
        }

        text += format("\t%s %s;\n", GetCodeType(parameter.key).c_str(), GetCodeData(parameter.key).c_str()).c_str();
    }

    text += "\n";
    text += "\t// Use for VkLayerSettingsCreateInfoEXT `settingCount` and `pSettings` argument\n";
    text += "\t// Provided by VK_EXT_layer_settings\n";
    text += "\t// typedef struct VkLayerSettingsCreateInfoEXT {\n";
    text += "\t// \tVkStructureType             sType;\n";
    text += "\t// \tconst void*                 pNext;\n";
    text += "\t// \tuint32_t                    settingCount;\n";
    text += "\t// \tconst VkLayerSettingEXT*    pSettings;\n";
    text += "\t// } VkLayerSettingsCreateInfoEXT;\n";
    text += "\tstd::vector<VkLayerSettingEXT> info() {\n";
    for (std::size_t parameter_index = 0, parameter_count = configuration->parameters.size(); parameter_index < parameter_count;
         ++parameter_index) {
        const Parameter& parameter = configuration->parameters[parameter_index];
        if (parameter.settings.empty()) {
            continue;
        }

        if (!parameter.override_settings) {
            continue;
        }

        if (parameter.builtin == LAYER_BUILTIN_UNORDERED) {
            continue;
        }

        if (parameter.control == LAYER_CONTROL_DISCARD || parameter.control == LAYER_CONTROL_OFF) {
            continue;
        }

        const Layer* layer = layers.FindFromManifest(parameter.manifest);
        if (layer == nullptr) {
            continue;
        }

        text += format("\t\tthis->%s.init();\n", ::GetCodeData(parameter.key).c_str()).c_str();
    }

    text += "\n";
    text += "\t\tstd::vector<VkLayerSettingEXT> init{\n";

    for (std::size_t parameter_index = 0, parameter_count = configuration->parameters.size(); parameter_index < parameter_count;
         ++parameter_index) {
        const Parameter& parameter = configuration->parameters[parameter_index];
        if (parameter.settings.empty()) {
            continue;
        }

        if (!parameter.override_settings) {
            continue;
        }

        if (parameter.builtin == LAYER_BUILTIN_UNORDERED) {
            continue;
        }

        if (parameter.control == LAYER_CONTROL_DISCARD || parameter.control == LAYER_CONTROL_OFF) {
            continue;
        }

        const Layer* layer = layers.FindFromManifest(parameter.manifest);
        if (layer == nullptr) {
            continue;
        }

        for (std::size_t setting_index = 0, setting_count = parameter.settings.size(); setting_index < setting_count;
             ++setting_index) {
            SettingData* setting = parameter.settings[setting_index];
            if (setting->type == SETTING_GROUP) {
                continue;
            }

            if (IsArray(setting->type)) {
                text +=
                    format("\t\t\t{\"%s\", \"%s\", %s, static_cast<uint32_t>(this->%s.%s_info.size()), &this->%s.%s_info[0]},\n",
                           parameter.key.c_str(), setting->key.c_str(), ::GetLayerSettingTypeString(setting->type),
                           ::GetCodeData(parameter.key).c_str(), setting->key.c_str(), ::GetCodeData(parameter.key).c_str(),
                           setting->key.c_str());
            } else if (IsString(setting->type)) {
                text +=
                    format("\t\t\t{\"%s\", \"%s\", %s, 1, this->%s.%s.c_str()},\n", parameter.key.c_str(), setting->key.c_str(),
                           ::GetLayerSettingTypeString(setting->type), ::GetCodeData(parameter.key).c_str(), setting->key.c_str());
            } else {
                text +=
                    format("\t\t\t{\"%s\", \"%s\", %s, 1, &this->%s.%s},\n", parameter.key.c_str(), setting->key.c_str(),
                           ::GetLayerSettingTypeString(setting->type), ::GetCodeData(parameter.key).c_str(), setting->key.c_str());
            }
        }
    }
    text += "\t\t};\n";
    text += "\t\treturn init;\n";
    text += "\t};\n";
    text += "};\n\n";

    return text;
}
